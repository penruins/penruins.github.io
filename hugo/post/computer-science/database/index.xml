<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Penruins</title>
    <link>https//penruins.github.io/hugo/post/computer-science/database/</link>
    <description>Recent content on Penruins</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>[Main Page](/)</copyright>
    <atom:link href="https//penruins.github.io/hugo/post/computer-science/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>database</title>
      <link>https//penruins.github.io/hugo/post/computer-science/database/database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https//penruins.github.io/hugo/post/computer-science/database/database/</guid>
      <description>&lt;h1 id=&#34;database&#34;&gt;database&lt;a class=&#34;anchor&#34; href=&#34;#database&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;索引-index&#34;&gt;索引 index&lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95-index&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是聚集索引非聚集索引&#34;&gt;什么是聚集索引、非聚集索引？&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e9%9d%9e%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;聚集索引：数据行的&lt;strong&gt;物理存储顺序&lt;/strong&gt;与&lt;strong&gt;索引的逻辑顺序&lt;/strong&gt;一致&lt;/li&gt;&#xA;&lt;li&gt;非聚集索引：数据行的&lt;strong&gt;物理存储顺序&lt;/strong&gt;与&lt;strong&gt;索引的逻辑顺序&lt;/strong&gt;不一致&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;为什么只能有一种聚集索引&#34;&gt;为什么只能有一种聚集索引？&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8f%aa%e8%83%bd%e6%9c%89%e4%b8%80%e7%a7%8d%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;因为数据物理的存储顺序只能有一种，因此只能有一种聚集索引&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;默认的聚集索引是什么&#34;&gt;默认的聚集索引是什么？&lt;a class=&#34;anchor&#34; href=&#34;#%e9%bb%98%e8%ae%a4%e7%9a%84%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主键&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;什么是回表&#34;&gt;什么是回表？&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e5%9b%9e%e8%a1%a8&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当查询条件使用普通索引并且查询的列不包含在索引中，就需要查询完普通索引后再去查询聚集索引的树拿到完整的行数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;当底层建了abc的联合索引底层会建aab-abc这3个索引么&#34;&gt;当底层建了abc的联合索引，底层会建a,ab, abc这3个索引么？&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bd%93%e5%ba%95%e5%b1%82%e5%bb%ba%e4%ba%86abc%e7%9a%84%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e5%ba%95%e5%b1%82%e4%bc%9a%e5%bb%baaab-abc%e8%bf%993%e4%b8%aa%e7%b4%a2%e5%bc%95%e4%b9%88&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不会，只创建一个联合索引树&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;联合索引abc当查询ab-ac会走索引么&#34;&gt;联合索引（abc)，当查询ab, ac会走索引么？&lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95abc%e5%bd%93%e6%9f%a5%e8%af%a2ab-ac%e4%bc%9a%e8%b5%b0%e7%b4%a2%e5%bc%95%e4%b9%88&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ab 走索引&lt;/li&gt;&#xA;&lt;li&gt;ac 只走 a 索引&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;order-by-和-group-by-如何创建索引&#34;&gt;order by 和 group by 如何创建索引？&lt;a class=&#34;anchor&#34; href=&#34;#order-by-%e5%92%8c-group-by-%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;order by&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单列 直接创建&lt;/li&gt;&#xA;&lt;li&gt;多列 创建联合索引, 索引顺序要和 order by 的顺序一致&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不一致索引会失效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;group by&#xA;&lt;ul&gt;&#xA;&lt;li&gt;group by 实际上是先进行排序，再进行分组。所以遵循 order by 的索引机制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;mysql索引失效的20种场景&#34;&gt;MySQL索引失效的20种场景&lt;a class=&#34;anchor&#34; href=&#34;#mysql%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e7%9a%8420%e7%a7%8d%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/10448449924&#34;&gt;MySQL索引失效的20种场景&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;1 查询条件未使用索引列&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE non_indexed_column = &#39;example&#39;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;2 查询条件对索引列使用了函数或表达式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE LEFT(name, 3) = &#39;Ali&#39;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;3 数据类型不一致引发隐式类型转换&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE phone = 1234567890; -- phone 是 VARCHAR&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;4 联合索引使用时的范围查询阻断&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE name = &#39;Alice&#39; AND age &amp;gt; 30 AND city = &#39;New York&#39;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;5 如果 OR 条件中有字段未使用索引，会导致整体索引失效&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE name = &#39;Alice&#39; OR age = 30;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：拆分查询，用 UNION 替代&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE name = &#39;Alice&#39; UNION SELECT * FROM users WHERE age = 30;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;6 LIKE 查询中使用前置通配符 &lt;code&gt;%&lt;/code&gt; 时，无法利用索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE name LIKE &#39;%Alice&#39;;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;替换为后置通配符 LIKE &amp;lsquo;Alice%&amp;rsquo;&lt;/li&gt;&#xA;&lt;li&gt;使用全文索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;ALTER TABLE users ADD FULLTEXT(name);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE MATCH(name) AGAINST(&#39;Alice&#39;);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;7 不等值操作符 &lt;code&gt;!= &amp;lt;&amp;gt;&lt;/code&gt; 通常会导致索引失效&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE age != 30;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：改写为范围查询&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE age &amp;lt; 30 OR age &amp;gt; 30;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;8 &lt;code&gt;IN&lt;/code&gt; 子句中参数过多时，索引可能失效&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE id IN (1, 2, ..., 10000)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：分批查询或控制 IN 参数数量&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE id BETWEEN 1 AND 5000&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;9 某些情况下对NULL值的查询可能导致索引失效&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE email IS NULL;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：避免使用 NULL，改为特定占位值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;10 ORDER BY 和 GROUP BY 不符合索引顺序&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;select * from users order by age, name;&lt;/code&gt; 索引顺序为(name,age)&lt;/li&gt;&#xA;&lt;li&gt;解决方法：调整查询或索引顺序一致&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;11 索引列未覆盖查询字段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;select age from users where name = &#39;Alice&#39;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：创建覆盖索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;alter table users add index(name, age)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;12 表统计信息过期&#xA;&lt;ul&gt;&#xA;&lt;li&gt;表的统计信息不准确时，MySQL优化器可能错误选择全表扫描&lt;/li&gt;&#xA;&lt;li&gt;解决方法：定期更新统计信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;ANALYZE TABLE users&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;13 数据分布不均&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;select * from users where gender = &#39;M&#39; -- gender 列 90% 的值相同&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：优化查询字段或调整数据分布&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;14 子查询未优化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;子查询结果集过大时，索引失效&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE total &amp;gt; 100)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：改为 JOIN 查询&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT u.* FROM users u JOIN orders o ON u.id = o.user_id WHERE o.total &amp;gt; 100&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;15 锁机制干扰 间隙锁&#xA;&lt;ul&gt;&#xA;&lt;li&gt;描述：间隙锁可能阻止索引的高效使用&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：降低事务隔离级别至 Read Committed(读已提交)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可重复读加上间隙锁防止幻读&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;16 索引被动态调整&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MySQL优化器动态调整索引，可能选择非最佳索引或直接全表扫描&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users FORCE INDEX (idx_name) WHERE name = &#39;Alice&#39;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;17 聚合函数未走索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用聚合函数(如 &lt;code&gt;COUNT&lt;/code&gt;, &lt;code&gt;SUM&lt;/code&gt;) 时，索引可能无法被利用&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT COUNT(*) FROM users WHERE age &amp;gt; 30&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：利用覆盖索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;ALTER TABLE users ADD INDEX(age)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;18 使用了非等值JOIN&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;select * from users u join orders o on u.id &amp;gt; o.user_id&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;优化连接条件，尽量使用等值连接&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;19 小表全表扫描替代索引扫描&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于非常小的表，MySQL优化器可能选择全表扫描而非索引&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM small_table WHERE id = 1;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：无需优化，小表全表扫描的代价通常可以忽略&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;20 分区表查询不走全局索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分区表的查询条件不覆盖分区键时，全局索引可能无法生效&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM partitioned_users WHERE city = &#39;New York&#39;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：在分区键上创建局部索引&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;分区表的索引如何创建&#34;&gt;分区表的索引如何创建&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%8c%ba%e8%a1%a8%e7%9a%84%e7%b4%a2%e5%bc%95%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;分区&#34;&gt;分区&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%8c%ba&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;分表和分区在物理存储上有什么区别&#34;&gt;分表和分区在物理存储上有什么区别？&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e8%a1%a8%e5%92%8c%e5%88%86%e5%8c%ba%e5%9c%a8%e7%89%a9%e7%90%86%e5%ad%98%e5%82%a8%e4%b8%8a%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在数据库中一张表对应磁盘中的2个文件，拓展名为&lt;strong&gt;idb&lt;/strong&gt;的文件和拓展名为&lt;strong&gt;frm&lt;/strong&gt;的文件，idb文件存储表中的记录，frm存储表的结构信息&lt;/li&gt;&#xA;&lt;li&gt;进行分表的话有几张表就有几个对应的文件，进行分区就只有一个frm文件和若干个idb文件，一个分区对应一个idb文件&lt;/li&gt;&#xA;&lt;li&gt;分区能提升大表的读写性能就是因为根据分区规则仅仅扫描对应分区的磁盘文件，而不用进行全表扫描&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;一张表最多可以分多少个区&#34;&gt;一张表最多可以分多少个区？&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%80%e5%bc%a0%e8%a1%a8%e6%9c%80%e5%a4%9a%e5%8f%af%e4%bb%a5%e5%88%86%e5%a4%9a%e5%b0%91%e4%b8%aa%e5%8c%ba&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1024&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;事务&#34;&gt;事务&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;数据隔离级别&#34;&gt;数据隔离级别&lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读未提交 &lt;strong&gt;Read Uncommitted&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;读已提交 &lt;strong&gt;Read Committed&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;脏读：同一个事务中，多次读取同一数据的结果不同&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;可重复读 &lt;strong&gt;Repeatable Read&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;幻读：同一个事务中，相同的查询条件读取到的数据条数不一样&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;串行化 &lt;strong&gt;Serializable&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;mvcc&#34;&gt;MVCC&lt;a class=&#34;anchor&#34; href=&#34;#mvcc&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;mvcc-的全称是什么&#34;&gt;MVCC 的全称是什么？&lt;a class=&#34;anchor&#34; href=&#34;#mvcc-%e7%9a%84%e5%85%a8%e7%a7%b0%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Multi-Version Concurrency Control 多版本并发控制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;mysql的事务引擎仅仅使用行级锁吗&#34;&gt;MySQL的事务引擎仅仅使用行级锁吗？&lt;a class=&#34;anchor&#34; href=&#34;#mysql%e7%9a%84%e4%ba%8b%e5%8a%a1%e5%bc%95%e6%93%8e%e4%bb%85%e4%bb%85%e4%bd%bf%e7%94%a8%e8%a1%8c%e7%ba%a7%e9%94%81%e5%90%97&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不是，它结合了行级锁+MVCC(多版本并发控制)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;mvcc适用于哪些隔离级别&#34;&gt;MVCC适用于哪些隔离级别？&lt;a class=&#34;anchor&#34; href=&#34;#mvcc%e9%80%82%e7%94%a8%e4%ba%8e%e5%93%aa%e4%ba%9b%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;适用于 &lt;code&gt;REPEATED READ&lt;/code&gt; 和 &lt;code&gt;READ COMMITTED&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;不适用于 &lt;code&gt;READ UNCOMMITTED&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>druid</title>
      <link>https//penruins.github.io/hugo/post/computer-science/database/druid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https//penruins.github.io/hugo/post/computer-science/database/druid/</guid>
      <description>&lt;h1 id=&#34;druid&#34;&gt;druid&lt;a class=&#34;anchor&#34; href=&#34;#druid&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://developer.aliyun.com/article/1157595&#34;&gt;Spring Boot 整合 Druid 指南&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_43842093/article/details/131340323&#34;&gt;SpringBoot——开启Druid监控统计功能(SQL监控、慢SQL记录、Spring监控、去广告)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.hangge.com/blog/cache/detail_2876.html&#34;&gt;SpringBoot - 开启Druid监控统计功能教程（SQL监控、慢SQL记录、去广告）&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这个有用，配置要全部加上，不能漏了&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>elasticsearch</title>
      <link>https//penruins.github.io/hugo/post/computer-science/database/elasticsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https//penruins.github.io/hugo/post/computer-science/database/elasticsearch/</guid>
      <description>&lt;h1 id=&#34;elasticsearch&#34;&gt;ElasticSearch&lt;a class=&#34;anchor&#34; href=&#34;#elasticsearch&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;使用场景&#34;&gt;使用场景&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;场景1&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全文搜索Elasticsearch 凭借其强大、可扩展和快速的搜索功能，在全文搜索场景中表现出色。它允许用户以近乎实时的响应执行复杂的查询&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;场景2&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实时分析Elasticsearch 能够实时执行分析，因此适用于跟踪实时数据（如用户活动、交易或传感器输出）的仪表板&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;场景3&#xA;&lt;ul&gt;&#xA;&lt;li&gt;机器学习通过在 X-Pack 中添加机器学习功能，Elasticsearch 可以自动检测数据中的异常、模式和趋势&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;场景4&#xA;&lt;ul&gt;&#xA;&lt;li&gt;地理数据应用程序Elasticsearch 通过地理空间索引和搜索功能支持地理数据。这对于需要管理和可视化地理信息的应用程序（如地图和基于位置的服务）非常有用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;场景5&#xA;&lt;ul&gt;&#xA;&lt;li&gt;日志和事件数据分析组织使用 Elasticsearch 来聚合、监控和分析来自各种来源的日志和事件数据。它是 ELK 堆栈（Elasticsearch、Logstash、Kibana）的关键组件，用于管理系统和应用程序日志以识别问题和监控系统运行状况&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;场景6&#xA;&lt;ul&gt;&#xA;&lt;li&gt;安全信息和事件管理 （SIEM）Elasticsearch 可用作 SIEM 工具，帮助组织实时分析安全事件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>mycat</title>
      <link>https//penruins.github.io/hugo/post/computer-science/database/mycat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https//penruins.github.io/hugo/post/computer-science/database/mycat/</guid>
      <description>&lt;h1 id=&#34;mycat&#34;&gt;mycat&lt;a class=&#34;anchor&#34; href=&#34;#mycat&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000021987297&#34;&gt;那些年非常火的MyCAT是什么？&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/m0_74436895/article/details/142969704&#34;&gt;MyCat(看这一篇就够了）&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应用场景&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MySQL读写分离&lt;/li&gt;&#xA;&lt;li&gt;分库分表&lt;/li&gt;&#xA;&lt;li&gt;数据库路由器&lt;/li&gt;&#xA;&lt;li&gt;整合数据源&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当一个项目需要用到多种数据源如Oracle, MySQL, SQL Server, &lt;code&gt;PostgreSQL&lt;/code&gt;时，可以利用&lt;code&gt;Mycat&lt;/code&gt;进行整合，只需访问&lt;code&gt;Mycat&lt;/code&gt;这一个数据源就行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;逻辑库 schema&#xA;&lt;ul&gt;&#xA;&lt;li&gt;业务开发人员通常在实际应用中并不需要知道中间件的存在，只需要关注数据库，所以数据库中间件可以被当做一个或多个数据库集群构成的逻辑库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;逻辑表 table&#xA;&lt;ul&gt;&#xA;&lt;li&gt;既然有逻辑库，就会有逻辑表。在分布式数据库中，对于应用来说，读写数据的表就是逻辑表。逻辑表可以分布在一个或多个分片库中，也可以不分片&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Mycat的原理最重要的一个动词是拦截，它拦截用户发送过来的SQL语句&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;mycat-如何实现高可用&#34;&gt;&lt;code&gt;Mycat&lt;/code&gt; 如何实现高可用&lt;a class=&#34;anchor&#34; href=&#34;#mycat-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e9%ab%98%e5%8f%af%e7%94%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于&lt;code&gt;keepalived&lt;/code&gt;的&lt;code&gt;MyCat&lt;/code&gt;高可用技术&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Keepalived&lt;/code&gt;通过&lt;code&gt;VRRP&lt;/code&gt;协议实现虚拟IP(VIP)的自动漂移，当主节点故障时，VIP会自动切换到备用节点，实现MyCat服务的高可用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;HAProxy+Keepalived实现高可用与负载均衡&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HAProxy实现MyCat多节点的负载均衡&lt;/li&gt;&#xA;&lt;li&gt;Keepalived实现HAProxy自身的高可用&lt;/li&gt;&#xA;&lt;li&gt;同时解决了MyCat的负载均衡器的高可用问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>mysql</title>
      <link>https//penruins.github.io/hugo/post/computer-science/database/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https//penruins.github.io/hugo/post/computer-science/database/mysql/</guid>
      <description>&lt;h1 id=&#34;mysql&#34;&gt;mysql&lt;a class=&#34;anchor&#34; href=&#34;#mysql&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://plantegg.github.io/2019/05/26/MySQL%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%89%E9%A9%BE%E9%A9%AC%E8%BD%A6/&#34;&gt;MySQL知识体系的三驾马车&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/yihong0618/gitblog/issues/13&#34;&gt;MySQL是怎样跑起来的读书笔记 #13&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;binlog&#34;&gt;binlog&lt;a class=&#34;anchor&#34; href=&#34;#binlog&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;redo-log-和-binlog日志&#34;&gt;redo log 和 binlog日志&lt;a class=&#34;anchor&#34; href=&#34;#redo-log-%e5%92%8c-binlog%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redo log 重做日志&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Redo log是InnoDB存储引擎特有的物理日志，主要保证事务的持久性和崩溃恢复能力(crash-safe)。当MySQL实例意外宕机时，InnoDB可以通过redo log恢复已提交但未写入数据文件的事务，确保数据不会丢失&lt;/li&gt;&#xA;&lt;li&gt;Redo log采用&amp;quot;预写日志(WAL, Write-Ahead Logging)&amp;ldquo;机制：在数据页修改前，先记录日志到redo log buffer，再根据策略刷盘到redo log文件&lt;/li&gt;&#xA;&lt;li&gt;刷盘策略&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过&lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt; 参数控制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0：每秒刷盘一次，事务提交时不刷盘(可能丢失1秒数据)&lt;/li&gt;&#xA;&lt;li&gt;1：每次事务提交都刷盘(默认，最安全)&lt;/li&gt;&#xA;&lt;li&gt;2：写入OS缓存，不立即刷盘(仅MySQL崩溃安全，服务器宕机可能丢失数据)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;bin log 二进制日志&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Binlog是MySQL Server层维护的逻辑日志，记录所有引起数据变更的SQL语句或行变更&lt;/li&gt;&#xA;&lt;li&gt;主要用于&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主从复制：从库通过重放主库的binlog实现数据同步&lt;/li&gt;&#xA;&lt;li&gt;时间点恢复：结合全量备份和binlog可实现任意时间点的数据恢复&lt;/li&gt;&#xA;&lt;li&gt;数据归档：记录数据库所有变更历史&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;三种格式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;STATEMENT：记录SQL原文(默认)，可能因函数(如NOW())导致主从不一致&lt;/li&gt;&#xA;&lt;li&gt;ROW：记录行数据变更(最安全)，但日志量大&lt;/li&gt;&#xA;&lt;li&gt;MIXED：混合模式，根据语句自动选择格式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;刷盘控制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过 &lt;code&gt;sync_binlog&lt;/code&gt; 参数控制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0：由系统决定刷盘时机&lt;/li&gt;&#xA;&lt;li&gt;1：每次事务提交都刷盘(最安全)&lt;/li&gt;&#xA;&lt;li&gt;N：每N个事务刷盘一次(平衡性能与安全性)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;两阶段提交：保证日志一致性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Prepare阶段：写入redo log并标记为prepare状态&lt;/li&gt;&#xA;&lt;li&gt;写入binlog&lt;/li&gt;&#xA;&lt;li&gt;Commit阶段：将redo log标记为commit状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;读写分离&#34;&gt;读写分离&lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/AAAAABBBBBYYYYY/article/details/110875245&#34;&gt;SpringBoot+Mybatis-Plus实现mysql读写分离方案&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://springdoc.cn/spring-boot-implement-read-write-separation/&#34;&gt;在 Spring Boot 中优雅地实现读写分离&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_33101675/article/details/114396476&#34;&gt;【读写分离】SpringBoot整合多数据源实现读写分离（一）&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;a class=&#34;anchor&#34; href=&#34;#reference&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://geekdaxue.co/books/zhangnio@or5bz8&#34;&gt;MySQL 架构原理&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>postgresql</title>
      <link>https//penruins.github.io/hugo/post/computer-science/database/postgresql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https//penruins.github.io/hugo/post/computer-science/database/postgresql/</guid>
      <description>&lt;h1 id=&#34;postgresql&#34;&gt;postgresql&lt;a class=&#34;anchor&#34; href=&#34;#postgresql&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>shardingsphere</title>
      <link>https//penruins.github.io/hugo/post/computer-science/database/shardingsphere/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https//penruins.github.io/hugo/post/computer-science/database/shardingsphere/</guid>
      <description>&lt;h1 id=&#34;shardingsphere&#34;&gt;shardingsphere&lt;a class=&#34;anchor&#34; href=&#34;#shardingsphere&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://shardingsphere.apache.org/index_zh.html&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;概览&#34;&gt;概览&lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e8%a7%88&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是-shardingsphere&#34;&gt;什么是 shardingsphere&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af-shardingsphere&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Apache ShardingSphere 是一款分布式的数据库生态系统， 可以将任意数据库转换为分布式数据库，并通过数据分片、弹性伸缩、加密等能力对原有数据库进行增强&lt;/li&gt;&#xA;&lt;li&gt;Apache ShardingSphere 设计哲学为 Database Plus，旨在构建异构数据库上层的标准和生态。 它关注如何充分合理地利用数据库的计算和存储能力，而并非实现一个全新的数据库。 它站在数据库的上层视角，关注它们之间的协作多于数据库自身&lt;/li&gt;&#xA;&lt;li&gt;ShardingSphere-JDBC&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ShardingSphere-JDBC 定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ShardingSphere-Proxy&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ShardingSphere-Proxy 定位为透明化的数据库代理端，通过实现数据库二进制协议，对异构语言提供支持&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;shardingsphere-jdbc&#34;&gt;ShardingSphere-JDBC&lt;a class=&#34;anchor&#34; href=&#34;#shardingsphere-jdbc&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;shardingsphere-proxy&#34;&gt;ShardingSphere-Proxy&lt;a class=&#34;anchor&#34; href=&#34;#shardingsphere-proxy&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;启动手册&#xA;&lt;ul&gt;&#xA;&lt;li&gt;二进制发布包&lt;/li&gt;&#xA;&lt;li&gt;使用 docker&lt;/li&gt;&#xA;&lt;li&gt;构建 GraalVM Native Image(Alpha)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;高性能数据库集群&#34;&gt;高性能数据库集群&lt;a class=&#34;anchor&#34; href=&#34;#%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e9%9b%86%e7%be%a4&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;第一种读写分离&#34;&gt;第一种：读写分离&lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e4%b8%80%e7%a7%8d%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主库负责处理事务性的增删改操作，从库负责处理查询操作&lt;/li&gt;&#xA;&lt;li&gt;能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善&lt;/li&gt;&#xA;&lt;li&gt;读写分离是根据SQL语义的分析，将读操作和写操作分别路由至主库与从库&lt;/li&gt;&#xA;&lt;li&gt;两种方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一主多从&lt;/li&gt;&#xA;&lt;li&gt;多主多从&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;第二种数据库分片&#34;&gt;第二种：数据库分片&lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e4%ba%8c%e7%a7%8d%e6%95%b0%e6%8d%ae%e5%ba%93%e5%88%86%e7%89%87&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;传统的将数据集中存储至单一节点的解决方案，在性能、可用性和运维成本这三方面已经难于满足海量数据的场景&#xA;&lt;ul&gt;&#xA;&lt;li&gt;性能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于关系型数据库大多采用 B+ 树类型的索引，在数据量超过阈值的情况下，索引深度的增加也将使得磁盘访问的 IO 次数增加，进而导致查询性能的下降； 同时，高并发访问请求也使得集中式数据库成为系统的最大瓶颈&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;可用性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从可用性的方面来讲，服务化的无状态性，能够达到较小成本的随意扩容，这必然导致系统的最终压力都落在数据库之上。 而单一的数据节点，或者简单的主从架构，已经越来越难以承担。数据库的可用性，已成为整个系统的关键。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;运维成本&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从运维成本方面考虑，当一个数据库实例中的数据达到阈值以上，对于 DBA 的运维压力就会增大。 数据备份和恢复的时间成本都将随着数据量的大小而愈发不可控。一般来讲，单一数据库实例的数据的阈值在 1TB 之内，是比较合理的范围&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;在传统的关系型数据库无法满足互联网场景需要的情况下，将数据存储至原生支持分布式的 NoSQL 的尝试越来越多。 但 NoSQL 对 SQL 的不兼容性以及生态圈的不完善，使得它们在与关系型数据库的博弈中始终无法完成致命一击，而关系型数据库的地位却依然不可撼动&lt;/li&gt;&#xA;&lt;li&gt;什么是数据分片？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。 数据分片的有效手段是对关系型数据库进行分库和分表。&lt;/li&gt;&#xA;&lt;li&gt;分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;除此之外，分库还能够用于有效的分散对数据库单点的访问量；&lt;/li&gt;&#xA;&lt;li&gt;分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;读写分离分散了数据库读写操作的压力，但是没有分散存储的压力，为了满足业务数据存储的需求，就需要将存储分散到多台数据库服务器上&lt;/li&gt;&#xA;&lt;li&gt;数据分片的有效手段是对关系型数据库进行分库和分表&lt;/li&gt;&#xA;&lt;li&gt;数据分片的拆分方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;垂直分片&lt;/li&gt;&#xA;&lt;li&gt;水平分片&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;垂直分片&#34;&gt;垂直分片&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9e%82%e7%9b%b4%e5%88%86%e7%89%87&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;什么是垂直分片？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;按照业务拆分的方式称为垂直分片，又称为纵向拆分，它的核心理念是专库专用&lt;/li&gt;&#xA;&lt;li&gt;在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务&lt;/li&gt;&#xA;&lt;li&gt;而拆分之后，则是按照业务将表进行归类，分布到不同的数据库中，从而将压力分散至不同的数据库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;垂直分片的问题&#xA;&lt;ul&gt;&#xA;&lt;li&gt;垂直分片往往需要对架构和设计进行调整。通常来讲，是来不及应对互联网业务需求快速变化的；而且，它也并无法真正的解决单点瓶颈。 垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;专库专用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例如将商城库拆分为订单库、用户库、库存库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理&lt;/li&gt;&#xA;&lt;li&gt;垂直分表适合将表中某些不常用的列，或者是占了大量空间的列拆分出去&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;水平分片&#34;&gt;水平分片&lt;a class=&#34;anchor&#34; href=&#34;#%e6%b0%b4%e5%b9%b3%e5%88%86%e7%89%87&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;什么是水平分片&#xA;&lt;ul&gt;&#xA;&lt;li&gt;水平分片又称为横向拆分。 相对于垂直分片，它不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是数据分片的标准解决方案&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;水平分表&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单表切分为多表之后，新的表即使在同一个数据库服务器中，也可能带来可观的性能提升，如果性能能够满足业务要求，可以不拆分到多台数据库服务器，毕竟业务分库也会引入很多复杂性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;水平分库&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果单表拆分为多表后，单台服务器依然无法满足性能要求，那就需要将多个表分散在不同的数据库服务器中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;数据分片的挑战&#34;&gt;数据分片的挑战&lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%88%86%e7%89%87%e7%9a%84%e6%8c%91%e6%88%98&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;面对如此散乱的分片之后的数据，应用开发工程师和数据库管理员对数据库的操作变得异常繁重就是其中的重要挑战之一。 他们需要知道数据需要从哪个具体的数据库的子表中获取&lt;/li&gt;&#xA;&lt;li&gt;另一个挑战则是，能够正确的运行在单节点数据库中的 SQL，在分片之后的数据库中并不一定能够正确运行。 例如，分表导致表名称的修改，或者分页、排序、聚合分组等操作的不正确处理。&lt;/li&gt;&#xA;&lt;li&gt;跨库事务也是分布式的数据库集群要面对的棘手事情&#xA;&lt;ul&gt;&#xA;&lt;li&gt;合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。 在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。 而基于 XA 的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;目标&#34;&gt;目标&lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%ae%e6%a0%87&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;尽量透明化分库分表所带来的影响，让使用方尽量像使用一个数据库一样使用水平分片之后的数据库集群，是 Apache ShardingSphere 数据分片模块的主要设计目标&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CAP理论中的C在实践中是不可能完美实现的，在数据复制的过程中，节点N1和节点N2的数据并不一致（强一致性）。即使无法做到强一致性，但应用可以采用合适的方式达到最终一致性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本可用&lt;/li&gt;&#xA;&lt;li&gt;软引用&lt;/li&gt;&#xA;&lt;li&gt;最终一致性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;阿里巴巴Java开发手册&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表&lt;/li&gt;&#xA;&lt;li&gt;如果预计3年后的数据量根本达不到这个级别，请不要在创建表时就分库分表&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;读写分离和数据分片具体的视线方式有两种&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序代码封装&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在代码中抽象一个数据访问层（中间层封装），实现读写操作分离和数据库服务器连接的管理&lt;/li&gt;&#xA;&lt;li&gt;Apache ShardingSphere&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ShardingSphere-JDBC 程序代码封装&lt;/li&gt;&#xA;&lt;li&gt;ShardingSphere-Proxy 中间件封装&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;中间件封装&#xA;&lt;ul&gt;&#xA;&lt;li&gt;独立一套系统处理，实现读写操作分离和数据库服务器连接的管理。对于业务服务器来说，访问中间件和访问数据库没有区别，在业务服务器看来，中间件就是一个数据库服务器&lt;/li&gt;&#xA;&lt;li&gt;MyCat&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;主从同步原理&#34;&gt;主从同步原理&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;slave会从master读取binlog来进行数据同步&lt;/li&gt;&#xA;&lt;li&gt;1 master将数据改变记录到bin log中&lt;/li&gt;&#xA;&lt;li&gt;2 当 slave 上执行 start slave 命令之后，slave会创建一个IO连接用来连接master，请求master中的binlog&lt;/li&gt;&#xA;&lt;li&gt;3 当 slave 连接 master 时，master 会创建一个 log dump 线程，用于发送 bin log 的内容。在读取 binlog 的内容的操作中，会对主节点中的binlog加锁，当读取完成并发送给从服务器后解锁&lt;/li&gt;&#xA;&lt;li&gt;4 IO 线程接收主节点 binlog dump 进程发来的更新之后，保存到中继日志 relay log 中&lt;/li&gt;&#xA;&lt;li&gt;5 slave 的 SQL 线程，读取 relay log 日志，并解析成具体操作，从而实现主从操作一直，最终数据一致&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;mycat与shardingsphere深度对比&#34;&gt;MyCat与ShardingSphere深度对比&lt;a class=&#34;anchor&#34; href=&#34;#mycat%e4%b8%8eshardingsphere%e6%b7%b1%e5%ba%a6%e5%af%b9%e6%af%94&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果是从传统单体结构迁移，且只需要基本的分库分表功能，MyCat可能更合适&lt;/li&gt;&#xA;&lt;li&gt;如果是新建的云原生系统或微服务架构，ShardingSphere是更好的选择&lt;/li&gt;&#xA;&lt;li&gt;考虑到技术演进和社区支持，新项目建议优先考虑ShardingSphere&lt;/li&gt;&#xA;&lt;li&gt;某些场景可以组合使用-用ShardingSphere-JDBC处理应用内分片，用MyCat/ShardingShpere-Proxy处理遗留系统访问&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;分布式事务&#34;&gt;分布式事务&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在单一数据节点中，事务仅限于对单一数据库资源的访问控制，称之为本地事务。 几乎所有的成熟的关系型数据库都提供了对本地事务的原生支持。 但是在基于微服务的分布式应用环境下，越来越多的应用场景要求对多个服务的访问及其相对应的多个数据库资源能纳入到同一个事务当中，分布式事务应运而生&lt;/li&gt;&#xA;&lt;li&gt;关系型数据库虽然对本地事务提供了完美的 ACID 原生支持。 但在分布式的场景下，它却成为系统性能的桎梏。 如何让数据库在分布式场景下满足 ACID 的特性或找寻相应的替代方案，是分布式事务的重点工作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;挑战&#34;&gt;挑战&lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%91%e6%88%98&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;强一致的事务与柔性事务的 API 和功能并不完全相同，在它们之间并不能做到自由的透明切换。 在开发决策阶段，就不得不在强一致的事务和柔性事务之间抉择，使得设计和开发成本被大幅增加&lt;/li&gt;&#xA;&lt;li&gt;基于 XA 的强一致事务使用相对简单，但是无法很好的应对互联网的高并发或复杂系统的长事务场景； 柔性事务则需要开发者对应用进行改造，接入成本非常高，并且需要开发者自行实现资源锁定和反向补偿&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;原理介绍&#34;&gt;原理介绍&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e7%90%86%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ShardingSphere 对外提供 begin/commit/rollback 传统事务接口，通过 LOCAL，XA，BASE 三种模式提供了分布式事务的能力&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;local事务&#34;&gt;LOCAL事务&lt;a class=&#34;anchor&#34; href=&#34;#local%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LOCAL 模式基于 ShardingSphere 代理的数据库 &lt;code&gt;begin/commit/rolllback&lt;/code&gt; 的接口实现， 对于一条逻辑 SQL，ShardingSphere 通过 &lt;code&gt;begin&lt;/code&gt; 指令在每个被代理的数据库开启事务，并执行实际 SQL，并执行 &lt;code&gt;commit/rollback&lt;/code&gt;。 由于每个数据节点各自管理自己的事务，它们之间没有协调以及通信的能力，也并不互相知晓其他数据节点事务的成功与否。 在性能方面无任何损耗，但在强一致性以及最终一致性方面不能够保证。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;xa事务&#34;&gt;XA事务&lt;a class=&#34;anchor&#34; href=&#34;#xa%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;XA 事务采用的是 X/OPEN 组织所定义的 &lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009680699/toc.pdf&#34;&gt;DTP 模型&lt;/a&gt; 所抽象的 AP（应用程序）, TM（事务管理器）和 RM（资源管理器） 概念来保证分布式事务的强一致性。 其中 TM 与 RM 间采用 XA 的协议进行双向通信，通过两阶段提交实现。 与传统的本地事务相比，XA 事务增加了准备阶段，数据库除了被动接受提交指令外，还可以反向通知调用方事务是否可以被提交。 &lt;code&gt;TM&lt;/code&gt; 可以收集所有分支事务的准备结果，并于最后进行原子提交，以保证事务的强一致性&lt;/li&gt;&#xA;&lt;li&gt;XA 事务建立在 ShardingSphere 代理的数据库 xa start/end/prepare/commit/rollback/recover 的接口上&lt;/li&gt;&#xA;&lt;li&gt;对于一条逻辑 SQL，ShardingSphere 通过 &lt;code&gt;xa begin&lt;/code&gt; 指令在每个被代理的数据库开启事务，内部集成 TM，用于协调各分支事务，并执行 &lt;code&gt;xa commit/rollback&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;基于 XA 协议实现的分布式事务，由于在执行的过程中需要对所需资源进行锁定，它更加适用于执行时间确定的短事务。 对于长事务来说，整个事务进行期间对数据的独占，将会对并发场景下的性能产生一定的影响&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;base事务&#34;&gt;BASE事务&lt;a class=&#34;anchor&#34; href=&#34;#base%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果将实现了 ACID 的事务要素的事务称为刚性事务的话，那么基于 BASE 事务要素的事务则称为柔性事务&lt;/li&gt;&#xA;&lt;li&gt;BASE 是基本可用、柔性状态和最终一致性这三个要素的缩写&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本可用（Basically Available）保证分布式事务参与方不一定同时在线&lt;/li&gt;&#xA;&lt;li&gt;柔性状态（Soft state）则允许系统状态更新有一定的延时，这个延时对客户来说不一定能够察觉&lt;/li&gt;&#xA;&lt;li&gt;最终一致性（Eventually consistent）通常是通过消息传递的方式保证系统的最终一致性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;在 ACID 事务中对隔离性的要求很高，在事务执行过程中，必须将所有的资源锁定。 柔性事务的理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面。 通过放宽对强一致性要求，来换取系统吞吐量的提升&lt;/li&gt;&#xA;&lt;li&gt;基于 ACID 的强一致性事务和基于 BASE 的最终一致性事务都不是银弹，只有在最适合的场景中才能发挥它们的最大长处。 Apache ShardingSphere 集成了 SEATA 作为柔性事务的使用方案&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;应用场景&#34;&gt;应用场景&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在单机应用场景中，依赖数据库提供的事务即可满足业务上对事务 ACID 的需求。但是在分布式场景下，传统数据库解决方案缺乏对全局事务的管控能力，用户在使用过程中可能遇到多个数据库节点上出现数据不一致的问题&lt;/li&gt;&#xA;&lt;li&gt;ShardingSphere 分布式事务，为用户屏蔽了分布式事务处理的复杂性，提供了灵活多样的分布式事务解决方案，用户可以根据自己的业务场景在 LOCAL，XA，BASE 三种模式中，选择适合自己的分布式事务解决方案&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ShardingSphere LOCAL 事务使用场景&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于 LOCAL 事务，在分布式环境下，不保证各个数据库节点之间数据的一致性和隔离性，需要业务方自行处理可能出现的不一致问题。适用于用户希望自行处理分布式环境下数据一致性问题的业务场景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ShardingSphere XA 事务使用场景&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于 XA 事务，提供了分布式环境下，对数据强一致性的保证。但是由于存在同步阻塞问题，对性能会有一定影响。适用于对数据一致性要求非常高且对并发性能要求不是很高的业务场景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ShardingSphere BASE 事务使用场景&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于 BASE 事务，提供了分布式环境下，对数据最终一致性的保证。由于在整个事务过程中，不会像 XA 事务那样全程锁定资源，所以性能较好。适用于对并发性能要求很高并且允许出现短暂数据不一致的业务场景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;ymal配置&#34;&gt;YMAL配置&lt;a class=&#34;anchor&#34; href=&#34;#ymal%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/transaction/&#34;&gt;YMAL配置&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;读写分离&#34;&gt;读写分离&lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;核心概念&#34;&gt;核心概念&lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://shardingsphere.apache.org/document/current/cn/features/readwrite-splitting/concept/&#34;&gt;核心概念&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;主库&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加、更新以及删除数据操作所使用的数据库，目前仅支持单主库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;从库&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询数据操作所使用的数据库，可支持多从库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;主从同步&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将主库的数据异步的同步到从库的操作。 由于主从同步的异步性，从库与主库的数据会短时间内不一致&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;负载均衡策略&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过负载均衡策略将查询请求疏导至不同从库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;使用限制&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不处理主库和从库的数据同步&lt;/li&gt;&#xA;&lt;li&gt;不处理主库和从库的数据同步延迟导致的数据不一致&lt;/li&gt;&#xA;&lt;li&gt;不支持主库多写&lt;/li&gt;&#xA;&lt;li&gt;不处理主从库间的事务一致性。主从模型中，事务中的数据读写均用主库。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;数据库网关&#34;&gt;数据库网关&lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ba%93%e7%bd%91%e5%85%b3&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;背景&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;随着数据库碎片化趋势的不可逆转，多种类型数据库的共存已渐成常态。使用一种 SQL 方言访问异构数据库的场景在不断增加&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;挑战&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多样化的数据库的存在，使访问数据库的 SQL 方言难于标准化，工程师需要针对不同种类的数据库使用不同的方言，缺乏统一化的查询平台&lt;/li&gt;&#xA;&lt;li&gt;将不同类型的数据库方言自动翻译为后端数据库所使用的方言，让工程师可以使用任意一种数据库方言访问所有的后端异构数据库，可以极大的降低开发和维护成本&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SQL 方言的自动翻译，是 Apache ShardingSphere 数据库网关希望达成的主要目标&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;随着业务场景的多元化，企业内部的数据库产品也呈现多元化的趋势，业务应用与不同数据库产品的对接也变得异常复杂，ShardingSphere 数据库网关可以屏蔽业务应用与底层多元化数据库之间连接，同时为不同的业务场景提供统一的访问协议和语法体系，能够帮助企业快速打造统一的数据访问平台。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;使用限制&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Apache ShardingSphere 的 SQL 方言翻译处于实验阶段&lt;/li&gt;&#xA;&lt;li&gt;目前仅支持 MySQL/PostgreSQL 的方言自动翻译，工程师可以使用 MySQL 的方言和协议，访问 PostgreSQL 数据库，反之亦然&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;流量治理&#34;&gt;流量治理&lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%81%e9%87%8f%e6%b2%bb%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;数据迁移&#34;&gt;数据迁移&lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e8%bf%81%e7%a7%bb&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;挑战&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在迁移过程中，不应该对正在运行的业务造成影响。尽可能减少迁移时数据不可用的时间窗口，是数据迁移的第一个挑战&lt;/li&gt;&#xA;&lt;li&gt;其次，数据迁移不应该对现有的数据造成影响，如何保证数据的正确性，是数据迁移的第二个挑战&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;应用场景&#xA;&lt;ul&gt;&#xA;&lt;li&gt;假如一个应用系统在使用传统单体数据库，单表数据量达到了1亿并且还在快速增长，单体数据库负载持续在高位，成为系统瓶颈。一旦数据库成为瓶颈，对应用服务器扩容是无效的，需要对数据库进行扩容&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;数据加密&#34;&gt;数据加密&lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%8a%a0%e5%af%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;数据脱敏&#34;&gt;数据脱敏&lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e8%84%b1%e6%95%8f&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;影子库&#34;&gt;影子库&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bd%b1%e5%ad%90%e5%ba%93&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;背景&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在基于微服务的分布式应用架构下，业务需要多个服务是通过一系列的服务、中间件的调用来完成，所以单个服务的压力测试已无法代表真实场景。 在测试环境中，如果重新搭建一整套与生产环境类似的压测环境，成本过高，并且往往无法模拟线上环境的复杂度以及流量。 因此，业内通常选择全链路压测的方式，即在生产环境进行压测，这样所获得的测试结果能够准确地反应系统真实容量和性能水平&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;可观察性&#34;&gt;可观察性&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%af%e8%a7%82%e5%af%9f%e6%80%a7&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何观测集群的运行状态，使运维人员可以快速掌握当前系统现状，并进行进一步的维护工作，是分布式系统的全新挑战&lt;/li&gt;&#xA;&lt;li&gt;登录到具体服务器的点对点运维方式，无法适用于面向大量分布式服务器的场景&lt;/li&gt;&#xA;&lt;li&gt;通过对系统可观察性数据的遥测是分布式系统推荐的运维方式。 Tracing（链路跟踪）、 Metrics（指标监控）和 Logging （日志）是系统运行状况的可观察性数据重要的获取手段&lt;/li&gt;&#xA;&lt;li&gt;APM（应用性能监控） 是通过对系统可观察性数据进行采集、存储和分析，进行系统的性能监控与诊断，主要功能包括性能指标监控、调用链分析，应用拓扑图等&lt;/li&gt;&#xA;&lt;li&gt;Apache ShardingSphere 并不负责如何采集、存储以及展示应用性能监控的相关数据，而是为应用监控系统提供必要的指标数据&lt;/li&gt;&#xA;&lt;li&gt;换句话说，Apache ShardingSphere 仅负责产生具有价值的数据，并通过标准协议或插件化的方式递交给相关系统&lt;/li&gt;&#xA;&lt;li&gt;Tracing 用于获取 SQL 解析与 SQL 执行的链路跟踪信息。Apache ShardingSphere 默认提供了对 OpenTelemetry，SkyWalking 的支持，也支持用户通过插件化的方式开发自定义的 Tracing 组件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 OpenTelemetry OpenTelemetry 在 2019 年由 OpenTracing 和 OpenCencus 合并而来。 使用这种方式，只需要在 agent 配置文件中，根据 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions/autoconfigure&#34;&gt;OpenTelemetry SDK 自动配置说明&lt;/a&gt; ，填写合适的配置即可。可以导出数据到 Jaeger，Zipkin&lt;/li&gt;&#xA;&lt;li&gt;使用 SkyWalking 需要在 agent 配置中配置启用对应插件，并且需要同时配置使用 SkyWalking 的 apm-toolkit 工具&lt;/li&gt;&#xA;&lt;li&gt;使用 SkyWalking 的内置自动探针 Apache ShardingSphere 团队与 Apache SkyWalking 团队共同合作，在 SkyWalking 中实现了 Apache ShardingSphere 自动探针，可以将相关的应用性能数据自动发送到 SkyWalking 中。注意这种方式的自动探针不能与 Apache ShardingSphere 插件探针同时使用&lt;/li&gt;&#xA;&lt;li&gt;Metrics 则用于收集和展示整个集群的统计指标。Apache ShardingSphere 默认提供了对 Prometheus 的支持&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;联邦查询&#34;&gt;联邦查询&lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%94%e9%82%a6%e6%9f%a5%e8%af%a2&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;背景&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当用户使用数据分片对海量数据进行水平拆分时，虽然能够有效解决数据库性能瓶颈，但业务上也因此带来了一些新的问题。 例如以下场景：跨节点关联查询、子查询、分页、排序、聚合查询。在进行业务实现时需要注意查询 SQL 的使用范围，尽量避免跨数据库实例查询，这使得业务层面的功能受到了数据库的限制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;shardingsphere的分布式事务功能具体是如何实现的&#34;&gt;ShardingSphere的分布式事务功能具体是如何实现的？&lt;a class=&#34;anchor&#34; href=&#34;#shardingsphere%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e5%8a%9f%e8%83%bd%e5%85%b7%e4%bd%93%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%9a%84&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;xa事务强一致性&#34;&gt;XA事务（强一致性）&lt;a class=&#34;anchor&#34; href=&#34;#xa%e4%ba%8b%e5%8a%a1%e5%bc%ba%e4%b8%80%e8%87%b4%e6%80%a7&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现原理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于XA协议的两阶段提交(2PC)&lt;/li&gt;&#xA;&lt;li&gt;使用ShardingSphere的XATransactionManager作为事务管理器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;工作流程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;准备阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事务协调器向所有参与者发送prepare请求&lt;/li&gt;&#xA;&lt;li&gt;各参与者执行事务但不提交，记录undo/redo日志&lt;/li&gt;&#xA;&lt;li&gt;参与者返回准备就绪或失败响应&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;提交/回滚阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果所有参与者都准备就绪，发送&lt;code&gt;commit&lt;/code&gt;请求&lt;/li&gt;&#xA;&lt;li&gt;如果任一参与者准备失败，发送&lt;code&gt;rollback&lt;/code&gt;请求&lt;/li&gt;&#xA;&lt;li&gt;参与者根据指令完成最终操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;seata事务柔性事务at模式&#34;&gt;&lt;code&gt;Seata&lt;/code&gt;事务（柔性事务/AT模式）&lt;a class=&#34;anchor&#34; href=&#34;#seata%e4%ba%8b%e5%8a%a1%e6%9f%94%e6%80%a7%e4%ba%8b%e5%8a%a1at%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;整合&lt;code&gt;Seata&lt;/code&gt;的AT(Automatic Transaction)模式&lt;/li&gt;&#xA;&lt;li&gt;基于全局锁+分支事务的补偿机制&lt;/li&gt;&#xA;&lt;li&gt;工作流程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;业务SQL被Seata拦截解析&lt;/li&gt;&#xA;&lt;li&gt;RM生成undo log记录修改前数据&lt;/li&gt;&#xA;&lt;li&gt;执行业务SQL并提交本地事务&lt;/li&gt;&#xA;&lt;li&gt;向TC注册分支事务并报告状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;第二阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;成功时：异步删除undo log&lt;/li&gt;&#xA;&lt;li&gt;失败时：基于 undo log 进行补偿回滚&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;base事务saga模式&#34;&gt;BASE事务（Saga模式）&lt;a class=&#34;anchor&#34; href=&#34;#base%e4%ba%8b%e5%8a%a1saga%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于Saga模式的长事务解决方案&lt;/li&gt;&#xA;&lt;li&gt;每个子事务都有对应的补偿操作&lt;/li&gt;&#xA;&lt;li&gt;最终一致性模型&lt;/li&gt;&#xA;&lt;li&gt;执行模式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;正向流程：按顺序执行所有子事务&lt;/li&gt;&#xA;&lt;li&gt;补偿流程：出现失败时，逆序执行补偿操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;生产实践建议&#34;&gt;生产实践建议&lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e4%ba%a7%e5%ae%9e%e8%b7%b5%e5%bb%ba%e8%ae%ae&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;金融核心系统：优先考虑XA事务&lt;/li&gt;&#xA;&lt;li&gt;普通交易系统：推荐&lt;code&gt;Seata AT&lt;/code&gt;模式&lt;/li&gt;&#xA;&lt;li&gt;跨系统长流程：考虑&lt;code&gt;Saga&lt;/code&gt;模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;a class=&#34;anchor&#34; href=&#34;#reference&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://shardingsphere.apache.org/document/current/cn/overview/&#34;&gt;官方文档&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这个很好，优先看这个&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_38263083/article/details/125439693&#34;&gt;shardingsphere分库分表示例（逻辑表，真实表，绑定表，广播表，单表），分页性能测试&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/hyzsuccess/article/details/127644291&#34;&gt;ShardingSphere学习（超详细）&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/352256403/answer/878733845&#34;&gt;为什么几乎所有的开源数据库中间件都是国内公司开源的？并且几乎都停止了更新？ - 张亮的回答 - 知乎&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>SQL</title>
      <link>https//penruins.github.io/hugo/post/computer-science/database/sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https//penruins.github.io/hugo/post/computer-science/database/sql/</guid>
      <description>&lt;h1 id=&#34;sql&#34;&gt;sql&lt;a class=&#34;anchor&#34; href=&#34;#sql&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;2502-设计内存分配器&#34;&gt;2502 设计内存分配器&lt;a class=&#34;anchor&#34; href=&#34;#2502-%e8%ae%be%e8%ae%a1%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;-175-组合两个表&#34;&gt;✅ 175 组合两个表&lt;a class=&#34;anchor&#34; href=&#34;#-175-%e7%bb%84%e5%90%88%e4%b8%a4%e4%b8%aa%e8%a1%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.cn/problems/combine-two-tables/&#34;&gt;175. 组合两个表&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要展示的字段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;姓 LastName&lt;/li&gt;&#xA;&lt;li&gt;名 FirstName&lt;/li&gt;&#xA;&lt;li&gt;城市 City&lt;/li&gt;&#xA;&lt;li&gt;州 State&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;如果 &lt;code&gt;personId&lt;/code&gt; 的地址不再 &lt;code&gt;Address&lt;/code&gt; 表中，则报告为 &lt;code&gt;null&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用左连接&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; FirstName, LastName, City, &lt;span style=&#34;color:#66d9ef&#34;&gt;State&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; Person&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#66d9ef&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;join&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; Person.PersonId &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Address.PersonId;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;176-第二高的薪水&#34;&gt;176 第二高的薪水&lt;a class=&#34;anchor&#34; href=&#34;#176-%e7%ac%ac%e4%ba%8c%e9%ab%98%e7%9a%84%e8%96%aa%e6%b0%b4&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.cn/problems/second-highest-salary/description/&#34;&gt;176. 第二高的薪水&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;If&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Exists&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id     &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    salary &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Truncate &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; Employee;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;100&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;200&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;300&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;400&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;5&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;500&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;6&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;600&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;7&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;700&amp;#39;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Employee 表：&#xA;+-------------+------+&#xA;| Column Name | Type |&#xA;+-------------+------+&#xA;| id          | int  |&#xA;| salary      | int  |&#xA;+-------------+------+&#xA;id 是这个表的主键。&#xA;表的每一行包含员工的工资信息。&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;distinct&lt;/span&gt; Salary &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; SecondHighestSalary&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; Employee&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;order&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;by&lt;/span&gt; Salary &lt;span style=&#34;color:#66d9ef&#34;&gt;desc&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;limit&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; offset &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然而，如果没有第 2 高的薪资，即表里可能只有一条记录，这个解答会被评测为 &amp;lsquo;Wrong Answer&amp;rsquo; 。为了克服这个问题，我们可以将其作为临时表。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Penruins</title>
      <link>https//penruins.github.io/hugo/post/computer-science/database/mongodb/</link>
      <pubDate>Thu, 14 Nov 2024 08:59:49 +0800</pubDate>
      <guid>https//penruins.github.io/hugo/post/computer-science/database/mongodb/</guid>
      <description>&lt;h1 id=&#34;mongodb&#34;&gt;mongodb&lt;a class=&#34;anchor&#34; href=&#34;#mongodb&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;</description>
    </item>
  </channel>
</rss>
