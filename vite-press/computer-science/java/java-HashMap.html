<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>java HashMap | Penruins</title>
    <meta name="description" content="A VitePress site">
    <meta name="generator" content="VitePress v2.0.0-alpha.12">
    <link rel="preload stylesheet" href="/vite-press/assets/style.1KD3S3dY.css" as="style">
    <link rel="preload stylesheet" href="/vite-press/vp-icons.css" as="style">
    
    <script type="module" src="/vite-press/assets/app.BGrLpcG3.js"></script>
    <link rel="preload" href="/vite-press/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/vite-press/assets/chunks/theme.C4J79lq7.js">
    <link rel="modulepreload" href="/vite-press/assets/chunks/framework.Bhntpte7.js">
    <link rel="modulepreload" href="/vite-press/assets/computer-science_java_java-HashMap.md.Dgk76Anm.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-304c8b69><!--[--><!--]--><!--[--><span tabindex="-1" data-v-fcbfc0e0></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-fcbfc0e0>Skip to content</a><!--]--><!----><header class="VPNav" data-v-304c8b69 data-v-d5bf7c8e><div class="VPNavBar" data-v-d5bf7c8e data-v-8eab0e6d><div class="wrapper" data-v-8eab0e6d><div class="container" data-v-8eab0e6d><div class="title" data-v-8eab0e6d><div class="VPNavBarTitle has-sidebar" data-v-8eab0e6d data-v-d4488dd0><a class="title" href="/vite-press/" data-v-d4488dd0><!--[--><!--]--><!----><span data-v-d4488dd0>Penruins</span><!--[--><!--]--></a></div></div><div class="content" data-v-8eab0e6d><div class="content-body" data-v-8eab0e6d><!--[--><!--]--><div class="VPNavBarSearch search" data-v-8eab0e6d><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-8eab0e6d data-v-020be4db><span id="main-nav-aria-label" class="visually-hidden" data-v-020be4db> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vite-press/" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vite-press/markdown-examples.html" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>Examples</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-8eab0e6d data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-8eab0e6d data-v-ef6192dc data-v-a1a7286e><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="me noopener" data-v-a1a7286e data-v-32d78712><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-8eab0e6d data-v-f953d92f data-v-d8fae6e2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-d8fae6e2><span class="vpi-more-horizontal icon" data-v-d8fae6e2></span></button><div class="menu" data-v-d8fae6e2><div class="VPMenu" data-v-d8fae6e2 data-v-fcd1d7a8><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>Appearance</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-a1a7286e><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="me noopener" data-v-a1a7286e data-v-32d78712><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8eab0e6d data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-8eab0e6d><div class="divider-line" data-v-8eab0e6d></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-304c8b69 data-v-5ae341c6><div class="container" data-v-5ae341c6><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-5ae341c6><span class="vpi-align-left menu-icon" data-v-5ae341c6></span><span class="menu-text" data-v-5ae341c6>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-5ae341c6 data-v-e28a51a6><button data-v-e28a51a6>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-304c8b69 data-v-e0eef791><div class="curtain" data-v-e0eef791></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-e0eef791><span class="visually-hidden" id="sidebar-aria-label" data-v-e0eef791> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>Computer Science</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/vite-press/computer-science/artificial-intelligence.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>Artificial Intelligence</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/vite-press/computer-science/networking.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>Networking</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/vite-press/computer-science/git.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>git</p><!--]--></a><!----></div><!----></div><section class="VPSidebarItem level-1" data-v-6b36a2fd data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h3 class="text" data-v-6b36a2fd>Java</h3><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-2 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/vite-press/computer-science/java/java.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>java</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/vite-press/computer-science/java/java-basic.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>java basic</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-304c8b69 data-v-2652e39a><div class="VPDoc has-sidebar has-aside" data-v-2652e39a data-v-d668f7cc><!--[--><!--]--><div class="container" data-v-d668f7cc><div class="aside" data-v-d668f7cc><div class="aside-curtain" data-v-d668f7cc></div><div class="aside-container" data-v-d668f7cc><div class="aside-content" data-v-d668f7cc><div class="VPDocAside" data-v-d668f7cc data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-c8b19031><div class="content" data-v-c8b19031><div class="outline-marker" data-v-c8b19031></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-c8b19031>On this page</div><ul class="VPDocOutlineItem root" data-v-c8b19031 data-v-b7d7ef80><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-d668f7cc><div class="content-container" data-v-d668f7cc><!--[--><!--]--><main class="main" data-v-d668f7cc><div style="position:relative;" class="vp-doc _vite-press_computer-science_java_java-HashMap" data-v-d668f7cc><div><h1 id="hashmap" tabindex="-1">HashMap <a class="header-anchor" href="#hashmap" aria-label="Permalink to “HashMap”">​</a></h1><h2 id="hashmap底层的数据结构是怎样的" tabindex="-1">HashMap底层的数据结构是怎样的 <a class="header-anchor" href="#hashmap底层的数据结构是怎样的" aria-label="Permalink to “HashMap底层的数据结构是怎样的”">​</a></h2><p>HashMap 底层的数据结构在 <strong>JDK 1.7</strong> 和 <strong>JDK 1.8</strong> 中有显著的不同，主要体现在如何处理哈希冲突和存储数据的方式上。</p><hr><h3 id="jdk-1-7-及之前" tabindex="-1"><strong>JDK 1.7 及之前</strong> <a class="header-anchor" href="#jdk-1-7-及之前" aria-label="Permalink to “JDK 1.7 及之前”">​</a></h3><ul><li><strong>数据结构</strong>：<code>数组 + 链表</code><ul><li><strong>数组</strong>：是 HashMap 的主体，用于存储键值对（<code>Entry</code> 对象）。数组的每个位置称为一个 <strong>桶</strong>（bucket）。</li><li><strong>链表</strong>：用于解决哈希冲突。当多个键的哈希值相同（即计算出的数组索引相同）时，这些键值对会以链表的形式存储在同一个桶中。</li></ul></li><li><strong>哈希冲突解决</strong>：通过 <strong>拉链法</strong>（Chaining）解决哈希冲突，即链表的形式。</li><li><strong>性能问题</strong>：当链表过长时，查询效率会降低，时间复杂度退化为 O(n)。</li></ul><hr><h3 id="jdk-1-8-及之后" tabindex="-1"><strong>JDK 1.8 及之后</strong> <a class="header-anchor" href="#jdk-1-8-及之后" aria-label="Permalink to “JDK 1.8 及之后”">​</a></h3><ul><li><strong>数据结构</strong>：<code>数组 + 链表 + 红黑树</code><ul><li><strong>数组</strong>：仍然是 HashMap 的主体，用于存储键值对（<code>Node</code> 对象）。</li><li><strong>链表</strong>：当哈希冲突时，键值对首先以链表的形式存储。</li><li><strong>红黑树</strong>：当链表长度超过 <strong>阈值（默认是 8）</strong> 且 <strong>数组长度大于 64</strong> 时，链表会转换为 <strong>红黑树</strong>，以提高查询效率。</li></ul></li><li><strong>哈希冲突解决</strong>：仍然使用 <strong>拉链法</strong>，但当链表过长时会转换为红黑树，时间复杂度优化为 O(log n)。</li><li><strong>性能优化</strong>：红黑树的引入大大减少了哈希冲突严重时的查询时间。</li></ul><hr><h3 id="核心机制" tabindex="-1"><strong>核心机制</strong> <a class="header-anchor" href="#核心机制" aria-label="Permalink to “核心机制”">​</a></h3><ol><li><p><strong>哈希计算</strong></p><ul><li>通过 <code>key.hashCode()</code> 计算哈希值，再通过 <code>(n - 1) &amp; hash</code> 计算数组索引（<code>n</code> 是数组长度）。</li><li>为了减少哈希冲突，JDK 1.8 对哈希值进行了优化，将高 16 位与低 16 位进行异或运算，使哈希分布更均匀<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li></ul></li><li><p><strong>扩容机制</strong></p><ul><li>当 HashMap 中的元素数量超过 <code>容量 * 负载因子</code> 时，会触发扩容（默认容量为 16，负载因子为 0.75）。</li><li>扩容时，数组长度变为原来的 2 倍，所有元素会重新计算哈希并分配到新的桶中<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li></ul></li><li><p><strong>红黑树转换</strong></p><ul><li>当链表长度超过 8 且数组长度大于 64 时，链表会转换为红黑树；当红黑树节点数小于 6 时，红黑树会退化为链表<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li></ul></li></ol><hr><h3 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h3><ul><li><strong>JDK 1.7</strong>：<code>数组 + 链表</code>，通过拉链法解决哈希冲突，性能较差。</li><li><strong>JDK 1.8</strong>：<code>数组 + 链表 + 红黑树</code>，通过链表和红黑树结合，优化了查询性能。</li></ul><p>这种数据结构的设计使得 HashMap 在大多数情况下能够以 O(1) 的时间复杂度进行查找、插入和删除操作，同时在高并发场景下也能保持较好的性能<a href="./@ref.html">1</a><a href="./@ref.html">2</a><a href="./@ref.html">3</a>。</p><h2 id="为什么hashmap要使用红黑树而不使用其他的树结构" tabindex="-1">为什么HashMap要使用红黑树而不使用其他的树结构？ <a class="header-anchor" href="#为什么hashmap要使用红黑树而不使用其他的树结构" aria-label="Permalink to “为什么HashMap要使用红黑树而不使用其他的树结构？”">​</a></h2><div class="language-ys_think"><button title="Copy Code" class="copy"></button><span class="lang">ys_think</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span></span></span>
<span class="line"><span>&lt;icon&gt;https://wy-static.wenxiaobai.com/bot-capability/prod/%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83.png&lt;/icon&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;start&gt;思考中...&lt;/start&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>嗯，用户问为什么HashMap用红黑树而不是其他树结构。我得仔细看看搜索结果里的内容。首先，记得之前学过的，红黑树是自平衡二叉搜索树，而HashMap在链表过长时转成红黑树是为了提高查询效率。那为什么要选红黑树而不是比如AVL树或者其他树呢？</span></span>
<span class="line"><span></span></span>
<span class="line"><span>搜索结果里，网页1提到红黑树的平均查找长度是log(n)，链表是n/2，当长度超过8的时候，转换成树更有必要。同时，网页6和网页8也讨论了红黑树和AVL树的区别。网页6说红黑树在插入和删除时效率更高，因为旋转次数少。而AVL树虽然查询更快，但维护平衡的成本高，每次调整可能需要更多旋转。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>网页8提到红黑树的平衡性不如AVL严格，但这样换来的是更高效的插入和删除操作。对于HashMap这种需要频繁插入和删除的场景，红黑树的性能更好。另外，红黑树在调整时最多三次旋转就能恢复平衡，而AVL可能需要O(log n)次，这在多线程或高并发情况下更有优势。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>还有网页4和网页7也提到，红黑树在解决哈希冲突时，能提供O(log n)的时间复杂度，而链表是O(n)。当链表长度增加到一定阈值时，转换为树结构能有效提升性能。而选择红黑树而不是其他树结构，比如B树或者二叉搜索树，可能是因为红黑树在内存中操作更高效，不需要像B树那样处理大量子节点，适合内存中的数据结构。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>另外，网页9和网页10提到HashMap在JDK8之后使用红黑树的条件是链表长度超过8且数组容量达到64。这说明红黑树的使用是有严格条件的，而红黑树的结构特性刚好满足这种需要部分平衡的场景，既保证了查询效率，又减少了维护平衡的开销。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>所以总结下来，HashMap选择红黑树主要是因为它在插入、删除和查询之间找到了一个平衡点，适合频繁修改的场景。而其他树结构如AVL树可能在查询上更快，但维护成本高；二叉堆或B树可能结构不适合HashMap的需求。红黑树的这些特性使得它在HashMap中表现更优。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;end&gt;已深度思考（用时14秒）&lt;/end&gt;</span></span></code></pre></div><p>在 Java 的 HashMap 中，当哈希冲突导致链表长度超过阈值（默认为 8）时，链表会转换为红黑树以优化性能。选择红黑树而非其他树结构（如 AVL 树、普通二叉搜索树等）是经过多方面权衡后的结果，主要原因如下：</p><hr><h3 id="一、红黑树的特性优势" tabindex="-1">一、<strong>红黑树的特性优势</strong> <a class="header-anchor" href="#一、红黑树的特性优势" aria-label="Permalink to “一、红黑树的特性优势”">​</a></h3><p>红黑树是一种<strong>自平衡二叉搜索树</strong>，其核心优势在于<strong>平衡性与操作效率的折中</strong>。以下是其关键特性：</p><ol><li><p><strong>近似平衡</strong><br> 红黑树通过约束条件（如红色节点不能连续、从根到叶子的黑节点数相同）保证最长路径不超过最短路径的两倍<a href="./@ref.html">1</a><a href="./@ref.html">5</a><a href="./@ref.html">9</a>。这种“非严格平衡”使得维护成本低于 AVL 树，同时仍能保证对数级时间复杂度（O(log n)）的查找效率。</p></li><li><p><strong>高效的增删操作</strong></p><ul><li><strong>插入/删除性能</strong>：红黑树在调整平衡时最多需要<strong>3次旋转</strong>即可完成，而 AVL 树可能需要多次旋转甚至 O(log n) 次调整<a href="./@ref.html">6</a><a href="./@ref.html">8</a>。例如，删除节点时，AVL 需维护从删除节点到根的路径平衡，而红黑树只需局部调整<a href="./@ref.html">8</a>。</li><li><strong>时间复杂度</strong>：红黑树的插入、删除和查找均为 O(log n)，且实际性能稳定，适合频繁修改的场景<a href="./@ref.html">7</a><a href="./@ref.html">12</a>。</li></ul></li><li><p><strong>内存占用优化</strong><br> 红黑树仅需存储颜色标记（1 bit），而 AVL 树需存储平衡因子（通常为整型），内存开销更小<a href="./@ref.html">8</a>。</p></li></ol><hr><h3 id="二、与其他树结构的对比" tabindex="-1">二、<strong>与其他树结构的对比</strong> <a class="header-anchor" href="#二、与其他树结构的对比" aria-label="Permalink to “二、与其他树结构的对比”">​</a></h3><h4 id="_1-与-avl-树的对比" tabindex="-1">1. <strong>与 AVL 树的对比</strong> <a class="header-anchor" href="#_1-与-avl-树的对比" aria-label="Permalink to “1. 与 AVL 树的对比”">​</a></h4><ul><li><strong>平衡性</strong>：AVL 树追求严格平衡（左右子树高度差≤1），查询效率略高于红黑树，但插入/删除时维护平衡的代价更高<a href="./@ref.html">6</a><a href="./@ref.html">8</a>。</li><li><strong>适用场景</strong>：AVL 树适合<strong>读多写少</strong>的场景（如数据库索引），而 HashMap 需要频繁插入和删除节点，红黑树的综合性能更优<a href="./@ref.html">8</a><a href="./@ref.html">12</a>。</li></ul><h4 id="_2-与普通二叉搜索树的对比" tabindex="-1">2. <strong>与普通二叉搜索树的对比</strong> <a class="header-anchor" href="#_2-与普通二叉搜索树的对比" aria-label="Permalink to “2. 与普通二叉搜索树的对比”">​</a></h4><ul><li><strong>退化问题</strong>：普通二叉搜索树在极端情况下（如数据有序插入）会退化为链表，时间复杂度退化为 O(n)，而红黑树通过自平衡机制避免此问题<a href="./@ref.html">5</a><a href="./@ref.html">9</a>。</li></ul><h4 id="_3-与-b-树-b-树的对比" tabindex="-1">3. <strong>与 B 树/B+ 树的对比</strong> <a class="header-anchor" href="#_3-与-b-树-b-树的对比" aria-label="Permalink to “3. 与 B 树/B+ 树的对比”">​</a></h4><ul><li><strong>内存与磁盘优化</strong>：B 树适用于磁盘存储（减少 I/O 次数），而红黑树作为内存数据结构，更适合 HashMap 的哈希桶管理<a href="./@ref.html">8</a>。</li></ul><hr><h3 id="三、hashmap-的特定需求" tabindex="-1">三、<strong>HashMap 的特定需求</strong> <a class="header-anchor" href="#三、hashmap-的特定需求" aria-label="Permalink to “三、HashMap 的特定需求”">​</a></h3><ol><li><p><strong>哈希冲突的局部性</strong><br> HashMap 仅在单个哈希桶内使用红黑树，冲突节点数量通常较小（默认阈值 8），红黑树的局部调整特性更契合这种场景<a href="./@ref.html">3</a><a href="./@ref.html">7</a><a href="./@ref.html">10</a>。</p></li><li><p><strong>性能与成本的权衡</strong></p><ul><li><strong>树化阈值选择</strong>：链表长度超过 8 才转换为红黑树，因为此时链表的平均查找长度为 4，而红黑树为 3，性能提升显著<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li><li><strong>树退化阈值</strong>：当节点数降至 6 时还原为链表，避免频繁树化与退化（中间差值 7 作为缓冲）<a href="./@ref.html">1</a><a href="./@ref.html">10</a>。</li></ul></li><li><p><strong>工程实践验证</strong><br> 红黑树的实现复杂度适中，且经过大量工程验证（如 Linux 内核、Java 集合框架），其稳定性和效率已被广泛认可<a href="./@ref.html">6</a><a href="./@ref.html">8</a>。</p></li></ol><hr><h3 id="四、总结" tabindex="-1">四、<strong>总结</strong> <a class="header-anchor" href="#四、总结" aria-label="Permalink to “四、总结”">​</a></h3><p>HashMap 选择红黑树的核心原因在于：</p><ol><li><strong>平衡效率与维护成本</strong>：在近似平衡的基础上，以更低的代价实现高效的增删操作。</li><li><strong>适应哈希冲突场景</strong>：适合局部、小规模的数据结构管理需求。</li><li><strong>工程实践优势</strong>：经过长期验证，性能稳定且实现成熟。</li></ol><p>相比之下，其他树结构或过于追求平衡（如 AVL 树），或缺乏自适应性（如普通二叉搜索树），无法在 HashMap 的特定场景中达到最优性能<a href="./@ref.html">1</a><a href="./@ref.html">6</a><a href="./@ref.html">8</a>。</p><h2 id="hashmap-get-的时间复杂度" tabindex="-1">HashMap get 的时间复杂度 <a class="header-anchor" href="#hashmap-get-的时间复杂度" aria-label="Permalink to “HashMap get 的时间复杂度”">​</a></h2><p><code>HashMap</code> 的 <code>get</code> 方法的时间复杂度在理想情况下是 <strong>O(1)</strong>，但在最坏情况下可能退化为 <strong>O(n)</strong>。以下是详细说明：</p><h3 id="_1-理想情况-o-1" tabindex="-1">1. <strong>理想情况（O(1)）</strong> <a class="header-anchor" href="#_1-理想情况-o-1" aria-label="Permalink to “1. 理想情况（O(1)）”">​</a></h3><ul><li><strong>哈希函数均匀分布</strong>：当哈希函数能够将键均匀地分布到各个桶（bucket）中时，<code>HashMap</code> 的 <code>get</code> 操作可以通过计算键的哈希值直接定位到对应的桶，从而在常数时间内获取值。</li><li><strong>无哈希冲突</strong>：如果每个桶中只有一个元素（没有哈希冲突），<code>get</code> 操作的时间复杂度为 O(1)。</li></ul><h3 id="_2-最坏情况-o-n" tabindex="-1">2. <strong>最坏情况（O(n)）</strong> <a class="header-anchor" href="#_2-最坏情况-o-n" aria-label="Permalink to “2. 最坏情况（O(n)）”">​</a></h3><ul><li><strong>哈希冲突严重</strong>：当多个键的哈希值相同（哈希冲突），且这些键被存储在同一个桶中时，<code>HashMap</code> 会使用链表或红黑树来存储这些键值对。在这种情况下，<code>get</code> 操作需要遍历链表或红黑树来查找目标键。 <ul><li><strong>链表</strong>：如果桶中的元素以链表形式存储，时间复杂度为 O(n)，其中n是链表的长度。</li><li><strong>红黑树</strong>：在 JDK 1.8 及之后，当链表长度超过一定阈值（默认是 8）且桶数组长度大于等于 64 时，链表会转换为红黑树。此时，<code>get</code> 操作的时间复杂度为 O(log n)，其中 n 是树中节点的数量<a href="./@ref.html">3</a><a href="./@ref.html">4</a>。</li></ul></li></ul><h3 id="_3-总结" tabindex="-1">3. <strong>总结</strong> <a class="header-anchor" href="#_3-总结" aria-label="Permalink to “3. 总结”">​</a></h3><ul><li><strong>平均时间复杂度</strong>：O(1)，在哈希函数分布均匀且哈希冲突较少的情况下。</li><li><strong>最坏时间复杂度</strong>：O(n)，在哈希冲突严重且链表未转换为红黑树的情况下。</li><li><strong>优化后的最坏时间复杂度</strong>：O(log n)，在链表转换为红黑树的情况下<a href="./@ref.html">4</a><a href="./@ref.html">5</a>。</li></ul><p>通过合理的哈希函数设计和 <code>HashMap</code> 的扩容机制，可以尽量减少哈希冲突，使 <code>get</code> 操作的时间复杂度接近 O(1)。</p><h2 id="hashmap如何保证线程安全" tabindex="-1">HashMap如何保证线程安全 <a class="header-anchor" href="#hashmap如何保证线程安全" aria-label="Permalink to “HashMap如何保证线程安全”">​</a></h2><p>HashMap 本身是 <strong>非线程安全</strong> 的，在多线程环境下可能会出现数据不一致、死循环等问题。为了保证线程安全，可以使用以下几种方法：</p><hr><h3 id="_1-使用-collections-synchronizedmap" tabindex="-1"><strong>1. 使用 <code>Collections.synchronizedMap</code></strong> <a class="header-anchor" href="#_1-使用-collections-synchronizedmap" aria-label="Permalink to “1. 使用 Collections.synchronizedMap”">​</a></h3><p><code>Collections.synchronizedMap</code> 方法可以将普通的 <code>HashMap</code> 包装为一个线程安全的 <code>Map</code>。它通过在 <code>HashMap</code> 的所有操作方法上加锁（<code>synchronized</code>）来保证线程安全。<br><strong>示例代码</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Map&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Collections.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">synchronizedMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HashMap&lt;&gt;());</span></span></code></pre></div><p><strong>特点</strong>：</p><ul><li><strong>优点</strong>：使用简单，适合低并发场景。</li><li><strong>缺点</strong>：锁粒度较大（整个 <code>Map</code>），性能较差<a href="./@ref.html">2</a>。</li></ul><hr><h3 id="_2-使用-concurrenthashmap" tabindex="-1"><strong>2. 使用 <code>ConcurrentHashMap</code></strong> <a class="header-anchor" href="#_2-使用-concurrenthashmap" aria-label="Permalink to “2. 使用 ConcurrentHashMap”">​</a></h3><p><code>ConcurrentHashMap</code> 是 Java 并发包中提供的线程安全的 <code>Map</code> 实现。它通过 <strong>分段锁</strong>（JDK 1.7）或 <strong>CAS + <code>synchronized</code></strong>（JDK 1.8 及之后）来保证线程安全。<br><strong>示例代码</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Map&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ConcurrentHashMap&lt;&gt;();</span></span></code></pre></div><p><strong>特点</strong>：</p><ul><li><strong>优点</strong>：锁粒度更细，性能更高，适合高并发场景。</li><li><strong>缺点</strong>：内存开销较大，实现复杂<a href="./@ref.html">3</a><a href="./@ref.html">4</a>。</li></ul><hr><h3 id="_3-使用读写锁-readwritelock" tabindex="-1"><strong>3. 使用读写锁 (<code>ReadWriteLock</code>)</strong> <a class="header-anchor" href="#_3-使用读写锁-readwritelock" aria-label="Permalink to “3. 使用读写锁 (ReadWriteLock)”">​</a></h3><p>读写锁将锁分为 <strong>读锁</strong> 和 <strong>写锁</strong>，允许多个线程同时读取数据，但写操作是独占的。<br><strong>示例代码</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ReadWriteLock lock</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReentrantReadWriteLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Map&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HashMap&lt;&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 写操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        lock.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        writeLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        map.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        put</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        lock.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        writeLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 读操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        lock.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        readLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        String value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        lock.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        readLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span></code></pre></div><p><strong>特点</strong>：</p><ul><li><strong>优点</strong>：适合读多写少的场景，性能较好。</li><li><strong>缺点</strong>：实现较为复杂<a href="./@ref.html">2</a>。</li></ul><hr><h3 id="_4-方法内部使用局部-hashmap" tabindex="-1"><strong>4. 方法内部使用局部 <code>HashMap</code></strong> <a class="header-anchor" href="#_4-方法内部使用局部-hashmap" aria-label="Permalink to “4. 方法内部使用局部 HashMap”">​</a></h3><p>如果 <code>HashMap</code> 只在方法内部使用，且每个线程都有自己的实例，则无需额外同步。<br><strong>示例代码</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Map&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; localMap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HashMap&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        localMap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">put</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 其他操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span></code></pre></div><p><strong>特点</strong>：</p><ul><li><strong>优点</strong>：简单且线程安全。</li><li><strong>缺点</strong>：仅适用于局部变量场景<a href="./@ref.html">2</a>。</li></ul><hr><h3 id="_5-初始化写-后续只读" tabindex="-1"><strong>5. 初始化写，后续只读</strong> <a class="header-anchor" href="#_5-初始化写-后续只读" aria-label="Permalink to “5. 初始化写，后续只读”">​</a></h3><p>如果 <code>HashMap</code> 在初始化后不再修改，可以将其设为只读，从而避免线程安全问题。<br><strong>示例代码</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Map&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HashMap&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        map.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        put</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Collections.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        unmodifiableMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(map);</span></span></code></pre></div><p><strong>特点</strong>：</p><ul><li><strong>优点</strong>：简单且线程安全。</li><li><strong>缺点</strong>：仅适用于初始化后不再修改的场景<a href="./@ref.html">2</a>。</li></ul><hr><h3 id="总结-1" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-1" aria-label="Permalink to “总结”">​</a></h3><table tabindex="0"><thead><tr><th>方法</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><code>Collections.synchronizedMap</code></td><td>低并发场景</td><td>使用简单</td><td>锁粒度大，性能差</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>高并发场景</td><td>锁粒度细，性能高</td><td>内存开销大，实现复杂</td></tr><tr><td>读写锁 (<code>ReadWriteLock</code>)</td><td>读多写少场景</td><td>读操作并发性好</td><td>实现复杂</td></tr><tr><td>局部 <code>HashMap</code></td><td>方法内部使用</td><td>简单且线程安全</td><td>仅适用于局部变量</td></tr><tr><td>初始化写，后续只读</td><td>初始化后不再修改的场景</td><td>简单且线程安全</td><td>仅适用于只读场景</td></tr></tbody></table><p>在实际开发中，<strong><code>ConcurrentHashMap</code></strong> 是保证 <code>HashMap</code> 线程安全的首选方案，尤其在高并发场景下<a href="./@ref.html">3</a><a href="./@ref.html">4</a>。</p><h2 id="hashmap-和-hashtable-有什么区别" tabindex="-1">HashMap 和 Hashtable 有什么区别？ <a class="header-anchor" href="#hashmap-和-hashtable-有什么区别" aria-label="Permalink to “HashMap 和 Hashtable 有什么区别？”">​</a></h2><p><code>HashMap</code> 和 <code>Hashtable</code> 是 Java 中两种常用的键值对存储结构，它们虽然功能相似，但在线程安全性、性能、对 null 值的支持等方面存在显著区别。以下是它们的详细对比：</p><hr><h3 id="_1-线程安全性" tabindex="-1"><strong>1. 线程安全性</strong> <a class="header-anchor" href="#_1-线程安全性" aria-label="Permalink to “1. 线程安全性”">​</a></h3><ul><li><strong><code>Hashtable</code></strong>：是线程安全的，其所有公共方法都使用了 <code>synchronized</code> 关键字进行同步，因此在多线程环境下可以直接使用，但性能较低<a href="./@ref.html">1</a><a href="./@ref.html">2</a><a href="./@ref.html">3</a>。</li><li><strong><code>HashMap</code></strong>：是非线程安全的，多线程环境下可能导致数据不一致。如果需要在多线程环境中使用，可以通过 <code>Collections.synchronizedMap</code> 方法将其包装为线程安全的 <code>Map</code> ，或者使用 <code>ConcurrentHashMap</code><a href="./@ref.html">1</a><a href="./@ref.html">2</a><a href="./@ref.html">3</a>。</li></ul><hr><h3 id="_2-对-null-值的支持" tabindex="-1"><strong>2. 对 null 值的支持</strong> <a class="header-anchor" href="#_2-对-null-值的支持" aria-label="Permalink to “2. 对 null 值的支持”">​</a></h3><ul><li><strong><code>Hashtable</code></strong>：不允许键或值为 <code>null</code>，否则会抛出 <code>NullPointerException</code><a href="./@ref.html">1</a><a href="./@ref.html">2</a><a href="./@ref.html">3</a>。</li><li><strong><code>HashMap</code></strong>：允许键和值均为 <code>null</code>，但键为 <code>null</code> 的情况只能有一个，因为键必须唯一<a href="./@ref.html">1</a><a href="./@ref.html">2</a><a href="./@ref.html">3</a>。</li></ul><hr><h3 id="_3-性能" tabindex="-1"><strong>3. 性能</strong> <a class="header-anchor" href="#_3-性能" aria-label="Permalink to “3. 性能”">​</a></h3><ul><li><strong><code>Hashtable</code></strong>：由于所有方法都是同步的，性能较低，尤其在多线程环境下<a href="./@ref.html">2</a><a href="./@ref.html">3</a>。</li><li><strong><code>HashMap</code></strong>：非同步实现，性能较高，适合单线程环境。在多线程环境下，可以通过 <code>ConcurrentHashMap</code> 获得更好的性能<a href="./@ref.html">1</a><a href="./@ref.html">2</a><a href="./@ref.html">3</a>。</li></ul><hr><h3 id="_4-继承与实现" tabindex="-1"><strong>4. 继承与实现</strong> <a class="header-anchor" href="#_4-继承与实现" aria-label="Permalink to “4. 继承与实现”">​</a></h3><ul><li><strong><code>Hashtable</code></strong>：继承自 <code>Dictionary</code> 类（已过时），并实现了 <code>Map</code> 接口<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li><li><strong><code>HashMap</code></strong>：继承自 <code>AbstractMap</code> 类，并实现了 <code>Map</code> 接口<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li></ul><hr><h3 id="_5-扩容机制" tabindex="-1"><strong>5. 扩容机制</strong> <a class="header-anchor" href="#_5-扩容机制" aria-label="Permalink to “5. 扩容机制”">​</a></h3><ul><li><strong><code>Hashtable</code></strong>：默认初始容量为 11，扩容时容量变为原来的 2 倍加 1<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li><li><strong><code>HashMap</code></strong>：默认初始容量为 16，扩容时容量变为原来的 2 倍<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li></ul><hr><h3 id="_6-迭代器" tabindex="-1"><strong>6. 迭代器</strong> <a class="header-anchor" href="#_6-迭代器" aria-label="Permalink to “6. 迭代器”">​</a></h3><ul><li><strong><code>Hashtable</code></strong>：使用 <code>Enumeration</code> 进行遍历，不支持 <code>fail-fast</code> 机制<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li><li><strong><code>HashMap</code></strong>：使用 <code>Iterator</code> 进行遍历，支持 <code>fail-fast</code> 机制。如果在迭代过程中修改了 <code>HashMap</code> 的结构（如添加或删除元素），会抛出 <code>ConcurrentModificationException</code><a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li></ul><hr><h3 id="_7-计算哈希值的方式" tabindex="-1"><strong>7. 计算哈希值的方式</strong> <a class="header-anchor" href="#_7-计算哈希值的方式" aria-label="Permalink to “7. 计算哈希值的方式”">​</a></h3><ul><li><strong><code>Hashtable</code></strong>：直接使用对象的 <code>hashCode</code> 方法计算哈希值<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li><li><strong><code>HashMap</code></strong>：对 <code>hashCode</code> 进行二次处理，通过 <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 重新计算哈希值，以减少哈希冲突<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li></ul><hr><h3 id="总结-2" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-2" aria-label="Permalink to “总结”">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th><code>Hashtable</code></th><th><code>HashMap</code></th></tr></thead><tbody><tr><td><strong>线程安全性</strong></td><td>线程安全（同步方法）</td><td>非线程安全</td></tr><tr><td><strong>对 null 值的支持</strong></td><td>不允许键或值为 <code>null</code></td><td>允许键和值为 <code>null</code></td></tr><tr><td><strong>性能</strong></td><td>较低</td><td>较高</td></tr><tr><td><strong>继承类</strong></td><td><code>Dictionary</code>（已过时）</td><td><code>AbstractMap</code></td></tr><tr><td><strong>扩容机制</strong></td><td>容量变为 2 倍加 1</td><td>容量变为 2 倍</td></tr><tr><td><strong>迭代器</strong></td><td><code>Enumeration</code>，不支持 <code>fail-fast</code></td><td><code>Iterator</code>，支持 <code>fail-fast</code></td></tr><tr><td><strong>哈希值计算</strong></td><td>直接使用 <code>hashCode</code></td><td>对 <code>hashCode</code> 进行二次处理</td></tr></tbody></table><p>在实际开发中，<strong><code>HashMap</code></strong> 是更常用的选择，尤其是在单线程环境下。如果需要线程安全，推荐使用 <strong><code>ConcurrentHashMap</code></strong>，而不是 <code>Hashtable</code><a href="./@ref.html">1</a><a href="./@ref.html">2</a><a href="./@ref.html">3</a> 。</p><h2 id="当-hashmap-扩容时-所有的红黑树或者链表都会重新构造吗" tabindex="-1">当 HashMap 扩容时，所有的红黑树或者链表都会重新构造吗 <a class="header-anchor" href="#当-hashmap-扩容时-所有的红黑树或者链表都会重新构造吗" aria-label="Permalink to “当 HashMap 扩容时，所有的红黑树或者链表都会重新构造吗”">​</a></h2><p>是的，当 <strong>HashMap 扩容</strong> 时，所有的 <strong>链表</strong> 和 <strong>红黑树</strong> 都会重新构造。这是因为扩容后，数组的长度发生了变化，原有的哈希值计算方式也会随之改变，因此需要对所有元素进行重新哈希和分配。以下是详细的过程：</p><hr><h3 id="_1-链表重新构造" tabindex="-1"><strong>1. 链表重新构造</strong> <a class="header-anchor" href="#_1-链表重新构造" aria-label="Permalink to “1. 链表重新构造”">​</a></h3><p>在扩容过程中，链表会被拆分为 <strong>高位链表</strong> 和 <strong>低位链表</strong>，分别对应新数组中的不同位置。具体步骤如下：</p><ol><li><strong>遍历链表</strong>：从链表的头节点开始，逐个遍历每个节点。</li><li><strong>计算新位置</strong>：通过位运算 <code>e.hash &amp; oldCap</code> 判断节点应该分配到高位还是低位。 <ul><li>如果结果为 0，节点放入 <strong>低位链表</strong>，位置为 <code>原索引</code>。</li><li>如果结果为 1，节点放入 <strong>高位链表</strong>，位置为 <code>原索引 + 旧数组长度</code>。</li></ul></li><li><strong>重新连接链表</strong>：将拆分后的链表重新连接到新数组的对应位置<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</li></ol><hr><h3 id="_2-红黑树重新构造" tabindex="-1"><strong>2. 红黑树重新构造</strong> <a class="header-anchor" href="#_2-红黑树重新构造" aria-label="Permalink to “2. 红黑树重新构造”">​</a></h3><p>红黑树的重新构造与链表类似，但会涉及到红黑树的拆分和可能的 <strong>树转链表</strong> 操作：</p><ol><li><strong>遍历红黑树</strong>：红黑树的节点保留了链表的结构，因此可以像链表一样遍历。</li><li><strong>计算新位置</strong>：同样通过 <code>e.hash &amp; oldCap</code> 判断节点应该分配到高位还是低位。</li><li><strong>拆分红黑树</strong>：将红黑树拆分为 <strong>高位树</strong> 和 <strong>低位树</strong>。</li><li><strong>判断是否需要转链表</strong>： <ul><li>如果拆分后的树节点数小于等于 <code>UNTREEIFY_THRESHOLD</code>（默认是 6），则将红黑树转换为链表。</li><li>否则，将拆分后的树重新插入新数组的对应位置<a href="./@ref.html">1</a><a href="./@ref.html">3</a><a href="./@ref.html">5</a>。</li></ul></li></ol><hr><h3 id="_3-重新哈希的原因" tabindex="-1"><strong>3. 重新哈希的原因</strong> <a class="header-anchor" href="#_3-重新哈希的原因" aria-label="Permalink to “3. 重新哈希的原因”">​</a></h3><p>扩容后，数组的长度变为原来的两倍（例如从 16 变为 32），哈希值的计算方式从 <code>(n - 1) &amp; hash</code> 变为 <code>(2n - 1) &amp; hash</code> 。因此，原有的哈希值可能会映射到不同的位置，需要重新计算和分配<a href="./@ref.html">1</a><a href="./@ref.html">3</a>。</p><hr><h3 id="总结-3" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-3" aria-label="Permalink to “总结”">​</a></h3><p>当 HashMap 扩容时，所有的链表和红黑树都会重新构造。链表会被拆分为高位和低位链表，红黑树会被拆分为高位和低位树，并根据节点数决定是否转换为链表。这一过程确保了扩容后元素的分布依然均匀，维持了 HashMap 的高效性<a href="./@ref.html">1</a><a href="./@ref.html">3</a><a href="./@ref.html">5</a>。</p><h2 id="为什么hashmap选择红黑树而不选择b-树" tabindex="-1">为什么HashMap选择红黑树而不选择B+树 <a class="header-anchor" href="#为什么hashmap选择红黑树而不选择b-树" aria-label="Permalink to “为什么HashMap选择红黑树而不选择B+树”">​</a></h2><p><code>HashMap</code> 选择红黑树而不是 B+ 树的原因主要有以下几点：</p><hr><h3 id="_1-算法实现复杂度" tabindex="-1">1. <strong>算法实现复杂度</strong> <a class="header-anchor" href="#_1-算法实现复杂度" aria-label="Permalink to “1. 算法实现复杂度”">​</a></h3><ul><li><strong>红黑树</strong>：Java 中已经实现了红黑树，且红黑树的实现相对简单，复杂度较低。红黑树是一种自平衡二叉查找树，适合内存中的数据结构操作<a href="./@ref.html">22</a>。</li><li><strong>B+ 树</strong>：B+ 树的实现较为复杂，尤其是在内存中维护 B+ 树的结构需要更多的指针和节点管理，增加了实现的难度<a href="./@ref.html">22</a>。</li></ul><hr><h3 id="_2-底层数据结构匹配" tabindex="-1">2. <strong>底层数据结构匹配</strong> <a class="header-anchor" href="#_2-底层数据结构匹配" aria-label="Permalink to “2. 底层数据结构匹配”">​</a></h3><ul><li><strong>红黑树</strong>：<code>HashMap</code> 的底层是哈希表，红黑树作为链表过长时的替代结构，能够很好地与哈希表结合，解决哈希冲突问题<a href="./@ref.html">22</a>。</li><li><strong>B+ 树</strong>：B+ 树通常用于磁盘存储结构，其设计目标是减少磁盘 I/O 操作。而 <code>HashMap</code> 是基于内存的数据结构，B+ 树的优势在内存中并不明显<a href="./@ref.html">22</a>。</li></ul><hr><h3 id="_3-修改效率" tabindex="-1">3. <strong>修改效率</strong> <a class="header-anchor" href="#_3-修改效率" aria-label="Permalink to “3. 修改效率”">​</a></h3><ul><li><strong>红黑树</strong>：红黑树在插入、删除和查找操作上都有较好的性能，且维护平衡的代价较低。红黑树的旋转操作次数较少，适合频繁修改的场景<a href="./@ref.html">22</a>。</li><li><strong>B+ 树</strong>：B+ 树的修改操作需要调整节点和指针，尤其是在内存中频繁修改时，开销较大。B+ 树更适合静态或冷数据存储<a href="./@ref.html">22</a>。</li></ul><hr><h3 id="_4-内存占用" tabindex="-1">4. <strong>内存占用</strong> <a class="header-anchor" href="#_4-内存占用" aria-label="Permalink to “4. 内存占用”">​</a></h3><ul><li><strong>红黑树</strong>：红黑树的结构相对简单，内存占用较少，适合内存中的高效操作<a href="./@ref.html">22</a>。</li><li><strong>B+ 树</strong>：B+ 树的节点通常包含多个子节点，需要更多的指针和空间来维护结构，内存占用较高<a href="./@ref.html">22</a>。</li></ul><hr><h3 id="_5-适用场景" tabindex="-1">5. <strong>适用场景</strong> <a class="header-anchor" href="#_5-适用场景" aria-label="Permalink to “5. 适用场景”">​</a></h3><ul><li><strong>红黑树</strong>：红黑树适合内存中的动态数据管理，尤其是需要频繁插入、删除和查找的场景。<code>HashMap</code> 在链表长度超过阈值（默认为 8）时，将链表转换为红黑树，以提高查询效率<a href="./@ref.html">55</a>。</li><li><strong>B+ 树</strong>：B+ 树更适合磁盘存储，其设计目标是减少磁盘 I/O 操作，适用于数据库和文件系统等场景<a href="./@ref.html">22</a>。</li></ul><hr><h3 id="_6-维护成本" tabindex="-1">6. <strong>维护成本</strong> <a class="header-anchor" href="#_6-维护成本" aria-label="Permalink to “6. 维护成本”">​</a></h3><ul><li><strong>红黑树</strong>：红黑树的维护成本较低，适合高并发的场景。<code>HashMap</code> 在链表长度小于 6 时，会将红黑树转换回链表，进一步降低维护成本<a href="./@ref.html">56</a>。</li><li><strong>B+ 树</strong>：B+ 树的维护成本较高，尤其是在内存中频繁修改时，需要复杂的节点调整和指针管理<a href="./@ref.html">22</a>。</li></ul><hr><h3 id="总结-4" tabindex="-1">总结 <a class="header-anchor" href="#总结-4" aria-label="Permalink to “总结”">​</a></h3><p><code>HashMap</code> 选择红黑树而不是 B+ 树的主要原因在于红黑树更适合内存中的动态数据管理，实现简单、修改效率高、内存占用少，且维护成本低。而 B+ 树更适合磁盘存储，其优势在内存中无法充分发挥<a href="./@ref.html">22</a><a href="./@ref.html">55</a><a href="./@ref.html">56</a>。</p></div></div></main><footer class="VPDocFooter" data-v-d668f7cc data-v-1bcd8184><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/vite-press/computer-science/artificial-intelligence.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>Next page</span><span class="title" data-v-1bcd8184>Artificial Intelligence</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"api-examples.md\":\"ASzWeCQc\",\"computer-science_artificial-intelligence.md\":\"BFwZNgrM\",\"computer-science_git.md\":\"BStjTCzp\",\"computer-science_java__index.md\":\"CYy9hRGc\",\"computer-science_java_concurrent.md\":\"DDPceTvy\",\"computer-science_java_jackson.md\":\"tPZLj9bM\",\"computer-science_java_java-basic.md\":\"DEzpzAAj\",\"computer-science_java_java-hashmap.md\":\"Dgk76Anm\",\"computer-science_java_java-utils.md\":\"D8vnoAVB\",\"computer-science_java_java-密码学.md\":\"DfFW2nQb\",\"computer-science_java_java.md\":\"DjU0YVWC\",\"computer-science_java_jvm.md\":\"CttspKjG\",\"computer-science_java_map.md\":\"DolaAOvn\",\"computer-science_java_mybatis-plus.md\":\"OAEXOFjI\",\"computer-science_java_mybatis.md\":\"BC4cGPET\",\"computer-science_java_spring__index.md\":\"tPbqYCQb\",\"computer-science_java_spring_spring-boot-validation.md\":\"CQtBRAUn\",\"computer-science_java_spring_spring-transaction.md\":\"Bflwwxuh\",\"computer-science_java_spring_spring.md\":\"o6pOGruA\",\"computer-science_java_spring_springboot.md\":\"Cz9xABRq\",\"computer-science_java_spring_unit-test.md\":\"ScI6Ol5Z\",\"computer-science_java_xxl-job.md\":\"KtTBX7Bm\",\"computer-science_networking.md\":\"DD6FqDaI\",\"index.md\":\"DH2eL3W5\",\"life_article-recommend.md\":\"5ffH0Sdk\",\"life_life-recommend.md\":\"Bh4Wl_KF\",\"life_movies-log.md\":\"CFPkX0f8\",\"life_my-timeline.md\":\"NoiHHcsv\",\"life_website-recommend.md\":\"QKYk0CyE\",\"life_摘抄分享.md\":\"DdKCnmte\",\"markdown-examples.md\":\"70lz3mBO\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Penruins\",\"description\":\"A VitePress site\",\"base\":\"/vite-press/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Examples\",\"link\":\"/markdown-examples\"}],\"sidebar\":{\"computer-science\":[{\"text\":\"Computer Science\",\"items\":[{\"text\":\"Artificial Intelligence\",\"link\":\"/computer-science/artificial-intelligence\"},{\"text\":\"Networking\",\"link\":\"/computer-science/networking\"},{\"text\":\"git\",\"link\":\"/computer-science/git\"},{\"text\":\"Java\",\"items\":[{\"text\":\"java\",\"link\":\"/computer-science/java/java\"},{\"text\":\"java basic\",\"link\":\"/computer-science/java/java-basic\"}]}]}],\"life\":[{\"text\":\"life\",\"items\":[{\"text\":\"My Timeline\",\"link\":\"/life/my-timeline\"},{\"text\":\"Article Recommend\",\"link\":\"/life/article-recommend\"},{\"text\":\"Life Recommend\",\"link\":\"/life/life-recommend\"},{\"text\":\"Website Recommend\",\"link\":\"/life/website-recommend\"},{\"text\":\"Movies Log\",\"link\":\"/life/movies-log\"},{\"text\":\"摘抄分享\",\"link\":\"/life/摘抄分享\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>