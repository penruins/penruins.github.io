import{_ as i,c as e,o as l,ah as s}from"./chunks/framework.BCCRz_IA.js";const b=JSON.parse('{"title":"spring boot","description":"","frontmatter":{"date":"","draft":false,"title":"spring boot","weight":1000},"headers":[],"relativePath":"computer-science/java/spring/springboot.md","filePath":"computer-science/java/spring/springboot.md"}'),r={name:"computer-science/java/spring/springboot.md"};function n(t,a,d,h,o,c){return l(),e("div",null,[...a[0]||(a[0]=[s(`<h1 id="spring-boot" tabindex="-1">spring boot <a class="header-anchor" href="#spring-boot" aria-label="Permalink to “spring boot”">​</a></h1><h2 id="aop" tabindex="-1">AOP <a class="header-anchor" href="#aop" aria-label="Permalink to “AOP”">​</a></h2><h3 id="为什么要使用aop" tabindex="-1">为什么要使用AOP？ <a class="header-anchor" href="#为什么要使用aop" aria-label="Permalink to “为什么要使用AOP？”">​</a></h3><h3 id="aop的术语和流程" tabindex="-1">AOP的术语和流程 <a class="header-anchor" href="#aop的术语和流程" aria-label="Permalink to “AOP的术语和流程”">​</a></h3><h3 id="aop开发详解" tabindex="-1">AOP开发详解 <a class="header-anchor" href="#aop开发详解" aria-label="Permalink to “AOP开发详解”">​</a></h3><ul><li>确定拦截目标 <ul><li>需要拦截什么类的什么方法</li></ul></li><li>开发切面 <ul><li><code>@Aspect</code> 注解的一个类 <ul><li><code>@Before</code></li><li><code>@After</code></li><li><code>@AfterReturning</code></li><li><code>@AfterThrowing</code></li></ul></li></ul></li><li>定义切点</li></ul><h3 id="环绕通知" tabindex="-1">环绕通知 <a class="header-anchor" href="#环绕通知" aria-label="Permalink to “环绕通知”">​</a></h3><ul><li>一般而言，只有在需要大幅度修改原有目标对象的服务逻辑时才使用它，一般情况下尽量不要使用它。环绕通知是一个取代整个流程的通知，当然它也提供了回调原有流程的能力</li></ul><h3 id="引入" tabindex="-1">引入 <a class="header-anchor" href="#引入" aria-label="Permalink to “引入”">​</a></h3><h3 id="通知获取参数" tabindex="-1">通知获取参数 <a class="header-anchor" href="#通知获取参数" aria-label="Permalink to “通知获取参数”">​</a></h3><h3 id="织入" tabindex="-1">织入 <a class="header-anchor" href="#织入" aria-label="Permalink to “织入”">​</a></h3><ul><li>织入是一个生成动态代理对象并且将切面和目标对象方法编入约定流程的过程</li><li>本书中采用先声明接口再提供一个实现类的形式来提供服务类，这也是Spring推荐的方式，但是是否拥有接口并不是AOP的强制要求 <ul><li>在Java中，当前有多种方式实现动态代理，我们之前谈到的CGLIB只是其中的一种，业界比较流行的还有JDK和Javassist等。Spring采用了JDK和CGLIB，对于JDK动态代理的要求是被代理的目标对象必须拥有接口，而对于CGLIB动态代理则不做要求。因此，在默认的情况下，Spring会按照这样的一条规则处理：当需要使用AOP的类拥有接口时，它会以JDK动态代理的方式运行，否则以CGLIB动态代理的方式运行</li></ul></li></ul><h3 id="多个切面" tabindex="-1">多个切面 <a class="header-anchor" href="#多个切面" aria-label="Permalink to “多个切面”">​</a></h3><h2 id="数据库事务" tabindex="-1">数据库事务 <a class="header-anchor" href="#数据库事务" aria-label="Permalink to “数据库事务”">​</a></h2><h3 id="jdbc的数据库事务" tabindex="-1">JDBC的数据库事务 <a class="header-anchor" href="#jdbc的数据库事务" aria-label="Permalink to “JDBC的数据库事务”">​</a></h3><h3 id="spring声明式事务的使用" tabindex="-1">Spring声明式事务的使用 <a class="header-anchor" href="#spring声明式事务的使用" aria-label="Permalink to “Spring声明式事务的使用”">​</a></h3><ul><li>声明式事务是使用注解@Transactional进行标注的，这个注解可以标注在类或者方法上，当它标注在类上时，表示这个类所有公共的(public)非静态的方法都将启用事务功能</li></ul><h4 id="spring事务管理器" tabindex="-1">Spring事务管理器 <a class="header-anchor" href="#spring事务管理器" aria-label="Permalink to “Spring事务管理器”">​</a></h4><ul><li>在Spring中，事务管理器的顶层接口为 <code>TransactionManager</code>，这个接口没有任何方法定义，这是因为这个接口下又可以划分两大类事务管理器 <ul><li>响应式编程的事务管理器</li><li>非响应式编程的事务管理器 <ul><li><code>PlatformTransactionManager</code><ul><li>getTransaction 获取事务，返回事务状态</li><li>commit 提交事务</li><li>rollback 回滚事务</li></ul></li></ul></li></ul></li><li>在Spring Boot中，添加Maven依赖<code>mybatis-spring-boot-starter</code>之后，会自动创建<code>JdbcTransactionManager</code>对象作为事务管理器</li><li>如果依赖<code>spring-boot-starter-data-jpa</code>，则会自动创建<code>JpaTransactionManager</code>对象作为事务管理器</li></ul><h3 id="隔离级别" tabindex="-1">隔离级别 <a class="header-anchor" href="#隔离级别" aria-label="Permalink to “隔离级别”">​</a></h3><ul><li>在企业的生产实践中，选择隔离级别一般会以读写提交为主，它能够防止脏读，但不能避免不可重复读和幻读</li></ul><h3 id="传播行为" tabindex="-1">传播行为 <a class="header-anchor" href="#传播行为" aria-label="Permalink to “传播行为”">​</a></h3><ul><li>执行一个批量任务，它会处理很多的交易，绝大部分交易可以顺利完成，但是也有极少数的交易因为特殊原因不能完成而发生异常，这时我们不应该因为极少数的交易不能完成而回滚批量任务调用的其他交易，使得那些本能完成的交易也不能完成了 <ul><li>在执行一个批量任务的过程中，调用多个交易时，如果有一些交易发生异常，只回滚那些出现异常的交易，而不回滚整个批量任务，这样就能够使得那些没有问题的交易顺利完成，而有问题的交易则不做任何事情</li></ul></li><li>在Spring中，当一个方法调用另一个方法时，可以让事务采取不同的策略工作，如新建事务或者挂起当前事务等，这便是事务的传播行为</li><li>7种传播行为 <ul><li><strong>REQUIRED</strong><ul><li>需要事务，它是默认传播行为。如果当前存在事务，就沿用当前事务；否则新建一个事务运行该方法</li></ul></li><li>SUPPORTS <ul><li>支持事务。如果当前存在事务，就沿用当前事务；否则继续采用无事务的方式运行该方法</li></ul></li><li>MANDATORY <ul><li>必须使用事务。如果当前没有事务，则会抛出异常；如果存在当前事务，则沿用当前事务运行该方法￼</li></ul></li><li><strong>REQUIRES_NEW</strong><ul><li>无论当前事务是否存在，都会创建新事务运行该方法，这样新事务就可以拥有新的锁和隔离级别等特性，与当前事务相互独立￼</li><li>e.g. <ul><li>在进行数据同步的时候，不用将整个同步过程都设置为一个事务</li></ul></li></ul></li><li>NOT_SUPPORTED <ul><li>不支持事务，当前存在事务时，将挂起事务，运行方法</li></ul></li><li>NEVER <ul><li>不支持事务，如果当前存在事务，则抛出异常，否则继续采用无事务的方式运行该方法￼</li></ul></li><li><strong>NESTED</strong><ul><li>在当前方法调用方法时，如果被调用的方法发生异常，只回滚被调用的方法运行过的SQL语句，而不回滚当前方法的事务</li><li>原理 <ul><li>在大部分的数据库中，一段SQL语句中可以设置一个标志位，运行后面的SQL语句时如果有问题，只回滚到这个标志位的数据状态，而不会让这个标志位之前的SQL语句也回滚。这个标志位在数据库概念中被称为保存点(save point)。从加粗日志部分可以看到，Spring生成了nested事务，也可以看到保存点的释放，可见Spring也是使用保存点技术来完成让子事务回滚而不致使当前事务回滚的工作。</li><li>注意，并不是所有数据库都支持保存点技术，因此Spring内部有这样的规则：当数据库支持保存点技术时，就启用保存点技术；如果不能支持，就新建一个事务来运行代码，即等价于REQUIRES_NEW传播行为</li><li>NESTED 和 REQUIRES_NEW 的区别 <ul><li>NESTED传播行为和REQUIRES_NEW传播行为是有区别的：NESTED传播行为会沿用当前事务，以保存点技术为主；REQUIRES_NEW传播行为则创建新的事务，事务的提交和回滚也是独立的，它拥有独立上下文（例如隔离级别和超时时间等），这是在应用中需要注意的地方。</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="占用事务时间过长" tabindex="-1">占用事务时间过长 <a class="header-anchor" href="#占用事务时间过长" aria-label="Permalink to “占用事务时间过长”">​</a></h3><h3 id="transactional自调用失效问题" tabindex="-1">@Transactional自调用失效问题 <a class="header-anchor" href="#transactional自调用失效问题" aria-label="Permalink to “@Transactional自调用失效问题”">​</a></h3><h2 id="spring-data-redis" tabindex="-1">spring-data-redis <a class="header-anchor" href="#spring-data-redis" aria-label="Permalink to “spring-data-redis”">​</a></h2><ul><li>Reference <ul><li>《深入迁出 Spring Boot 3.x》7.1 spring-data-redis项目简介</li></ul></li></ul><h3 id="lettuce-vs-jedis" tabindex="-1">Lettuce vs Jedis <a class="header-anchor" href="#lettuce-vs-jedis" aria-label="Permalink to “Lettuce vs Jedis”">​</a></h3><ul><li>在Java中有很多种与Redis连接的驱动，目前使用比较广泛的是Lettuce和Jedis，它们是类似的，不过自Spring Boot 2.0发布以来，默认使用的是Lettuce</li><li>Lettuce是基于Netty框架的事件驱动的Redis客户端，其方法调用是异步的，其API也是线程安全的，因此多个线程可以操作单个Lettuce连接来完成各种操作，并且Lettuce支持连接池。Lettuce线程可以被多个请求公用，且不会产生频繁创建和关闭Lettuce连接的开销，因此比较适合应用于高并发网站。</li><li>Jedis是同步的，不支持异步，Jedis客户端连接不是线程安全的，需要为每个请求创建和关闭一个Jedis连接，所以一般通过连接池来使用Jedis客户端连接。Jedis不太适合在高并发网站使用，当遇到高并发场景时，Jedis连接池无法避免频繁创建和关闭Jedis连接，因为这会造成十分大的系统开销</li></ul><h3 id="redistemplate和-stringredistemplate" tabindex="-1">RedisTemplate和 StringRedisTemplate <a class="header-anchor" href="#redistemplate和-stringredistemplate" aria-label="Permalink to “RedisTemplate和 StringRedisTemplate”">​</a></h3><ul><li>StringRedisTemplate是RedisTemplate的子类，从名称就可以看出，StringRedisTemplate专门用于操作字符串</li><li>RedisTemplate，它是一个强大的类，会自动从RedisConnectionFactory工厂中获取连接，然后执行对应的Redis命令，最后还会关闭Redis的连接。这些操作都被封装在RedisTemplate中，所以开发者并不需要关注Redis连接的闭合问题</li></ul><h3 id="spring对redis数据类型操作的封装" tabindex="-1">Spring对Redis数据类型操作的封装 <a class="header-anchor" href="#spring对redis数据类型操作的封装" aria-label="Permalink to “Spring对Redis数据类型操作的封装”">​</a></h3><ul><li>ValueOperations 字符串操作接口</li><li>HashOperations 哈希操作接口</li><li>ListOperations 列表（链表）操作接口</li><li>SetOperations 集合操作接口</li><li>ZSetOperations 有序集合操作接口</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取字符串操作接口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">redisTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">opsForValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取哈希操作接口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">redisTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">opsForHash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取列表（链表）操作接口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">redisTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">opsForList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取集合操作接口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">redisTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">opsForSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取有序集合操作接口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">redisTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">opsForZSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="sessioncallback-和-rediscallback-接口" tabindex="-1">SessionCallback 和 RedisCallback 接口 <a class="header-anchor" href="#sessioncallback-和-rediscallback-接口" aria-label="Permalink to “SessionCallback 和 RedisCallback 接口”">​</a></h3><h3 id="redis事务" tabindex="-1">Redis事务 <a class="header-anchor" href="#redis事务" aria-label="Permalink to “Redis事务”">​</a></h3><h3 id="使用-redis-流水线" tabindex="-1">使用 Redis 流水线 <a class="header-anchor" href="#使用-redis-流水线" aria-label="Permalink to “使用 Redis 流水线”">​</a></h3><ul><li>在默认的情况下，Redis客户端把命令逐条发送到Redis服务器，这样做显然性能不高。在关系数据库中我们可以批量运行语句，也就是只有需要运行SQL语句时，才一次性地发送所有SQL语句去运行，这样性能就提高了许多。类似地，Redis也可以批量执行命令，这便是流水线(pipeline)技术，在很多情况下并不是Redis性能不佳，而是网络传输的速度慢造成瓶颈，使用流水线技术可以在需要执行很多命令时大幅度地提升Redis的性能</li></ul><h3 id="使用-redis发布-订阅" tabindex="-1">使用 Redis发布 / 订阅 <a class="header-anchor" href="#使用-redis发布-订阅" aria-label="Permalink to “使用 Redis发布 / 订阅”">​</a></h3><h3 id="使用-lua-脚本" tabindex="-1">使用 Lua 脚本 <a class="header-anchor" href="#使用-lua-脚本" aria-label="Permalink to “使用 Lua 脚本”">​</a></h3><ul><li>在Redis中运行Lua脚本具备原子性，且Lua脚本具备更加强大的计算能力，在高并发环境中需要保证数据一致性时，使用Lua脚本方案比使用Redis自身提供的事务更好</li><li>Redis提供了两种运行Lua的方法 <ul><li>一种是直接发送Lua脚本到Redis服务器运行</li><li>另一种是先把Lua脚本发送给Redis服务器，Redis服务器对Lua脚本进行缓存，然后返回一个32位的SHA1编码，之后只需要发送SHA1和相关参数给Redis服务器便可以运行了。 <ul><li>这里需要解释为什么会存在通过32位编码运行Lua脚本的方法。如果Lua脚本很长，那么就需要通过网络传递脚本给Redis服务器运行，而现实的情况是网络的传递速度往往跟不上Redis的运行速度，因此网络速度就会成为Redis运行的瓶颈。如果只传递32位编码和参数，那么需要通过网络传输的消息就少了许多，这样就可以提高系统的性能</li></ul></li></ul></li></ul><h3 id="使用-spring-缓存注解操作-redis" tabindex="-1">使用 Spring 缓存注解操作 Redis <a class="header-anchor" href="#使用-spring-缓存注解操作-redis" aria-label="Permalink to “使用 Spring 缓存注解操作 Redis”">​</a></h3><ul><li><code>@CachePut</code> 将方法返回的结果存储到缓存中</li><li><code>@Cacheable</code> 先通过定义的键从缓存中查询，如果可以查询到数据则返回，否则运行该方法，返回数据，并且将返回的结果存储到缓存中</li><li><code>@CacheEvict</code> 通过定义的键移除缓存</li></ul><h4 id="缓存注解自调用失效问题" tabindex="-1">缓存注解自调用失效问题 <a class="header-anchor" href="#缓存注解自调用失效问题" aria-label="Permalink to “缓存注解自调用失效问题”">​</a></h4><h4 id="自定义缓存管理器" tabindex="-1">自定义缓存管理器 <a class="header-anchor" href="#自定义缓存管理器" aria-label="Permalink to “自定义缓存管理器”">​</a></h4><h2 id="异步线程池" tabindex="-1">异步线程池 <a class="header-anchor" href="#异步线程池" aria-label="Permalink to “异步线程池”">​</a></h2><h2 id="异步消息-rabbitmq" tabindex="-1">异步消息 RabbitMQ <a class="header-anchor" href="#异步消息-rabbitmq" aria-label="Permalink to “异步消息 RabbitMQ”">​</a></h2><h2 id="定时任务" tabindex="-1">定时任务 <a class="header-anchor" href="#定时任务" aria-label="Permalink to “定时任务”">​</a></h2><h2 id="validation" tabindex="-1">validation <a class="header-anchor" href="#validation" aria-label="Permalink to “validation”">​</a></h2><ul><li><a href="https://blog.51cto.com/u_16213456/12497314" target="_blank" rel="noreferrer">spring boot validated 验证开始时间和结束时间</a></li></ul><h2 id="spring-boot-monitor" tabindex="-1">Spring-boot-monitor <a class="header-anchor" href="#spring-boot-monitor" aria-label="Permalink to “Spring-boot-monitor”">​</a></h2><ul><li>好久没维护了，服务有上下文资源会请求不到，这。。。。。。。</li><li>单机监控SpringBoot应用指标</li><li><a href="https://www.pomit.cn/SpringBootMonitor/#/" target="_blank" rel="noreferrer">官网</a></li></ul><h2 id="spring-boot-actuator" tabindex="-1">spring boot actuator <a class="header-anchor" href="#spring-boot-actuator" aria-label="Permalink to “spring boot actuator”">​</a></h2><ul><li><a href="https://www.cnkirito.moe/spring-boot-actuator-notes/" target="_blank" rel="noreferrer">警惕 Spring Boot Actuator 引发的安全漏洞</a></li></ul>`,54)])])}const u=i(r,[["render",n]]);export{b as __pageData,u as default};
