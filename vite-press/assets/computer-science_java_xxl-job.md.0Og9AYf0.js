import{_ as i,c as l,o as a,ah as n}from"./chunks/framework.DzUG-V_P.js";const k=JSON.parse('{"title":"xxl job","description":"","frontmatter":{"date":"","draft":false,"title":"xxl job","weight":1000},"headers":[],"relativePath":"computer-science/java/xxl-job.md","filePath":"computer-science/java/xxl-job.md"}'),t={name:"computer-science/java/xxl-job.md"};function e(r,s,o,h,p,d){return a(),l("div",null,[...s[0]||(s[0]=[n(`<ul><li><a href="https://github.com/xuxueli/xxl-job?tab=readme-ov-file" target="_blank" rel="noreferrer">xuxueli/xxl-job</a><ul><li><a href="https://www.xuxueli.com/xxl-job/" target="_blank" rel="noreferrer">文档</a></li></ul></li></ul><h1 id="什么情况下使用-springboot自带的schedule-什么时候应该使用-xxl-job" tabindex="-1">什么情况下使用 springboot自带的schedule，什么时候应该使用 xxl job <a class="header-anchor" href="#什么情况下使用-springboot自带的schedule-什么时候应该使用-xxl-job" aria-label="Permalink to “什么情况下使用 springboot自带的schedule，什么时候应该使用 xxl job”">​</a></h1><p>在分布式系统和定时任务调度场景中，选择 Spring Boot 自带的 <code>@Scheduled</code> 还是分布式任务调度框架（如 XXL-JOB）取决于业务需求和技术架构。以下是详细的对比和决策建议：</p><hr><h3 id="_1-spring-boot-自带的-scheduled" tabindex="-1"><strong>1. Spring Boot 自带的 <code>@Scheduled</code></strong> <a class="header-anchor" href="#_1-spring-boot-自带的-scheduled" aria-label="Permalink to “1. Spring Boot 自带的 @Scheduled”">​</a></h3><p><strong>适用场景</strong>：</p><ul><li><strong>单机环境</strong>：任务只需在单个节点运行，无需分布式协调。</li><li><strong>简单任务</strong>：轻量级、短时间执行的定时任务（如本地缓存刷新、日志清理）。</li><li><strong>开发效率</strong>：快速集成，无需额外部署中间件。</li><li><strong>强一致性要求低</strong>：任务重复执行或偶尔遗漏对业务影响较小（如非关键统计报表）。</li></ul><p><strong>优势</strong>：</p><ul><li>零依赖，与 Spring 生态无缝集成。</li><li>注解驱动（<code>@Scheduled</code>），配置简单（支持 cron 表达式、固定速率/延迟）。</li></ul><p><strong>局限性</strong>：</p><ul><li><strong>无分布式协调</strong>：多实例部署时任务会重复执行（需自行加锁，如 <code>@SchedulerLock</code>）。</li><li><strong>无可视化管控</strong>：任务状态、日志需自行实现。</li><li><strong>缺乏弹性调度</strong>：不支持动态调整、故障转移、分片等高级特性。</li></ul><p><strong>示例代码</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Scheduled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cron</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;0 0/5 * * * ?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> refreshCache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 单机任务逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h3 id="_2-xxl-job" tabindex="-1"><strong>2. XXL-JOB</strong> <a class="header-anchor" href="#_2-xxl-job" aria-label="Permalink to “2. XXL-JOB”">​</a></h3><p><strong>适用场景</strong>：</p><ul><li><strong>分布式环境</strong>：需要任务在多个节点间协调（如唯一执行、分片处理）。</li><li><strong>复杂任务</strong>：长耗时任务（需超时控制）、需动态启停或修改调度策略。</li><li><strong>高可靠性</strong>：要求任务失败重试、故障自动转移、报警通知。</li><li><strong>运维需求</strong>：需要可视化任务管理、执行日志追踪、用户权限控制。</li></ul><p><strong>优势</strong>：</p><ul><li><strong>分布式调度</strong>：通过中心化调度器（如数据库、Redis）避免任务重复执行。</li><li><strong>任务分片</strong>：将大数据任务拆分到多个节点并行处理（如批量处理百万条数据）。</li><li><strong>运维友好</strong>：提供管理界面，支持动态配置、日志查看、报警推送。</li><li><strong>扩展性</strong>：支持 GLUE 脚本（动态修改代码）、跨语言任务（通过 HTTP 调用）。</li></ul><p><strong>局限性</strong>：</p><ul><li>需要额外部署调度中心（Admin）和执行器（Executor），增加架构复杂度。</li><li>依赖中间件（如 MySQL），存在性能瓶颈风险（高频任务需优化）。</li></ul><p><strong>示例配置</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">XxlJob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;demoJobHandler&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 分布式任务逻辑（支持分片参数）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shardIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> XxlJobHelper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getShardIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shardTotal </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> XxlJobHelper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getShardTotal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h3 id="决策树-如何选择" tabindex="-1"><strong>决策树：如何选择？</strong> <a class="header-anchor" href="#决策树-如何选择" aria-label="Permalink to “决策树：如何选择？”">​</a></h3><ol><li><p><strong>是否多实例部署？</strong></p><ul><li>是 → 选择 XXL-JOB（避免任务重复）。</li><li>否 → 考虑 <code>@Scheduled</code>。</li></ul></li><li><p><strong>是否需要任务高可用/弹性？</strong></p><ul><li>是（如支付对账、订单补单）→ XXL-JOB。</li><li>否（如本地日志清理）→ <code>@Scheduled</code>。</li></ul></li><li><p><strong>是否需要动态管理？</strong></p><ul><li>是（如频繁调整 cron 表达式）→ XXL-JOB。</li><li>否（固定任务）→ <code>@Scheduled</code>。</li></ul></li><li><p><strong>任务是否分片/并行？</strong></p><ul><li>是（如大数据处理）→ XXL-JOB。</li><li>否 → <code>@Scheduled</code>。</li></ul></li></ol><hr><h3 id="_3-其他替代方案" tabindex="-1"><strong>3. 其他替代方案</strong> <a class="header-anchor" href="#_3-其他替代方案" aria-label="Permalink to “3. 其他替代方案”">​</a></h3><ul><li><strong>Quartz</strong>：适合需要数据库持久化但无需复杂管理的场景（需自行封装分布式锁）。</li><li><strong>Elastic-Job</strong>：基于 ZooKeeper 的分布式调度，适合分片需求高的场景（已停更，可考虑 ShedLock）。</li><li><strong>Kubernetes CronJob</strong>：若应用部署在 K8s 中，可直接使用原生 CronJob 实现单次任务调度。</li></ul><hr><h3 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h3><ul><li><strong>Spring Boot <code>@Scheduled</code></strong>：简单、单机、轻量级任务。</li><li><strong>XXL-JOB</strong>：分布式、高可靠、需运维管控的复杂任务。</li></ul><p>根据团队规模、运维能力和业务需求权衡，避免为简单场景过度设计，也不要在分布式环境下强用单机方案。</p>`,33)])])}const c=i(t,[["render",e]]);export{k as __pageData,c as default};
