import{_ as t,c as i,o as r,ah as a}from"./chunks/framework.CUZTSfUD.js";const p=JSON.parse('{"title":"SecurityContextHolder","description":"","frontmatter":{},"headers":[],"relativePath":"computer-science/java/spring/spring-security.md","filePath":"computer-science/java/spring/spring-security.md"}'),n={name:"computer-science/java/spring/spring-security.md"};function s(l,e,o,c,h,u){return r(),i("div",null,[...e[0]||(e[0]=[a(`<ul><li><a href="https://springdoc.cn/spring-security/" target="_blank" rel="noreferrer">Spring Security 中文文档</a></li><li><a href="https://springdoc.cn/spring-security/servlet/getting-started.html" target="_blank" rel="noreferrer">Hello Spring Security</a><ul><li>Spring Boot 将任何以 @Bean 形式发布的 Filter 添加到应用程序的 filter chain 中。这意味着，结合 Spring Boot 使用 @EnableWebSecurity 会自动为每个请求注册 Spring Security 的 filter chain。</li></ul></li></ul><h1 id="securitycontextholder" tabindex="-1">SecurityContextHolder <a class="header-anchor" href="#securitycontextholder" aria-label="Permalink to “SecurityContextHolder”">​</a></h1><ul><li><p>The SecurityContext is used to store the details of the currently authenticated user, also known as a principle. So, if you have to get the username or any other user details, you need to get this SecurityContext first. The SecurityContextHolder is a helper class, which provide access to the security context. By default, it uses a ThreadLocal object to store security context, which means that the security context is always available to methods in the same thread of execution, even if you don’t pass the SecurityContext object around.</p></li><li><p>reference</p><ul><li><a href="https://www.javacodegeeks.com/2018/02/securitycontext-securitycontextholder-spring-security.html" target="_blank" rel="noreferrer">What is SecurityContext and SecurityContextHolder in Spring Security?</a></li></ul></li></ul><h1 id="架构" tabindex="-1">架构 <a class="header-anchor" href="#架构" aria-label="Permalink to “架构”">​</a></h1><p>Spring Security 对 Servlet 的支持是基于Servlet过滤器的，所以先看一下过滤器的一般作用是很有帮助的</p><ul><li><a href="https://springdoc.cn/spring-security/servlet/architecture.html" target="_blank" rel="noreferrer">架构</a></li></ul><h1 id="cas-认证" tabindex="-1">CAS 认证 <a class="header-anchor" href="#cas-认证" aria-label="Permalink to “CAS 认证”">​</a></h1><ul><li><a href="https://springdoc.cn/spring-security/servlet/authentication/cas.html" target="_blank" rel="noreferrer">CAS 认证</a></li></ul><h1 id="oauth-2-0-资源服务器-jwt" tabindex="-1">OAuth 2.0 资源服务器 JWT <a class="header-anchor" href="#oauth-2-0-资源服务器-jwt" aria-label="Permalink to “OAuth 2.0 资源服务器 JWT”">​</a></h1><ul><li><a href="https://springdoc.cn/spring-security/servlet/oauth2/resource-server/jwt.html" target="_blank" rel="noreferrer">OAuth 2.0 资源服务器 JWT</a></li></ul><h1 id="how-to-manually-authenticate-user-with-spring-security" tabindex="-1">How to Manually Authenticate User with Spring Security <a class="header-anchor" href="#how-to-manually-authenticate-user-with-spring-security" aria-label="Permalink to “How to Manually Authenticate User with Spring Security”">​</a></h1><p>Simply put, Spring Security hold the principal information of each authenticated user in a ThreadLocal – represented as an Authentication object.</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UsernamePasswordAuthenticationToken authReq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UsernamePasswordAuthenticationToken</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user, pass);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Authentication auth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> authManager.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">authenticate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(authReq);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SecurityContext sc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SecurityContextHolder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sc.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAuthentication</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(auth);</span></span></code></pre></div><p>After setting the Authentication in the context, we’ll now be able to check if the current user is authenticated – using securityContext.getAuthentication().isAuthenticated().</p><ul><li>reference <ul><li><a href="https://www.baeldung.com/manually-set-user-authentication-spring-security" target="_blank" rel="noreferrer">How to Manually Authenticate User with Spring Security</a></li></ul></li></ul><h1 id="reference" tabindex="-1">reference <a class="header-anchor" href="#reference" aria-label="Permalink to “reference”">​</a></h1><ul><li><a href="https://blog.csdn.net/u012373815/article/details/54632176" target="_blank" rel="noreferrer">springboot+mybatis＋SpringSecurity 实现用户角色数据库管理(一)</a></li><li><a href="https://github.com/Snailclimb/spring-security-jwt-guide" target="_blank" rel="noreferrer">Snailclimb/spring-security-jwt-guide</a><ul><li><a href="https://github.com/Snailclimb/spring-security-jwt-guide/blob/master/docs/SpringSecurity%E4%BB%8B%E7%BB%8D.md" target="_blank" rel="noreferrer">Spring Security 介绍</a></li></ul></li></ul><h2 id="spring-security-一-architecture-overview" tabindex="-1">Spring Security(一)--Architecture Overview <a class="header-anchor" href="#spring-security-一-architecture-overview" aria-label="Permalink to “Spring Security(一)--Architecture Overview”">​</a></h2><ul><li><a href="https://www.cnkirito.moe/spring-security-1/" target="_blank" rel="noreferrer">Spring Security(一)--Architecture Overview</a></li></ul><h3 id="核心组件" tabindex="-1">核心组件 <a class="header-anchor" href="#核心组件" aria-label="Permalink to “核心组件”">​</a></h3><h4 id="_1-1-securitycontextholder" tabindex="-1"><strong>1.1 SecurityContextHolder</strong> <a class="header-anchor" href="#_1-1-securitycontextholder" aria-label="Permalink to “1.1 SecurityContextHolder”">​</a></h4><ul><li>SecurityContextHolder 用于存储安全上下文（security context）的信息。当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限… 这些都被保存在 SecurityContextHolder 中</li><li>SecurityContextHolder 默认使用 ThreadLocal 策略来存储认证信息 <ul><li>看到 ThreadLocal 也就意味着，这是一种与线程绑定的策略</li><li>Spring Security 在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息</li><li>但这一切的前提，是你在 web 场景下使用 Spring Security，而如果是 Swing 界面，Spring 也提供了支持，SecurityContextHolder 的策略则需要被替换，鉴于我的初衷是基于 web 来介绍 Spring Security，所以这里以及后续，非 web 的相关的内容都一笔带过</li></ul></li><li>获取当前用户的信息 <ul><li>因为身份信息是与线程绑定的，所以可以在程序的任何地方使用静态方法获取用户信息</li></ul></li></ul><h4 id="_1-2-authentication" tabindex="-1"><strong>1.2 Authentication</strong> <a class="header-anchor" href="#_1-2-authentication" aria-label="Permalink to “1.2 Authentication”">​</a></h4><ul><li>Authentication 是 spring security 包中的接口，直接继承自 Principal 类，而 Principal 是位于 java.security 包中的。可以见得，Authentication 在 spring security 中是最高级别的身份 / 认证的抽象。</li><li>由这个顶级接口，我们可以得到用户拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息</li></ul><h4 id="spring-security-是如何完成身份认证的" tabindex="-1"><strong>Spring Security 是如何完成身份认证的？</strong> <a class="header-anchor" href="#spring-security-是如何完成身份认证的" aria-label="Permalink to “Spring Security 是如何完成身份认证的？”">​</a></h4><ul><li>1 用户名和密码被过滤器获取到，封装成 Authentication, 通常情况下是 UsernamePasswordAuthenticationToken 这个实现类。</li><li>2 AuthenticationManager 身份管理器负责验证这个 Authentication</li><li>3 认证成功后，AuthenticationManager 身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）Authentication 实例。</li><li>4 SecurityContextHolder 安全上下文容器将第 3 步填充了信息的 Authentication，通过 SecurityContextHolder.getContext().setAuthentication(…) 方法，设置到其中。</li></ul><h4 id="_1-3-authenticationmanager" tabindex="-1"><strong>1.3 AuthenticationManager</strong> <a class="header-anchor" href="#_1-3-authenticationmanager" aria-label="Permalink to “1.3 AuthenticationManager”">​</a></h4><ul><li>AuthenticationManager（接口）是认证相关的核心接口，也是发起认证的出发点，因为在实际需求中，我们可能会允许用户使用用户名 + 密码登录，同时允许用户使用邮箱 + 密码，手机号码 + 密码登录，甚至，可能允许用户使用指纹登录</li><li>所以说 AuthenticationManager 一般不直接认证，AuthenticationManager 接口的常用实现类 ProviderManager 内部会维护一个 <code>List&lt;AuthenticationProvider&gt;</code> 列表，存放多种认证方式，实际上这是委托者模式的应用（Delegate）。也就是说，核心的认证入口始终只有一个：AuthenticationManager，不同的认证方式：用户名 + 密码（UsernamePasswordAuthenticationToken），邮箱 + 密码，手机号码 + 密码登录则对应了三个 AuthenticationProvider</li><li>ProviderManager 中的 List，会依照次序去认证，认证成功则立即返回，若认证失败则返回 null，下一个 AuthenticationProvider 会继续尝试认证，如果所有认证器都无法认证成功，则 ProviderManager 会抛出一个 ProviderNotFoundException 异常</li></ul><h4 id="_1-4-daoauthenticationprovider" tabindex="-1"><strong>1.4 DaoAuthenticationProvider</strong> <a class="header-anchor" href="#_1-4-daoauthenticationprovider" aria-label="Permalink to “1.4 DaoAuthenticationProvider”">​</a></h4><ul><li>AuthenticationProvider 最最最常用的一个实现便是 DaoAuthenticationProvider。顾名思义，Dao 正是数据访问层的缩写，也暗示了这个身份认证器的实现思路</li><li>按照我们最直观的思路，怎么去认证一个用户呢？用户前台提交了用户名和密码，而数据库中保存了用户名和密码，认证便是负责比对同一个用户名，提交的密码和保存的密码是否相同便是了。在 Spring Security 中。提交的用户名和密码，被封装成了 UsernamePasswordAuthenticationToken，而根据用户名加载用户的任务则是交给了 UserDetailsService，在 DaoAuthenticationProvider 中，对应的方法便是 retrieveUser，虽然有两个参数，但是 retrieveUser 只有第一个参数起主要作用，返回一个 UserDetails。还需要完成 UsernamePasswordAuthenticationToken 和 UserDetails 密码的比对，这便是交给 additionalAuthenticationChecks 方法完成的，如果这个 void 方法没有抛异常，则认为比对成功。比对密码的过程，用到了 PasswordEncoder 和 SaltSource，密码加密和盐的概念相信不用我赘述了，它们为保障安全而设计，都是比较基础的概念。</li></ul><h4 id="_1-5-userdetails-与-userdetailsservice" tabindex="-1"><strong>1.5 UserDetails 与 UserDetailsService</strong> <a class="header-anchor" href="#_1-5-userdetails-与-userdetailsservice" aria-label="Permalink to “1.5 UserDetails 与 UserDetailsService”">​</a></h4><p>UserDetailsService 和 AuthenticationProvider 两者的职责常常被人们搞混，关于他们的问题在文档的 FAQ 和 issues 中屡见不鲜。记住一点即可，敲黑板！！！UserDetailsService 只负责从特定的地方（通常是数据库）加载用户信息，仅此而已，记住这一点，可以避免走很多弯路。UserDetailsService 常见的实现类有 JdbcDaoImpl，InMemoryUserDetailsManager，前者从数据库加载用户，后者从内存中加载用户，也可以自己实现 UserDetailsService，通常这更加灵活</p>`,32)])])}const g=t(n,[["render",s]]);export{p as __pageData,g as default};
