import{_ as i,c as e,o as a,af as r}from"./chunks/framework.Bhntpte7.js";const p=JSON.parse('{"title":"spring","description":"","frontmatter":{"date":"","draft":false,"title":"spring","weight":1000},"headers":[],"relativePath":"computer-science/java/spring/spring.md","filePath":"computer-science/java/spring/spring.md"}'),n={name:"computer-science/java/spring/spring.md"};function o(t,l,s,c,h,u){return a(),e("div",null,[...l[0]||(l[0]=[r('<h1 id="spring" tabindex="-1">Spring <a class="header-anchor" href="#spring" aria-label="Permalink to “Spring”">​</a></h1><ul><li><a href="https://github.com/ThomasVitale/awesome-spring" target="_blank" rel="noreferrer">ThomasVitale/awesome-spring</a></li><li><a href="https://www.thomasvitale.com/" target="_blank" rel="noreferrer">Thomas Vitale</a><ul><li>Software Engineer | Java | Cloud Native | Developer Experience</li></ul></li><li><a href="https://github.com/huanzi-qch/springBoot" target="_blank" rel="noreferrer">huanzi-qch/springBoot</a><ul><li>SpringBoot系列Demo代码</li></ul></li><li><a href="https://github.com/ThomasVitale/developer-experience-java-kubernetes" target="_blank" rel="noreferrer">ThomasVitale/developer-experience-java-kubernetes</a></li><li><a href="https://github.com/ThomasVitale/cloud-native-spring-in-action" target="_blank" rel="noreferrer">ThomasVitale/cloud-native-spring-in-action</a></li><li><a href="https://github.com/ThomasVitale" target="_blank" rel="noreferrer">Thomas Vitale</a><ul><li>Software Engineer 📚 Author of “Cloud Native Spring in Action” + &quot;Developer Experience on Kubernetes&quot; 🛳️ CNCF Ambassador 👨‍💻 OSS, Java, Cloud Native, AI</li></ul></li><li><a href="https://github.com/ThomasVitale/supply-chain-security-java" target="_blank" rel="noreferrer">ThomasVitale/supply-chain-security-java</a><ul><li>Samples showing how to secure the supply chain for Java applications</li></ul></li><li><a href="https://github.com/ThomasVitale/langchain4j-spring" target="_blank" rel="noreferrer">ThomasVitale/langchain4j-spring</a></li><li><a href="https://github.com/ThomasVitale/spring-tutorials" target="_blank" rel="noreferrer">ThomasVitale/spring-tutorials</a></li><li><a href="https://github.com/xmolecules/jmolecules" target="_blank" rel="noreferrer">xmolecules/jmolecules</a><ul><li>Libraries to help developers express architectural abstractions in Java code</li></ul></li><li><a href="https://github.com/kcctl/kcctl" target="_blank" rel="noreferrer">kcctl/kcctl</a><ul><li>A modern and intuitive command line client for Kafka Connect</li></ul></li><li><a href="https://github.com/marcushellberg/practical-ai-in-java" target="_blank" rel="noreferrer">marcushellberg/practical-ai-in-java</a></li><li><a href="https://github.com/jline/jline3" target="_blank" rel="noreferrer">jline/jline3</a></li></ul><h2 id="什么是spring" tabindex="-1">什么是Spring <a class="header-anchor" href="#什么是spring" aria-label="Permalink to “什么是Spring”">​</a></h2><ul><li>Spring是一个java开发框架</li><li>它的核心特性是 <ul><li><strong>控制反转</strong></li><li><strong>依赖注入</strong></li><li><strong>面向切面编程</strong></li><li><strong>声明式事务管理</strong></li><li><strong>模块化设计</strong></li></ul></li></ul><h2 id="spring-mvc" tabindex="-1">Spring MVC <a class="header-anchor" href="#spring-mvc" aria-label="Permalink to “Spring MVC”">​</a></h2><h3 id="spring-mvc-流程" tabindex="-1">Spring MVC 流程 <a class="header-anchor" href="#spring-mvc-流程" aria-label="Permalink to “Spring MVC 流程”">​</a></h3><ul><li>流程 <ul><li>用户发送请求</li><li><code>DispatcherServlet</code> 调用 <code>HandlerMapping</code></li><li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code></li><li>Controller 处理请求</li><li><code>DispatcherServlet</code> 调用 <code>ViewResolver</code></li><li>视图渲染 ModelAndView -&gt; ViewResolver -&gt; View</li><li>返回响应</li></ul></li><li>核心组件 <ul><li><strong>DispatcherServlet</strong>：前端控制器，负责请求的分发和协调</li><li><strong>HandlerMapping</strong>：根据请求 URL 查找对应的 Handler</li><li><strong>HandlerAdapter</strong>：适配并执行 Handler</li><li><strong>Controller</strong>：处理具体的业务逻辑</li><li><strong>ViewResolver</strong>：解析视图名称，生成具体的 View 对象</li><li><strong>View</strong>：负责视图的渲染</li></ul></li></ul><h2 id="bean" tabindex="-1">Bean <a class="header-anchor" href="#bean" aria-label="Permalink to “Bean”">​</a></h2><h3 id="bean的生命周期" tabindex="-1">Bean的生命周期 <a class="header-anchor" href="#bean的生命周期" aria-label="Permalink to “Bean的生命周期”">​</a></h3><ul><li>Bean的实例化 <ul><li>通过反射调用 Bean 的构造函数，创建Bean的实例</li></ul></li><li>填充属性（依赖注入） <ul><li>Spring根据配置文件或注解，将依赖的Bean注入到当前Bean中</li></ul></li><li>调用Aware接口 <ul><li>如果Bean实现了Spring的<code>Aware</code>接口，Spring会调用对应的回调方法</li></ul></li><li><code>BeanPostProcessor</code> 的前置处理 <ul><li>Spring调用所有<code>BeanPostProcessor</code>的<code>postProcessBeforeInitialization()</code>方法</li></ul></li><li>执行初始化方法 <ul><li>Spring会调用Bean的初始化方法。</li><li>@PostConstruct</li></ul></li><li>BeanPostProcessor的后置处理 <ul><li>Spring调用所有<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization()</code>方法。</li></ul></li><li>Bean初始化完成 <ul><li>Bean已经完全初始化，可以被其他Bean使用。</li></ul></li><li>Bean的使用</li><li>Bean的销毁</li></ul><h3 id="bean的作用域" tabindex="-1">Bean的作用域 <a class="header-anchor" href="#bean的作用域" aria-label="Permalink to “Bean的作用域”">​</a></h3><ul><li>Singleton（单例） <ul><li>默认作用域，单例模式</li></ul></li><li>Prototype（原型） <ul><li>每次请求创建新实例</li></ul></li><li>Request（请求） <ul><li>每个 HTTP 请求创建一个实例</li></ul></li><li>Session（会话） <ul><li>每个 HTTP Session 创建一个实例</li></ul></li><li>Application（应用） <ul><li>整个 ServletContext 生命周期内有效</li></ul></li><li>WebSocket <ul><li>WebSocket 会话生命周期内有效</li></ul></li></ul><h3 id="spring-循环依赖如何解决" tabindex="-1">spring 循环依赖如何解决？ <a class="header-anchor" href="#spring-循环依赖如何解决" aria-label="Permalink to “spring 循环依赖如何解决？”">​</a></h3><ul><li>三级缓存 <ul><li><code>singletonObjects</code>：一级缓存，存储经历了完整生命周期的Bean对象</li><li><code>earlySingletonObjects</code>：二级缓存，存储提前暴露出来的Bean对象，其生命周期未结束，属性未完全填充</li><li><code>singletonFactories</code>：三级缓存，存储生成Bean的工厂</li></ul></li></ul><h2 id="ioc" tabindex="-1">IOC <a class="header-anchor" href="#ioc" aria-label="Permalink to “IOC”">​</a></h2><h3 id="什么是ioc" tabindex="-1">什么是IOC <a class="header-anchor" href="#什么是ioc" aria-label="Permalink to “什么是IOC”">​</a></h3><ul><li>IOC是控制反转的意思，在一个程序中对象的创建与管理由一个容器负责，对象之间的引用通过注入(属性填充)的方式从容器中获取，降低了代码之间的耦合度</li></ul><h3 id="ioc-的核心概念是什么" tabindex="-1">IOC 的核心概念是什么？ <a class="header-anchor" href="#ioc-的核心概念是什么" aria-label="Permalink to “IOC 的核心概念是什么？”">​</a></h3><ul><li>依赖注入</li><li>控制反转</li><li>IOC容器</li></ul><h3 id="举一个-spring-的容器" tabindex="-1">举一个 Spring 的容器？ <a class="header-anchor" href="#举一个-spring-的容器" aria-label="Permalink to “举一个 Spring 的容器？”">​</a></h3><ul><li><code>BeanFactory</code></li><li><code>ApplicationContext</code></li><li><code>WebApplicationContext</code></li></ul><h3 id="ioc-的优势是什么" tabindex="-1">IOC 的优势是什么？ <a class="header-anchor" href="#ioc-的优势是什么" aria-label="Permalink to “IOC 的优势是什么？”">​</a></h3><ul><li>降低耦合度</li><li>提高可测试性 <ul><li>注入模拟对象进行测试</li></ul></li><li>增强可扩展性</li><li>优化资源管理 <ul><li>容器管理对象的创建和销毁，避免资源浪费</li></ul></li></ul><h2 id="aop" tabindex="-1">AOP <a class="header-anchor" href="#aop" aria-label="Permalink to “AOP”">​</a></h2><h3 id="什么是aop" tabindex="-1">什么是AOP？ <a class="header-anchor" href="#什么是aop" aria-label="Permalink to “什么是AOP？”">​</a></h3><ul><li>AOP 是一种<strong>编程范式</strong>, 通过将横切关注点与业务代码分离，提高代码的可维护性与可重用性</li></ul><h3 id="aop的核心概念是什么" tabindex="-1">AOP的核心概念是什么？ <a class="header-anchor" href="#aop的核心概念是什么" aria-label="Permalink to “AOP的核心概念是什么？”">​</a></h3><ul><li>切面 <strong>Aspect</strong></li><li>连接点 <strong>Join Point</strong><ul><li>程序执行过程中可以插入切面的点（方法的调用或异常的处理）</li></ul></li><li>通知 <strong>Advice</strong> 切面在连接点执行的操作 <ul><li>@Before</li><li>@After</li><li>@Around</li></ul></li><li>切入点 <strong>Pointcut</strong><ul><li>定义在哪些连接点上应用通知，通常通过表达式来匹配</li></ul></li><li>织入 <strong>Weaving</strong><ul><li>将切面应用到目标对象并创建代理对象的过程，可以在编译期、类加载期或运行期进行</li></ul></li></ul><h3 id="aop的应用场景" tabindex="-1">AOP的应用场景 <a class="header-anchor" href="#aop的应用场景" aria-label="Permalink to “AOP的应用场景”">​</a></h3><ul><li>日志记录</li><li>事务管理</li><li>权限控制</li><li>性能监控 <ul><li>记录方法执行时间</li></ul></li></ul><h3 id="aop的实现方式" tabindex="-1">AOP的实现方式 <a class="header-anchor" href="#aop的实现方式" aria-label="Permalink to “AOP的实现方式”">​</a></h3><ul><li>JDK动态代理 <ul><li>实现了接口的类</li></ul></li><li>CGLIB代理 <ul><li>未实现接口的类</li></ul></li></ul><h2 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-label="Permalink to “事务”">​</a></h2>',33)])])}const g=i(n,[["render",o]]);export{p as __pageData,g as default};
