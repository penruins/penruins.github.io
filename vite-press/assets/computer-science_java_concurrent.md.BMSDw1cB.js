import{_ as i,c as e,o as a,ah as r}from"./chunks/framework.DzUG-V_P.js";const m=JSON.parse('{"title":"synchronized","description":"","frontmatter":{},"headers":[],"relativePath":"computer-science/java/concurrent.md","filePath":"computer-science/java/concurrent.md"}'),o={name:"computer-science/java/concurrent.md"};function n(c,l,t,d,h,u){return a(),e("div",null,[...l[0]||(l[0]=[r('<p>+++ date = &#39;&#39; draft = false title = &#39;concurrent&#39; +++</p><h1 id="synchronized" tabindex="-1">synchronized <a class="header-anchor" href="#synchronized" aria-label="Permalink to “synchronized”">​</a></h1><h2 id="synchronized-的底层原理是什么" tabindex="-1">synchronized 的底层原理是什么？ <a class="header-anchor" href="#synchronized-的底层原理是什么" aria-label="Permalink to “synchronized 的底层原理是什么？”">​</a></h2><ul><li>基于 jvm 的 Monitor 机制</li><li>通过进入和退出 Monitor 对象来实现方法和代码块的同步</li><li>字节码指令 <ul><li><code>monitorenter</code> 获取 Monitor 的所有权</li><li><code>monitorexit</code> 释放 Monitor 的所有权</li></ul></li><li>同步方法的实现 <ul><li>ACC_SYNCHRONIZED 标志：当方法被 synchronized 修饰时，JVM 会在方法常量池中设置 ACC_SYNCHRONIZED 标志。</li><li>调用方法时，JVM 检查该标志。如果设置了，线程必须先获取 Monitor 才能执行方法，执行完成后释放 Monitor</li></ul></li><li>锁的优化 <ul><li>为了提升性能，JVM 对 synchronized 进行了优化，包括 <ul><li>偏向锁（Biased Locking）：当锁始终由同一线程持有时，JVM 会将锁标记为偏向锁，减少锁获取的开销</li><li>轻量级锁（Lightweight Locking）：当存在多个线程交替执行时，JVM 会将锁升级为轻量级锁，通过 CAS 操作减少阻塞</li><li>重量级锁（Heavyweight Locking）：当锁竞争激烈时，JVM 会将锁升级为重量级锁，依赖于操作系统的互斥量（Mutex）实现</li><li>自旋锁（Spin Locking）：当线程无法获取锁时，会进行有限次数的自旋尝试，避免直接进入阻塞状态</li></ul></li></ul></li></ul><h1 id="concurrenthashmap" tabindex="-1">ConcurrentHashMap <a class="header-anchor" href="#concurrenthashmap" aria-label="Permalink to “ConcurrentHashMap”">​</a></h1><h1 id="concurrentlinkedhashmap" tabindex="-1">ConcurrentLinkedHashMap <a class="header-anchor" href="#concurrentlinkedhashmap" aria-label="Permalink to “ConcurrentLinkedHashMap”">​</a></h1><h2 id="比较-concurrenthash-和-concurrentlinkedhashmap" tabindex="-1">比较 ConcurrentHash 和 ConcurrentLinkedHashMap <a class="header-anchor" href="#比较-concurrenthash-和-concurrentlinkedhashmap" aria-label="Permalink to “比较 ConcurrentHash 和 ConcurrentLinkedHashMap”">​</a></h2><ul><li>在ConcurrentHashMap的基础上，增加了<strong>双向链表</strong>来维护插入顺序或访问顺序</li><li>支持LRU缓存淘汰策略，通过Weigher计算存储单元数，自动清理最近最少使用的数据</li></ul><h1 id="线程池" tabindex="-1">线程池 <a class="header-anchor" href="#线程池" aria-label="Permalink to “线程池”">​</a></h1><h2 id="线程池的核心参数" tabindex="-1">线程池的核心参数 <a class="header-anchor" href="#线程池的核心参数" aria-label="Permalink to “线程池的核心参数”">​</a></h2><ul><li>核心线程数 corePoolSize</li><li>最大线程数 maximumPoolSize</li><li>空闲线程存活时间 keepAliveTime</li><li>时间单位 unit</li><li>任务队列 workQueue <ul><li>ArrayBlockingQueue 基于数组的<strong>有界</strong>队列</li><li>LinkedBlockingQueue 基于链表的<strong>无界</strong>队列</li><li>SynchronousQueue 不存储元素的队列，直接交给线程处理</li><li>PriorityBlockingQueue 支持优先级的<strong>无界</strong>队列</li></ul></li><li>线程工厂 threadFactory</li><li>拒绝策略 handler <ul><li>AbortPolicy 抛弃任务并抛出异常 RejectedExecutionException</li><li>DiscardPolicy 抛弃任务但不抛出异常</li><li>CallerRunsPolicy 由提交任务的线程自己执行任务</li><li>DiscardOldestPolicy 抛弃优先级最低的任务</li></ul></li></ul><h2 id="线程池的关键参数-比如核心线程数、等待队列、拒绝策略-在创建的时候做什么考虑" tabindex="-1">线程池的关键参数，比如核心线程数、等待队列、拒绝策略，在创建的时候做什么考虑 <a class="header-anchor" href="#线程池的关键参数-比如核心线程数、等待队列、拒绝策略-在创建的时候做什么考虑" aria-label="Permalink to “线程池的关键参数，比如核心线程数、等待队列、拒绝策略，在创建的时候做什么考虑”">​</a></h2><ul><li>核心线程数 <ul><li>任务类型 <ul><li>CPU密集型: CPU核数 + 1</li><li>IO密集型: CPU核数 * 2</li></ul></li></ul></li><li>最大线程数 <ul><li>默认设置为与核心线程数一致，减少创建线程和销毁线程的开销</li></ul></li><li>等待队列 <ul><li>无界队列: 任务量稳定的场景, 但可能导致内存溢出</li><li>有界队列: 任务量波动的场景</li><li>同步队列: 适合任务量较少的场景</li></ul></li><li>拒绝策略 <ul><li>任务重要性: 如果任务不能丢弃，使用 CallerRunsPolicy(由提交任务的线程自己执行任务)</li><li>系统容错性: 如果任务可以丢弃, 使用 DiscardPolicy(抛弃任务但不抛出异常) 和 DiscardOldestPolicy(抛弃优先级最低的任务)</li></ul></li><li>线程空闲时间 <ul><li>任务波动性: 如果任务波动较大，可以设置较短的空闲时间，及时回收线程 <ul><li>如果在出现任务峰值的时候，创建线程锁产生的开销要如何处理？</li></ul></li></ul></li><li>线程工厂 <ul><li>线程命名: 自定义线程名称，便于监控与查询问题</li><li>线程优先级: 根据任务重要性设置线程优先级</li></ul></li></ul><h2 id="线程池拒绝策略有哪些-你项目通常选用哪个-遇到重要场景触发拒绝策略必须需要处理任务你如何处理" tabindex="-1">线程池拒绝策略有哪些，你项目通常选用哪个，遇到重要场景触发拒绝策略必须需要处理任务你如何处理 <a class="header-anchor" href="#线程池拒绝策略有哪些-你项目通常选用哪个-遇到重要场景触发拒绝策略必须需要处理任务你如何处理" aria-label="Permalink to “线程池拒绝策略有哪些，你项目通常选用哪个，遇到重要场景触发拒绝策略必须需要处理任务你如何处理”">​</a></h2><ul><li>线程池拒绝策略 <ul><li>AbortPolicy 抛异常</li><li>CallerRunsPolicy</li><li>DiscardPolicy 不抛异常</li><li>DiscardOldestPolicy</li></ul></li><li>项目中常用哪个？ <ul><li>可以容忍丢失的情况 DiscardPolicy DiscardOldestPolicy</li><li>不允许有丢弃的情况：CallerRunsPolicy</li></ul></li><li>重要场景触发拒绝策略的处理方法 <ul><li>使用 CallerRunsPolicy</li><li>自定义拒绝策略：增加自定义异常处理器，将拒绝的任务添加到外部的消息队列中，后续再进行提交</li></ul></li><li>动态调整线程池的参数 <ul><li>监控线程池的状态，动态调整 corePoolSize, maximumPoolSize, queueCapacity, 以应对突发流量</li></ul></li></ul><h2 id="如何实现动态线程池" tabindex="-1">如何实现动态线程池？ <a class="header-anchor" href="#如何实现动态线程池" aria-label="Permalink to “如何实现动态线程池？”">​</a></h2><ul><li>通过线程池的方法设置<strong>核心线程数</strong>、<strong>最大线程数</strong>、<strong>最大空闲时间</strong></li></ul><h2 id="jdk-创建线程池有哪些方式" tabindex="-1">JDK 创建线程池有哪些方式 <a class="header-anchor" href="#jdk-创建线程池有哪些方式" aria-label="Permalink to “JDK 创建线程池有哪些方式”">​</a></h2><ul><li>通过 <code>Executors</code> 工厂类创建 <ul><li>newFixedThreadPool</li><li>newCachedThreadPool</li><li>newSingleThreadExecutor</li><li>newScheduledThreadPool</li><li>newSingleThreadScheduledExecutor</li><li>newWorkStealingPool</li></ul></li><li>通过 <code>ThreadPoolExecutor</code> 手动指定参数创建</li></ul><h1 id="进程间通信" tabindex="-1">进程间通信 <a class="header-anchor" href="#进程间通信" aria-label="Permalink to “进程间通信”">​</a></h1><ul><li>管道 Pipe</li><li>消息队列 Message Queue</li><li>共享内存 Shared Memory</li><li>信号 Signal <ul><li>kill</li></ul></li><li>信号量 Semaphore</li><li>套接字 Socket</li><li>文件 File</li><li>内存映射文件 Memory-Mapped File</li><li>远程过程调用 RPC, Remote Procedure Call</li></ul><h1 id="juc" tabindex="-1">JUC <a class="header-anchor" href="#juc" aria-label="Permalink to “JUC”">​</a></h1><ul><li><code>java.util.concurrent</code></li></ul><h2 id="juc-包下的7大类" tabindex="-1">JUC 包下的7大类 <a class="header-anchor" href="#juc-包下的7大类" aria-label="Permalink to “JUC 包下的7大类”">​</a></h2><ul><li><strong>原子变量类（<code>java.util.concurrent.atomic</code> 包）</strong><ul><li>用于实现无锁的线程安全操作，基于CAS（Compare and Swap）机制：</li><li><code>AtomicInteger</code>：原子操作的整型变量。</li><li><code>AtomicLong</code>：原子操作的长整型变量。</li><li><code>AtomicBoolean</code>：原子操作的布尔变量。</li><li><code>AtomicReference&lt;V&gt;</code>：原子操作的引用类型变量。</li><li><code>AtomicStampedReference&lt;V&gt;</code>：带版本戳的原子引用，解决ABA问题。</li></ul></li><li><strong>锁和同步器类（<code>java.util.concurrent.locks</code> 包）</strong><ul><li>提供更灵活的锁机制，替代传统的<code>synchronized</code>关键字：</li><li><code>ReentrantLock</code>：可重入锁，支持公平锁和非公平锁。</li><li><code>ReentrantReadWriteLock</code>：读写锁，支持读多写少的场景。</li><li><code>StampedLock</code>：基于邮戳的锁，提供乐观读锁。</li><li><code>Condition</code>：条件变量，用于线程间的等待和唤醒。</li></ul></li><li><strong>并发集合类（<code>java.util.concurrent</code> 包）</strong><ul><li>线程安全的集合类，优化了高并发场景下的性能：</li><li><code>ConcurrentHashMap</code>：线程安全的哈希表，采用分段锁或CAS机制。</li><li><code>CopyOnWriteArrayList</code>：写时复制的线程安全列表，适合读多写少的场景。</li><li><code>ConcurrentLinkedQueue</code>：无界的线程安全队列，基于CAS实现。</li></ul></li><li><strong>同步工具类</strong><ul><li>用于线程间的协作和同步：</li><li><code>CountDownLatch</code>：计数器门闩，等待一组线程完成。</li><li><code>CyclicBarrier</code>：循环栅栏，等待一组线程到达同步点。</li><li><code>Semaphore</code>：信号量，控制同时访问资源的线程数量。</li><li><code>Phaser</code>：更灵活的同步器，支持动态注册线程和多次同步。</li></ul></li><li><strong>线程池框架（<code>java.util.concurrent</code> 包）</strong><ul><li>用于管理线程的生命周期和任务调度：</li><li><code>ExecutorService</code>：线程池接口，提供任务提交、关闭等功能。</li><li><code>ThreadPoolExecutor</code>：可自定义的线程池实现。</li><li><code>ScheduledExecutorService</code>：支持定时任务和周期任务的线程池。</li><li><code>ForkJoinPool</code>：用于分治算法和并行流的线程池。</li></ul></li><li><strong>阻塞队列类（<code>java.util.concurrent</code> 包）</strong><ul><li>线程安全的阻塞队列，用于生产者-消费者模型：</li><li><code>ArrayBlockingQueue</code>：基于数组的<strong>有界</strong>阻塞队列。</li><li><code>LinkedBlockingQueue</code>：基于链表的<strong>无界</strong>阻塞队列。</li><li><code>PriorityBlockingQueue</code>：支持优先级的无界阻塞队列。</li></ul></li><li><strong>其他工具类</strong><ul><li><code>Future&lt;V&gt;</code>：表示异步计算的结果。</li><li><code>CompletableFuture&lt;V&gt;</code>：支持异步编程的增强版<code>Future</code>。</li><li><code>Exchanger&lt;V&gt;</code>：用于线程间交换数据的工具。</li></ul></li></ul><h1 id="threadlocal" tabindex="-1">ThreadLocal <a class="header-anchor" href="#threadlocal" aria-label="Permalink to “ThreadLocal”">​</a></h1><h2 id="threadlocal-原理" tabindex="-1">ThreadLocal 原理 <a class="header-anchor" href="#threadlocal-原理" aria-label="Permalink to “ThreadLocal 原理”">​</a></h2><ul><li>每一个线程都维护一个对象副本，每个线程独立地访问和操作各自的副本</li><li>数据是保存在 Thread 父类的 ThreadLocalMap 中</li></ul><h1 id="锁" tabindex="-1">锁 <a class="header-anchor" href="#锁" aria-label="Permalink to “锁”">​</a></h1><h2 id="java里的锁有哪些" tabindex="-1">Java里的锁有哪些 <a class="header-anchor" href="#java里的锁有哪些" aria-label="Permalink to “Java里的锁有哪些”">​</a></h2><ul><li>锁的类型 <ul><li>synchronized 内置锁</li><li>ReentrantLock 可重入锁</li><li>ReadWriteLock 读写锁</li><li>StampedLock 邮戳锁</li><li>Condition 条件锁 <ul><li>与ReentrantLock 配合使用，实现线程间的等待和唤醒</li><li>类似于 Object.wait() 和 Object.notify()，但更灵活</li></ul></li><li>LockSupport</li><li>Semaphore 信号量</li><li>CountDownLatch 倒计时锁</li><li>CyclicBarrier 循环屏障</li><li>Phaser 阶段锁</li></ul></li><li>不同的锁的使用场景 <ul><li>简单场景：使用 synchronized</li><li>复杂场景：使用 ReentrantLock、ReadWriteLock 或 StampedLock</li><li>线程协作：使用 Condition、CountDownLatch、CyclicBarrier 或 Phaser</li><li>资源限制：使用 Semaphore</li></ul></li></ul><h2 id="锁升级" tabindex="-1">锁升级 <a class="header-anchor" href="#锁升级" aria-label="Permalink to “锁升级”">​</a></h2><h3 id="锁升级的过程" tabindex="-1">锁升级的过程 <a class="header-anchor" href="#锁升级的过程" aria-label="Permalink to “锁升级的过程”">​</a></h3><ul><li>锁机制根据竞争情况自动或手动调整锁的粒度和强度的过程，目的是在保证线程安全的同时优化性能</li><li>在Java中，锁升级特指synchronized关键字的优化机制。JDK 1.6后，为了减少锁操作的开销，JVM引入了<strong>偏向锁</strong>、<strong>轻量级锁</strong>、<strong>重量级锁</strong>三种状态，锁状态只能从低到高单向升级，不可降级</li></ul><h3 id="锁升级的4个阶段是什么" tabindex="-1">锁升级的4个阶段是什么？ <a class="header-anchor" href="#锁升级的4个阶段是什么" aria-label="Permalink to “锁升级的4个阶段是什么？”">​</a></h3><ul><li><strong>无锁状态</strong><ul><li>共享对象没有被任何线程锁定</li></ul></li><li><strong>偏向锁</strong><ul><li>首次通过 synchronized 获取锁时，JVM讲锁标记为偏向锁</li></ul></li><li><strong>轻量级锁</strong><ul><li>当多线程竞争偏向锁时，JVM讲锁由偏向锁转换为轻量级锁</li><li>通过CAS实现</li></ul></li><li><strong>重量级锁</strong><ul><li>轻量级锁自旋失败（如自旋次数超过阈值）或高并发竞争激烈时</li><li>依赖操作系统的互斥量 Mutex</li></ul></li></ul><h2 id="公平、非公平" tabindex="-1">公平、非公平 <a class="header-anchor" href="#公平、非公平" aria-label="Permalink to “公平、非公平”">​</a></h2><h3 id="什么是公平锁、非公平锁" tabindex="-1">什么是公平锁、非公平锁？ <a class="header-anchor" href="#什么是公平锁、非公平锁" aria-label="Permalink to “什么是公平锁、非公平锁？”">​</a></h3><ul><li>公平锁：线程根据申请锁的顺序获取锁</li><li>非公平锁：允许线程直接获取锁，而不用考虑申请锁的顺序</li></ul><h3 id="synchronized-是公平的还是不公平的" tabindex="-1">synchronized 是公平的还是不公平的？ <a class="header-anchor" href="#synchronized-是公平的还是不公平的" aria-label="Permalink to “synchronized 是公平的还是不公平的？”">​</a></h3><ul><li>不公平的</li></ul><h3 id="reentrantlock-公平性" tabindex="-1">ReentrantLock 公平性 <a class="header-anchor" href="#reentrantlock-公平性" aria-label="Permalink to “ReentrantLock 公平性”">​</a></h3><ul><li>可以在构造可重入锁时指定是公平锁还是非公平锁 <ul><li>AQS AbstractQueuedSynchronizer的队列机制 <ul><li>FairSync 维护一个 FIFO 的队列</li></ul></li></ul></li></ul><h1 id="cas" tabindex="-1">CAS <a class="header-anchor" href="#cas" aria-label="Permalink to “CAS”">​</a></h1><h2 id="什么是cas" tabindex="-1">什么是CAS <a class="header-anchor" href="#什么是cas" aria-label="Permalink to “什么是CAS”">​</a></h2><ul><li>一个原子性的硬件指令 compare and swap 比较并交换。多线程的场景下，只有一个线程能比较成功并交换值，其他线程比较失败不执行交换</li></ul><h1 id="aqs" tabindex="-1">AQS <a class="header-anchor" href="#aqs" aria-label="Permalink to “AQS”">​</a></h1><h2 id="什么是aqs" tabindex="-1">什么是AQS <a class="header-anchor" href="#什么是aqs" aria-label="Permalink to “什么是AQS”">​</a></h2><ul><li><code>AbstractQueuedSynchronizer</code> 用于构造锁和同步器类的基础类 <ul><li><code>ReentrantLock</code></li><li><code>Semaphore</code></li><li><code>CountDownLatch</code></li></ul></li></ul><h2 id="aqs的核心概念是什么" tabindex="-1">AQS的核心概念是什么？ <a class="header-anchor" href="#aqs的核心概念是什么" aria-label="Permalink to “AQS的核心概念是什么？”">​</a></h2><ul><li>同步状态</li><li>等待队列</li></ul><h2 id="aqs的模板方法有哪些" tabindex="-1">AQS的模板方法有哪些？ <a class="header-anchor" href="#aqs的模板方法有哪些" aria-label="Permalink to “AQS的模板方法有哪些？”">​</a></h2><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryAcquireReleased</li></ul><h1 id="aba-问题" tabindex="-1">ABA 问题 <a class="header-anchor" href="#aba-问题" aria-label="Permalink to “ABA 问题”">​</a></h1><h2 id="aba问题产生的原因是什么" tabindex="-1">ABA问题产生的原因是什么？ <a class="header-anchor" href="#aba问题产生的原因是什么" aria-label="Permalink to “ABA问题产生的原因是什么？”">​</a></h2><ul><li>使用 CAS 实现无锁数据结构，因为CAS只关注数据是否一致，没有关注数据是否更改过</li></ul><h2 id="如何解决aba问题" tabindex="-1">如何解决ABA问题？ <a class="header-anchor" href="#如何解决aba问题" aria-label="Permalink to “如何解决ABA问题？”">​</a></h2><ul><li>使用版本号, 比如使用原子变量类<code>AtomicStampedReference</code></li></ul><h2 id="jdk提供的原子变量类会存在aba问题吗" tabindex="-1">JDK提供的原子变量类会存在ABA问题吗？ <a class="header-anchor" href="#jdk提供的原子变量类会存在aba问题吗" aria-label="Permalink to “JDK提供的原子变量类会存在ABA问题吗？”">​</a></h2><h1 id="completablefuture" tabindex="-1">CompletableFuture <a class="header-anchor" href="#completablefuture" aria-label="Permalink to “CompletableFuture”">​</a></h1><ul><li><a href="https://segmentfault.com/a/1190000044543793" target="_blank" rel="noreferrer">优雅处理并发：Java CompletableFuture最佳实践</a></li></ul>',61)])])}const b=i(o,[["render",n]]);export{m as __pageData,b as default};
