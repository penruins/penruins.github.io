import{_ as l,c as i,o as e,ah as r}from"./chunks/framework.CUZTSfUD.js";const u=JSON.parse('{"title":"java basic","description":"","frontmatter":{"date":"","draft":false,"title":"java basic","weight":1,"outline":[1,8]},"headers":[],"relativePath":"computer-science/java/java-basic.md","filePath":"computer-science/java/java-basic.md"}'),n={name:"computer-science/java/java-basic.md"};function o(s,a,t,h,c,d){return e(),i("div",null,[...a[0]||(a[0]=[r('<h1 id="java-basic" tabindex="-1">java basic <a class="header-anchor" href="#java-basic" aria-label="Permalink to “java basic”">​</a></h1><h2 id="mess" tabindex="-1">mess <a class="header-anchor" href="#mess" aria-label="Permalink to “mess”">​</a></h2><h3 id="八大数据类型" tabindex="-1">八大数据类型 <a class="header-anchor" href="#八大数据类型" aria-label="Permalink to “八大数据类型”">​</a></h3><ul><li><code>byte</code></li><li><code>char</code></li><li><code>boolean</code></li><li><code>short</code></li><li><code>int</code></li><li><code>long</code></li><li><code>float</code></li><li><code>double</code></li></ul><h3 id="transient-关键字的作用是什么" tabindex="-1">transient 关键字的作用是什么？ <a class="header-anchor" href="#transient-关键字的作用是什么" aria-label="Permalink to “transient 关键字的作用是什么？”">​</a></h3><ul><li>在一个类中如果变量被 transient 关键字修饰，在对类的对象进行序列化的时候就会忽略这个变量</li></ul><h3 id="什么是深拷贝-什么是浅拷贝" tabindex="-1">什么是深拷贝？什么是浅拷贝？ <a class="header-anchor" href="#什么是深拷贝-什么是浅拷贝" aria-label="Permalink to “什么是深拷贝？什么是浅拷贝？”">​</a></h3><ul><li>深拷贝：递归地复制对象及其所有嵌套的子对象，生成一个完全独立的新对象。两个对象之间不共享引用</li><li>浅拷贝：创建一个新的对象，但只复制对象的最外层属性的引用</li></ul><h2 id="string" tabindex="-1">String <a class="header-anchor" href="#string" aria-label="Permalink to “String”">​</a></h2><h3 id="equals与-区别" tabindex="-1">equals与 == 区别 <a class="header-anchor" href="#equals与-区别" aria-label="Permalink to “equals与 == 区别”">​</a></h3><ul><li><code>equals</code> 比较的是两个字符串的内容是否是相等的</li><li><code>==</code> 比较的是两个变量指向的引用是否是相等的</li></ul><h3 id="stringbuilder-stringbuffer区别" tabindex="-1">StringBuilder StringBuffer区别 <a class="header-anchor" href="#stringbuilder-stringbuffer区别" aria-label="Permalink to “StringBuilder StringBuffer区别”">​</a></h3><ul><li>StringBuilder 线程不安全</li><li>StringBuffer 线程安全</li></ul><h3 id="stringbuffer-是怎么保证线程安全的" tabindex="-1">StringBuffer 是怎么保证线程安全的？ <a class="header-anchor" href="#stringbuffer-是怎么保证线程安全的" aria-label="Permalink to “StringBuffer 是怎么保证线程安全的？”">​</a></h3><ul><li>对字符串操作的方法都通过 synchronized 关键字修饰，保证线程安全</li></ul><h3 id="stringbuffer-和-stringbuilder-字符串在底层是以什么数据结构保存的" tabindex="-1">StringBuffer 和 StringBuilder 字符串在底层是以什么数据结构保存的 <a class="header-anchor" href="#stringbuffer-和-stringbuilder-字符串在底层是以什么数据结构保存的" aria-label="Permalink to “StringBuffer 和 StringBuilder 字符串在底层是以什么数据结构保存的”">​</a></h3><ul><li>两个类都继承子 <code>AbstractStringBuilder</code> 均使用 <code>char[] value</code> 保存字符串数据</li></ul><h2 id="hashmap" tabindex="-1">HashMap <a class="header-anchor" href="#hashmap" aria-label="Permalink to “HashMap”">​</a></h2><h3 id="hashmap底层的数据结构是怎样的" tabindex="-1">HashMap底层的数据结构是怎样的？ <a class="header-anchor" href="#hashmap底层的数据结构是怎样的" aria-label="Permalink to “HashMap底层的数据结构是怎样的？”">​</a></h3><ul><li>java 1.8 之前 数组 + 链表</li><li>java 1.8 之后 数组 + 链表/红黑树</li></ul><h3 id="hashmap-是否线程安全-如何保证线程安全" tabindex="-1">HashMap 是否线程安全，如何保证线程安全 <a class="header-anchor" href="#hashmap-是否线程安全-如何保证线程安全" aria-label="Permalink to “HashMap 是否线程安全，如何保证线程安全”">​</a></h3><ul><li>不是线程安全的</li><li>如何保证线程安全 <ul><li>Collections.synchronizedMap()</li><li>ConcurrentHashMap</li><li>读写锁 ReadWriteLock</li><li>局部使用 HashMap</li><li>初始化写，后续只读</li></ul></li></ul><h3 id="hashmap-get-时间复杂度" tabindex="-1">HashMap get 时间复杂度 <a class="header-anchor" href="#hashmap-get-时间复杂度" aria-label="Permalink to “HashMap get 时间复杂度”">​</a></h3><ul><li>最好的情况是O(1)</li><li>若发生哈希碰撞，对应到桶之后还需要查询链表或红黑树，时间复杂度下降到O(N)或O(logN)</li></ul><h3 id="hashmap-和-hashtable-有什么区别" tabindex="-1">HashMap 和 Hashtable 有什么区别？ <a class="header-anchor" href="#hashmap-和-hashtable-有什么区别" aria-label="Permalink to “HashMap 和 Hashtable 有什么区别？”">​</a></h3><ul><li>线程安全性 <ul><li>HashMap是线程不安全的，HashTable是线程安全的</li></ul></li><li>对空值的支持 <ul><li>HashMap的key和value都支持空值，HashTable不支持key或value为空值</li></ul></li></ul><h2 id="list" tabindex="-1">List <a class="header-anchor" href="#list" aria-label="Permalink to “List”">​</a></h2><h3 id="collection-和-collections-有什么区别" tabindex="-1">Collection 和 Collections 有什么区别？ <a class="header-anchor" href="#collection-和-collections-有什么区别" aria-label="Permalink to “Collection 和 Collections 有什么区别？”">​</a></h3><ul><li>Collection 是集合类的一个接口</li><li>Collections 是集合的一个工具类</li></ul><h2 id="linkedlist-删除时间复杂度" tabindex="-1">LinkedList 删除时间复杂度 <a class="header-anchor" href="#linkedlist-删除时间复杂度" aria-label="Permalink to “LinkedList 删除时间复杂度”">​</a></h2><ul><li>删除头和尾的时间复杂度为O(1)，因为在LinkedList中维护了头和尾2个指针</li><li>其他位置的时间复杂度为O(n)</li></ul><h2 id="函数式编程" tabindex="-1">函数式编程 <a class="header-anchor" href="#函数式编程" aria-label="Permalink to “函数式编程”">​</a></h2><h3 id="java的函数式编程包含哪些内容" tabindex="-1">java的函数式编程包含哪些内容？ <a class="header-anchor" href="#java的函数式编程包含哪些内容" aria-label="Permalink to “java的函数式编程包含哪些内容？”">​</a></h3><ul><li>java的函数式编程的概念中将只包含一个方法的接口称为函数式接口，可以通过Lambda表达式简化匿名类的定义</li><li>提供流操作了API，可以将集合的迭代操作变为链式操作，提供了并行处理集合的方法</li><li>提供了Optional类用来处理空指针的情况</li></ul><h2 id="i-o" tabindex="-1">I/O <a class="header-anchor" href="#i-o" aria-label="Permalink to “I/O”">​</a></h2><h3 id="网络io分为哪几种" tabindex="-1">网络io分为哪几种 <a class="header-anchor" href="#网络io分为哪几种" aria-label="Permalink to “网络io分为哪几种”">​</a></h3><p>网络 I/O 模型主要分为以下五种：</p><ul><li><strong>阻塞 I/O（Blocking I/O, BIO）</strong><ul><li><strong>特点</strong>：用户线程在发起 I/O 操作后，如果数据未准备好，会一直阻塞等待，直到数据就绪并完成拷贝。</li><li><strong>优点</strong>：实现简单，适合连接数少、并发度低的场景。</li><li><strong>缺点</strong>：每个连接需要一个线程处理，线程开销大，不适合高并发场景。</li></ul></li><li><strong>非阻塞 I/O（Non-blocking I/O, NIO）</strong><ul><li><strong>特点</strong>：用户线程发起 I/O 操作后，如果数据未准备好，会立即返回错误码，线程通过轮询不断检查数据是否就绪。</li><li><strong>优点</strong>：一个线程可以处理多个连接，减少了线程阻塞。</li><li><strong>缺点</strong>：频繁的系统调用和轮询会导致 CPU 资源浪费。</li></ul></li><li><strong>I/O 多路复用（I/O Multiplexing）</strong><ul><li><strong>特点</strong>：使用单个线程监听多个文件描述符（如 socket），当某个描述符就绪时，通知用户线程进行处理。常见的实现有 <code>select</code>、<code>poll</code> 和 <code>epoll</code>。</li><li><strong>优点</strong>：适合高并发场景，减少线程数量和系统开销。</li><li><strong>缺点</strong>：数据拷贝阶段仍然是阻塞的，且实现复杂度较高。</li></ul></li><li><strong>信号驱动 I/O（Signal-driven I/O）</strong><ul><li><strong>特点</strong>：用户线程发起 I/O 操作后，内核通过信号通知用户线程数据已就绪。</li><li><strong>优点</strong>：避免了轮询，减少 CPU 资源浪费。</li><li><strong>缺点</strong>：信号处理复杂，且信号队列可能溢出。</li></ul></li><li><strong>异步 I/O（Asynchronous I/O, AIO）</strong><ul><li><strong>特点</strong>：用户线程发起 I/O 操作后立即返回，内核在数据准备和拷贝完成后通知用户线程。</li><li><strong>优点</strong>：完全非阻塞，适合高性能场景。</li><li><strong>缺点</strong>：实现复杂，且并非所有系统都支持。</li></ul></li></ul><p><strong>Reference</strong><br> 所以当发生一次网络请求时，将会按顺序经历“等待数据从远程主机到达缓冲区”和“将数据从缓冲区复制到应用程序地址空间”两个阶段</p><p>根据实现这两个阶段的不同方法，人们把网络I/O模型总结为两类、五种模型：两类是指同步I/O与异步I/O，五种是指在同步I/O中又划分出阻塞I/O、非阻塞I/O、多路复用I/O、信号驱动I/O四种细分模型以及异步I/O模型</p><p>异步I/O(Asynchronous I/O)：比如你在美团外卖订了个盒饭，付款之后你自己该干嘛干嘛，饭送到时骑手自然会打电话通知你。异步I/O中数据到达缓冲区后，不需要由调用进程主动进行从缓冲区复制数据的操作，而是复制完成后由操作系统向线程发送信号，所以它一定是非阻塞的。</p><p>阻塞I/O(Blocking I/O)：你去饭堂打饭，发现饭还没做好，只能等待（线程休眠），直到饭做好，这就是被阻塞了。阻塞I/O是最直观的I/O模型，逻辑清晰，也比较节省CPU资源，但缺点是线程休眠所带来的上下文切换，这是一种需要切换到内核态的重负载操作，不应当频繁进行。</p><p>非阻塞I/O(Non-Blocking I/O)：你去饭堂，发现饭还没做好，你就回去了，然后每隔3分钟来一次饭堂看饭是否做好，一直重复，直到饭做好。非阻塞I/O能够避免线程休眠，对于一些很快就能返回结果的请求，非阻塞I/O可以节省切换上下文切换的消耗，但是对于较长时间才能返回的请求，非阻塞I/O反而白白浪费了CPU资源，所以目前并不太常用。</p><p>多路复用I/O(Multiplexing I/O)：多路复用I/O本质上是阻塞I/O的一种，但是它的好处是可以在同一条阻塞线程上处理多个不同端口的监听。仍以去食堂打饭为例，比如你代表整个宿舍去饭堂打饭，去到饭堂，发现饭还没做好，还是继续等待，其中某个舍友的饭好了，你就马上把那份饭送回去，然后继续等待其他舍友的饭做好。多路复用I/O是目前高并发网络应用的主流，它还可以细分为select、epoll、kqueue等不同实现，这里就不再展开了。</p><p>信号驱动I/O(Signal-Driven I/O)：你去到饭堂，发现饭还没做好，但你跟厨师很熟，跟他说饭做好了叫你，然后你就回去了，等收到厨师通知后，你再去饭堂把饭拿回宿舍。这里厨师的通知就是那个“信号”，<strong>信号驱动I/O与异步I/O的区别是“从缓冲区获取数据”这个步骤的处理，前者收到的通知是可以开始进行复制操作了，即要你自己从饭堂拿回宿舍，在复制完成之前线程处于阻塞状态，所以它仍属于同步I/O操作，而后者收到的通知是复制操作已经完成，即外卖小哥已经把饭送到了。</strong></p><p>显然，异步I/O模型是最方便的，但前提是系统支持异步操作。异步I/O受限于操作系统，Windows NT内核早在3.5以后，就通过IOCP实现了真正的异步I/O模型。而Linux系统是在Linux Kernel 2.6才首次引入，目前还不算很完善，因此在Linux系统下实现高并发网络编程时仍以多路复用I/O模型模式为主。</p><p>《凤凰架构》 7.2.2 网络I/O 模型</p><h3 id="java支持的io模型" tabindex="-1">Java支持的IO模型 <a class="header-anchor" href="#java支持的io模型" aria-label="Permalink to “Java支持的IO模型”">​</a></h3><ul><li><strong>阻塞 I/O（Blocking I/O, BIO）</strong><ul><li><strong>特点</strong>：线程在发起 I/O 操作后会被阻塞，直到数据准备就绪并完成拷贝。</li><li><strong>实现</strong>：Java 的传统 I/O 模型，位于 <code>java.io</code> 包下，如 <code>FileInputStream</code>、<code>FileOutputStream</code> 等。</li><li><strong>适用场景</strong>：适合连接数较少、并发度低的场景。</li><li><strong>缺点</strong>：每个连接需要一个线程处理，线程开销大，不适合高并发。</li></ul></li><li><strong>非阻塞 I/O（Non-blocking I/O, NIO）</strong><ul><li><strong>特点</strong>：线程在发起 I/O 操作后不会被阻塞，可以立即返回并继续执行其他任务。</li><li><strong>实现</strong>：Java 1.4 引入的新 I/O 模型，位于 <code>java.nio</code> 包下，如 <code>ByteBuffer</code>、<code>FileChannel</code>、<code>SocketChannel</code> 等。</li><li><strong>适用场景</strong>：适合高并发场景，一个线程可以处理多个连接。</li><li><strong>缺点</strong>：需要复杂的调度和管理。</li></ul></li><li><strong>异步 I/O（Asynchronous I/O, AIO）</strong><ul><li><strong>特点</strong>：线程发起 I/O 操作后立即返回，内核在数据准备和拷贝完成后通知线程。</li><li><strong>实现</strong>：Java 7 引入的异步 I/O 模型，位于 <code>java.nio.channels</code> 包下，如 <code>AsynchronousFileChannel</code>、<code>AsynchronousSocketChannel</code> 等。</li><li><strong>适用场景</strong>：适合高性能、高并发的场景。</li><li><strong>缺点</strong>：实现复杂，且并非所有系统都支持。</li></ul></li></ul><h3 id="stream-结构" tabindex="-1">stream 结构 <a class="header-anchor" href="#stream-结构" aria-label="Permalink to “stream 结构”">​</a></h3>',50)])])}const O=l(n,[["render",o]]);export{u as __pageData,O as default};
