import{_ as a,c as i,o as r,af as e}from"./chunks/framework.Bhntpte7.js";const c=JSON.parse('{"title":"jvm","description":"","frontmatter":{"date":"","draft":false,"title":"jvm","weight":1000},"headers":[],"relativePath":"computer-science/java/jvm.md","filePath":"computer-science/java/jvm.md"}'),t={name:"computer-science/java/jvm.md"};function o(n,l,s,h,d,u){return r(),i("div",null,[...l[0]||(l[0]=[e('<h1 id="jvm" tabindex="-1">jvm <a class="header-anchor" href="#jvm" aria-label="Permalink to “jvm”">​</a></h1><h2 id="jmm" tabindex="-1">JMM <a class="header-anchor" href="#jmm" aria-label="Permalink to “JMM”">​</a></h2><h3 id="java的jvm内存模型-java-memory-model" tabindex="-1">Java的JVM内存模型 Java Memory Model <a class="header-anchor" href="#java的jvm内存模型-java-memory-model" aria-label="Permalink to “Java的JVM内存模型 Java Memory Model”">​</a></h3><ul><li>主内存 Main Memory</li><li>工作内存 Working Memory</li></ul><h3 id="jmm-的核心问题" tabindex="-1">JMM 的核心问题 <a class="header-anchor" href="#jmm-的核心问题" aria-label="Permalink to “JMM 的核心问题”">​</a></h3><ul><li>可见性</li><li>原子性</li><li>有序性</li></ul><h2 id="内存机制" tabindex="-1">内存机制 <a class="header-anchor" href="#内存机制" aria-label="Permalink to “内存机制”">​</a></h2><h3 id="jvm的内存机制是怎样的" tabindex="-1"><code>JVM</code>的内存机制是怎样的？ <a class="header-anchor" href="#jvm的内存机制是怎样的" aria-label="Permalink to “JVM的内存机制是怎样的？”">​</a></h3><ul><li>jvm 的内存区域 <ul><li><strong>程序计数器 Program Counter</strong><ul><li>记录当前线程的指令地址，用于记录线程恢复运行状态后执行指令的地址</li></ul></li><li><strong>虚拟机栈 Java Virtual Machine Stack</strong><ul><li>用于记录方法调用链</li></ul></li><li><strong>本地方法栈 Native Method Stack</strong><ul><li>类似于Java虚拟机栈，用于记录本地方法的调用链</li></ul></li><li><strong>堆 Heap</strong><ul><li>用于保存实例化的对象</li></ul></li><li><strong>方法区 Method Area</strong><ul><li>记录加载到内存中的类相关的信息</li></ul></li><li><strong>直接内存 Direct Memory</strong><ul><li>非阻塞式的IO操作的内存分配</li></ul></li></ul></li><li>垃圾回收机制 <ul><li><strong>标记-清除算法</strong><ul><li>标记存活对象，清除未标记对象，但会产生内存碎片</li></ul></li><li><strong>标记-复制算法</strong><ul><li>将存活对象复制到另一个内存区域，适用于新生代，效率高但内存利用率低</li></ul></li><li><strong>标记-整理算法</strong><ul><li>标记存活对象后，将对象向一端移动，整理内存空间，适用于老年代</li></ul></li><li><strong>分代收集算法</strong><ul><li>根据对象生命周期将堆分为新生代和老年代，分别采用不同的回收算法</li></ul></li></ul></li></ul><h3 id="jvm的内存模型中哪些是线程私有的" tabindex="-1">JVM的内存模型中哪些是线程私有的？ <a class="header-anchor" href="#jvm的内存模型中哪些是线程私有的" aria-label="Permalink to “JVM的内存模型中哪些是线程私有的？”">​</a></h3><ul><li>程序计数器 Program Counter</li><li>Java 虚拟机栈 Java Virtual Stack</li><li>本地方法栈 Native Method Stack</li></ul><h2 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to “垃圾回收”">​</a></h2><h3 id="垃圾回收算法有哪些" tabindex="-1">垃圾回收算法有哪些 <a class="header-anchor" href="#垃圾回收算法有哪些" aria-label="Permalink to “垃圾回收算法有哪些”">​</a></h3><ul><li>标记-清除算法</li><li>标记-复制算法</li><li>标记-整理算法</li></ul><p><strong>Reference</strong></p><p>《深入理解Java虚拟机》 3.3 垃圾收集算法</p><h3 id="如何判断对象是否可以被回收" tabindex="-1">如何判断对象是否可以被回收 <a class="header-anchor" href="#如何判断对象是否可以被回收" aria-label="Permalink to “如何判断对象是否可以被回收”">​</a></h3><ul><li>引用计数</li><li>可达性分析</li></ul><h2 id="类加载" tabindex="-1">类加载 <a class="header-anchor" href="#类加载" aria-label="Permalink to “类加载”">​</a></h2><h3 id="java类加载流程" tabindex="-1">java类加载流程 <a class="header-anchor" href="#java类加载流程" aria-label="Permalink to “java类加载流程”">​</a></h3><ul><li><strong>加载</strong><ul><li>获取字节流</li><li>转换数据结构</li><li>生成Class对象</li></ul></li><li><strong>连接</strong><ul><li><strong>验证</strong></li><li><strong>准备</strong><ul><li>静态变量分配默认值</li></ul></li><li><strong>解析</strong><ul><li>常量池的符号引用(类名、方法名)替换为直接引用(内存地址或偏移量)</li></ul></li></ul></li><li><strong>初始化</strong><ul><li>执行类的静态代码块和复制操作</li></ul></li></ul><h3 id="classloader-的种类" tabindex="-1">classloader 的种类 <a class="header-anchor" href="#classloader-的种类" aria-label="Permalink to “classloader 的种类”">​</a></h3><ul><li><strong>启动</strong>类加载器</li><li><strong>拓展</strong>类加载器</li><li><strong>应用</strong>类加载器</li><li><strong>自定义</strong>类加载器</li></ul><h3 id="什么是双亲委派" tabindex="-1">什么是双亲委派？ <a class="header-anchor" href="#什么是双亲委派" aria-label="Permalink to “什么是双亲委派？”">​</a></h3><ul><li>对类的加载任务会不断请求父加载器完成，当父加载器不进行加载时，才由本级加载器完成加载</li><li>为了解决的问题 <ul><li>避免类的重复加载</li><li>保证程序的安全性 <ul><li>防止类加载器加载核心类，出现潜在的安全风险</li></ul></li><li>维护类的唯一性</li></ul></li></ul>',25)])])}const g=a(t,[["render",o]]);export{c as __pageData,g as default};
