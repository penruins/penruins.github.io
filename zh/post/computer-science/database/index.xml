<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Penruins</title>
    <link>/zh/post/computer-science/database/</link>
    <description>Recent content on Penruins</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="/zh/post/computer-science/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>database</title>
      <link>/zh/post/computer-science/database/database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/database/database/</guid>
      <description>&lt;h1 id=&#34;database&#34;&gt;&#xA;  database&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#database&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;索引-index&#34;&gt;&#xA;  索引 index&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95-index&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是聚集索引非聚集索引&#34;&gt;&#xA;  什么是聚集索引、非聚集索引？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e9%9d%9e%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;聚集索引：数据行的&lt;strong&gt;物理存储顺序&lt;/strong&gt;与&lt;strong&gt;索引的逻辑顺序&lt;/strong&gt;一致&lt;/li&gt;&#xA;&lt;li&gt;非聚集索引：数据行的&lt;strong&gt;物理存储顺序&lt;/strong&gt;与&lt;strong&gt;索引的逻辑顺序&lt;/strong&gt;不一致&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;为什么只能有一种聚集索引&#34;&gt;&#xA;  为什么只能有一种聚集索引？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8f%aa%e8%83%bd%e6%9c%89%e4%b8%80%e7%a7%8d%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;因为数据物理的存储顺序只能有一种，因此只能有一种聚集索引&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;默认的聚集索引是什么&#34;&gt;&#xA;  默认的聚集索引是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%bb%98%e8%ae%a4%e7%9a%84%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主键&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;什么是回表&#34;&gt;&#xA;  什么是回表？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e5%9b%9e%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当查询条件使用普通索引并且查询的列不包含在索引中，就需要查询完普通索引后再去查询聚集索引的树拿到完整的行数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;当底层建了abc的联合索引底层会建aab-abc这3个索引么&#34;&gt;&#xA;  当底层建了abc的联合索引，底层会建a,ab, abc这3个索引么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bd%93%e5%ba%95%e5%b1%82%e5%bb%ba%e4%ba%86abc%e7%9a%84%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e5%ba%95%e5%b1%82%e4%bc%9a%e5%bb%baaab-abc%e8%bf%993%e4%b8%aa%e7%b4%a2%e5%bc%95%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不会，只创建一个联合索引树&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;联合索引abc当查询ab-ac会走索引么&#34;&gt;&#xA;  联合索引（abc)，当查询ab, ac会走索引么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95abc%e5%bd%93%e6%9f%a5%e8%af%a2ab-ac%e4%bc%9a%e8%b5%b0%e7%b4%a2%e5%bc%95%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ab 走索引&lt;/li&gt;&#xA;&lt;li&gt;ac 只走 a 索引&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;order-by-和-group-by-如何创建索引&#34;&gt;&#xA;  order by 和 group by 如何创建索引？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#order-by-%e5%92%8c-group-by-%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;order by&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单列 直接创建&lt;/li&gt;&#xA;&lt;li&gt;多列 创建联合索引, 索引顺序要和 order by 的顺序一致&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不一致索引会失效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;group by&#xA;&lt;ul&gt;&#xA;&lt;li&gt;group by 实际上是先进行排序，再进行分组。所以遵循 order by 的索引机制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;mysql索引失效的20种场景&#34;&gt;&#xA;  MySQL索引失效的20种场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mysql%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e7%9a%8420%e7%a7%8d%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/10448449924&#34;&gt;MySQL索引失效的20种场景&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;1 查询条件未使用索引列&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE non_indexed_column = &#39;example&#39;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;2 查询条件对索引列使用了函数或表达式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE LEFT(name, 3) = &#39;Ali&#39;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;3 数据类型不一致引发隐式类型转换&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE phone = 1234567890; -- phone 是 VARCHAR&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;4 联合索引使用时的范围查询阻断&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE name = &#39;Alice&#39; AND age &amp;gt; 30 AND city = &#39;New York&#39;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;5 如果 OR 条件中有字段未使用索引，会导致整体索引失效&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE name = &#39;Alice&#39; OR age = 30;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：拆分查询，用 UNION 替代&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE name = &#39;Alice&#39; UNION SELECT * FROM users WHERE age = 30;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;6 LIKE 查询中使用前置通配符 &lt;code&gt;%&lt;/code&gt; 时，无法利用索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE name LIKE &#39;%Alice&#39;;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;替换为后置通配符 LIKE &amp;lsquo;Alice%&amp;rsquo;&lt;/li&gt;&#xA;&lt;li&gt;使用全文索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;ALTER TABLE users ADD FULLTEXT(name);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE MATCH(name) AGAINST(&#39;Alice&#39;);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;7 不等值操作符 &lt;code&gt;!= &amp;lt;&amp;gt;&lt;/code&gt; 通常会导致索引失效&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE age != 30;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：改写为范围查询&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE age &amp;lt; 30 OR age &amp;gt; 30;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;8 &lt;code&gt;IN&lt;/code&gt; 子句中参数过多时，索引可能失效&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE id IN (1, 2, ..., 10000)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：分批查询或控制 IN 参数数量&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE id BETWEEN 1 AND 5000&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;9 某些情况下对NULL值的查询可能导致索引失效&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE email IS NULL;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：避免使用 NULL，改为特定占位值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;10 ORDER BY 和 GROUP BY 不符合索引顺序&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;select * from users order by age, name;&lt;/code&gt; 索引顺序为(name,age)&lt;/li&gt;&#xA;&lt;li&gt;解决方法：调整查询或索引顺序一致&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;11 索引列未覆盖查询字段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;select age from users where name = &#39;Alice&#39;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：创建覆盖索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;alter table users add index(name, age)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;12 表统计信息过期&#xA;&lt;ul&gt;&#xA;&lt;li&gt;表的统计信息不准确时，MySQL优化器可能错误选择全表扫描&lt;/li&gt;&#xA;&lt;li&gt;解决方法：定期更新统计信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;ANALYZE TABLE users&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;13 数据分布不均&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;select * from users where gender = &#39;M&#39; -- gender 列 90% 的值相同&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：优化查询字段或调整数据分布&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;14 子查询未优化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;子查询结果集过大时，索引失效&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE total &amp;gt; 100)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：改为 JOIN 查询&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT u.* FROM users u JOIN orders o ON u.id = o.user_id WHERE o.total &amp;gt; 100&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;15 锁机制干扰 间隙锁&#xA;&lt;ul&gt;&#xA;&lt;li&gt;描述：间隙锁可能阻止索引的高效使用&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：降低事务隔离级别至 Read Committed(读已提交)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可重复读加上间隙锁防止幻读&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;16 索引被动态调整&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MySQL优化器动态调整索引，可能选择非最佳索引或直接全表扫描&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM users FORCE INDEX (idx_name) WHERE name = &#39;Alice&#39;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;17 聚合函数未走索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用聚合函数(如 &lt;code&gt;COUNT&lt;/code&gt;, &lt;code&gt;SUM&lt;/code&gt;) 时，索引可能无法被利用&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT COUNT(*) FROM users WHERE age &amp;gt; 30&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：利用覆盖索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;ALTER TABLE users ADD INDEX(age)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;18 使用了非等值JOIN&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;select * from users u join orders o on u.id &amp;gt; o.user_id&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;优化连接条件，尽量使用等值连接&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;19 小表全表扫描替代索引扫描&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于非常小的表，MySQL优化器可能选择全表扫描而非索引&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM small_table WHERE id = 1;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：无需优化，小表全表扫描的代价通常可以忽略&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;20 分区表查询不走全局索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分区表的查询条件不覆盖分区键时，全局索引可能无法生效&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT * FROM partitioned_users WHERE city = &#39;New York&#39;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;解决方法：在分区键上创建局部索引&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;分区表的索引如何创建&#34;&gt;&#xA;  分区表的索引如何创建&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%8c%ba%e8%a1%a8%e7%9a%84%e7%b4%a2%e5%bc%95%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;分区&#34;&gt;&#xA;  分区&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%8c%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;分表和分区在物理存储上有什么区别&#34;&gt;&#xA;  分表和分区在物理存储上有什么区别？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e8%a1%a8%e5%92%8c%e5%88%86%e5%8c%ba%e5%9c%a8%e7%89%a9%e7%90%86%e5%ad%98%e5%82%a8%e4%b8%8a%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在数据库中一张表对应磁盘中的2个文件，拓展名为&lt;strong&gt;idb&lt;/strong&gt;的文件和拓展名为&lt;strong&gt;frm&lt;/strong&gt;的文件，idb文件存储表中的记录，frm存储表的结构信息&lt;/li&gt;&#xA;&lt;li&gt;进行分表的话有几张表就有几个对应的文件，进行分区就只有一个frm文件和若干个idb文件，一个分区对应一个idb文件&lt;/li&gt;&#xA;&lt;li&gt;分区能提升大表的读写性能就是因为根据分区规则仅仅扫描对应分区的磁盘文件，而不用进行全表扫描&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;一张表最多可以分多少个区&#34;&gt;&#xA;  一张表最多可以分多少个区？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%80%e5%bc%a0%e8%a1%a8%e6%9c%80%e5%a4%9a%e5%8f%af%e4%bb%a5%e5%88%86%e5%a4%9a%e5%b0%91%e4%b8%aa%e5%8c%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1024&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;事务&#34;&gt;&#xA;  事务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;数据隔离级别&#34;&gt;&#xA;  数据隔离级别&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读未提交 &lt;strong&gt;Read Uncommitted&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;读已提交 &lt;strong&gt;Read Committed&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;脏读：同一个事务中，多次读取同一数据的结果不同&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;可重复读 &lt;strong&gt;Repeatable Read&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;幻读：同一个事务中，相同的查询条件读取到的数据条数不一样&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;串行化 &lt;strong&gt;Serializable&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;mvcc&#34;&gt;&#xA;  MVCC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mvcc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;mvcc-的全称是什么&#34;&gt;&#xA;  MVCC 的全称是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mvcc-%e7%9a%84%e5%85%a8%e7%a7%b0%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Multi-Version Concurrency Control 多版本并发控制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;mysql的事务引擎仅仅使用行级锁吗&#34;&gt;&#xA;  MySQL的事务引擎仅仅使用行级锁吗？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mysql%e7%9a%84%e4%ba%8b%e5%8a%a1%e5%bc%95%e6%93%8e%e4%bb%85%e4%bb%85%e4%bd%bf%e7%94%a8%e8%a1%8c%e7%ba%a7%e9%94%81%e5%90%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不是，它结合了行级锁+MVCC(多版本并发控制)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;mvcc适用于哪些隔离级别&#34;&gt;&#xA;  MVCC适用于哪些隔离级别？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mvcc%e9%80%82%e7%94%a8%e4%ba%8e%e5%93%aa%e4%ba%9b%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;适用于 &lt;code&gt;REPEATED READ&lt;/code&gt; 和 &lt;code&gt;READ COMMITTED&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;不适用于 &lt;code&gt;READ UNCOMMITTED&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>elasticsearch</title>
      <link>/zh/post/computer-science/database/druid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/database/druid/</guid>
      <description>&lt;h1 id=&#34;druid&#34;&gt;&#xA;  druid&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#druid&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_43842093/article/details/131340323&#34;&gt;SpringBoot——开启Druid监控统计功能(SQL监控、慢SQL记录、Spring监控、去广告)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>elasticsearch</title>
      <link>/zh/post/computer-science/database/elasticsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/database/elasticsearch/</guid>
      <description>&lt;h1 id=&#34;elasticsearch&#34;&gt;&#xA;  elasticsearch&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#elasticsearch&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>mycat</title>
      <link>/zh/post/computer-science/database/mycat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/database/mycat/</guid>
      <description>&lt;h1 id=&#34;mycat&#34;&gt;&#xA;  mycat&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mycat&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000021987297&#34;&gt;那些年非常火的MyCAT是什么？&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/m0_74436895/article/details/142969704&#34;&gt;MyCat(看这一篇就够了）&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应用场景&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MySQL读写分离&lt;/li&gt;&#xA;&lt;li&gt;分库分表&lt;/li&gt;&#xA;&lt;li&gt;数据库路由器&lt;/li&gt;&#xA;&lt;li&gt;整合数据源&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当一个项目需要用到多种数据源如Oracle, MySQL, SQL Server, &lt;code&gt;PostgreSQL&lt;/code&gt;时，可以利用&lt;code&gt;Mycat&lt;/code&gt;进行整合，只需访问&lt;code&gt;Mycat&lt;/code&gt;这一个数据源就行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;逻辑库 schema&#xA;&lt;ul&gt;&#xA;&lt;li&gt;业务开发人员通常在实际应用中并不需要知道中间件的存在，只需要关注数据库，所以数据库中间件可以被当做一个或多个数据库集群构成的逻辑库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;逻辑表 table&#xA;&lt;ul&gt;&#xA;&lt;li&gt;既然有逻辑库，就会有逻辑表。在分布式数据库中，对于应用来说，读写数据的表就是逻辑表。逻辑表可以分布在一个或多个分片库中，也可以不分片&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Mycat的原理最重要的一个动词是拦截，它拦截用户发送过来的SQL语句&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;mycat-如何实现高可用&#34;&gt;&#xA;  &lt;code&gt;Mycat&lt;/code&gt; 如何实现高可用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mycat-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e9%ab%98%e5%8f%af%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于&lt;code&gt;keepalived&lt;/code&gt;的&lt;code&gt;MyCat&lt;/code&gt;高可用技术&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Keepalived&lt;/code&gt;通过&lt;code&gt;VRRP&lt;/code&gt;协议实现虚拟IP(VIP)的自动漂移，当主节点故障时，VIP会自动切换到备用节点，实现MyCat服务的高可用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;HAProxy+Keepalived实现高可用与负载均衡&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HAProxy实现MyCat多节点的负载均衡&lt;/li&gt;&#xA;&lt;li&gt;Keepalived实现HAProxy自身的高可用&lt;/li&gt;&#xA;&lt;li&gt;同时解决了MyCat的负载均衡器的高可用问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>mysql</title>
      <link>/zh/post/computer-science/database/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/database/mysql/</guid>
      <description>&lt;h1 id=&#34;mysql&#34;&gt;&#xA;  mysql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mysql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;binlog&#34;&gt;&#xA;  binlog&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#binlog&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;redo-log-和-binlog日志&#34;&gt;&#xA;  redo log 和 binlog日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redo-log-%e5%92%8c-binlog%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redo log 重做日志&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Redo log是InnoDB存储引擎特有的物理日志，主要保证事务的持久性和崩溃恢复能力(crash-safe)。当MySQL实例意外宕机时，InnoDB可以通过redo log恢复已提交但未写入数据文件的事务，确保数据不会丢失&lt;/li&gt;&#xA;&lt;li&gt;Redo log采用&amp;quot;预写日志(WAL, Write-Ahead Logging)&amp;ldquo;机制：在数据页修改前，先记录日志到redo log buffer，再根据策略刷盘到redo log文件&lt;/li&gt;&#xA;&lt;li&gt;刷盘策略&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过innodb_flush_log_at_trx_commit参数控制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0：每秒刷盘一次，事务提交时不刷盘(可能丢失1秒数据)&lt;/li&gt;&#xA;&lt;li&gt;1：每次事务提交都刷盘(默认，最安全)&lt;/li&gt;&#xA;&lt;li&gt;2：写入OS缓存，不立即刷盘(仅MySQL崩溃安全，服务器宕机可能丢失数据)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;bin log 二进制日志&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Binlog是MySQL Server层维护的逻辑日志，记录所有引起数据变更的SQL语句或行变更&lt;/li&gt;&#xA;&lt;li&gt;主要用于&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主从复制：从库通过重放主库的binlog实现数据同步&lt;/li&gt;&#xA;&lt;li&gt;时间点恢复：结合全量备份和binlog可实现任意时间点的数据恢复&lt;/li&gt;&#xA;&lt;li&gt;数据归档：记录数据库所有变更历史&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;三种格式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;STATEMENT：记录SQL原文(默认)，可能因函数(如NOW())导致主从不一致&lt;/li&gt;&#xA;&lt;li&gt;ROW：记录行数据变更(最安全)，但日志量大&lt;/li&gt;&#xA;&lt;li&gt;MIXED：混合模式，根据语句自动选择格式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;刷盘控制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过 sync_binlog 参数控制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0：由系统决定刷盘时机&lt;/li&gt;&#xA;&lt;li&gt;1：每次事务提交都刷盘(最安全)&lt;/li&gt;&#xA;&lt;li&gt;N：每N个事务刷盘一次(平衡性能与安全性)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;两阶段提交：保证日志一致性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Prepare阶段：写入redo log并标记为prepare状态&lt;/li&gt;&#xA;&lt;li&gt;写入binlog&lt;/li&gt;&#xA;&lt;li&gt;Commit阶段：将redo log标记为commit状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;reference&#34;&gt;&#xA;  Reference&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reference&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://geekdaxue.co/books/zhangnio@or5bz8&#34;&gt;MySQL 架构原理&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>postgresql</title>
      <link>/zh/post/computer-science/database/postgresql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/database/postgresql/</guid>
      <description>&lt;h1 id=&#34;postgresql&#34;&gt;&#xA;  postgresql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#postgresql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>shardingsphere</title>
      <link>/zh/post/computer-science/database/shardingsphere/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/database/shardingsphere/</guid>
      <description>&lt;h1 id=&#34;shardingsphere&#34;&gt;&#xA;  shardingsphere&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#shardingsphere&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;高性能数据库集群&#34;&gt;&#xA;  高性能数据库集群&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e9%9b%86%e7%be%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;第一种读写分离&#34;&gt;&#xA;  第一种：读写分离&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e4%b8%80%e7%a7%8d%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主库负责处理事务性的增删改操作，从库负责处理查询操作&lt;/li&gt;&#xA;&lt;li&gt;能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善&lt;/li&gt;&#xA;&lt;li&gt;读写分离是根据SQL语义的分析，将读操作和写操作分别路由至主库与从库&lt;/li&gt;&#xA;&lt;li&gt;两种方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一主多从&lt;/li&gt;&#xA;&lt;li&gt;多主多从&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;第二种数据库分片&#34;&gt;&#xA;  第二种：数据库分片&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e4%ba%8c%e7%a7%8d%e6%95%b0%e6%8d%ae%e5%ba%93%e5%88%86%e7%89%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读写分离分散了数据库读写操作的压力，但是没有分散存储的压力，为了满足业务数据存储的需求，就需要将存储分散到多台数据库服务器上&lt;/li&gt;&#xA;&lt;li&gt;数据分片的有效手段是对关系型数据库进行分库和分表&lt;/li&gt;&#xA;&lt;li&gt;数据分片的拆分方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;垂直分片&#xA;&lt;ul&gt;&#xA;&lt;li&gt;专库专用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例如将商城库拆分为订单库、用户库、库存库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理&lt;/li&gt;&#xA;&lt;li&gt;垂直分表适合将表中某些不常用的列，或者是占了大量空间的列拆分出去&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;水平分片&#xA;&lt;ul&gt;&#xA;&lt;li&gt;水平分表&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单表切分为多表之后，新的表即使在同一个数据库服务器中，也可能带来可观的性能提升，如果性能能够满足业务要求，可以不拆分到多台数据库服务器，毕竟业务分库也会引入很多复杂性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;水平分库&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果单表拆分为多表后，单台服务器依然无法满足性能要求，那就需要将多个表分散在不同的数据库服务器中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CAP理论中的C在实践中是不可能完美实现的，在数据复制的过程中，节点N1和节点N2的数据并不一致（强一致性）。即使无法做到强一致性，但应用可以采用合适的方式达到最终一致性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本可用&lt;/li&gt;&#xA;&lt;li&gt;软引用&lt;/li&gt;&#xA;&lt;li&gt;最终一致性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;阿里巴巴Java开发手册&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表&lt;/li&gt;&#xA;&lt;li&gt;如果预计3年后的数据量根本达不到这个级别，请不要在创建表时就分库分表&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;读写分离和数据分片具体的视线方式有两种&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序代码封装&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在代码中抽象一个数据访问层（中间层封装），实现读写操作分离和数据库服务器连接的管理&lt;/li&gt;&#xA;&lt;li&gt;Apache ShardingSphere&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ShardingSphere-JDBC 程序代码封装&lt;/li&gt;&#xA;&lt;li&gt;ShardingSphere-Proxy 中间件封装&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;中间件封装&#xA;&lt;ul&gt;&#xA;&lt;li&gt;独立一套系统处理，实现读写操作分离和数据库服务器连接的管理。对于业务服务器来说，访问中间件和访问数据库没有区别，在业务服务器看来，中间件就是一个数据库服务器&lt;/li&gt;&#xA;&lt;li&gt;MyCat&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;主从同步原理&#34;&gt;&#xA;  主从同步原理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;slave会从master读取binlog来进行数据同步&lt;/li&gt;&#xA;&lt;li&gt;1 master将数据改变记录到bin log中&lt;/li&gt;&#xA;&lt;li&gt;2 当 slave 上执行 start slave 命令之后，slave会创建一个IO连接用来连接master，请求master中的binlog&lt;/li&gt;&#xA;&lt;li&gt;3 当 slave 连接 master 时，master 会创建一个 log dump 线程，用于发送 bin log 的内容。在读取 binlog 的内容的操作中，会对主节点中的binlog加锁，当读取完成并发送给从服务器后解锁&lt;/li&gt;&#xA;&lt;li&gt;4 IO 线程接收主节点 binlog dump 进程发来的更新之后，保存到中继日志 relay log 中&lt;/li&gt;&#xA;&lt;li&gt;5 slave 的 SQL 线程，读取 relay log 日志，并解析成具体操作，从而实现主从操作一直，最终数据一致&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;mycat与shardingsphere深度对比&#34;&gt;&#xA;  MyCat与ShardingSphere深度对比&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mycat%e4%b8%8eshardingsphere%e6%b7%b1%e5%ba%a6%e5%af%b9%e6%af%94&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果是从传统单体结构迁移，且只需要基本的分库分表功能，MyCat可能更合适&lt;/li&gt;&#xA;&lt;li&gt;如果是新建的云原生系统或微服务架构，ShardingSphere是更好的选择&lt;/li&gt;&#xA;&lt;li&gt;考虑到技术演进和社区支持，新项目建议优先考虑ShardingSphere&lt;/li&gt;&#xA;&lt;li&gt;某些场景可以组合使用-用ShardingSphere-JDBC处理应用内分片，用MyCat/ShardingShpere-Proxy处理遗留系统访问&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;shardingsphere的分布式事务功能具体是如何实现的&#34;&gt;&#xA;  ShardingSphere的分布式事务功能具体是如何实现的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#shardingsphere%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e5%8a%9f%e8%83%bd%e5%85%b7%e4%bd%93%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;xa事务强一致性&#34;&gt;&#xA;  XA事务（强一致性）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#xa%e4%ba%8b%e5%8a%a1%e5%bc%ba%e4%b8%80%e8%87%b4%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现原理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于XA协议的两阶段提交(2PC)&lt;/li&gt;&#xA;&lt;li&gt;使用ShardingSphere的XATransactionManager作为事务管理器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;工作流程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;准备阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事务协调器向所有参与者发送prepare请求&lt;/li&gt;&#xA;&lt;li&gt;各参与者执行事务但不提交，记录undo/redo日志&lt;/li&gt;&#xA;&lt;li&gt;参与者返回准备就绪或失败响应&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;提交/回滚阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果所有参与者都准备就绪，发送&lt;code&gt;commit&lt;/code&gt;请求&lt;/li&gt;&#xA;&lt;li&gt;如果任一参与者准备失败，发送&lt;code&gt;rollback&lt;/code&gt;请求&lt;/li&gt;&#xA;&lt;li&gt;参与者根据指令完成最终操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;seata事务柔性事务at模式&#34;&gt;&#xA;  &lt;code&gt;Seata&lt;/code&gt;事务（柔性事务/AT模式）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#seata%e4%ba%8b%e5%8a%a1%e6%9f%94%e6%80%a7%e4%ba%8b%e5%8a%a1at%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;整合&lt;code&gt;Seata&lt;/code&gt;的AT(Automatic Transaction)模式&lt;/li&gt;&#xA;&lt;li&gt;基于全局锁+分支事务的补偿机制&lt;/li&gt;&#xA;&lt;li&gt;工作流程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;业务SQL被Seata拦截解析&lt;/li&gt;&#xA;&lt;li&gt;RM生成undo log记录修改前数据&lt;/li&gt;&#xA;&lt;li&gt;执行业务SQL并提交本地事务&lt;/li&gt;&#xA;&lt;li&gt;向TC注册分支事务并报告状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;第二阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;成功时：异步删除undo log&lt;/li&gt;&#xA;&lt;li&gt;失败时：基于 undo log 进行补偿回滚&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;base事务saga模式&#34;&gt;&#xA;  BASE事务（Saga模式）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#base%e4%ba%8b%e5%8a%a1saga%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于Saga模式的长事务解决方案&lt;/li&gt;&#xA;&lt;li&gt;每个子事务都有对应的补偿操作&lt;/li&gt;&#xA;&lt;li&gt;最终一致性模型&lt;/li&gt;&#xA;&lt;li&gt;执行模式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;正向流程：按顺序执行所有子事务&lt;/li&gt;&#xA;&lt;li&gt;补偿流程：出现失败时，逆序执行补偿操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;生产实践建议&#34;&gt;&#xA;  生产实践建议&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e4%ba%a7%e5%ae%9e%e8%b7%b5%e5%bb%ba%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;金融核心系统：优先考虑XA事务&lt;/li&gt;&#xA;&lt;li&gt;普通交易系统：推荐&lt;code&gt;Seata AT&lt;/code&gt;模式&lt;/li&gt;&#xA;&lt;li&gt;跨系统长流程：考虑&lt;code&gt;Saga&lt;/code&gt;模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;reference&#34;&gt;&#xA;  Reference&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reference&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_38263083/article/details/125439693&#34;&gt;shardingsphere分库分表示例（逻辑表，真实表，绑定表，广播表，单表），分页性能测试&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/hyzsuccess/article/details/127644291&#34;&gt;ShardingSphere学习（超详细）&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>SQL</title>
      <link>/zh/post/computer-science/database/sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/database/sql/</guid>
      <description>&lt;h1 id=&#34;sql&#34;&gt;&#xA;  sql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;2502-设计内存分配器&#34;&gt;&#xA;  2502 设计内存分配器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2502-%e8%ae%be%e8%ae%a1%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;-175-组合两个表&#34;&gt;&#xA;  ✅ 175 组合两个表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-175-%e7%bb%84%e5%90%88%e4%b8%a4%e4%b8%aa%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.cn/problems/combine-two-tables/&#34;&gt;175. 组合两个表&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要展示的字段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;姓 LastName&lt;/li&gt;&#xA;&lt;li&gt;名 FirstName&lt;/li&gt;&#xA;&lt;li&gt;城市 City&lt;/li&gt;&#xA;&lt;li&gt;州 State&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;如果 &lt;code&gt;personId&lt;/code&gt; 的地址不再 &lt;code&gt;Address&lt;/code&gt; 表中，则报告为 &lt;code&gt;null&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用左连接&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; FirstName, LastName, City, &lt;span style=&#34;color:#66d9ef&#34;&gt;State&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; Person&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#66d9ef&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;join&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; Person.PersonId &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Address.PersonId;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;176-第二高的薪水&#34;&gt;&#xA;  176 第二高的薪水&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#176-%e7%ac%ac%e4%ba%8c%e9%ab%98%e7%9a%84%e8%96%aa%e6%b0%b4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.cn/problems/second-highest-salary/description/&#34;&gt;176. 第二高的薪水&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;If&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Exists&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id     &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    salary &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Truncate &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; Employee;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;100&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;200&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;300&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;400&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;5&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;500&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;6&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;600&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; (id, salary)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;7&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;700&amp;#39;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Employee 表：&#xA;+-------------+------+&#xA;| Column Name | Type |&#xA;+-------------+------+&#xA;| id          | int  |&#xA;| salary      | int  |&#xA;+-------------+------+&#xA;id 是这个表的主键。&#xA;表的每一行包含员工的工资信息。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;distinct&lt;/span&gt; Salary &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; SecondHighestSalary&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; Employee&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;order&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;by&lt;/span&gt; Salary &lt;span style=&#34;color:#66d9ef&#34;&gt;desc&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;limit&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; offset &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然而，如果没有第 2 高的薪资，即表里可能只有一条记录，这个解答会被评测为 &amp;lsquo;Wrong Answer&amp;rsquo; 。为了克服这个问题，我们可以将其作为临时表。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
