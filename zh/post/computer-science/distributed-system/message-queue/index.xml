<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Penruins</title>
    <link>/zh/post/computer-science/distributed-system/message-queue/</link>
    <description>Recent content on Penruins</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="/zh/post/computer-science/distributed-system/message-queue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>kafka</title>
      <link>/zh/post/computer-science/distributed-system/message-queue/kafka/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/distributed-system/message-queue/kafka/</guid>
      <description>&lt;h1 id=&#34;kafka&#34;&gt;&#xA;  kafka&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;kafka-vs-rocketmq&#34;&gt;&#xA;  kafka vs rocketmq&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka-vs-rocketmq&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/341156308&#34;&gt;Kafka 和 RocketMQ 之性能对比&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kafka如何实现高吞吐量的&#34;&gt;&#xA;  kafka如何实现高吞吐量的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e9%ab%98%e5%90%9e%e5%90%90%e9%87%8f%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;顺序读写&lt;/li&gt;&#xA;&lt;li&gt;零拷贝&lt;/li&gt;&#xA;&lt;li&gt;分区与并行处理&lt;/li&gt;&#xA;&lt;li&gt;批量发送&lt;/li&gt;&#xA;&lt;li&gt;数据压缩&lt;/li&gt;&#xA;&lt;li&gt;页缓存&lt;/li&gt;&#xA;&lt;li&gt;高效的日志存储(将消息分段、并建立索引文件、支持快速定位与消息读取)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kafka突然宕机了消息会不会丢失&#34;&gt;&#xA;  Kafka突然宕机了消息会不会丢失&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka%e7%aa%81%e7%84%b6%e5%ae%95%e6%9c%ba%e4%ba%86%e6%b6%88%e6%81%af%e4%bc%9a%e4%b8%8d%e4%bc%9a%e4%b8%a2%e5%a4%b1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;消息的持久化机制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;消息会存储到日志文件中，宕机后不会丢失&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;副本机制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个分区可以建立副本，确保数据不丢失&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;生产者确认机制&lt;/li&gt;&#xA;&lt;li&gt;刷盘机制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步刷盘, 每次写入消息就将写入到磁盘中, 但损失了效率&lt;/li&gt;&#xA;&lt;li&gt;异步刷盘&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kafka如何保障顺序消费&#34;&gt;&#xA;  kafka如何保障顺序消费&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka%e5%a6%82%e4%bd%95%e4%bf%9d%e9%9a%9c%e9%a1%ba%e5%ba%8f%e6%b6%88%e8%b4%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分区内的顺序性&lt;/li&gt;&#xA;&lt;li&gt;将分区键与业务ID进行绑定，保证相同业务的消息都发送到对应分区进行顺序消费&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kafka重平衡的触发条件是什么&#34;&gt;&#xA;  kafka重平衡的触发条件是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka%e9%87%8d%e5%b9%b3%e8%a1%a1%e7%9a%84%e8%a7%a6%e5%8f%91%e6%9d%a1%e4%bb%b6%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;消费者组成员发生变化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;消费者的加入、退出或崩溃&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;订阅主题分区数发生变化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主题分区增加或减少&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;订阅主题发生变化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用正则表达式订阅主题时，新的主题被匹配&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kafka发送失败如何处理&#34;&gt;&#xA;  kafka发送失败如何处理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka%e5%8f%91%e9%80%81%e5%a4%b1%e8%b4%a5%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;同步发送模式&lt;/strong&gt; 捕获异常&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;异步发送模式&lt;/strong&gt; 在回调方法中捕获异常&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;重试机制&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;设置重试次数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;错误分类处理&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可恢复错误&#xA;&lt;ul&gt;&#xA;&lt;li&gt;网络超时&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;不可恢复错误&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无效的主题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;调整生产者配置&#xA;&lt;ul&gt;&#xA;&lt;li&gt;设置&lt;code&gt;acks&lt;/code&gt;, 可以设置为all，确保所有副本都确认才返回成功&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;使用死信队列&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将发送失败的消息加入到死信队列中，以便后续处理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;kafka的分区分配策略有哪些&#34;&gt;&#xA;  kafka的分区分配策略有哪些？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka%e7%9a%84%e5%88%86%e5%8c%ba%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5%e6%9c%89%e5%93%aa%e4%ba%9b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;RangeAssignor&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;RoundRobinAssignor&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;StickerAssignor&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CooperativeStickerAssignor&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;kafka默认的分区策略是什么&#34;&gt;&#xA;  kafka默认的分区策略是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka%e9%bb%98%e8%ae%a4%e7%9a%84%e5%88%86%e5%8c%ba%e7%ad%96%e7%95%a5%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;DefaultPartitioner&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指定分区&lt;/li&gt;&#xA;&lt;li&gt;基于key分配&lt;/li&gt;&#xA;&lt;li&gt;轮询分配&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Message Queue</title>
      <link>/zh/post/computer-science/distributed-system/message-queue/message-queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/distributed-system/message-queue/message-queue/</guid>
      <description>&lt;h1 id=&#34;message-queue&#34;&gt;&#xA;  Message Queue&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#message-queue&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;消息队列如何选型&#34;&gt;&#xA;  消息队列如何选型？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e5%a6%82%e4%bd%95%e9%80%89%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;高吞吐量、大数据场景：&lt;strong&gt;Kafka&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;金融交易、高可靠场景：&lt;strong&gt;RocketMQ&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;支持事务消息和高可用性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;易于使用、功能丰富：&lt;strong&gt;RabbitMQ&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;云原生、多租户场景：Pulsar 适合需要高扩展性和分层存储的场景&lt;/li&gt;&#xA;&lt;li&gt;简单轻量、定制开发场景：NSQ 适合 Golang技术栈&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>rabbitmq</title>
      <link>/zh/post/computer-science/distributed-system/message-queue/rabbitmq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/distributed-system/message-queue/rabbitmq/</guid>
      <description>&lt;h1 id=&#34;rabbitmq&#34;&gt;&#xA;  rabbitmq&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rabbitmq&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;main&#34;&gt;&#xA;  main&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#main&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.rabbitmq.com/&#34;&gt;RabbitMQ&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.rabbitmq.com/tutorials&#34;&gt;RabbitMQ Tutorials&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Hello World&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Work Queues&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Distributing tasks among workers&lt;/li&gt;&#xA;&lt;li&gt;一个生产者，多个消费者&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Publish/Subscribe&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Sending messages to many consumers at once&lt;/li&gt;&#xA;&lt;li&gt;一个消息，每个消费者都能接收到&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Routing&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多个消费者订阅同一个生产者的消息, 通过路由键，选择性消费&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Topics&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过匹配的方式来选择性接收&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;RPC&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;rabbitmq有哪几种模式&#34;&gt;&#xA;  rabbitmq有哪几种模式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rabbitmq%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;简单模式（Simple Mode）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;：一个生产者（Producer）和一个消费者（Consumer），消息直接发送到队列中，不需要交换机（Exchange）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：消息只能被一个消费者处理，适合简单的点对点通信。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：简单的任务队列，如日志收集。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;工作队列模式（Work Queue Mode）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;：一个生产者和多个消费者，消息分发到多个消费者，但每个消息只能被一个消费者处理。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：默认采用轮询机制分发消息，支持手动确认（ack）以确保消息处理成功。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：任务分发，如多个消费者处理不同的任务。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;发布/订阅模式（Publish/Subscribe Mode）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;：生产者将消息发送到交换机（Exchange），交换机将消息广播到所有绑定的队列，每个队列可以有多个消费者。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：使用 &lt;strong&gt;fanout&lt;/strong&gt; 类型的交换机，消息会被所有消费者接收。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：消息广播，如通知多个系统或用户。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;路由模式（Routing Mode）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;：生产者将消息发送到交换机，交换机根据路由键（Routing Key）将消息分发到匹配的队列。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：使用 &lt;strong&gt;direct&lt;/strong&gt; 类型的交换机，支持精确的路由规则。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：根据特定规则分发消息，如按日志级别分类。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;主题模式（Topics Mode）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;：类似于路由模式，但支持更灵活的路由规则，使用通配符（如 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;#&lt;/code&gt;）匹配路由键。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：使用 &lt;strong&gt;topic&lt;/strong&gt; 类型的交换机，支持复杂的路由逻辑。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：需要灵活匹配和过滤消息的场景，如多维度消息分发。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RPC 模式（Remote Procedure Call Mode）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;：生产者发送消息后，等待消费者处理并返回结果，类似于远程过程调用。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：通过回调队列实现请求和响应的匹配。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：需要同步返回结果的场景，如远程调用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;发布确认模式（Publisher Confirms Mode）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;：生产者在发送消息后，等待 RabbitMQ 的确认，确保消息被成功接收。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：提高消息的可靠性，避免消息丢失。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：需要高可靠性的消息传递，如金融交易。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Header 模式（Headers Mode）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;：根据消息的头部信息（Headers）进行路由，而不是依赖路由键。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：使用 &lt;strong&gt;headers&lt;/strong&gt; 类型的交换机，支持复杂的匹配规则。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：需要根据消息属性进行路由的场景。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;rabbitmq有哪些类型的路由键&#34;&gt;&#xA;  rabbitmq有哪些类型的路由键&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rabbitmq%e6%9c%89%e5%93%aa%e4%ba%9b%e7%b1%bb%e5%9e%8b%e7%9a%84%e8%b7%af%e7%94%b1%e9%94%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;在 RabbitMQ 中，&lt;strong&gt;路由键（Routing Key）&lt;/strong&gt; 是用于决定消息如何被路由到队列的关键字。路由键的具体使用方式取决于 &lt;strong&gt;交换机类型&lt;/strong&gt;，不同类型的交换机对路由键的处理方式不同。以下是 RabbitMQ 中常见的交换机类型及其对应的路由键使用方式：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
