<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Penruins</title>
    <link>/zh/post/computer-science/java/</link>
    <description>Recent content on Penruins</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="/zh/post/computer-science/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>java basic</title>
      <link>/zh/post/computer-science/java/java-basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/java/java-basic/</guid>
      <description>&lt;h1 id=&#34;java-basic&#34;&gt;&#xA;  java basic&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java-basic&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;mess&#34;&gt;&#xA;  mess&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mess&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;八大数据类型&#34;&gt;&#xA;  八大数据类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%ab%e5%a4%a7%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;byte&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;char&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;short&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;long&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;float&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;double&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;transient-关键字的作用是什么&#34;&gt;&#xA;  transient 关键字的作用是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#transient-%e5%85%b3%e9%94%ae%e5%ad%97%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在一个类中如果变量被 transient 关键字修饰，在对类的对象进行序列化的时候就会忽略这个变量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;什么是深拷贝什么是浅拷贝&#34;&gt;&#xA;  什么是深拷贝？什么是浅拷贝？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e6%b7%b1%e6%8b%b7%e8%b4%9d%e4%bb%80%e4%b9%88%e6%98%af%e6%b5%85%e6%8b%b7%e8%b4%9d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;深拷贝：递归地复制对象及其所有嵌套的子对象，生成一个完全独立的新对象。两个对象之间不共享引用&lt;/li&gt;&#xA;&lt;li&gt;浅拷贝：创建一个新的对象，但只复制对象的最外层属性的引用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;string&#34;&gt;&#xA;  String&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#string&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;equals与--区别&#34;&gt;&#xA;  equals与 == 区别&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#equals%e4%b8%8e--%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;equals&lt;/code&gt; 比较的是两个字符串的内容是否是相等的&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 比较的是两个变量指向的引用是否是相等的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;stringbuilder-stringbuffer区别&#34;&gt;&#xA;  StringBuilder StringBuffer区别&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuilder-stringbuffer%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;StringBuilder 线程不安全&lt;/li&gt;&#xA;&lt;li&gt;StringBuffer 线程安全&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;stringbuffer-是怎么保证线程安全的&#34;&gt;&#xA;  StringBuffer 是怎么保证线程安全的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuffer-%e6%98%af%e6%80%8e%e4%b9%88%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对字符串操作的方法都通过 synchronized 关键字修饰，保证线程安全&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;stringbuffer-和-stringbuilder-字符串在底层是以什么数据结构保存的&#34;&gt;&#xA;  StringBuffer 和 StringBuilder 字符串在底层是以什么数据结构保存的&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuffer-%e5%92%8c-stringbuilder-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%9c%a8%e5%ba%95%e5%b1%82%e6%98%af%e4%bb%a5%e4%bb%80%e4%b9%88%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%bf%9d%e5%ad%98%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;两个类都继承子 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 均使用 &lt;code&gt;char[] value&lt;/code&gt; 保存字符串数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;hashmap&#34;&gt;&#xA;  HashMap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;hashmap底层的数据结构是怎样的&#34;&gt;&#xA;  HashMap底层的数据结构是怎样的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap%e5%ba%95%e5%b1%82%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;java 1.8 之前 数组 + 链表&lt;/li&gt;&#xA;&lt;li&gt;java 1.8 之后 数组 + 链表/红黑树&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;hashmap-是否线程安全如何保证线程安全&#34;&gt;&#xA;  HashMap 是否线程安全，如何保证线程安全&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap-%e6%98%af%e5%90%a6%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不是线程安全的&lt;/li&gt;&#xA;&lt;li&gt;如何保证线程安全&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Collections.synchronizedMap()&lt;/li&gt;&#xA;&lt;li&gt;ConcurrentHashMap&lt;/li&gt;&#xA;&lt;li&gt;读写锁 ReadWriteLock&lt;/li&gt;&#xA;&lt;li&gt;局部使用 HashMap&lt;/li&gt;&#xA;&lt;li&gt;初始化写，后续只读&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;hashmap-get-时间复杂度&#34;&gt;&#xA;  HashMap get 时间复杂度&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap-get-%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最好的情况是O(1)&lt;/li&gt;&#xA;&lt;li&gt;若发生哈希碰撞，对应到桶之后还需要查询链表或红黑树，时间复杂度下降到O(N)或O(logN)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;hashmap-和-hashtable-有什么区别&#34;&gt;&#xA;  HashMap 和 Hashtable 有什么区别？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap-%e5%92%8c-hashtable-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程安全性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HashMap是线程不安全的，HashTable是线程安全的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;对空值的支持&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HashMap的key和value都支持空值，HashTable不支持key或value为空值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;list&#34;&gt;&#xA;  List&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#list&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;collection-和-collections-有什么区别&#34;&gt;&#xA;  Collection 和 Collections 有什么区别？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#collection-%e5%92%8c-collections-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Collection 是集合类的一个接口&lt;/li&gt;&#xA;&lt;li&gt;Collections 是集合的一个工具类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;linkedlist-删除时间复杂度&#34;&gt;&#xA;  LinkedList 删除时间复杂度&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linkedlist-%e5%88%a0%e9%99%a4%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除头和尾的时间复杂度为O(1)，因为在LinkedList中维护了头和尾2个指针&lt;/li&gt;&#xA;&lt;li&gt;其他位置的时间复杂度为O(n)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;函数式编程&#34;&gt;&#xA;  函数式编程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;java的函数式编程包含哪些内容&#34;&gt;&#xA;  java的函数式编程包含哪些内容？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e7%9a%84%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%8c%85%e5%90%ab%e5%93%aa%e4%ba%9b%e5%86%85%e5%ae%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;java的函数式编程的概念中将只包含一个方法的接口称为函数式接口，可以通过Lambda表达式简化匿名类的定义&lt;/li&gt;&#xA;&lt;li&gt;提供流操作了API，可以将集合的迭代操作变为链式操作，提供了并行处理集合的方法&lt;/li&gt;&#xA;&lt;li&gt;提供了Optional类用来处理空指针的情况&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;io&#34;&gt;&#xA;  I/O&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#io&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;网络io分为哪几种&#34;&gt;&#xA;  网络io分为哪几种&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bd%91%e7%bb%9cio%e5%88%86%e4%b8%ba%e5%93%aa%e5%87%a0%e7%a7%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;网络 I/O 模型主要分为以下五种：&lt;/p&gt;</description>
    </item>
    <item>
      <title>java</title>
      <link>/zh/post/computer-science/java/java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/java/java/</guid>
      <description>&lt;h1 id=&#34;string&#34;&gt;&#xA;  String&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#string&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;stringbuffer-是怎么保证线程安全的&#34;&gt;&#xA;  StringBuffer 是怎么保证线程安全的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuffer-%e6%98%af%e6%80%8e%e4%b9%88%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt; 是通过 &lt;strong&gt;同步机制&lt;/strong&gt; 来保证线程安全的。具体来说，它的所有关键方法（如 &lt;code&gt;append()&lt;/code&gt;、&lt;code&gt;insert()&lt;/code&gt;、&lt;code&gt;delete()&lt;/code&gt;、&lt;code&gt;reverse()&lt;/code&gt; 等）都使用了 &lt;code&gt;synchronized&lt;/code&gt; 关键字进行修饰，确保同一时间只有一个线程可以执行这些方法&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;2&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;7&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-同步方法&#34;&gt;&#xA;  1. &lt;strong&gt;同步方法&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e5%90%8c%e6%ad%a5%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt; 的方法在设计时都加了 &lt;code&gt;synchronized&lt;/code&gt; 关键字，例如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; StringBuffer &lt;span style=&#34;color:#a6e22e&#34;&gt;append&lt;/span&gt;(String str) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 方法实现&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种机制确保了在多线程环境下，只有一个线程可以访问和修改 &lt;code&gt;StringBuffer&lt;/code&gt; 的内容，避免了竞态条件（Race Condition）和数据不一致的问题&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;2&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-锁机制&#34;&gt;&#xA;  2. &lt;strong&gt;锁机制&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%e9%94%81%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt; 内部使用了一个锁对象（即 &lt;code&gt;this&lt;/code&gt; 锁），当一个线程调用 &lt;code&gt;StringBuffer&lt;/code&gt; 的同步方法时，会获取这个锁，其他线程必须等待锁释放后才能继续执行。这种锁机制保证了线程间的同步&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;7&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-性能影响&#34;&gt;&#xA;  3. &lt;strong&gt;性能影响&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%e6%80%a7%e8%83%bd%e5%bd%b1%e5%93%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;虽然 &lt;code&gt;StringBuffer&lt;/code&gt; 的同步机制确保了线程安全，但也带来了性能开销。因为在多线程环境下，每次只能有一个线程操作 &lt;code&gt;StringBuffer&lt;/code&gt;，其他线程会被阻塞。因此，在单线程环境下，推荐使用性能更高的 &lt;code&gt;StringBuilder&lt;/code&gt;，它没有同步机制&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;5&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;8&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-适用场景&#34;&gt;&#xA;  4. &lt;strong&gt;适用场景&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;多线程环境&lt;/strong&gt;：如果需要在多线程环境下对字符串进行操作，&lt;code&gt;StringBuffer&lt;/code&gt; 是合适的选择，因为它确保了线程安全&lt;a href=&#34;@ref&#34;&gt;2&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;9&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;单线程环境&lt;/strong&gt;：在单线程环境下，建议使用 &lt;code&gt;StringBuilder&lt;/code&gt;，因为它没有同步开销，性能更高&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;8&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;总结&#34;&gt;&#xA;  总结&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%bb%e7%bb%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt; 通过 &lt;code&gt;synchronized&lt;/code&gt; 关键字实现的同步机制，确保了多线程环境下的线程安全性。虽然这种机制带来了性能开销，但在需要线程安全的场景下，它是一个可靠的选择&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;2&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;7&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;stringbuffer-和-stringbuilder-字符串在底层是以什么数据结构保存的&#34;&gt;&#xA;  StringBuffer 和 StringBuilder 字符串在底层是以什么数据结构保存的&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuffer-%e5%92%8c-stringbuilder-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%9c%a8%e5%ba%95%e5%b1%82%e6%98%af%e4%bb%a5%e4%bb%80%e4%b9%88%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%bf%9d%e5%ad%98%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt; 和 &lt;code&gt;StringBuilder&lt;/code&gt; 在底层都是使用 &lt;strong&gt;字符数组（&lt;code&gt;char[]&lt;/code&gt;）&lt;/strong&gt; 来保存字符串数据的。具体来说，它们继承了 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 类，而 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 类中定义了一个 &lt;code&gt;char[] value&lt;/code&gt; 数组，用于存储字符序列&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;3&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;4&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>concurrent</title>
      <link>/zh/post/computer-science/java/concurrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/java/concurrent/</guid>
      <description>&lt;h1 id=&#34;concurrent&#34;&gt;&#xA;  concurrent&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#concurrent&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;synchronized&#34;&gt;&#xA;  synchronized&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;synchronized-的底层原理是什么&#34;&gt;&#xA;  synchronized 的底层原理是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized-%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于 jvm 的 Monitor 机制&lt;/li&gt;&#xA;&lt;li&gt;通过进入和退出 Monitor 对象来实现方法和代码块的同步&lt;/li&gt;&#xA;&lt;li&gt;字节码指令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;monitorenter&lt;/code&gt; 获取 Monitor 的所有权&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;monitorexit&lt;/code&gt; 释放 Monitor 的所有权&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;同步方法的实现&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ACC_SYNCHRONIZED 标志：当方法被 synchronized 修饰时，JVM 会在方法常量池中设置 ACC_SYNCHRONIZED 标志。&lt;/li&gt;&#xA;&lt;li&gt;调用方法时，JVM 检查该标志。如果设置了，线程必须先获取 Monitor 才能执行方法，执行完成后释放 Monitor&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;锁的优化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为了提升性能，JVM 对 synchronized 进行了优化，包括&#xA;&lt;ul&gt;&#xA;&lt;li&gt;偏向锁（Biased Locking）：当锁始终由同一线程持有时，JVM 会将锁标记为偏向锁，减少锁获取的开销&lt;/li&gt;&#xA;&lt;li&gt;轻量级锁（Lightweight Locking）：当存在多个线程交替执行时，JVM 会将锁升级为轻量级锁，通过 CAS 操作减少阻塞&lt;/li&gt;&#xA;&lt;li&gt;重量级锁（Heavyweight Locking）：当锁竞争激烈时，JVM 会将锁升级为重量级锁，依赖于操作系统的互斥量（Mutex）实现&lt;/li&gt;&#xA;&lt;li&gt;自旋锁（Spin Locking）：当线程无法获取锁时，会进行有限次数的自旋尝试，避免直接进入阻塞状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;concurrenthashmap&#34;&gt;&#xA;  ConcurrentHashMap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#concurrenthashmap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;concurrentlinkedhashmap&#34;&gt;&#xA;  ConcurrentLinkedHashMap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#concurrentlinkedhashmap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;比较-concurrenthash-和-concurrentlinkedhashmap&#34;&gt;&#xA;  比较 ConcurrentHash 和 ConcurrentLinkedHashMap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%af%94%e8%be%83-concurrenthash-%e5%92%8c-concurrentlinkedhashmap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在ConcurrentHashMap的基础上，增加了&lt;strong&gt;双向链表&lt;/strong&gt;来维护插入顺序或访问顺序&lt;/li&gt;&#xA;&lt;li&gt;支持LRU缓存淘汰策略，通过Weigher计算存储单元数，自动清理最近最少使用的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;线程池&#34;&gt;&#xA;  线程池&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;线程池的核心参数&#34;&gt;&#xA;  线程池的核心参数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e6%a0%b8%e5%bf%83%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;核心线程数 corePoolSize&lt;/li&gt;&#xA;&lt;li&gt;最大线程数 maximumPoolSize&lt;/li&gt;&#xA;&lt;li&gt;空闲线程存活时间 keepAliveTime&lt;/li&gt;&#xA;&lt;li&gt;时间单位 unit&lt;/li&gt;&#xA;&lt;li&gt;任务队列 workQueue&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ArrayBlockingQueue 基于数组的&lt;strong&gt;有界&lt;/strong&gt;队列&lt;/li&gt;&#xA;&lt;li&gt;LinkedBlockingQueue 基于链表的&lt;strong&gt;无界&lt;/strong&gt;队列&lt;/li&gt;&#xA;&lt;li&gt;SynchronousQueue 不存储元素的队列，直接交给线程处理&lt;/li&gt;&#xA;&lt;li&gt;PriorityBlockingQueue 支持优先级的&lt;strong&gt;无界&lt;/strong&gt;队列&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;线程工厂 threadFactory&lt;/li&gt;&#xA;&lt;li&gt;拒绝策略 handler&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AbortPolicy 抛弃任务并抛出异常 RejectedExecutionException&lt;/li&gt;&#xA;&lt;li&gt;DiscardPolicy 抛弃任务但不抛出异常&lt;/li&gt;&#xA;&lt;li&gt;CallerRunsPolicy 由提交任务的线程自己执行任务&lt;/li&gt;&#xA;&lt;li&gt;DiscardOldestPolicy 抛弃优先级最低的任务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;线程池的关键参数比如核心线程数等待队列拒绝策略在创建的时候做什么考虑&#34;&gt;&#xA;  线程池的关键参数，比如核心线程数、等待队列、拒绝策略，在创建的时候做什么考虑&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%85%b3%e9%94%ae%e5%8f%82%e6%95%b0%e6%af%94%e5%a6%82%e6%a0%b8%e5%bf%83%e7%ba%bf%e7%a8%8b%e6%95%b0%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5%e5%9c%a8%e5%88%9b%e5%bb%ba%e7%9a%84%e6%97%b6%e5%80%99%e5%81%9a%e4%bb%80%e4%b9%88%e8%80%83%e8%99%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;核心线程数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;任务类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU密集型: CPU核数 + 1&lt;/li&gt;&#xA;&lt;li&gt;IO密集型: CPU核数 * 2&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;最大线程数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;默认设置为与核心线程数一致，减少创建线程和销毁线程的开销&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;等待队列&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无界队列: 任务量稳定的场景, 但可能导致内存溢出&lt;/li&gt;&#xA;&lt;li&gt;有界队列: 任务量波动的场景&lt;/li&gt;&#xA;&lt;li&gt;同步队列: 适合任务量较少的场景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;拒绝策略&#xA;&lt;ul&gt;&#xA;&lt;li&gt;任务重要性: 如果任务不能丢弃，使用 CallerRunsPolicy(由提交任务的线程自己执行任务)&lt;/li&gt;&#xA;&lt;li&gt;系统容错性: 如果任务可以丢弃, 使用 DiscardPolicy(抛弃任务但不抛出异常) 和 DiscardOldestPolicy(抛弃优先级最低的任务)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;线程空闲时间&#xA;&lt;ul&gt;&#xA;&lt;li&gt;任务波动性: 如果任务波动较大，可以设置较短的空闲时间，及时回收线程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果在出现任务峰值的时候，创建线程锁产生的开销要如何处理？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;线程工厂&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程命名: 自定义线程名称，便于监控与查询问题&lt;/li&gt;&#xA;&lt;li&gt;线程优先级: 根据任务重要性设置线程优先级&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;线程池拒绝策略有哪些你项目通常选用哪个遇到重要场景触发拒绝策略必须需要处理任务你如何处理&#34;&gt;&#xA;  线程池拒绝策略有哪些，你项目通常选用哪个，遇到重要场景触发拒绝策略必须需要处理任务你如何处理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bd%a0%e9%a1%b9%e7%9b%ae%e9%80%9a%e5%b8%b8%e9%80%89%e7%94%a8%e5%93%aa%e4%b8%aa%e9%81%87%e5%88%b0%e9%87%8d%e8%a6%81%e5%9c%ba%e6%99%af%e8%a7%a6%e5%8f%91%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5%e5%bf%85%e9%a1%bb%e9%9c%80%e8%a6%81%e5%a4%84%e7%90%86%e4%bb%bb%e5%8a%a1%e4%bd%a0%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程池拒绝策略&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AbortPolicy 抛异常&lt;/li&gt;&#xA;&lt;li&gt;CallerRunsPolicy&lt;/li&gt;&#xA;&lt;li&gt;DiscardPolicy 不抛异常&lt;/li&gt;&#xA;&lt;li&gt;DiscardOldestPolicy&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;项目中常用哪个？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以容忍丢失的情况 DiscardPolicy DiscardOldestPolicy&lt;/li&gt;&#xA;&lt;li&gt;不允许有丢弃的情况：CallerRunsPolicy&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;重要场景触发拒绝策略的处理方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 CallerRunsPolicy&lt;/li&gt;&#xA;&lt;li&gt;自定义拒绝策略：增加自定义异常处理器，将拒绝的任务添加到外部的消息队列中，后续再进行提交&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;动态调整线程池的参数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;监控线程池的状态，动态调整 corePoolSize, maximumPoolSize, queueCapacity, 以应对突发流量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;如何实现动态线程池&#34;&gt;&#xA;  如何实现动态线程池？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过线程池的方法设置&lt;strong&gt;核心线程数&lt;/strong&gt;、&lt;strong&gt;最大线程数&lt;/strong&gt;、&lt;strong&gt;最大空闲时间&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;jdk-创建线程池有哪些方式&#34;&gt;&#xA;  JDK 创建线程池有哪些方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdk-%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%9c%89%e5%93%aa%e4%ba%9b%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过 &lt;code&gt;Executors&lt;/code&gt; 工厂类创建&#xA;&lt;ul&gt;&#xA;&lt;li&gt;newFixedThreadPool&lt;/li&gt;&#xA;&lt;li&gt;newCachedThreadPool&lt;/li&gt;&#xA;&lt;li&gt;newSingleThreadExecutor&lt;/li&gt;&#xA;&lt;li&gt;newScheduledThreadPool&lt;/li&gt;&#xA;&lt;li&gt;newSingleThreadScheduledExecutor&lt;/li&gt;&#xA;&lt;li&gt;newWorkStealingPool&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通过 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 手动指定参数创建&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;进程间通信&#34;&gt;&#xA;  进程间通信&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;管道 Pipe&lt;/li&gt;&#xA;&lt;li&gt;消息队列 Message Queue&lt;/li&gt;&#xA;&lt;li&gt;共享内存 Shared Memory&lt;/li&gt;&#xA;&lt;li&gt;信号 Signal&#xA;&lt;ul&gt;&#xA;&lt;li&gt;kill&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;信号量 Semaphore&lt;/li&gt;&#xA;&lt;li&gt;套接字 Socket&lt;/li&gt;&#xA;&lt;li&gt;文件 File&lt;/li&gt;&#xA;&lt;li&gt;内存映射文件 Memory-Mapped File&lt;/li&gt;&#xA;&lt;li&gt;远程过程调用 RPC, Remote Procedure Call&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;juc&#34;&gt;&#xA;  JUC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#juc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;juc-包下的7大类&#34;&gt;&#xA;  JUC 包下的7大类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#juc-%e5%8c%85%e4%b8%8b%e7%9a%847%e5%a4%a7%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;原子变量类（&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; 包）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于实现无锁的线程安全操作，基于CAS（Compare and Swap）机制：&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;AtomicInteger&lt;/code&gt;：原子操作的整型变量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;AtomicLong&lt;/code&gt;：原子操作的长整型变量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;AtomicBoolean&lt;/code&gt;：原子操作的布尔变量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;AtomicReference&amp;lt;V&amp;gt;&lt;/code&gt;：原子操作的引用类型变量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;AtomicStampedReference&amp;lt;V&amp;gt;&lt;/code&gt;：带版本戳的原子引用，解决ABA问题。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;锁和同步器类（&lt;code&gt;java.util.concurrent.locks&lt;/code&gt; 包）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提供更灵活的锁机制，替代传统的&lt;code&gt;synchronized&lt;/code&gt;关键字：&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;：可重入锁，支持公平锁和非公平锁。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;：读写锁，支持读多写少的场景。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;StampedLock&lt;/code&gt;：基于邮戳的锁，提供乐观读锁。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Condition&lt;/code&gt;：条件变量，用于线程间的等待和唤醒。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;并发集合类（&lt;code&gt;java.util.concurrent&lt;/code&gt; 包）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程安全的集合类，优化了高并发场景下的性能：&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;：线程安全的哈希表，采用分段锁或CAS机制。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;：写时复制的线程安全列表，适合读多写少的场景。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;：无界的线程安全队列，基于CAS实现。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;同步工具类&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于线程间的协作和同步：&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;：计数器门闩，等待一组线程完成。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CyclicBarrier&lt;/code&gt;：循环栅栏，等待一组线程到达同步点。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;：信号量，控制同时访问资源的线程数量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Phaser&lt;/code&gt;：更灵活的同步器，支持动态注册线程和多次同步。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;线程池框架（&lt;code&gt;java.util.concurrent&lt;/code&gt; 包）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于管理线程的生命周期和任务调度：&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ExecutorService&lt;/code&gt;：线程池接口，提供任务提交、关闭等功能。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;：可自定义的线程池实现。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ScheduledExecutorService&lt;/code&gt;：支持定时任务和周期任务的线程池。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ForkJoinPool&lt;/code&gt;：用于分治算法和并行流的线程池。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;阻塞队列类（&lt;code&gt;java.util.concurrent&lt;/code&gt; 包）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程安全的阻塞队列，用于生产者-消费者模型：&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;：基于数组的&lt;strong&gt;有界&lt;/strong&gt;阻塞队列。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;：基于链表的&lt;strong&gt;无界&lt;/strong&gt;阻塞队列。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;PriorityBlockingQueue&lt;/code&gt;：支持优先级的无界阻塞队列。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;其他工具类&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Future&amp;lt;V&amp;gt;&lt;/code&gt;：表示异步计算的结果。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CompletableFuture&amp;lt;V&amp;gt;&lt;/code&gt;：支持异步编程的增强版&lt;code&gt;Future&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Exchanger&amp;lt;V&amp;gt;&lt;/code&gt;：用于线程间交换数据的工具。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;threadlocal&#34;&gt;&#xA;  ThreadLocal&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadlocal&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;threadlocal-原理&#34;&gt;&#xA;  ThreadLocal 原理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadlocal-%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每一个线程都维护一个对象副本，每个线程独立地访问和操作各自的副本&lt;/li&gt;&#xA;&lt;li&gt;数据是保存在 Thread 父类的 ThreadLocalMap 中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;锁&#34;&gt;&#xA;  锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;java里的锁有哪些&#34;&gt;&#xA;  Java里的锁有哪些&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e9%87%8c%e7%9a%84%e9%94%81%e6%9c%89%e5%93%aa%e4%ba%9b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;锁的类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;synchronized 内置锁&lt;/li&gt;&#xA;&lt;li&gt;ReentrantLock 可重入锁&lt;/li&gt;&#xA;&lt;li&gt;ReadWriteLock 读写锁&lt;/li&gt;&#xA;&lt;li&gt;StampedLock 邮戳锁&lt;/li&gt;&#xA;&lt;li&gt;Condition 条件锁&#xA;&lt;ul&gt;&#xA;&lt;li&gt;与ReentrantLock 配合使用，实现线程间的等待和唤醒&lt;/li&gt;&#xA;&lt;li&gt;类似于 Object.wait() 和 Object.notify()，但更灵活&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;LockSupport&lt;/li&gt;&#xA;&lt;li&gt;Semaphore 信号量&lt;/li&gt;&#xA;&lt;li&gt;CountDownLatch 倒计时锁&lt;/li&gt;&#xA;&lt;li&gt;CyclicBarrier 循环屏障&lt;/li&gt;&#xA;&lt;li&gt;Phaser 阶段锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;不同的锁的使用场景&#xA;&lt;ul&gt;&#xA;&lt;li&gt;简单场景：使用 synchronized&lt;/li&gt;&#xA;&lt;li&gt;复杂场景：使用 ReentrantLock、ReadWriteLock 或 StampedLock&lt;/li&gt;&#xA;&lt;li&gt;线程协作：使用 Condition、CountDownLatch、CyclicBarrier 或 Phaser&lt;/li&gt;&#xA;&lt;li&gt;资源限制：使用 Semaphore&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;锁升级&#34;&gt;&#xA;  锁升级&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81%e5%8d%87%e7%ba%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;锁升级的过程&#34;&gt;&#xA;  锁升级的过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81%e5%8d%87%e7%ba%a7%e7%9a%84%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;锁机制根据竞争情况自动或手动调整锁的粒度和强度的过程，目的是在保证线程安全的同时优化性能&lt;/li&gt;&#xA;&lt;li&gt;在Java中，锁升级特指synchronized关键字的优化机制。JDK 1.6后，为了减少锁操作的开销，JVM引入了&lt;strong&gt;偏向锁&lt;/strong&gt;、&lt;strong&gt;轻量级锁&lt;/strong&gt;、&lt;strong&gt;重量级锁&lt;/strong&gt;三种状态，锁状态只能从低到高单向升级，不可降级&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;锁升级的4个阶段是什么&#34;&gt;&#xA;  锁升级的4个阶段是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81%e5%8d%87%e7%ba%a7%e7%9a%844%e4%b8%aa%e9%98%b6%e6%ae%b5%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;无锁状态&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;共享对象没有被任何线程锁定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;首次通过 synchronized 获取锁时，JVM讲锁标记为偏向锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当多线程竞争偏向锁时，JVM讲锁由偏向锁转换为轻量级锁&lt;/li&gt;&#xA;&lt;li&gt;通过CAS实现&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;重量级锁&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;轻量级锁自旋失败（如自旋次数超过阈值）或高并发竞争激烈时&lt;/li&gt;&#xA;&lt;li&gt;依赖操作系统的互斥量 Mutex&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;公平非公平&#34;&gt;&#xA;  公平、非公平&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%ac%e5%b9%b3%e9%9d%9e%e5%85%ac%e5%b9%b3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;什么是公平锁非公平锁&#34;&gt;&#xA;  什么是公平锁、非公平锁？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e5%85%ac%e5%b9%b3%e9%94%81%e9%9d%9e%e5%85%ac%e5%b9%b3%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;公平锁：线程根据申请锁的顺序获取锁&lt;/li&gt;&#xA;&lt;li&gt;非公平锁：允许线程直接获取锁，而不用考虑申请锁的顺序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;synchronized-是公平的还是不公平的&#34;&gt;&#xA;  synchronized 是公平的还是不公平的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized-%e6%98%af%e5%85%ac%e5%b9%b3%e7%9a%84%e8%bf%98%e6%98%af%e4%b8%8d%e5%85%ac%e5%b9%b3%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不公平的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;reentrantlock-公平性&#34;&gt;&#xA;  ReentrantLock 公平性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reentrantlock-%e5%85%ac%e5%b9%b3%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以在构造可重入锁时指定是公平锁还是非公平锁&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AQS AbstractQueuedSynchronizer的队列机制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FairSync 维护一个 FIFO 的队列&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;cas&#34;&gt;&#xA;  CAS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是cas&#34;&gt;&#xA;  什么是CAS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afcas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个原子性的硬件指令 compare and swap 比较并交换。多线程的场景下，只有一个线程能比较成功并交换值，其他线程比较失败不执行交换&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;aqs&#34;&gt;&#xA;  AQS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aqs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是aqs&#34;&gt;&#xA;  什么是AQS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afaqs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 用于构造锁和同步器类的基础类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aqs的核心概念是什么&#34;&gt;&#xA;  AQS的核心概念是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aqs%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步状态&lt;/li&gt;&#xA;&lt;li&gt;等待队列&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aqs的模板方法有哪些&#34;&gt;&#xA;  AQS的模板方法有哪些？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aqs%e7%9a%84%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;tryAcquire&lt;/li&gt;&#xA;&lt;li&gt;tryRelease&lt;/li&gt;&#xA;&lt;li&gt;tryAcquireShared&lt;/li&gt;&#xA;&lt;li&gt;tryAcquireReleased&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;aba-问题&#34;&gt;&#xA;  ABA 问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aba-%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;aba问题产生的原因是什么&#34;&gt;&#xA;  ABA问题产生的原因是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aba%e9%97%ae%e9%a2%98%e4%ba%a7%e7%94%9f%e7%9a%84%e5%8e%9f%e5%9b%a0%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 CAS 实现无锁数据结构，因为CAS只关注数据是否一致，没有关注数据是否更改过&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;如何解决aba问题&#34;&gt;&#xA;  如何解决ABA问题？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3aba%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用版本号, 比如使用原子变量类&lt;code&gt;AtomicStampedReference&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;jdk提供的原子变量类会存在aba问题吗&#34;&gt;&#xA;  JDK提供的原子变量类会存在ABA问题吗？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdk%e6%8f%90%e4%be%9b%e7%9a%84%e5%8e%9f%e5%ad%90%e5%8f%98%e9%87%8f%e7%b1%bb%e4%bc%9a%e5%ad%98%e5%9c%a8aba%e9%97%ae%e9%a2%98%e5%90%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>jvm</title>
      <link>/zh/post/computer-science/java/jvm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/java/jvm/</guid>
      <description>&lt;h1 id=&#34;jvm&#34;&gt;&#xA;  jvm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;jmm&#34;&gt;&#xA;  JMM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jmm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;java的jvm内存模型-java-memory-model&#34;&gt;&#xA;  Java的JVM内存模型 Java Memory Model&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e7%9a%84jvm%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b-java-memory-model&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主内存 Main Memory&lt;/li&gt;&#xA;&lt;li&gt;工作内存 Working Memory&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;jmm-的核心问题&#34;&gt;&#xA;  JMM 的核心问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jmm-%e7%9a%84%e6%a0%b8%e5%bf%83%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可见性&lt;/li&gt;&#xA;&lt;li&gt;原子性&lt;/li&gt;&#xA;&lt;li&gt;有序性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;内存机制&#34;&gt;&#xA;  内存机制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;jvm的内存机制是怎样的&#34;&gt;&#xA;  &lt;code&gt;JVM&lt;/code&gt;的内存机制是怎样的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm%e7%9a%84%e5%86%85%e5%ad%98%e6%9c%ba%e5%88%b6%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;jvm 的内存区域&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序计数器 Program Counter&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录当前线程的指令地址，用于记录线程恢复运行状态后执行指令的地址&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;虚拟机栈 Java Virtual Machine Stack&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于记录方法调用链&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;本地方法栈 Native Method Stack&#xA;&lt;ul&gt;&#xA;&lt;li&gt;类似于Java虚拟机栈，用于记录本地方法的调用链&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;堆 Heap&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于保存实例化的对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;方法区 Method Area&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录加载到内存中的类相关的信息&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;直接内存 Direct Memory&#xA;&lt;ul&gt;&#xA;&lt;li&gt;非阻塞式的IO操作的内存分配&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;垃圾回收机制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标记-清除算法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标记存活对象，清除未标记对象，但会产生内存碎片&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;标记-复制算法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将存活对象复制到另一个内存区域，适用于新生代，效率高但内存利用率低&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;标记-整理算法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标记存活对象后，将对象向一端移动，整理内存空间，适用于老年代&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;分代收集算法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据对象生命周期将堆分为新生代和老年代，分别采用不同的回收算法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;jvm的内存模型中哪些是线程私有的&#34;&gt;&#xA;  JVM的内存模型中哪些是线程私有的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm%e7%9a%84%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e4%b8%ad%e5%93%aa%e4%ba%9b%e6%98%af%e7%ba%bf%e7%a8%8b%e7%a7%81%e6%9c%89%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序计数器 Program Counter&lt;/li&gt;&#xA;&lt;li&gt;Java 虚拟机栈 Java Virtual Stack&lt;/li&gt;&#xA;&lt;li&gt;本地方法栈 Native Method Stack&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;垃圾回收&#34;&gt;&#xA;  垃圾回收&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;垃圾回收算法有哪些&#34;&gt;&#xA;  垃圾回收算法有哪些&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e7%ae%97%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标记-清除算法&lt;/li&gt;&#xA;&lt;li&gt;标记-复制算法&lt;/li&gt;&#xA;&lt;li&gt;标记-整理算法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote class=&#34;book-hint info&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;Reference&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mybatis</title>
      <link>/zh/post/computer-science/java/mybatis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/java/mybatis/</guid>
      <description>&lt;h2 id=&#34;mybatis是怎么进行事务管理的-2025-02-08&#34;&gt;&#xA;  mybatis是怎么进行事务管理的 2025-02-08&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mybatis%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9b%e8%a1%8c%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86%e7%9a%84-2025-02-08&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;MyBatis 通过集成外部事务管理器（如 Spring 或 Java EE 容器）或使用内置的 JDBC 事务管理机制来管理事务。以下是 MyBatis 事务管理的主要方式：&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-使用-jdbc-事务管理&#34;&gt;&#xA;  1. 使用 JDBC 事务管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e4%bd%bf%e7%94%a8-jdbc-%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;MyBatis 默认使用 JDBC 的事务管理，通过 &lt;code&gt;java.sql.Connection&lt;/code&gt; 实现。具体步骤如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;开启事务&lt;/strong&gt;：调用 &lt;code&gt;Connection.setAutoCommit(false)&lt;/code&gt; 关闭自动提交。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;提交事务&lt;/strong&gt;：调用 &lt;code&gt;Connection.commit()&lt;/code&gt; 提交事务。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;回滚事务&lt;/strong&gt;：调用 &lt;code&gt;Connection.rollback()&lt;/code&gt; 回滚事务。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;示例代码：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SqlSession sqlSession &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sqlSessionFactory.&lt;span style=&#34;color:#a6e22e&#34;&gt;openSession&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 执行数据库操作&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;insert&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;insertUser&amp;#34;&lt;/span&gt;,user);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;updateUser&amp;#34;&lt;/span&gt;,user);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 提交事务&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;commit&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Exception e){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 回滚事务&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;rollback&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 关闭 SqlSession&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-集成-spring-事务管理&#34;&gt;&#xA;  2. 集成 Spring 事务管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%e9%9b%86%e6%88%90-spring-%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;MyBatis 通常与 Spring 集成，利用 Spring 的事务管理功能。Spring 提供了声明式和编程式事务管理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>spring</title>
      <link>/zh/post/computer-science/java/spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/java/spring/</guid>
      <description>&lt;h1 id=&#34;spring&#34;&gt;&#xA;  Spring&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是spring&#34;&gt;&#xA;  什么是Spring&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afspring&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring是一个java开发框架&lt;/li&gt;&#xA;&lt;li&gt;它的核心特性是&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;控制反转&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;依赖注入&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;面向切面编程&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;声明式事务管理&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;模块化设计&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;spring-mvc&#34;&gt;&#xA;  Spring MVC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;spring-mvc-流程&#34;&gt;&#xA;  Spring MVC 流程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc-%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;流程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户发送请求&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 调用 &lt;code&gt;HandlerMapping&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 调用 &lt;code&gt;HandlerAdapter&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Controller 处理请求&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 调用 &lt;code&gt;ViewResolver&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;视图渲染 ModelAndView -&amp;gt; ViewResolver -&amp;gt; View&lt;/li&gt;&#xA;&lt;li&gt;返回响应&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;核心组件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;：前端控制器，负责请求的分发和协调&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HandlerMapping&lt;/strong&gt;：根据请求 URL 查找对应的 Handler&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HandlerAdapter&lt;/strong&gt;：适配并执行 Handler&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Controller&lt;/strong&gt;：处理具体的业务逻辑&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ViewResolver&lt;/strong&gt;：解析视图名称，生成具体的 View 对象&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;：负责视图的渲染&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;bean&#34;&gt;&#xA;  Bean&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;bean的生命周期&#34;&gt;&#xA;  Bean的生命周期&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bean的实例化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过反射调用 Bean 的构造函数，创建Bean的实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;填充属性（依赖注入）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring根据配置文件或注解，将依赖的Bean注入到当前Bean中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;调用Aware接口&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果Bean实现了Spring的&lt;code&gt;Aware&lt;/code&gt;接口，Spring会调用对应的回调方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;BeanPostProcessor&lt;/code&gt; 的前置处理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring调用所有&lt;code&gt;BeanPostProcessor&lt;/code&gt;的&lt;code&gt;postProcessBeforeInitialization()&lt;/code&gt;方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;执行初始化方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring会调用Bean的初始化方法。&lt;/li&gt;&#xA;&lt;li&gt;@PostConstruct&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;BeanPostProcessor的后置处理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring调用所有&lt;code&gt;BeanPostProcessor&lt;/code&gt;的&lt;code&gt;postProcessAfterInitialization()&lt;/code&gt;方法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Bean初始化完成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bean已经完全初始化，可以被其他Bean使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Bean的使用&lt;/li&gt;&#xA;&lt;li&gt;Bean的销毁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;bean的作用域&#34;&gt;&#xA;  Bean的作用域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Singleton（单例）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;默认作用域，单例模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Prototype（原型）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每次请求创建新实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Request（请求）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个 HTTP 请求创建一个实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Session（会话）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个 HTTP Session 创建一个实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Application（应用）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;整个 ServletContext 生命周期内有效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;WebSocket&#xA;&lt;ul&gt;&#xA;&lt;li&gt;WebSocket 会话生命周期内有效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;spring-循环依赖如何解决&#34;&gt;&#xA;  spring 循环依赖如何解决？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;三级缓存&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;singletonObjects&lt;/code&gt;：一级缓存，存储经历了完整生命周期的Bean对象&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;earlySingletonObjects&lt;/code&gt;：二级缓存，存储提前暴露出来的Bean对象，其生命周期未结束，属性未完全填充&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;singletonFactories&lt;/code&gt;：三级缓存，存储生成Bean的工厂&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;ioc&#34;&gt;&#xA;  IOC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ioc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是ioc&#34;&gt;&#xA;  什么是IOC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afioc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IOC是控制反转的意思，在一个程序中对象的创建与管理由一个容器负责，对象之间的引用通过注入(属性填充)的方式从容器中获取，降低了代码之间的耦合度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;ioc-的核心概念是什么&#34;&gt;&#xA;  IOC 的核心概念是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ioc-%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;依赖注入&lt;/li&gt;&#xA;&lt;li&gt;控制反转&lt;/li&gt;&#xA;&lt;li&gt;IOC容器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;举一个-spring-的容器&#34;&gt;&#xA;  举一个 Spring 的容器？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%be%e4%b8%80%e4%b8%aa-spring-%e7%9a%84%e5%ae%b9%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;WebApplicationContext&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;ioc-的优势是什么&#34;&gt;&#xA;  IOC 的优势是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ioc-%e7%9a%84%e4%bc%98%e5%8a%bf%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;降低耦合度&lt;/li&gt;&#xA;&lt;li&gt;提高可测试性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;注入模拟对象进行测试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;增强可扩展性&lt;/li&gt;&#xA;&lt;li&gt;优化资源管理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;容器管理对象的创建和销毁，避免资源浪费&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;aop&#34;&gt;&#xA;  AOP&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是aop&#34;&gt;&#xA;  什么是AOP？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afaop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AOP 是一种&lt;strong&gt;编程范式&lt;/strong&gt;, 通过将横切关注点与业务代码分离，提高代码的可维护性与可重用性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aop的核心概念是什么&#34;&gt;&#xA;  AOP的核心概念是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;切面 &lt;strong&gt;Aspect&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;连接点 &lt;strong&gt;Join Point&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序执行过程中可以插入切面的点（方法的调用或异常的处理）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通知 &lt;strong&gt;Advice&lt;/strong&gt; 切面在连接点执行的操作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;@Before&lt;/li&gt;&#xA;&lt;li&gt;@After&lt;/li&gt;&#xA;&lt;li&gt;@Around&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;切入点 &lt;strong&gt;Pointcut&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义在哪些连接点上应用通知，通常通过表达式来匹配&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;织入 &lt;strong&gt;Weaving&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将切面应用到目标对象并创建代理对象的过程，可以在编译期、类加载期或运行期进行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aop的应用场景&#34;&gt;&#xA;  AOP的应用场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;日志记录&lt;/li&gt;&#xA;&lt;li&gt;事务管理&lt;/li&gt;&#xA;&lt;li&gt;权限控制&lt;/li&gt;&#xA;&lt;li&gt;性能监控&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录方法执行时间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aop的实现方式&#34;&gt;&#xA;  AOP的实现方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JDK动态代理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现了接口的类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CGLIB代理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;未实现接口的类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;事务&#34;&gt;&#xA;  事务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;transaction的底层原理是什么&#34;&gt;&#xA;  @Transaction的底层原理是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#transaction%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;spring的事务管理机制，结合AOP和动态代理技术实现事务的控制和管理&lt;/li&gt;&#xA;&lt;li&gt;事务管理核心组件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事务管理器&lt;/li&gt;&#xA;&lt;li&gt;事务拦截器&lt;/li&gt;&#xA;&lt;li&gt;事务属性源&lt;/li&gt;&#xA;&lt;li&gt;事务代理对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;实现流程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代理对象的创建&lt;/li&gt;&#xA;&lt;li&gt;事务拦截器的应用 TransactionInterceptor&lt;/li&gt;&#xA;&lt;li&gt;事务的开启与提交&lt;/li&gt;&#xA;&lt;li&gt;事务的传播行为&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;transactional-事务传播机制&#34;&gt;&#xA;  @Transactional 事务传播机制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#transactional-%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当一个事务方法调用另一个事务方法时，事务应该如何传递或处理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;REQUIRED&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果当前存在事务，则加入该事务；如果不存在事务，则创建一个新事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SUPPORTS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果当前存在事务，则加入该事务；如果不存在事务，则以非事务方式执行&lt;/li&gt;&#xA;&lt;li&gt;场景：适用于查询操作，是否在事务中执行均可&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;MANDATORY&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果当前存在事务，则加入该事务；如果不存在事务，则抛出异常&lt;/li&gt;&#xA;&lt;li&gt;场景：强制要求调用方必须在事务中调用该方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;REQUIRES_NEW&lt;/li&gt;&#xA;&lt;li&gt;NOT_SUPPORTED&lt;/li&gt;&#xA;&lt;li&gt;NEVER&lt;/li&gt;&#xA;&lt;li&gt;NESTED&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>spring boot</title>
      <link>/zh/post/computer-science/java/springboot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/java/springboot/</guid>
      <description>&lt;h1 id=&#34;spring-boot&#34;&gt;&#xA;  spring boot&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-boot&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;spring-boot-monitor&#34;&gt;&#xA;  Spring-boot-monitor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-boot-monitor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单机监控SpringBoot应用指标&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.pomit.cn/SpringBootMonitor/#/&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
