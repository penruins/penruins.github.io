<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Penruins</title>
    <link>/zh/post/computer-science/java/</link>
    <description>Recent content on Penruins</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="/zh/post/computer-science/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>java</title>
      <link>/zh/post/computer-science/java/java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/java/java/</guid>
      <description>&lt;h1 id=&#34;java&#34;&gt;&#xA;  java&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;响应式编程和虚拟线程都能提高程序的并发量它们的差异是什么&#34;&gt;&#xA;  响应式编程和虚拟线程都能提高程序的并发量，它们的差异是什么&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%92%8c%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e9%83%bd%e8%83%bd%e6%8f%90%e9%ab%98%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%b9%b6%e5%8f%91%e9%87%8f%e5%ae%83%e4%bb%ac%e7%9a%84%e5%b7%ae%e5%bc%82%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;响应式编程和虚拟线程虽然都能提高程序的并发量，但它们的实现方式、适用场景以及开发体验存在显著差异。以下是两者的主要区别：&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;1-实现原理&#34;&gt;&#xA;  1. &lt;strong&gt;实现原理&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;响应式编程&lt;/strong&gt;：&lt;br&gt;&#xA;响应式编程基于异步数据流和事件驱动模型，使用发布/订阅模式（如 &lt;code&gt;Flux&lt;/code&gt; 和 &lt;code&gt;Mono&lt;/code&gt;）来处理异步任务。它通过非阻塞 I/O 和回调机制，确保线程在等待 I/O 操作时不会阻塞，而是继续处理其他任务。响应式编程的核心是“&lt;strong&gt;非阻塞&lt;/strong&gt;”和“&lt;strong&gt;事件驱动&lt;/strong&gt;”&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;2&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;虚拟线程&lt;/strong&gt;：&lt;br&gt;&#xA;虚拟线程是 JVM 管理的轻量级线程，底层仍然依赖于操作系统的平台线程（内核线程），但虚拟线程的创建和切换开销远低于传统线程。当虚拟线程遇到阻塞操作时，JVM 会将其挂起并切换到其他虚拟线程，从而避免线程资源的浪费&lt;a href=&#34;@ref&#34;&gt;3&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;7&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-编程模型&#34;&gt;&#xA;  2. &lt;strong&gt;编程模型&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;响应式编程&lt;/strong&gt;：&lt;br&gt;&#xA;响应式编程采用声明式编程范式，代码通常由一系列操作符（如 &lt;code&gt;map&lt;/code&gt;、&lt;code&gt;flatMap&lt;/code&gt;）组成，形成数据流的转换管道。这种模型需要开发者熟悉函数式编程和响应式 API，代码可读性较差，调试难度较高&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;4&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;虚拟线程&lt;/strong&gt;：&lt;br&gt;&#xA;虚拟线程保留了传统的阻塞式编程模型，开发者可以像使用平台线程一样编写代码，无需改变编程习惯。虚拟线程的引入使得高并发编程更加简单和直观&lt;a href=&#34;@ref&#34;&gt;3&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;7&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;3-适用场景&#34;&gt;&#xA;  3. &lt;strong&gt;适用场景&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;响应式编程&lt;/strong&gt;：&lt;br&gt;&#xA;适用于 I/O 密集型任务，如网络请求、数据库操作等。它通过非阻塞 I/O 和事件驱动机制，最大化线程的利用率。但在 CPU 密集型任务中，响应式编程的性能提升有限，甚至可能适得其反&lt;a href=&#34;@ref&#34;&gt;2&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;4&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;虚拟线程&lt;/strong&gt;：&lt;br&gt;&#xA;同样适用于 I/O 密集型任务，能够显著提高并发性能。虚拟线程的优势在于其轻量化和低开销，适合处理大量并发请求。但对于 CPU 密集型任务，虚拟线程的性能提升有限，因为虚拟线程的调度仍然依赖于平台线程&lt;a href=&#34;@ref&#34;&gt;3&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;7&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;4-开发体验&#34;&gt;&#xA;  4. &lt;strong&gt;开发体验&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-%e5%bc%80%e5%8f%91%e4%bd%93%e9%aa%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;响应式编程&lt;/strong&gt;：&lt;br&gt;&#xA;响应式编程的代码通常难以理解和调试，尤其是回调嵌套和复杂的操作符链。开发者需要具备函数式编程和响应式编程的知识，学习成本较高。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;虚拟线程&lt;/strong&gt;：&lt;br&gt;&#xA;虚拟线程的使用与传统的线程编程类似，开发者无需学习新的编程范式，代码更直观且易于维护。虚拟线程的引入降低了高并发编程的门槛。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;5-性能优化&#34;&gt;&#xA;  5. &lt;strong&gt;性能优化&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#5-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;响应式编程&lt;/strong&gt;：&lt;br&gt;&#xA;通过减少线程阻塞和上下文切换，响应式编程能够提高 CPU 和内存的利用率。但它依赖于开发者正确使用非阻塞 API 和操作符。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;虚拟线程&lt;/strong&gt;：&lt;br&gt;&#xA;虚拟线程通过轻量化的线程管理和高效的调度机制，减少了线程创建和上下文切换的开销。虚拟线程的性能优化由 JVM 自动完成，开发者无需额外干预。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;总结&#34;&gt;&#xA;  总结&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%bb%e7%bb%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;响应式编程&lt;/strong&gt;和&lt;strong&gt;虚拟线程&lt;/strong&gt;的目标都是提高程序的并发性能，但它们的实现方式和适用场景不同。&lt;/li&gt;&#xA;&lt;li&gt;响应式编程适合需要高度优化的 I/O 密集型任务，但代码复杂且学习成本高。&lt;/li&gt;&#xA;&lt;li&gt;虚拟线程提供了一种更简单、直观的方式来实现高并发，特别适合需要快速开发和维护的场景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果需要更深入的技术细节，可以参考相关文档或实践案例。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mybatis</title>
      <link>/zh/post/computer-science/java/mybatis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/java/mybatis/</guid>
      <description>&lt;h2 id=&#34;mybatis是怎么进行事务管理的-2025-02-08&#34;&gt;&#xA;  mybatis是怎么进行事务管理的 2025-02-08&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mybatis%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9b%e8%a1%8c%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86%e7%9a%84-2025-02-08&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;MyBatis 通过集成外部事务管理器（如 Spring 或 Java EE 容器）或使用内置的 JDBC 事务管理机制来管理事务。以下是 MyBatis 事务管理的主要方式：&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-使用-jdbc-事务管理&#34;&gt;&#xA;  1. 使用 JDBC 事务管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e4%bd%bf%e7%94%a8-jdbc-%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;MyBatis 默认使用 JDBC 的事务管理，通过 &lt;code&gt;java.sql.Connection&lt;/code&gt; 实现。具体步骤如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;开启事务&lt;/strong&gt;：调用 &lt;code&gt;Connection.setAutoCommit(false)&lt;/code&gt; 关闭自动提交。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;提交事务&lt;/strong&gt;：调用 &lt;code&gt;Connection.commit()&lt;/code&gt; 提交事务。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;回滚事务&lt;/strong&gt;：调用 &lt;code&gt;Connection.rollback()&lt;/code&gt; 回滚事务。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;示例代码：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SqlSession sqlSession &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sqlSessionFactory.&lt;span style=&#34;color:#a6e22e&#34;&gt;openSession&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 执行数据库操作&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;insert&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;insertUser&amp;#34;&lt;/span&gt;,user);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;updateUser&amp;#34;&lt;/span&gt;,user);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 提交事务&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;commit&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Exception e){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 回滚事务&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;rollback&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 关闭 SqlSession&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-集成-spring-事务管理&#34;&gt;&#xA;  2. 集成 Spring 事务管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%e9%9b%86%e6%88%90-spring-%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;MyBatis 通常与 Spring 集成，利用 Spring 的事务管理功能。Spring 提供了声明式和编程式事务管理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>jvm</title>
      <link>/zh/post/computer-science/java/jvm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/computer-science/java/jvm/</guid>
      <description>&lt;h1 id=&#34;jvm&#34;&gt;&#xA;  jvm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
  </channel>
</rss>
