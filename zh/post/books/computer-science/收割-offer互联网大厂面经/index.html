<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  第1章 八股文
  #


  1.1 综合知识
  #


  1.1.1 单元化高可用架构演进历程
  #


单体应用→单数据库→单机房→单地部署
微服务→分库分表→同城多机房→单元化
1 单体应用与单机房微服务

单体应用把所有的功能模块耦合在一起，它存在的问题是领域边界模糊，无法根据业务模块的需要进行伸缩扩容。除此之外，还存在需求开发分支冲突、线上问题定位困难、整体打包编译费时等问题，不适用于大型复杂项目。
由于系统内部处理耗时很小，并且后端服务与数据库部署在同一机房，因此该架构下整个请求链路上的耗时主要发生在用户到机房的物理距离上。
微服务化时代，巨大的单体应用被拆分为模块化的服务，每个服务都围绕特定的业务领域构建，微服务之间通过远程过程调用(Remote Procedure Call，RPC)实现通信，这就是单机房微服务。尽管服务拆分使得原本进程内部的调用变成了网络调用，但是应用都部署在同一个机房，因此RPC网络开销可以忽略。微服务解决了应用层的瓶颈，但随着业务的发展，数据库又成为制约系统扩容的瓶颈。


2 单数据库与分库分表

随着业务的发展数据量不断增多，出现了数据存储、读取方面的问题：一方面单机物理服务器的资源（如CPU、磁盘、内存、IO等）有限，磁盘读取和网络IO出现瓶颈；另一方面单表的数据量太大，查询时扫描的数据很多，造成SQL执行效率低下。为了解决上述问题，引入数据库中间件—实现对上层业务透明的分库分表。
分布式数据库的数据分区一般采用Hash函数&#43;Map映射的方式来实现：首先根据数据的分表字段（一般为userid）计算出该数据的Hash桶位置，然后使用事先定义好的映射表将这个Hash桶中的数据映射到数据库物理节点。


3 单机房演进为同城多机房

为了解决单机房的容量限制，可在同城新建多个机房，机房之间通过专线连接，将应用服务部署在多个机房，数据库主库和备库部署到不同的机房，依靠不同的服务注册中心将应用层逻辑隔离，实现应用层请求不跨机房处理
数据库主库只在其中一个机房内，数据写入时只写主库，主备数据同步，异地机房备库可提供读服务。该方案存在的缺点是访问数据库存在跨机房调用、主备数据同步延迟的问题，但该方案的优点也很多

容量不受单机房限制，数据层与应用层均可自由扩容。
避免不可测因素导致单机房故障，使得全域产品服务不可用，比如地震、火灾、洪水等灾害使得机房断电或者网线被施工方意外挖断等。
用户请求就近接入，优先被物理距离较近的机房处理，减少网络耗时，保障用户体验。




4 同城多机房演进为单元化部署

因为应用层流量是随机的，任何一个应用节点都可能访问任意一个数据库节点，所以应用层每增加一台服务器实例都需要与数据库建立连接，数据库连接数量存在上限，这又制约了系统的水平扩容
提出了单元化的架构，该种架构的应用层也像数据层一样分片，但从应用层到数据层组成一个封闭的单元，一次请求处理收敛在一个单元内部，数据库只负责本单元的应用请求，从而大大节省了连接数；而每个单元可以作为一个独立整体进行部署或挪动，甚至还可以将单元部署到异地来实现容灾。
单元化设计的原则如下：

业务是可分片的，常以用户id或者地区作为分片维度
整个系统要面向逻辑分区进行设计，方便单元挪动
理想状态下单元内部是自封闭的，单元内可以完成业务的所有处理。


缺点是，有时跨单元调用是无法避免的，比如转账场景，用户A和B分别属于单元1和单元2，数据也存储在不同单元，扣减用户A的账户余额需要在单元1执行，增加用户B的账户余额需要在单元2执行，因此跨单元调用增加网络耗时这一问题无法避免。




  1.1.2 Java中5种重要的队列
  #


1 ArrayBlockingQueue队列
2 LinkedBlockingQueue队列
3 SynchronousQueue队
4 无锁队列
5 PriorityBlockingQueue队列


  1.1.3 IO多路复用
  #


IO多路复用就是通过一种机制来监听多个文件描述符，某个文件描述符一旦就绪，它就能通知应用程序进行相应的处理。多路复用的3种实现方式有select、poll和epoll
1 阻塞IO
2 引入线程池
3 IO多路复用3种实现方式


  1.1.4 ReentrantLock锁与Syschronized锁
  #


1 公平锁与非公平锁

公平锁是指多个线程竞争锁时直接进入队列排队，根据申请锁的顺序获得锁，先到先得。而非公平锁则是多个线程竞争锁时，首先尝试直接抢锁，失败后再进入等待队列。
使用公平锁，先到先得，线程获取锁时不会出现饥饿现象。使用非公平锁，整体的吞吐效率比较高。
ReentrantLock默认是非公平锁，在构造方法中传入参数true则为公平锁；Synchronized是非公平锁。


2 可重入锁

可重入锁是指一个线程可以多次获取同一把锁，其实现原理是，为每个锁关联一个计数器，线程首次获取锁时，计数器置为1，再次获取该锁时，计数器加1；线程每退出同步块一次，计数器就减1。计数器为0则代表锁被当前线程释放。
Synchronized和ReentrantLock都是可重入锁。


3 ReentrantLock锁
4 Syschronized锁


  1.1.5 Java SPI机制
  #


  1.1.6 限流算法
  #



1 计数器">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="/zh/post/books/computer-science/%E6%94%B6%E5%89%B2-offer%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F/">
  <meta property="og:site_name" content="Penruins">
  <meta property="og:title" content="收割Offer：互联网大厂面经">
  <meta property="og:description" content="第1章 八股文 # 1.1 综合知识 # 1.1.1 单元化高可用架构演进历程 # 单体应用→单数据库→单机房→单地部署 微服务→分库分表→同城多机房→单元化 1 单体应用与单机房微服务 单体应用把所有的功能模块耦合在一起，它存在的问题是领域边界模糊，无法根据业务模块的需要进行伸缩扩容。除此之外，还存在需求开发分支冲突、线上问题定位困难、整体打包编译费时等问题，不适用于大型复杂项目。 由于系统内部处理耗时很小，并且后端服务与数据库部署在同一机房，因此该架构下整个请求链路上的耗时主要发生在用户到机房的物理距离上。 微服务化时代，巨大的单体应用被拆分为模块化的服务，每个服务都围绕特定的业务领域构建，微服务之间通过远程过程调用(Remote Procedure Call，RPC)实现通信，这就是单机房微服务。尽管服务拆分使得原本进程内部的调用变成了网络调用，但是应用都部署在同一个机房，因此RPC网络开销可以忽略。微服务解决了应用层的瓶颈，但随着业务的发展，数据库又成为制约系统扩容的瓶颈。 2 单数据库与分库分表 随着业务的发展数据量不断增多，出现了数据存储、读取方面的问题：一方面单机物理服务器的资源（如CPU、磁盘、内存、IO等）有限，磁盘读取和网络IO出现瓶颈；另一方面单表的数据量太大，查询时扫描的数据很多，造成SQL执行效率低下。为了解决上述问题，引入数据库中间件—实现对上层业务透明的分库分表。 分布式数据库的数据分区一般采用Hash函数&#43;Map映射的方式来实现：首先根据数据的分表字段（一般为userid）计算出该数据的Hash桶位置，然后使用事先定义好的映射表将这个Hash桶中的数据映射到数据库物理节点。 3 单机房演进为同城多机房 为了解决单机房的容量限制，可在同城新建多个机房，机房之间通过专线连接，将应用服务部署在多个机房，数据库主库和备库部署到不同的机房，依靠不同的服务注册中心将应用层逻辑隔离，实现应用层请求不跨机房处理 数据库主库只在其中一个机房内，数据写入时只写主库，主备数据同步，异地机房备库可提供读服务。该方案存在的缺点是访问数据库存在跨机房调用、主备数据同步延迟的问题，但该方案的优点也很多 容量不受单机房限制，数据层与应用层均可自由扩容。 避免不可测因素导致单机房故障，使得全域产品服务不可用，比如地震、火灾、洪水等灾害使得机房断电或者网线被施工方意外挖断等。 用户请求就近接入，优先被物理距离较近的机房处理，减少网络耗时，保障用户体验。 4 同城多机房演进为单元化部署 因为应用层流量是随机的，任何一个应用节点都可能访问任意一个数据库节点，所以应用层每增加一台服务器实例都需要与数据库建立连接，数据库连接数量存在上限，这又制约了系统的水平扩容 提出了单元化的架构，该种架构的应用层也像数据层一样分片，但从应用层到数据层组成一个封闭的单元，一次请求处理收敛在一个单元内部，数据库只负责本单元的应用请求，从而大大节省了连接数；而每个单元可以作为一个独立整体进行部署或挪动，甚至还可以将单元部署到异地来实现容灾。 单元化设计的原则如下： 业务是可分片的，常以用户id或者地区作为分片维度 整个系统要面向逻辑分区进行设计，方便单元挪动 理想状态下单元内部是自封闭的，单元内可以完成业务的所有处理。 缺点是，有时跨单元调用是无法避免的，比如转账场景，用户A和B分别属于单元1和单元2，数据也存储在不同单元，扣减用户A的账户余额需要在单元1执行，增加用户B的账户余额需要在单元2执行，因此跨单元调用增加网络耗时这一问题无法避免。 1.1.2 Java中5种重要的队列 # 1 ArrayBlockingQueue队列 2 LinkedBlockingQueue队列 3 SynchronousQueue队 4 无锁队列 5 PriorityBlockingQueue队列 1.1.3 IO多路复用 # IO多路复用就是通过一种机制来监听多个文件描述符，某个文件描述符一旦就绪，它就能通知应用程序进行相应的处理。多路复用的3种实现方式有select、poll和epoll 1 阻塞IO 2 引入线程池 3 IO多路复用3种实现方式 1.1.4 ReentrantLock锁与Syschronized锁 # 1 公平锁与非公平锁 公平锁是指多个线程竞争锁时直接进入队列排队，根据申请锁的顺序获得锁，先到先得。而非公平锁则是多个线程竞争锁时，首先尝试直接抢锁，失败后再进入等待队列。 使用公平锁，先到先得，线程获取锁时不会出现饥饿现象。使用非公平锁，整体的吞吐效率比较高。 ReentrantLock默认是非公平锁，在构造方法中传入参数true则为公平锁；Synchronized是非公平锁。 2 可重入锁 可重入锁是指一个线程可以多次获取同一把锁，其实现原理是，为每个锁关联一个计数器，线程首次获取锁时，计数器置为1，再次获取该锁时，计数器加1；线程每退出同步块一次，计数器就减1。计数器为0则代表锁被当前线程释放。 Synchronized和ReentrantLock都是可重入锁。 3 ReentrantLock锁 4 Syschronized锁 1.1.5 Java SPI机制 # 1.1.6 限流算法 # 1 计数器">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
<title>收割Offer：互联网大厂面经 | Penruins</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="/zh/post/books/computer-science/%E6%94%B6%E5%89%B2-offer%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F/">
<link rel="stylesheet" href="/book.min.26e661cf8028ea69ebe162050990c3a07de74e5bfe9389e880f2d6a7e5fa587c.css" >
  <script defer src="/fuse.min.js"></script>
  <script defer src="/zh.search.min.0f2ae857a1e607257cfd2f7176904b9d487bacde24b623dddc58527190b675fc.js" ></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/zh/"><span>Penruins</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>



  



  
    
  
    
  



<ul class="book-languages">
  <li>
    <input type="checkbox" id="languages" class="toggle" />
    <label for="languages" class="flex justify-between">
      <a role="button" class="flex align-center">
        <img src="/svg/translate.svg" class="book-icon" alt="Languages" />
        中文
      </a>
    </label>

    <ul>
      
      <li>
        <a href="/cn/">
          
        </a>
      </li>
      
      <li>
        <a href="/en/">
          English
        </a>
      </li>
      
    </ul>
  </li>
</ul>














  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Life</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/movies-log/" class="">观影记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/bilibili/" class="">bilibili</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/books/" class="">books</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/cycling/" class="">cycling</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/hiking/" class="">hiking</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/life-recommend/" class="">life recommand</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/learning-others-log/" class="">other learning</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/podcast/" class="">podcast</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/politics/" class="">politics</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/goal/" class="">goal</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/accumulation/" class="">accumulation</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/coffee/" class="">coffee</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Computer Science</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-855531983528655844a29f37632e7e30" class="toggle"  />
    <label for="section-855531983528655844a29f37632e7e30" class="flex justify-between">
      <a role="button" class="">Java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/java/" class="">java</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/mybatis/" class="">Mybatis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/jvm/" class="">jvm</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-recommend/" class="">推荐</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-learning-log/" class="">学习记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/database/" class="">database</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/echarts/" class="">echarts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/github/" class="">github</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/ios/" class="">ios</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/job/" class="">job</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/mac/" class="">mac</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/raspberrypi/" class="">raspberry pi</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/security/" class="">security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/vue/" class="">vue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/algorithm/" class="">Algorithm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/linux/" class="">linux</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Others</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/about-me/" class="">about me</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/english-learning/" class="">English Learning</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Books</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-70696d57febbe00561bcceac2d174d7c" class="toggle" checked />
    <label for="section-70696d57febbe00561bcceac2d174d7c" class="flex justify-between">
      <a role="button" class="">Computer Science</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" class="">Java并发编程实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%AE%9E%E6%88%98/" class="">Java实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="">Python神经网络编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="">Redis设计与实现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/" class="">Spring Cloud微服务：入门、实战与进阶</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E5%89%91%E6%8C%87offer/" class="">剑指Offer</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/" class="">深入浅出HTTPS：从原理到实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E6%94%B6%E5%89%B2-offer%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F/" class="active">收割Offer：互联网大厂面经</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" class="">一本书讲透 ElasticSearch：原理、进阶与工程实践</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E7%AC%AC%E4%B8%89%E7%89%88/" class="">宏观经济学 第三版</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E7%BE%8E%E5%9B%BD%E5%9B%B0%E5%B1%80/" class="">美国困局</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E8%8B%B1%E4%BC%9F%E8%BE%BE-%E9%BB%84%E4%BB%81%E5%8B%8B%E4%B9%8B%E8%8A%AF/" class="">英伟达-黄仁勋之芯</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E7%94%A8%E5%9C%B0%E5%9B%BE%E7%9C%8B%E6%87%82%E4%B8%96%E7%95%8C%E6%A0%BC%E5%B1%80/" class="">用地图看懂世界格局</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>收割Offer：互联网大厂面经</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第1章-八股文">第1章 八股文</a>
      <ul>
        <li><a href="#11-综合知识">1.1 综合知识</a>
          <ul>
            <li><a href="#111-单元化高可用架构演进历程">1.1.1 单元化高可用架构演进历程</a></li>
            <li><a href="#112-java中5种重要的队列">1.1.2 Java中5种重要的队列</a></li>
            <li><a href="#113-io多路复用">1.1.3 IO多路复用</a></li>
            <li><a href="#114-reentrantlock锁与syschronized锁">1.1.4 ReentrantLock锁与Syschronized锁</a></li>
            <li><a href="#115-java-spi机制">1.1.5 Java SPI机制</a></li>
            <li><a href="#116-限流算法">1.1.6 限流算法</a></li>
            <li><a href="#117-领域驱动设计">1.1.7 领域驱动设计</a></li>
            <li><a href="#118-hashmap的底层原理">1.1.8 HashMap的底层原理</a></li>
            <li><a href="#119-jvm垃圾回收机制">1.1.9 JVM垃圾回收机制</a></li>
            <li><a href="#1110-零复制">1.1.10 零复制</a></li>
            <li><a href="#1111-tcc柔性事务">1.1.11 TCC柔性事务</a></li>
            <li><a href="#1112-cap与base">1.1.12 CAP与BASE</a></li>
            <li><a href="#1113-volatile关键字">1.1.13 Volatile关键字</a></li>
            <li><a href="#1114-双亲委派类加载器">1.1.14 双亲委派类加载器</a></li>
            <li><a href="#1115-从微服务到service-mesh">1.1.15 从微服务到Service Mesh</a></li>
            <li><a href="#1116-进程线程与协程">1.1.16 进程、线程与协程</a></li>
            <li><a href="#1117-强引用软引用弱引用虚引用">1.1.17 强引用、软引用、弱引用、虚引用</a></li>
            <li><a href="#1118-threadlocal">1.1.18 ThreadLocal</a></li>
            <li><a href="#1119-线程池">1.1.19 线程池</a></li>
            <li><a href="#1120-控制访问某个资源或方法的并发数">1.1.20 控制访问某个资源或方法的并发数</a></li>
            <li><a href="#1121-happens-before">1.1.21 Happens-Before</a></li>
            <li><a href="#1122-对java的理解">1.1.22 对Java的理解</a></li>
            <li><a href="#1123-缓存穿透雪崩击穿">1.1.23 缓存穿透、雪崩、击穿</a></li>
            <li><a href="#1124-虚拟机与容器对比">1.1.24 虚拟机与容器对比</a></li>
            <li><a href="#1125-保障系统高可用的一般方法">1.1.25 保障系统高可用的一般方法</a></li>
            <li><a href="#1126-伪共享">1.1.26 伪共享</a></li>
            <li><a href="#1127-caffeine缓存高性能分析">1.1.27 Caffeine缓存高性能分析</a></li>
            <li><a href="#1128-请自我介绍一下">1.1.28 请自我介绍一下</a></li>
          </ul>
        </li>
        <li><a href="#12-数据库">1.2 数据库</a>
          <ul>
            <li><a href="#121-一次sql查询的执行过程">1.2.1 一次SQL查询的执行过程</a></li>
            <li><a href="#122-binlog日志备份的3种模式">1.2.2 binlog日志备份的3种模式</a></li>
            <li><a href="#123-事务的两阶段提交">1.2.3 事务的两阶段提交</a></li>
            <li><a href="#124-二叉搜索树平衡树红黑树b树b树的区别">1.2.4 二叉搜索树、平衡树、红黑树、B树、B+树的区别</a></li>
            <li><a href="#125-mysql存储引擎innodb与myisam的区别">1.2.5 MySQL存储引擎InnoDB与MyISAM的区别</a></li>
            <li><a href="#126-聚集索引与非聚集索引的区别">1.2.6 聚集索引与非聚集索引的区别</a></li>
            <li><a href="#127-数据库事务的4大特性">1.2.7 数据库事务的4大特性</a></li>
            <li><a href="#128-事务隔离级别与脏读不可重复读幻读">1.2.8 事务隔离级别与脏读、不可重复读、幻读</a></li>
            <li><a href="#129-redoundobinlog数据库日志的作用">1.2.9 redo、undo、binlog数据库日志的作用</a></li>
            <li><a href="#1210-多版本并发控制">1.2.10 多版本并发控制</a></li>
            <li><a href="#1211-数据库行锁表锁乐观锁与悲观锁">1.2.11 数据库行锁、表锁、乐观锁与悲观锁</a></li>
            <li><a href="#1212-当前读与快照读">1.2.12 当前读与快照读</a></li>
            <li><a href="#1213-幻读是怎么解决的">1.2.13 幻读是怎么解决的</a></li>
            <li><a href="#1214-sql索引优化">1.2.14 SQL索引优化</a></li>
            <li><a href="#1215-dao层缓存先更新缓存还是先更新数据库">1.2.15 Dao层缓存先更新缓存还是先更新数据库</a></li>
            <li><a href="#1216-mysql高可用架构">1.2.16 MySQL高可用架构</a></li>
            <li><a href="#1217-为什么遇到范围查询会停止索引的最左匹配">1.2.17 为什么遇到范围查询会停止索引的最左匹配</a></li>
            <li><a href="#1218-索引下推">1.2.18 索引下推</a></li>
            <li><a href="#1219-索引覆盖">1.2.19 索引覆盖</a></li>
            <li><a href="#1220-经典sql语句考察group-byjoinhaving">1.2.20 经典SQL语句考察：group by、join、having</a></li>
            <li><a href="#1221-避免数据库热点更新">1.2.21 避免数据库热点更新</a></li>
            <li><a href="#1222-线上环境如何修改表结构">1.2.22 线上环境如何修改表结构</a></li>
          </ul>
        </li>
        <li><a href="#13-redis">1.3 Redis</a>
          <ul>
            <li><a href="#131-redis的5种基本数据类型及对应底层实现">1.3.1 Redis的5种基本数据类型及对应底层实现</a></li>
            <li><a href="#132-redis为什么这么快">1.3.2 Redis为什么这么快</a></li>
            <li><a href="#133-redis持久化之rdb与aof">1.3.3 Redis持久化之RDB与AOF</a></li>
            <li><a href="#134-redis实现分布式锁的关键点">1.3.4 Redis实现分布式锁的关键点</a></li>
            <li><a href="#135-redis与memcache的区别">1.3.5 Redis与Memcache的区别</a></li>
            <li><a href="#136-redis主从复制原理之sync与psync">1.3.6 Redis主从复制原理之SYNC与PSYNC</a></li>
            <li><a href="#137-过期删除策略">1.3.7 过期删除策略</a></li>
            <li><a href="#138-redis哈希槽-113">1.3.8 Redis哈希槽 113</a></li>
            <li><a href="#139-redis-gossip协议-114">1.3.9 Redis Gossip协议 114</a></li>
            <li><a href="#1310-重定向moved与ask-115">1.3.10 重定向moved与ask 115</a></li>
            <li><a href="#1311-pipeline有什么好处-116">1.3.11 Pipeline有什么好处 116</a></li>
          </ul>
        </li>
        <li><a href="#14-rocketmq">1.4 RocketMQ</a>
          <ul>
            <li><a href="#141-rocketmq的整体架构">1.4.1 RocketMQ的整体架构</a></li>
            <li><a href="#142-消息队列典型的适用场景">1.4.2 消息队列典型的适用场景</a></li>
            <li><a href="#143-消费者消费者组队列之间的关系">1.4.3 消费者、消费者组、队列之间的关系</a></li>
            <li><a href="#144-rocketmq消息发送与消费流程">1.4.4 RocketMQ消息发送与消费流程</a></li>
            <li><a href="#145-消息刷盘策略">1.4.5 消息刷盘策略</a></li>
            <li><a href="#146-底层文件存储设计">1.4.6 底层文件存储设计</a></li>
            <li><a href="#147-事务消息">1.4.7 事务消息</a></li>
            <li><a href="#148-延迟消息">1.4.8 延迟消息</a></li>
            <li><a href="#149-如何保证消息不丢失">1.4.9 如何保证消息不丢失</a></li>
            <li><a href="#1410-消息过滤-128">1.4.10 消息过滤 128</a></li>
            <li><a href="#1411-顺序消息-128">1.4.11 顺序消息 128</a></li>
            <li><a href="#1412-消费者offset管理">1.4.12 消费者offset管理</a></li>
            <li><a href="#1413-rebalance的危害">1.4.13 Rebalance的危害</a></li>
            <li><a href="#1414-rocketmq与kafka的对比">1.4.14 RocketMQ与Kafka的对比</a></li>
          </ul>
        </li>
        <li><a href="#15-操作系统">1.5 操作系统</a>
          <ul>
            <li><a href="#151-进程与线程的区别">1.5.1 进程与线程的区别</a></li>
            <li><a href="#152-为什么页内存大小是4kb">1.5.2 为什么页内存大小是4KB</a></li>
            <li><a href="#153-进程间的通信方式">1.5.3 进程间的通信方式</a></li>
            <li><a href="#154-页面置换算法">1.5.4 页面置换算法</a></li>
            <li><a href="#155-虚拟内存">1.5.5 虚拟内存</a></li>
            <li><a href="#156-为什么多级页表可以节省内存">1.5.6 为什么多级页表可以节省内存</a></li>
            <li><a href="#157-死锁及其产生的条件">1.5.7 死锁及其产生的条件</a></li>
            <li><a href="#158-线程状态转换">1.5.8 线程状态转换</a></li>
            <li><a href="#159-进程调度策略">1.5.9 进程调度策略</a></li>
            <li><a href="#1510-线程同步有哪几种方式">1.5.10 线程同步有哪几种方式</a></li>
            <li><a href="#1511-内存颠簸">1.5.11 内存颠簸</a></li>
            <li><a href="#1512-局部性原理">1.5.12 局部性原理</a></li>
          </ul>
        </li>
        <li><a href="#16-计算机网络">1.6 计算机网络</a>
          <ul>
            <li><a href="#161-tcp与udp的区别">1.6.1 TCP与UDP的区别</a></li>
            <li><a href="#162-滑动窗口">1.6.2 滑动窗口</a></li>
            <li><a href="#163-拥塞控制">1.6.3 拥塞控制</a></li>
            <li><a href="#164-重传机制">1.6.4 重传机制</a></li>
            <li><a href="#165-流量控制">1.6.5 流量控制</a></li>
            <li><a href="#166-三次握手与四次挥手">1.6.6 三次握手与四次挥手</a></li>
            <li><a href="#167-tcp四次挥手为什么要等待2msl">1.6.7 TCP四次挥手为什么要等待2MSL</a></li>
            <li><a href="#168-一次完整的http请求">1.6.8 一次完整的HTTP请求</a></li>
            <li><a href="#169-https加密过程">1.6.9 HTTPS加密过程</a></li>
            <li><a href="#1610-tcp粘包与拆包">1.6.10 TCP粘包与拆包</a></li>
            <li><a href="#1611-nagle算法">1.6.11 Nagle算法</a></li>
          </ul>
        </li>
        <li><a href="#17-spring">1.7 Spring</a>
          <ul>
            <li><a href="#171-spring-bean的作用域">1.7.1 Spring Bean的作用域</a></li>
            <li><a href="#172-spring-bean的生命周期">1.7.2 Spring Bean的生命周期</a></li>
            <li><a href="#173-spring-ioc">1.7.3 Spring IoC</a></li>
            <li><a href="#174-spring-aop">1.7.4 Spring AOP</a></li>
            <li><a href="#175-spring三级缓存解决bean循环依赖">1.7.5 Spring三级缓存解决Bean循环依赖</a></li>
            <li><a href="#176-spring事务实现">1.7.6 Spring事务实现</a></li>
            <li><a href="#177-spring事务失效的典型场景">1.7.7 Spring事务失效的典型场景</a></li>
            <li><a href="#178-spring中beanfactory和applicationcontext的区别">1.7.8 Spring中BeanFactory和ApplicationContext的区别</a></li>
          </ul>
        </li>
        <li><a href="#18-zookeeper">1.8 ZooKeeper</a>
          <ul>
            <li><a href="#181-zookeeper典型使用场景">1.8.1 ZooKeeper典型使用场景</a></li>
            <li><a href="#182-zookeeper四种节点类型">1.8.2 ZooKeeper四种节点类型</a></li>
            <li><a href="#183-zookeeper的顺序一致性">1.8.3 ZooKeeper的顺序一致性</a></li>
            <li><a href="#184-zookeeper集群节点为什么是奇数个">1.8.4 ZooKeeper集群节点为什么是奇数个</a></li>
            <li><a href="#185-zookeeper集群中的三种角色">1.8.5 ZooKeeper集群中的三种角色</a></li>
            <li><a href="#186-zookeeper的选主机制">1.8.6 ZooKeeper的选主机制</a></li>
            <li><a href="#187-zookeeper与eureka的区别">1.8.7 ZooKeeper与Eureka的区别</a></li>
            <li><a href="#188-zookeeper-atomic-broadcast协议">1.8.8 ZooKeeper Atomic Broadcast协议</a></li>
          </ul>
        </li>
        <li><a href="#19-dubbo">1.9 Dubbo</a>
          <ul>
            <li><a href="#191-dubbo架构简述">1.9.1 Dubbo架构简述</a></li>
            <li><a href="#192-路由机制">1.9.2 路由机制</a></li>
            <li><a href="#193-负载均衡">1.9.3 负载均衡</a></li>
            <li><a href="#194-集群容错">1.9.4 集群容错</a></li>
            <li><a href="#195-dubbo的序列化">1.9.5 Dubbo的序列化</a></li>
            <li><a href="#196-有了http请求为什么还需要rpc调用">1.9.6 有了HTTP请求为什么还需要RPC调用</a></li>
            <li><a href="#197-dubbo的spi机制">1.9.7 Dubbo的SPI机制</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第2章-算法题目">第2章 算法题目</a>
      <ul>
        <li><a href="#21-递归">2.1 递归</a></li>
        <li><a href="#22-双指针">2.2 双指针</a></li>
        <li><a href="#23-滑动窗口-184">2.3 滑动窗口 184</a></li>
        <li><a href="#24-二分搜索-185">2.4 二分搜索 185</a></li>
        <li><a href="#25-动态规划-186">2.5 动态规划 186</a></li>
        <li><a href="#26-回溯-188">2.6 回溯 188</a></li>
        <li><a href="#27-广度深度优先搜索-192">2.7 广度/深度优先搜索 192</a></li>
      </ul>
    </li>
    <li><a href="#第3章-设计题-197">第3章 设计题 197</a>
      <ul>
        <li><a href="#31-秒杀系统-197">3.1 秒杀系统 197</a></li>
        <li><a href="#32-分布式定时任务-201">3.2 分布式定时任务 201</a></li>
        <li><a href="#33-其他高频出现的经典方案设计题目-205">3.3 其他高频出现的经典方案设计题目 205</a></li>
      </ul>
    </li>
    <li><a href="#第4章-一个项目案例分析合约广告库存预估-206">第4章 一个项目案例分析：合约广告库存预估 206</a>
      <ul>
        <li><a href="#41-项目背景-207">4.1 项目背景 207</a></li>
        <li><a href="#42-系统领域划分与自己所在的位置-207">4.2 系统领域划分与自己所在的位置 207</a></li>
        <li><a href="#43-发现或者定义一个问题-207">4.3 发现或者定义一个问题 207</a></li>
        <li><a href="#44-可量化的正向结果-208">4.4 可量化的正向结果 208</a></li>
        <li><a href="#45-未来改进点-209">4.5 未来改进点 209</a></li>
      </ul>
    </li>
    <li><a href="#第5章-一个完整的后端系统-211">第5章 一个完整的后端系统 211</a>
      <ul>
        <li><a href="#51-接入层nginx与网关-212">5.1 接入层（Nginx与网关） 212</a></li>
        <li><a href="#52-业务层-212">5.2 业务层 212</a></li>
        <li><a href="#53-数据层db分布式缓存本地内存-213">5.3 数据层（DB→分布式缓存→本地内存） 213</a></li>
      </ul>
    </li>
    <li><a href="#第6章-hr面试技巧头部大厂hr访谈-215">第6章 HR面试技巧——头部大厂HR访谈 215</a>
      <ul>
        <li><a href="#61-面试的全流程不要以为通过技术hr面试就能拿offer-215">6.1 面试的全流程—不要以为通过技术&amp;HR面试就能拿Offer 215</a></li>
        <li><a href="#62-跳槽时找谁内推更容易通过面试-216">6.2 跳槽时找谁内推更容易通过面试 216</a></li>
        <li><a href="#63-谈薪技巧-217">6.3 谈薪技巧 217</a></li>
        <li><a href="#64-反问环节怎么提问能加分-217">6.4 反问环节—怎么提问能加分 217</a></li>
        <li><a href="#65-你的职业规划-218">6.5 你的职业规划 218</a></li>
        <li><a href="#66-为什么要跳槽-218">6.6 为什么要跳槽 218</a></li>
        <li><a href="#67-你的优点和缺点-218">6.7 你的优点和缺点 218</a></li>
        <li><a href="#68-过往工作中取得的成果-219">6.8 过往工作中取得的成果 219</a></li>
        <li><a href="#69-过往工作中遇到的困难是怎么解决的-219">6.9 过往工作中遇到的困难是怎么解决的 219</a></li>
        <li><a href="#610-行业薪酬水平-219">6.10 行业薪酬水平 219</a></li>
        <li><a href="#611-没有做出算法题是否一定会被淘汰-224">6.11 没有做出算法题是否一定会被淘汰 224</a></li>
        <li><a href="#612-能不能短时间内频繁面试同一家公司-224">6.12 能不能短时间内频繁面试同一家公司 224</a></li>
        <li><a href="#613-毕业季应选择什么样的公司-225">6.13 “毕业季”应选择什么样的公司 225</a></li>
        <li><a href="#614-国内互联网面试为什么要刷题-225">6.14 国内互联网面试为什么要刷题 225</a></li>
        <li><a href="#615-薪酬报高了会不会被hr直接淘汰-225">6.15 薪酬报高了会不会被HR直接淘汰 225</a></li>
        <li><a href="#616-几年一跳算频繁-226">6.16 几年一跳算频繁 226</a></li>
        <li><a href="#617-你是如何学习技术的-226">6.17 你是如何学习技术的 226</a></li>
        <li><a href="#618-思维发散题目-227">6.18 思维发散题目 227</a></li>
      </ul>
    </li>
    <li><a href="#参考文献-229">参考文献 229</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h2 id="第1章-八股文">
  第1章 八股文
  <a class="anchor" href="#%e7%ac%ac1%e7%ab%a0-%e5%85%ab%e8%82%a1%e6%96%87">#</a>
</h2>
<h3 id="11-综合知识">
  1.1 综合知识
  <a class="anchor" href="#11-%e7%bb%bc%e5%90%88%e7%9f%a5%e8%af%86">#</a>
</h3>
<h4 id="111-单元化高可用架构演进历程">
  1.1.1 单元化高可用架构演进历程
  <a class="anchor" href="#111-%e5%8d%95%e5%85%83%e5%8c%96%e9%ab%98%e5%8f%af%e7%94%a8%e6%9e%b6%e6%9e%84%e6%bc%94%e8%bf%9b%e5%8e%86%e7%a8%8b">#</a>
</h4>
<ul>
<li>单体应用→单数据库→单机房→单地部署</li>
<li>微服务→分库分表→同城多机房→单元化</li>
<li>1 单体应用与单机房微服务
<ul>
<li>单体应用把所有的功能模块耦合在一起，它存在的问题是领域边界模糊，无法根据业务模块的需要进行伸缩扩容。除此之外，还存在需求开发分支冲突、线上问题定位困难、整体打包编译费时等问题，不适用于大型复杂项目。</li>
<li>由于系统内部处理耗时很小，并且后端服务与数据库部署在同一机房，因此该架构下整个请求链路上的耗时主要发生在用户到机房的物理距离上。</li>
<li>微服务化时代，巨大的单体应用被拆分为模块化的服务，每个服务都围绕特定的业务领域构建，微服务之间通过远程过程调用(Remote Procedure Call，RPC)实现通信，这就是单机房微服务。尽管服务拆分使得原本进程内部的调用变成了网络调用，但是应用都部署在同一个机房，因此RPC网络开销可以忽略。微服务解决了应用层的瓶颈，但随着业务的发展，数据库又成为制约系统扩容的瓶颈。</li>
</ul>
</li>
<li>2 单数据库与分库分表
<ul>
<li>随着业务的发展数据量不断增多，出现了数据存储、读取方面的问题：一方面单机物理服务器的资源（如CPU、磁盘、内存、IO等）有限，磁盘读取和网络IO出现瓶颈；另一方面单表的数据量太大，查询时扫描的数据很多，造成SQL执行效率低下。为了解决上述问题，引入数据库中间件—实现对上层业务透明的分库分表。</li>
<li>分布式数据库的数据分区一般采用Hash函数+Map映射的方式来实现：首先根据数据的分表字段（一般为userid）计算出该数据的Hash桶位置，然后使用事先定义好的映射表将这个Hash桶中的数据映射到数据库物理节点。</li>
</ul>
</li>
<li>3 单机房演进为同城多机房
<ul>
<li>为了解决单机房的容量限制，可在同城新建多个机房，机房之间通过专线连接，将应用服务部署在多个机房，数据库主库和备库部署到不同的机房，依靠不同的服务注册中心将应用层逻辑隔离，实现应用层请求不跨机房处理</li>
<li>数据库主库只在其中一个机房内，数据写入时只写主库，主备数据同步，异地机房备库可提供读服务。该方案存在的缺点是访问数据库存在跨机房调用、主备数据同步延迟的问题，但该方案的优点也很多
<ul>
<li>容量不受单机房限制，数据层与应用层均可自由扩容。</li>
<li>避免不可测因素导致单机房故障，使得全域产品服务不可用，比如地震、火灾、洪水等灾害使得机房断电或者网线被施工方意外挖断等。</li>
<li>用户请求就近接入，优先被物理距离较近的机房处理，减少网络耗时，保障用户体验。</li>
</ul>
</li>
</ul>
</li>
<li>4 同城多机房演进为单元化部署
<ul>
<li>因为应用层流量是随机的，任何一个应用节点都可能访问任意一个数据库节点，所以应用层每增加一台服务器实例都需要与数据库建立连接，数据库连接数量存在上限，这又制约了系统的水平扩容</li>
<li>提出了单元化的架构，该种架构的应用层也像数据层一样分片，但从应用层到数据层组成一个封闭的单元，一次请求处理收敛在一个单元内部，数据库只负责本单元的应用请求，从而大大节省了连接数；而每个单元可以作为一个独立整体进行部署或挪动，甚至还可以将单元部署到异地来实现容灾。</li>
<li>单元化设计的原则如下：
<ul>
<li>业务是可分片的，常以用户id或者地区作为分片维度</li>
<li>整个系统要面向逻辑分区进行设计，方便单元挪动</li>
<li>理想状态下单元内部是自封闭的，单元内可以完成业务的所有处理。</li>
</ul>
</li>
<li>缺点是，有时跨单元调用是无法避免的，比如转账场景，用户A和B分别属于单元1和单元2，数据也存储在不同单元，扣减用户A的账户余额需要在单元1执行，增加用户B的账户余额需要在单元2执行，因此跨单元调用增加网络耗时这一问题无法避免。</li>
</ul>
</li>
</ul>
<h4 id="112-java中5种重要的队列">
  1.1.2 Java中5种重要的队列
  <a class="anchor" href="#112-java%e4%b8%ad5%e7%a7%8d%e9%87%8d%e8%a6%81%e7%9a%84%e9%98%9f%e5%88%97">#</a>
</h4>
<ul>
<li>1 ArrayBlockingQueue队列</li>
<li>2 LinkedBlockingQueue队列</li>
<li>3 SynchronousQueue队</li>
<li>4 无锁队列</li>
<li>5 PriorityBlockingQueue队列</li>
</ul>
<h4 id="113-io多路复用">
  1.1.3 IO多路复用
  <a class="anchor" href="#113-io%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8">#</a>
</h4>
<ul>
<li>IO多路复用就是通过一种机制来监听多个文件描述符，某个文件描述符一旦就绪，它就能通知应用程序进行相应的处理。多路复用的3种实现方式有select、poll和epoll</li>
<li>1 阻塞IO</li>
<li>2 引入线程池</li>
<li>3 IO多路复用3种实现方式</li>
</ul>
<h4 id="114-reentrantlock锁与syschronized锁">
  1.1.4 ReentrantLock锁与Syschronized锁
  <a class="anchor" href="#114-reentrantlock%e9%94%81%e4%b8%8esyschronized%e9%94%81">#</a>
</h4>
<ul>
<li>1 公平锁与非公平锁
<ul>
<li>公平锁是指多个线程竞争锁时直接进入队列排队，根据申请锁的顺序获得锁，先到先得。而非公平锁则是多个线程竞争锁时，首先尝试直接抢锁，失败后再进入等待队列。</li>
<li>使用公平锁，先到先得，线程获取锁时不会出现饥饿现象。使用非公平锁，整体的吞吐效率比较高。</li>
<li>ReentrantLock默认是非公平锁，在构造方法中传入参数true则为公平锁；Synchronized是非公平锁。</li>
</ul>
</li>
<li>2 可重入锁
<ul>
<li>可重入锁是指一个线程可以多次获取同一把锁，其实现原理是，为每个锁关联一个计数器，线程首次获取锁时，计数器置为1，再次获取该锁时，计数器加1；线程每退出同步块一次，计数器就减1。计数器为0则代表锁被当前线程释放。</li>
<li>Synchronized和ReentrantLock都是可重入锁。</li>
</ul>
</li>
<li>3 ReentrantLock锁</li>
<li>4 Syschronized锁</li>
</ul>
<h4 id="115-java-spi机制">
  1.1.5 Java SPI机制
  <a class="anchor" href="#115-java-spi%e6%9c%ba%e5%88%b6">#</a>
</h4>
<h4 id="116-限流算法">
  1.1.6 限流算法
  <a class="anchor" href="#116-%e9%99%90%e6%b5%81%e7%ae%97%e6%b3%95">#</a>
</h4>
<ul>
<li>
<p>1 计数器</p>
</li>
<li>
<p>2 漏桶算法</p>
</li>
<li>
<p>3 令牌桶算法</p>
</li>
</ul>
<h4 id="117-领域驱动设计">
  1.1.7 领域驱动设计
  <a class="anchor" href="#117-%e9%a2%86%e5%9f%9f%e9%a9%b1%e5%8a%a8%e8%ae%be%e8%ae%a1">#</a>
</h4>
<ul>
<li>1 领域模型 数据模型</li>
<li>2 架构分层</li>
<li>3 领域驱动设计的基本概念</li>
<li>4 领域驱动实践</li>
</ul>
<h4 id="118-hashmap的底层原理">
  1.1.8 HashMap的底层原理
  <a class="anchor" href="#118-hashmap%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86">#</a>
</h4>
<ul>
<li>1 HashMap的get与put方法的执行过程</li>
<li>2 key的hash值的计算过程</li>
<li>3 HashMap是如何解决Hash冲突的</li>
<li>4 为什么链表转换为红黑树的阈值是8，而红黑树转换为链表的阈值却是6</li>
<li>5 JDK8为什么使用红黑树</li>
<li>6 HashMap扩容机制</li>
<li>7 为什么HashMap是两倍扩容，容量总为2的n次幂</li>
</ul>
<h4 id="119-jvm垃圾回收机制">
  1.1.9 JVM垃圾回收机制
  <a class="anchor" href="#119-jvm%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6">#</a>
</h4>
<h4 id="1110-零复制">
  1.1.10 零复制
  <a class="anchor" href="#1110-%e9%9b%b6%e5%a4%8d%e5%88%b6">#</a>
</h4>
<h4 id="1111-tcc柔性事务">
  1.1.11 TCC柔性事务
  <a class="anchor" href="#1111-tcc%e6%9f%94%e6%80%a7%e4%ba%8b%e5%8a%a1">#</a>
</h4>
<h4 id="1112-cap与base">
  1.1.12 CAP与BASE
  <a class="anchor" href="#1112-cap%e4%b8%8ebase">#</a>
</h4>
<h4 id="1113-volatile关键字">
  1.1.13 Volatile关键字
  <a class="anchor" href="#1113-volatile%e5%85%b3%e9%94%ae%e5%ad%97">#</a>
</h4>
<h4 id="1114-双亲委派类加载器">
  1.1.14 双亲委派类加载器
  <a class="anchor" href="#1114-%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8">#</a>
</h4>
<h4 id="1115-从微服务到service-mesh">
  1.1.15 从微服务到Service Mesh
  <a class="anchor" href="#1115-%e4%bb%8e%e5%be%ae%e6%9c%8d%e5%8a%a1%e5%88%b0service-mesh">#</a>
</h4>
<h4 id="1116-进程线程与协程">
  1.1.16 进程、线程与协程
  <a class="anchor" href="#1116-%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e4%b8%8e%e5%8d%8f%e7%a8%8b">#</a>
</h4>
<ul>
<li>进程
<ul>
<li>进程是系统进行资源调度和分配的基本单位</li>
</ul>
</li>
<li>线程
<ul>
<li>线程是CPU调度和分配的基本单位</li>
</ul>
</li>
<li>协程
<ul>
<li>协程比线程更加轻量级，它是一个特殊的函数，该函数可以在某个地方被挂起，也可以在挂起处继续执行。</li>
</ul>
</li>
<li>从上下文切换方面来讲，进程和线程的切换者都是操作系统，切换时机也由操作系统决定，用户无感知；协程的切换者是用户（编程者），切换时机也由用户程序决定。</li>
<li>从并行运行方面来讲，多个进程或一个进程内的多个线程是可以并行运行的，一个线程的多个协程是串行执行的。</li>
</ul>
<h4 id="1117-强引用软引用弱引用虚引用">
  1.1.17 强引用、软引用、弱引用、虚引用
  <a class="anchor" href="#1117-%e5%bc%ba%e5%bc%95%e7%94%a8%e8%bd%af%e5%bc%95%e7%94%a8%e5%bc%b1%e5%bc%95%e7%94%a8%e8%99%9a%e5%bc%95%e7%94%a8">#</a>
</h4>
<ul>
<li>
<p>1 强引用(StrongReference)</p>
</li>
<li>
<p>当内存空间不足时，即使JVM抛出OutOfMemoryError错误，垃圾回收器也不会回收具有强引用的对象。类似Object object = new Object()这种使用new操作符创建的对象，将它赋值给一个变量，这个变量就是指向该对象的一个强引用。</p>
</li>
<li>
<p>2 软引用(SoftReference)</p>
</li>
<li>
<p>3 弱引用(WeakReference)</p>
</li>
<li>
<p>4 虚引用(PhantomReference)</p>
</li>
</ul>
<h4 id="1118-threadlocal">
  1.1.18 ThreadLocal
  <a class="anchor" href="#1118-threadlocal">#</a>
</h4>
<ul>
<li>ThreadLocal为每个使用该变量的线程提供一个副本，每个线程都可以独立修改自己的副本，而不会与其他线程的副本产生冲突。</li>
</ul>
<h4 id="1119-线程池">
  1.1.19 线程池
  <a class="anchor" href="#1119-%e7%ba%bf%e7%a8%8b%e6%b1%a0">#</a>
</h4>
<ul>
<li>1 使用线程池的好处
<ul>
<li>已创建的线程，避免频繁创建和销毁线程带来的性能开销。</li>
<li>提高了线程的可管理性，避免了无节制创建线程而耗尽系统资源。</li>
<li>提高任务响应速度，任务到达时可立即执行，节省了线程创建的时间。</li>
</ul>
</li>
<li>2 线程池ThreadPoolExecutor的设计与实现</li>
<li>3 线程池的状态与生命周期</li>
<li>4 如何设置线程池核心线程数量
<ul>
<li>对于CPU密集型任务，核心线程数设置为CPU核数+1。</li>
<li>对于I/O密集型任务，核心线程数设置为2×CPU核数。</li>
</ul>
</li>
</ul>
<h4 id="1120-控制访问某个资源或方法的并发数">
  1.1.20 控制访问某个资源或方法的并发数
  <a class="anchor" href="#1120-%e6%8e%a7%e5%88%b6%e8%ae%bf%e9%97%ae%e6%9f%90%e4%b8%aa%e8%b5%84%e6%ba%90%e6%88%96%e6%96%b9%e6%b3%95%e7%9a%84%e5%b9%b6%e5%8f%91%e6%95%b0">#</a>
</h4>
<ul>
<li>(1)使用线程池异步处理任务，通过设置线程池最大线程数来限制执行方法的最大并发数</li>
<li>(2)使用信号量semaphore控制同时访问共享资源的线程个数</li>
</ul>
<h4 id="1121-happens-before">
  1.1.21 Happens-Before
  <a class="anchor" href="#1121-happens-before">#</a>
</h4>
<h4 id="1122-对java的理解">
  1.1.22 对Java的理解
  <a class="anchor" href="#1122-%e5%af%b9java%e7%9a%84%e7%90%86%e8%a7%a3">#</a>
</h4>
<h4 id="1123-缓存穿透雪崩击穿">
  1.1.23 缓存穿透、雪崩、击穿
  <a class="anchor" href="#1123-%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f%e9%9b%aa%e5%b4%a9%e5%87%bb%e7%a9%bf">#</a>
</h4>
<ul>
<li>1 缓存穿透
<ul>
<li>穿透是指查询一个底层存储不存在的key，每次查询时缓存中都不存在该数据，进而穿透到底层存储进行二次查询。流量高峰时，缓存失去了意义，底层存储可能被打挂。</li>
<li>解决方案：
<ul>
<li>使用布隆过滤器拦截对底层存储不存在的key的读请求，减轻对底层存储的查询压力。</li>
<li>缓存空值，查询底层存储返回空时，将空值缓存起来，下次同样的查询就可避免穿透。</li>
<li>缓存预热，有些场景可以认为缓存不存在，底层数据也不会存在，比如广告特征数据从HBase预热到Redis中，Redis未命中，没必要穿透查询HBase。</li>
</ul>
</li>
</ul>
</li>
<li>2 缓存雪崩
<ul>
<li>雪崩是指大量的key过期时间设置得相同或者近似，导致某一时刻缓存同时失效，请求全部打到底层存储，引起系统崩溃。</li>
<li>解决方案
<ul>
<li>在缓存原有失效时间基础上加一个随机值，将失效时间随机打散。</li>
</ul>
</li>
</ul>
</li>
<li>3 缓存击穿
<ul>
<li>击穿是指缓存在某时刻过期，恰好此时对该key有大量的并发请求。击穿和雪崩的区别在于：缓存击穿是同一时刻对某一个key进行大量请求但没命中缓存，缓存雪崩是同一时刻对不同的过期的key进行大量请求。</li>
<li>解决方案：
<ul>
<li>抢锁成功的线程去底层存储获取数据并放入缓存，后续其他线程等待读取缓存中的数据。</li>
<li>一些场景允许这样的假设：缓存中没有数据，底层存储也没有。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1124-虚拟机与容器对比">
  1.1.24 虚拟机与容器对比
  <a class="anchor" href="#1124-%e8%99%9a%e6%8b%9f%e6%9c%ba%e4%b8%8e%e5%ae%b9%e5%99%a8%e5%af%b9%e6%af%94">#</a>
</h4>
<h4 id="1125-保障系统高可用的一般方法">
  1.1.25 保障系统高可用的一般方法
  <a class="anchor" href="#1125-%e4%bf%9d%e9%9a%9c%e7%b3%bb%e7%bb%9f%e9%ab%98%e5%8f%af%e7%94%a8%e7%9a%84%e4%b8%80%e8%88%ac%e6%96%b9%e6%b3%95">#</a>
</h4>
<h4 id="1126-伪共享">
  1.1.26 伪共享
  <a class="anchor" href="#1126-%e4%bc%aa%e5%85%b1%e4%ba%ab">#</a>
</h4>
<h4 id="1127-caffeine缓存高性能分析">
  1.1.27 Caffeine缓存高性能分析
  <a class="anchor" href="#1127-caffeine%e7%bc%93%e5%ad%98%e9%ab%98%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90">#</a>
</h4>
<h4 id="1128-请自我介绍一下">
  1.1.28 请自我介绍一下
  <a class="anchor" href="#1128-%e8%af%b7%e8%87%aa%e6%88%91%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b">#</a>
</h4>
<h3 id="12-数据库">
  1.2 数据库
  <a class="anchor" href="#12-%e6%95%b0%e6%8d%ae%e5%ba%93">#</a>
</h3>
<h4 id="121-一次sql查询的执行过程">
  1.2.1 一次SQL查询的执行过程
  <a class="anchor" href="#121-%e4%b8%80%e6%ac%a1sql%e6%9f%a5%e8%af%a2%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b">#</a>
</h4>
<ul>
<li>
<p>步骤01 连接器负责与客户端建立并管理连接、获取权限等。</p>
</li>
<li>
<p>步骤02 查询缓存，执行过的语句及其结果可能会以键值对的形式缓存在内存中，key是查询语句，value是查询结果；若查询命中缓存则直接返回。如果表发生变化，那么和该表相关的所有缓存数据都将失效，因此只有数据更新不频繁的静态配置表才开启查询缓存。</p>
</li>
<li>
<p>步骤03 分析器进行语法分析，判断SQL是否满足MySQL语法。</p>
</li>
<li>
<p>步骤04 优化器选择索引，或者在多表关联时决定各个表的连接顺序，以此获取较好的查询性能。</p>
</li>
<li>
<p>步骤05 执行器通过存储引擎的接口获取数据。</p>
</li>
</ul>
<h4 id="122-binlog日志备份的3种模式">
  1.2.2 binlog日志备份的3种模式
  <a class="anchor" href="#122-binlog%e6%97%a5%e5%bf%97%e5%a4%87%e4%bb%bd%e7%9a%843%e7%a7%8d%e6%a8%a1%e5%bc%8f">#</a>
</h4>
<h4 id="123-事务的两阶段提交">
  1.2.3 事务的两阶段提交
  <a class="anchor" href="#123-%e4%ba%8b%e5%8a%a1%e7%9a%84%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4">#</a>
</h4>
<ul>
<li>1 投票阶段
<ul>
<li>协调者发送事务执行请求给所有参与者，参与者根据事务在本地执行成功或者失败的结果回复同意或取消。</li>
</ul>
</li>
<li>2 提交阶段
<ul>
<li>协调者可能收到3种事务执行结果：
<ul>
<li>所有参与者成功执行事务
<ul>
<li>如果所有参与者成功执行事务，那么协调者将向所有参与者发送事务提交的通知，参与者提交事务并返回执行结果</li>
</ul>
</li>
<li>部分参与者执行事务失败
<ul>
<li>如果部分参与者执行事务失败或者协调者等待超时，那么协调者向所有参与者发送事务回滚通知，参与者执行回滚操作、释放资源，并将执行结果返回给协调者</li>
</ul>
</li>
<li>协调者等待超时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="124-二叉搜索树平衡树红黑树b树b树的区别">
  1.2.4 二叉搜索树、平衡树、红黑树、B树、B+树的区别
  <a class="anchor" href="#124-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e5%b9%b3%e8%a1%a1%e6%a0%91%e7%ba%a2%e9%bb%91%e6%a0%91b%e6%a0%91b%e6%a0%91%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h4>
<ul>
<li>1 二叉搜索树</li>
<li>2 AVL树</li>
<li>3 红黑树的特点
<ul>
<li>红黑树需要满足以下条件：
<ul>
<li>根节点是黑的</li>
<li>每个节点非红即黑</li>
<li>叶子节点是黑的</li>
<li>如果一个节点是红的，那么它的子节点一定是黑的</li>
<li>对于任意节点，它到叶子节点的所有路径上都包含相同数目的黑节点</li>
</ul>
</li>
</ul>
</li>
<li>4 B树</li>
<li>5 B+树</li>
</ul>
<h4 id="125-mysql存储引擎innodb与myisam的区别">
  1.2.5 MySQL存储引擎InnoDB与MyISAM的区别
  <a class="anchor" href="#125-mysql%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8einnodb%e4%b8%8emyisam%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h4>
<ul>
<li>MySQL有多种存储引擎，包括：MyISAM和InnoDB等。两者的主要区别如下</li>
<li>InnoDB支持事务，MyISAM不支持事务</li>
<li>InnoDB支持外键，MyISAM不支持</li>
<li>InnoDB是聚集索引，MyISAM是非聚集索引</li>
<li>InnoDB锁最小粒度是行锁，MyISAM锁最小粒度是表锁</li>
</ul>
<h4 id="126-聚集索引与非聚集索引的区别">
  1.2.6 聚集索引与非聚集索引的区别
  <a class="anchor" href="#126-%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e4%b8%8e%e9%9d%9e%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h4>
<ul>
<li>(1)每张表只能有一个聚集索引，可以有多个非聚集索引。</li>
<li>(2)聚集索引的叶节点就是数据节点，非聚集索引的叶节点仍然是索引，存在一个指针指向对应的数据块。</li>
<li>(3)聚集索引键值的逻辑顺序决定了相应行的物理存储顺序，非聚集索引的逻辑顺序与磁盘上行的物理存储顺序不同。</li>
</ul>
<h4 id="127-数据库事务的4大特性">
  1.2.7 数据库事务的4大特性
  <a class="anchor" href="#127-%e6%95%b0%e6%8d%ae%e5%ba%93%e4%ba%8b%e5%8a%a1%e7%9a%844%e5%a4%a7%e7%89%b9%e6%80%a7">#</a>
</h4>
<ul>
<li>1 原子性(Atomicity)</li>
<li>2 一致性(Consistency)</li>
<li>3 隔离性(Isolation)</li>
<li>4 持久性(Durability)</li>
</ul>
<h4 id="128-事务隔离级别与脏读不可重复读幻读">
  1.2.8 事务隔离级别与脏读、不可重复读、幻读
  <a class="anchor" href="#128-%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e4%b8%8e%e8%84%8f%e8%af%bb%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e5%b9%bb%e8%af%bb">#</a>
</h4>
<ul>
<li>事务隔离级别
<ul>
<li>读未提交：该隔离级别下，一个事务在执行过程中可以看到其他未提交的事务操作。</li>
<li>读已提交：该隔离级别下，一个事务只能看见已提交事务所做的改变。</li>
<li>可重复读：MySQL默认的隔离级别，该隔离级别下，保证在同一个事务中多次读取同样记录的结果是一致的。</li>
<li>串行化：最高的隔离级别，强制事务串行执行。</li>
</ul>
</li>
<li>1 脏读</li>
<li>2 不可重复读</li>
<li>3 幻读</li>
<li>不可重复读与幻读的区别在于前者是数据变了，后者是数据的行数变了</li>
</ul>
<h4 id="129-redoundobinlog数据库日志的作用">
  1.2.9 redo、undo、binlog数据库日志的作用
  <a class="anchor" href="#129-redoundobinlog%e6%95%b0%e6%8d%ae%e5%ba%93%e6%97%a5%e5%bf%97%e7%9a%84%e4%bd%9c%e7%94%a8">#</a>
</h4>
<ul>
<li>1 redo log</li>
<li>2 undo log</li>
<li>3 binlog</li>
</ul>
<h4 id="1210-多版本并发控制">
  1.2.10 多版本并发控制
  <a class="anchor" href="#1210-%e5%a4%9a%e7%89%88%e6%9c%ac%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6">#</a>
</h4>
<ul>
<li>1 redo log
<ul>
<li>为了避免每次读写数据库都会产生随机IO，InnoDB为MySQL提供了Buffer Pool，读取数据时先从Buffer Pool读取，数据不存在则从磁盘读取后再写入Buffer Pool；数据写入时先写入Buffer Pool，Buffer Pool中的数据定期刷盘。Buffer Pool提升了数据库的读写性能，但数据库一旦宕机，Buffer Pool中缓存的数据若未刷盘就会丢失，因此，当数据变更时，还需要记录redo log，redo log是预写日志(Write-ahead logging，WAL)，所有对数据的修改先写入redo log，再更新到Buffer Pool，如果MySQL宕机，重启时可以读取redo log对数据进行恢复。这里需要说明的是，不同于数据库操作产生的随机读写，写redo日志是顺序写，效率极高。因此，记录redo日志虽然是磁盘操作但对数据库整体的读写性能几乎没有影响。</li>
</ul>
</li>
<li>2 undo log
<ul>
<li>事务执行前，MySQL会将更新前的数据保存到undo日志中，如果事务回滚或者数据库崩溃，可以利用undo日志进行回退。undo log也可以用于实现多版本并发控制(MVCC)。</li>
</ul>
</li>
<li>3 binlog
<ul>
<li>主从复制，从库利用主库上的binlog进行数据回放，实现主从同步。</li>
</ul>
</li>
</ul>
<h4 id="1211-数据库行锁表锁乐观锁与悲观锁">
  1.2.11 数据库行锁、表锁、乐观锁与悲观锁
  <a class="anchor" href="#1211-%e6%95%b0%e6%8d%ae%e5%ba%93%e8%a1%8c%e9%94%81%e8%a1%a8%e9%94%81%e4%b9%90%e8%a7%82%e9%94%81%e4%b8%8e%e6%82%b2%e8%a7%82%e9%94%81">#</a>
</h4>
<ul>
<li>1 行锁
<ul>
<li>行锁锁住一行或者多行记录。行锁开销大，加锁慢，可能会出现死锁，但锁定粒度小、并发度高。InnoDB存储引擎默认的事务隔离级别为可重复读，并且在参数innodb_locks_unsafe_for_binlog = 0的模式下，行锁有3种类型：记录锁(record lock)、间隙锁(GAP lock)、临键锁(next-key lock)。
<ul>
<li>1）记录锁</li>
<li>2）间隙锁</li>
<li>3）临键锁</li>
</ul>
</li>
</ul>
</li>
<li>2 表锁
<ul>
<li>表锁锁定整张表，锁定期间其他事务不能对该表进行操作。查询非索引字段时一般触发表锁。表锁开销小，加锁快，不会出现死锁，但锁粒度大，并发度低。</li>
</ul>
</li>
<li>3 数据库的乐观锁与悲观锁
<ul>
<li>悲观锁：数据修改前，假设一定会发生冲突，先尝试为它加锁。</li>
<li>乐观锁：假设数据修改不会造成冲突，在数据提交更新时才进行冲突检测。</li>
<li>在低并发场景下，使用乐观锁可以避免加锁开销；在高并发场景下，使用乐观锁会因为数据冲突频繁而导致执行效率变低，该场景下应使用悲观锁。</li>
</ul>
</li>
</ul>
<h4 id="1212-当前读与快照读">
  1.2.12 当前读与快照读
  <a class="anchor" href="#1212-%e5%bd%93%e5%89%8d%e8%af%bb%e4%b8%8e%e5%bf%ab%e7%85%a7%e8%af%bb">#</a>
</h4>
<ul>
<li>当前读</li>
<li>快照读</li>
</ul>
<h4 id="1213-幻读是怎么解决的">
  1.2.13 幻读是怎么解决的
  <a class="anchor" href="#1213-%e5%b9%bb%e8%af%bb%e6%98%af%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3%e7%9a%84">#</a>
</h4>
<ul>
<li>幻读是指一个事务在前后两次查询同一个范围时，后一次查询观察到了前一次查询结果集中没有的记录。</li>
<li>快照读
<ul>
<li>在可重复读隔离级别下，普通的查询是快照读，ReadView只在事务开启的第一次查询时生成，之后的查询都复用之前的ReadView，这就使得前后两次查询结果相同。因此，快照读不会出现幻读问题。</li>
</ul>
</li>
<li>当前读
<ul>
<li>当前读读取的是最新版本的数据，如果无法阻止其他事务在查询区间范围内插入新的数据，就会出现幻读现象。</li>
<li>为了解决幻读问题，引入间隙锁。间隙锁给某一个范围区间加锁，阻止其他事务将新的记录插入该范围区间内，因此也就不会出现幻读了。</li>
</ul>
</li>
</ul>
<h4 id="1214-sql索引优化">
  1.2.14 SQL索引优化
  <a class="anchor" href="#1214-sql%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96">#</a>
</h4>
<h4 id="1215-dao层缓存先更新缓存还是先更新数据库">
  1.2.15 Dao层缓存先更新缓存还是先更新数据库
  <a class="anchor" href="#1215-dao%e5%b1%82%e7%bc%93%e5%ad%98%e5%85%88%e6%9b%b4%e6%96%b0%e7%bc%93%e5%ad%98%e8%bf%98%e6%98%af%e5%85%88%e6%9b%b4%e6%96%b0%e6%95%b0%e6%8d%ae%e5%ba%93">#</a>
</h4>
<h4 id="1216-mysql高可用架构">
  1.2.16 MySQL高可用架构
  <a class="anchor" href="#1216-mysql%e9%ab%98%e5%8f%af%e7%94%a8%e6%9e%b6%e6%9e%84">#</a>
</h4>
<ul>
<li>MySQL通过主从复制实现高可用
<ul>
<li>主库向从库同步自己的binlog日志</li>
<li>从库的IO线程将binlog日志写入relay log</li>
<li>从库的SQL线程读取relay log并进行数据回放。</li>
</ul>
</li>
<li>1 异步复制</li>
<li>2 半同步复制</li>
<li>3 组复制</li>
</ul>
<h4 id="1217-为什么遇到范围查询会停止索引的最左匹配">
  1.2.17 为什么遇到范围查询会停止索引的最左匹配
  <a class="anchor" href="#1217-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%81%87%e5%88%b0%e8%8c%83%e5%9b%b4%e6%9f%a5%e8%af%a2%e4%bc%9a%e5%81%9c%e6%ad%a2%e7%b4%a2%e5%bc%95%e7%9a%84%e6%9c%80%e5%b7%a6%e5%8c%b9%e9%85%8d">#</a>
</h4>
<h4 id="1218-索引下推">
  1.2.18 索引下推
  <a class="anchor" href="#1218-%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8">#</a>
</h4>
<h4 id="1219-索引覆盖">
  1.2.19 索引覆盖
  <a class="anchor" href="#1219-%e7%b4%a2%e5%bc%95%e8%a6%86%e7%9b%96">#</a>
</h4>
<h4 id="1220-经典sql语句考察group-byjoinhaving">
  1.2.20 经典SQL语句考察：group by、join、having
  <a class="anchor" href="#1220-%e7%bb%8f%e5%85%b8sql%e8%af%ad%e5%8f%a5%e8%80%83%e5%af%9fgroup-byjoinhaving">#</a>
</h4>
<h4 id="1221-避免数据库热点更新">
  1.2.21 避免数据库热点更新
  <a class="anchor" href="#1221-%e9%81%bf%e5%85%8d%e6%95%b0%e6%8d%ae%e5%ba%93%e7%83%ad%e7%82%b9%e6%9b%b4%e6%96%b0">#</a>
</h4>
<h4 id="1222-线上环境如何修改表结构">
  1.2.22 线上环境如何修改表结构
  <a class="anchor" href="#1222-%e7%ba%bf%e4%b8%8a%e7%8e%af%e5%a2%83%e5%a6%82%e4%bd%95%e4%bf%ae%e6%94%b9%e8%a1%a8%e7%bb%93%e6%9e%84">#</a>
</h4>
<ul>
<li>MySQL在进行alter table等DDL操作时，有时会出现Waiting for table metadata lock的情况，后续对表的任何操作都无法进行。对千万数量级的表新增字段或者其他DDL操作，如何保证在不影响在线读写的同时完成表结构的修改？</li>
</ul>
<h3 id="13-redis">
  1.3 Redis
  <a class="anchor" href="#13-redis">#</a>
</h3>
<h4 id="131-redis的5种基本数据类型及对应底层实现">
  1.3.1 Redis的5种基本数据类型及对应底层实现
  <a class="anchor" href="#131-redis%e7%9a%845%e7%a7%8d%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%8f%8a%e5%af%b9%e5%ba%94%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0">#</a>
</h4>
<ul>
<li>1 Redis底层数据结构之SDS</li>
<li>2 Redis底层数据结构之压缩列表ziplist</li>
<li>3 Redis底层数据结构之双端链表linkedlist</li>
<li>4 Redis底层数据结构之快表quicklist</li>
<li>5 Redis底层数据结构之整数集合intset</li>
<li>6 Redis底层数据结构之哈希表hashtable</li>
<li>7 Redis底层数据结构之跳表skiplist</li>
</ul>
<h4 id="132-redis为什么这么快">
  1.3.2 Redis为什么这么快
  <a class="anchor" href="#132-redis%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%99%e4%b9%88%e5%bf%ab">#</a>
</h4>
<p>-(1)Redis是一个键值对内存数据库。</p>
<ul>
<li>(2)使用IO多路复用技术。</li>
<li>(3)非CPU密集型任务。对大key进行非O(1)时间复杂度的操作（CPU密集）会阻塞后续请求，Redis快的前提是不会出现类似情况。</li>
<li>(4)单线程的优势。避免了多线程上下文切换以及共享资源加锁的性能损耗。</li>
</ul>
<h4 id="133-redis持久化之rdb与aof">
  1.3.3 Redis持久化之RDB与AOF
  <a class="anchor" href="#133-redis%e6%8c%81%e4%b9%85%e5%8c%96%e4%b9%8brdb%e4%b8%8eaof">#</a>
</h4>
<h4 id="134-redis实现分布式锁的关键点">
  1.3.4 Redis实现分布式锁的关键点
  <a class="anchor" href="#134-redis%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e7%9a%84%e5%85%b3%e9%94%ae%e7%82%b9">#</a>
</h4>
<ul>
<li>Redis锁主要利用Redis的setnx命令实现，setnx是SET if Not exists的简写。执行setnx key value，当键不存在时，将key的值设置为value，此时锁抢占成功。可以通过删除键值对或者过期时间来释放锁。</li>
<li>实现Redis锁需要注意的事项如下：
<ul>
<li>1 避免死锁
<ul>
<li>设置key的过期时间，以保证即使锁没有被显式释放，也可以在一定时间后自动释放，避免资源被永远锁住。</li>
</ul>
</li>
<li>2 锁续期
<ul>
<li>当前线程获取锁后执行任务，当任务耗时大于Redis key过期时间时，锁会被释放，会存在其他线程获取到该锁的可能。此时可以为已经获取锁的线程增加守护线程，对将要过期但未释放的锁延长有效时间。</li>
</ul>
</li>
<li>3 只允许获取锁的线程释放锁
<ul>
<li>将参与抢锁的客户端id设置在value中(setnx key value)，释放锁前校验value中存放的id是否为自己。</li>
</ul>
</li>
<li>4 互斥性
<ul>
<li>Redis正常运行时执行setnx命令可以保证只允许一个客户端持有锁；当Redis发生主从切换时，key未及时同步到从节点，锁可能被其他客户端再一次获取，针对该场景可引入红锁机制。</li>
</ul>
</li>
<li>5 可重入（可选）
<ul>
<li>若允许当前线程在持有锁的情况下再次请求加锁，那么这个锁就是可重入的。Redis可对锁进行重入计数，加锁时加1，解锁时减1，当计数归0时释放锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="135-redis与memcache的区别">
  1.3.5 Redis与Memcache的区别
  <a class="anchor" href="#135-redis%e4%b8%8ememcache%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h4>
<h4 id="136-redis主从复制原理之sync与psync">
  1.3.6 Redis主从复制原理之SYNC与PSYNC
  <a class="anchor" href="#136-redis%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e5%8e%9f%e7%90%86%e4%b9%8bsync%e4%b8%8epsync">#</a>
</h4>
<h4 id="137-过期删除策略">
  1.3.7 过期删除策略
  <a class="anchor" href="#137-%e8%bf%87%e6%9c%9f%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5">#</a>
</h4>
<ul>
<li>(1)定时删除策略。设置key过期时间的同时创建一个定时器，在键的过期时间来临时立即删除键。定时删除及时释放内存，但浪费CPU。</li>
<li>(2)惰性删除策略。在访问key时顺便检查它是否过期，若过期则删除，否则返回该键值对。惰性删除策略对CPU友好，但浪费内存空间。</li>
<li>(3)定期删除策略。该策略是定时删除和惰性删除方案的折中，每隔一段时间执行一次删除过期key的操作，删除哪些数据库的哪些过期键由算法决定。我们通过限制执行的时长和频率来减少对CPU的影响，同时定期主动删除过期键又有效地减少了内存浪费。</li>
<li>Redis使用的是惰性删除和定期删除策略。</li>
</ul>
<h4 id="138-redis哈希槽-113">
  1.3.8 Redis哈希槽 113
  <a class="anchor" href="#138-redis%e5%93%88%e5%b8%8c%e6%a7%bd-113">#</a>
</h4>
<h4 id="139-redis-gossip协议-114">
  1.3.9 Redis Gossip协议 114
  <a class="anchor" href="#139-redis-gossip%e5%8d%8f%e8%ae%ae-114">#</a>
</h4>
<h4 id="1310-重定向moved与ask-115">
  1.3.10 重定向moved与ask 115
  <a class="anchor" href="#1310-%e9%87%8d%e5%ae%9a%e5%90%91moved%e4%b8%8eask-115">#</a>
</h4>
<h4 id="1311-pipeline有什么好处-116">
  1.3.11 Pipeline有什么好处 116
  <a class="anchor" href="#1311-pipeline%e6%9c%89%e4%bb%80%e4%b9%88%e5%a5%bd%e5%a4%84-116">#</a>
</h4>
<h3 id="14-rocketmq">
  1.4 RocketMQ
  <a class="anchor" href="#14-rocketmq">#</a>
</h3>
<h4 id="141-rocketmq的整体架构">
  1.4.1 RocketMQ的整体架构
  <a class="anchor" href="#141-rocketmq%e7%9a%84%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84">#</a>
</h4>
<h4 id="142-消息队列典型的适用场景">
  1.4.2 消息队列典型的适用场景
  <a class="anchor" href="#142-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e5%85%b8%e5%9e%8b%e7%9a%84%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h4>
<ul>
<li>1 系统解耦</li>
<li>2 削峰填谷</li>
</ul>
<h4 id="143-消费者消费者组队列之间的关系">
  1.4.3 消费者、消费者组、队列之间的关系
  <a class="anchor" href="#143-%e6%b6%88%e8%b4%b9%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e7%bb%84%e9%98%9f%e5%88%97%e4%b9%8b%e9%97%b4%e7%9a%84%e5%85%b3%e7%b3%bb">#</a>
</h4>
<h4 id="144-rocketmq消息发送与消费流程">
  1.4.4 RocketMQ消息发送与消费流程
  <a class="anchor" href="#144-rocketmq%e6%b6%88%e6%81%af%e5%8f%91%e9%80%81%e4%b8%8e%e6%b6%88%e8%b4%b9%e6%b5%81%e7%a8%8b">#</a>
</h4>
<h4 id="145-消息刷盘策略">
  1.4.5 消息刷盘策略
  <a class="anchor" href="#145-%e6%b6%88%e6%81%af%e5%88%b7%e7%9b%98%e7%ad%96%e7%95%a5">#</a>
</h4>
<h4 id="146-底层文件存储设计">
  1.4.6 底层文件存储设计
  <a class="anchor" href="#146-%e5%ba%95%e5%b1%82%e6%96%87%e4%bb%b6%e5%ad%98%e5%82%a8%e8%ae%be%e8%ae%a1">#</a>
</h4>
<h4 id="147-事务消息">
  1.4.7 事务消息
  <a class="anchor" href="#147-%e4%ba%8b%e5%8a%a1%e6%b6%88%e6%81%af">#</a>
</h4>
<h4 id="148-延迟消息">
  1.4.8 延迟消息
  <a class="anchor" href="#148-%e5%bb%b6%e8%bf%9f%e6%b6%88%e6%81%af">#</a>
</h4>
<h4 id="149-如何保证消息不丢失">
  1.4.9 如何保证消息不丢失
  <a class="anchor" href="#149-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e6%b6%88%e6%81%af%e4%b8%8d%e4%b8%a2%e5%a4%b1">#</a>
</h4>
<h4 id="1410-消息过滤-128">
  1.4.10 消息过滤 128
  <a class="anchor" href="#1410-%e6%b6%88%e6%81%af%e8%bf%87%e6%bb%a4-128">#</a>
</h4>
<h4 id="1411-顺序消息-128">
  1.4.11 顺序消息 128
  <a class="anchor" href="#1411-%e9%a1%ba%e5%ba%8f%e6%b6%88%e6%81%af-128">#</a>
</h4>
<h4 id="1412-消费者offset管理">
  1.4.12 消费者offset管理
  <a class="anchor" href="#1412-%e6%b6%88%e8%b4%b9%e8%80%85offset%e7%ae%a1%e7%90%86">#</a>
</h4>
<h4 id="1413-rebalance的危害">
  1.4.13 Rebalance的危害
  <a class="anchor" href="#1413-rebalance%e7%9a%84%e5%8d%b1%e5%ae%b3">#</a>
</h4>
<h4 id="1414-rocketmq与kafka的对比">
  1.4.14 RocketMQ与Kafka的对比
  <a class="anchor" href="#1414-rocketmq%e4%b8%8ekafka%e7%9a%84%e5%af%b9%e6%af%94">#</a>
</h4>
<ul>
<li>1 存储形式</li>
<li>2 延时消息</li>
<li>3 消息重复</li>
<li>4 消息过滤</li>
<li>5 消费失败重试</li>
<li>6 服务发现</li>
<li>7 高可用</li>
</ul>
<h3 id="15-操作系统">
  1.5 操作系统
  <a class="anchor" href="#15-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f">#</a>
</h3>
<h4 id="151-进程与线程的区别">
  1.5.1 进程与线程的区别
  <a class="anchor" href="#151-%e8%bf%9b%e7%a8%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h4>
<ul>
<li>进程是系统进行资源调度和分配的基本单位，用于实现操作系统的并发。线程是CPU调度和分配的基本单位，用来实现进程内部的并发。</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；进程在执行过程中拥有独立的内存单元，而多个线程共享进程的资源。</li>
</ul>
<h4 id="152-为什么页内存大小是4kb">
  1.5.2 为什么页内存大小是4KB
  <a class="anchor" href="#152-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%a1%b5%e5%86%85%e5%ad%98%e5%a4%a7%e5%b0%8f%e6%98%af4kb">#</a>
</h4>
<h4 id="153-进程间的通信方式">
  1.5.3 进程间的通信方式
  <a class="anchor" href="#153-%e8%bf%9b%e7%a8%8b%e9%97%b4%e7%9a%84%e9%80%9a%e4%bf%a1%e6%96%b9%e5%bc%8f">#</a>
</h4>
<h4 id="154-页面置换算法">
  1.5.4 页面置换算法
  <a class="anchor" href="#154-%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95">#</a>
</h4>
<h4 id="155-虚拟内存">
  1.5.5 虚拟内存
  <a class="anchor" href="#155-%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98">#</a>
</h4>
<h4 id="156-为什么多级页表可以节省内存">
  1.5.6 为什么多级页表可以节省内存
  <a class="anchor" href="#156-%e4%b8%ba%e4%bb%80%e4%b9%88%e5%a4%9a%e7%ba%a7%e9%a1%b5%e8%a1%a8%e5%8f%af%e4%bb%a5%e8%8a%82%e7%9c%81%e5%86%85%e5%ad%98">#</a>
</h4>
<h4 id="157-死锁及其产生的条件">
  1.5.7 死锁及其产生的条件
  <a class="anchor" href="#157-%e6%ad%bb%e9%94%81%e5%8f%8a%e5%85%b6%e4%ba%a7%e7%94%9f%e7%9a%84%e6%9d%a1%e4%bb%b6">#</a>
</h4>
<h4 id="158-线程状态转换">
  1.5.8 线程状态转换
  <a class="anchor" href="#158-%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2">#</a>
</h4>
<h4 id="159-进程调度策略">
  1.5.9 进程调度策略
  <a class="anchor" href="#159-%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5">#</a>
</h4>
<h4 id="1510-线程同步有哪几种方式">
  1.5.10 线程同步有哪几种方式
  <a class="anchor" href="#1510-%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e6%96%b9%e5%bc%8f">#</a>
</h4>
<h4 id="1511-内存颠簸">
  1.5.11 内存颠簸
  <a class="anchor" href="#1511-%e5%86%85%e5%ad%98%e9%a2%a0%e7%b0%b8">#</a>
</h4>
<h4 id="1512-局部性原理">
  1.5.12 局部性原理
  <a class="anchor" href="#1512-%e5%b1%80%e9%83%a8%e6%80%a7%e5%8e%9f%e7%90%86">#</a>
</h4>
<h3 id="16-计算机网络">
  1.6 计算机网络
  <a class="anchor" href="#16-%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c">#</a>
</h3>
<h4 id="161-tcp与udp的区别">
  1.6.1 TCP与UDP的区别
  <a class="anchor" href="#161-tcp%e4%b8%8eudp%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h4>
<ul>
<li>
<p>TCP是面向连接的，UDP是无连接的，即发送数据前不需要建立连接。</p>
</li>
<li>
<p>TCP提供可靠的服务，传送数据无差错、不丢失、不重复且按序到达；UDP尽最大努力交付。</p>
</li>
<li>
<p>UDP实时性强，工作效率比TCP高，适用于对传输速度和延迟要求较高的场景，如语音和视频通信等。</p>
</li>
</ul>
<h4 id="162-滑动窗口">
  1.6.2 滑动窗口
  <a class="anchor" href="#162-%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3">#</a>
</h4>
<h4 id="163-拥塞控制">
  1.6.3 拥塞控制
  <a class="anchor" href="#163-%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6">#</a>
</h4>
<ul>
<li>1 慢开始算法</li>
<li>2 拥塞避免算法</li>
<li>3 快重传算法</li>
<li>4 快恢复算法</li>
</ul>
<h4 id="164-重传机制">
  1.6.4 重传机制
  <a class="anchor" href="#164-%e9%87%8d%e4%bc%a0%e6%9c%ba%e5%88%b6">#</a>
</h4>
<ul>
<li>1 超时重传</li>
<li>2 快速重传</li>
<li>3 Selective Acknowledgment，SACK</li>
<li>4 D-SACK</li>
</ul>
<h4 id="165-流量控制">
  1.6.5 流量控制
  <a class="anchor" href="#165-%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6">#</a>
</h4>
<h4 id="166-三次握手与四次挥手">
  1.6.6 三次握手与四次挥手
  <a class="anchor" href="#166-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%b8%8e%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b">#</a>
</h4>
<ul>
<li>1 三次握手建立连接</li>
<li>2 四次挥手</li>
</ul>
<h4 id="167-tcp四次挥手为什么要等待2msl">
  1.6.7 TCP四次挥手为什么要等待2MSL
  <a class="anchor" href="#167-tcp%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%ad%89%e5%be%852msl">#</a>
</h4>
<h4 id="168-一次完整的http请求">
  1.6.8 一次完整的HTTP请求
  <a class="anchor" href="#168-%e4%b8%80%e6%ac%a1%e5%ae%8c%e6%95%b4%e7%9a%84http%e8%af%b7%e6%b1%82">#</a>
</h4>
<ul>
<li>域名解析→3次握手建立TCP连接→发起HTTP请求→服务器返回数据，浏览器渲染页面</li>
<li>域名解析流程</li>
</ul>
<h4 id="169-https加密过程">
  1.6.9 HTTPS加密过程
  <a class="anchor" href="#169-https%e5%8a%a0%e5%af%86%e8%bf%87%e7%a8%8b">#</a>
</h4>
<ul>
<li>1 对称与非对称加密
<ul>
<li>对称加密：所谓对称加密其实就是加密与解密使用同一把密钥。</li>
<li>非对称加密：一对密钥（公钥与私钥），使用其中一个密钥进行加密，另一个密钥进行解密。比如若使用公钥加密，则用私钥解密；若使用私钥加密，则用公钥解密。</li>
</ul>
</li>
<li>2 使用两组非对称密钥可以保证通信安全吗
<ul>
<li>使用两组非对称密钥不可以保证通信安全。举个例子，客户端与服务器端通信，服务器端拥有公钥A与对应的私钥A&rsquo;；客户端拥有公钥B与对应的私钥B&rsquo;。客户端把公钥B明文传输给服务器端，服务器端把公钥A明文给传输给客户端，之后客户端向服务器端传输数据都用公钥A加密，服务器收到后用私钥A&rsquo;解密。同理，服务器端向客户端传输数据都用公钥B加密，客户端收到后用私钥B&rsquo;解密。私钥被通信发起方安全持有，使用两对密钥看起来可以保证信息安全，但其实存在非对称加密耗时与中间人攻击问题。
<ul>
<li>1）非对称加密耗时问题
<ul>
<li>相对于对称加密而言，非对称加密是耗时的，因此仅使用非对称加密的方式传递对称加密的密钥，后续数据通信使用对称密钥加解密。</li>
</ul>
</li>
<li>2）中间人攻击问题
<ul>
<li>中间人分别与客户端和服务端进行密钥协商</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>3 数字签名保障证书不被篡改</li>
</ul>
<h4 id="1610-tcp粘包与拆包">
  1.6.10 TCP粘包与拆包
  <a class="anchor" href="#1610-tcp%e7%b2%98%e5%8c%85%e4%b8%8e%e6%8b%86%e5%8c%85">#</a>
</h4>
<h4 id="1611-nagle算法">
  1.6.11 Nagle算法
  <a class="anchor" href="#1611-nagle%e7%ae%97%e6%b3%95">#</a>
</h4>
<h3 id="17-spring">
  1.7 Spring
  <a class="anchor" href="#17-spring">#</a>
</h3>
<h4 id="171-spring-bean的作用域">
  1.7.1 Spring Bean的作用域
  <a class="anchor" href="#171-spring-bean%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f">#</a>
</h4>
<h4 id="172-spring-bean的生命周期">
  1.7.2 Spring Bean的生命周期
  <a class="anchor" href="#172-spring-bean%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">#</a>
</h4>
<h4 id="173-spring-ioc">
  1.7.3 Spring IoC
  <a class="anchor" href="#173-spring-ioc">#</a>
</h4>
<h4 id="174-spring-aop">
  1.7.4 Spring AOP
  <a class="anchor" href="#174-spring-aop">#</a>
</h4>
<h4 id="175-spring三级缓存解决bean循环依赖">
  1.7.5 Spring三级缓存解决Bean循环依赖
  <a class="anchor" href="#175-spring%e4%b8%89%e7%ba%a7%e7%bc%93%e5%ad%98%e8%a7%a3%e5%86%b3bean%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96">#</a>
</h4>
<h4 id="176-spring事务实现">
  1.7.6 Spring事务实现
  <a class="anchor" href="#176-spring%e4%ba%8b%e5%8a%a1%e5%ae%9e%e7%8e%b0">#</a>
</h4>
<h4 id="177-spring事务失效的典型场景">
  1.7.7 Spring事务失效的典型场景
  <a class="anchor" href="#177-spring%e4%ba%8b%e5%8a%a1%e5%a4%b1%e6%95%88%e7%9a%84%e5%85%b8%e5%9e%8b%e5%9c%ba%e6%99%af">#</a>
</h4>
<h4 id="178-spring中beanfactory和applicationcontext的区别">
  1.7.8 Spring中BeanFactory和ApplicationContext的区别
  <a class="anchor" href="#178-spring%e4%b8%adbeanfactory%e5%92%8capplicationcontext%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h4>
<h3 id="18-zookeeper">
  1.8 ZooKeeper
  <a class="anchor" href="#18-zookeeper">#</a>
</h3>
<h4 id="181-zookeeper典型使用场景">
  1.8.1 ZooKeeper典型使用场景
  <a class="anchor" href="#181-zookeeper%e5%85%b8%e5%9e%8b%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h4>
<ul>
<li>1 分布式锁
<ul>
<li>在开发业务功能时常需要使用定时任务来触发事件，假如我们的服务集群有n台服务器，而定时任务又要求时机来临仅被触发一次，则n台服务器抢锁成功者执行具体任务。</li>
</ul>
</li>
<li>2 配置管理
<ul>
<li>有时需要配置实时生效，比如业务代码中的开关等。如果我们有n台服务器，那么硬编码修改起来就会特别麻烦，并且还需要重新发布应用。</li>
</ul>
</li>
<li>3 服务注册与发现</li>
</ul>
<h4 id="182-zookeeper四种节点类型">
  1.8.2 ZooKeeper四种节点类型
  <a class="anchor" href="#182-zookeeper%e5%9b%9b%e7%a7%8d%e8%8a%82%e7%82%b9%e7%b1%bb%e5%9e%8b">#</a>
</h4>
<h4 id="183-zookeeper的顺序一致性">
  1.8.3 ZooKeeper的顺序一致性
  <a class="anchor" href="#183-zookeeper%e7%9a%84%e9%a1%ba%e5%ba%8f%e4%b8%80%e8%87%b4%e6%80%a7">#</a>
</h4>
<h4 id="184-zookeeper集群节点为什么是奇数个">
  1.8.4 ZooKeeper集群节点为什么是奇数个
  <a class="anchor" href="#184-zookeeper%e9%9b%86%e7%be%a4%e8%8a%82%e7%82%b9%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e5%a5%87%e6%95%b0%e4%b8%aa">#</a>
</h4>
<h4 id="185-zookeeper集群中的三种角色">
  1.8.5 ZooKeeper集群中的三种角色
  <a class="anchor" href="#185-zookeeper%e9%9b%86%e7%be%a4%e4%b8%ad%e7%9a%84%e4%b8%89%e7%a7%8d%e8%a7%92%e8%89%b2">#</a>
</h4>
<h4 id="186-zookeeper的选主机制">
  1.8.6 ZooKeeper的选主机制
  <a class="anchor" href="#186-zookeeper%e7%9a%84%e9%80%89%e4%b8%bb%e6%9c%ba%e5%88%b6">#</a>
</h4>
<h4 id="187-zookeeper与eureka的区别">
  1.8.7 ZooKeeper与Eureka的区别
  <a class="anchor" href="#187-zookeeper%e4%b8%8eeureka%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h4>
<p>-(1)ZooKeeper保证数据一致性(consistency)和分区容错性Partition Tolerance。
ZooKeeper的过半策略保证了数据强一致性，当Leader节点因为网络故障与其他节点失去联系时，剩余节点会重新进行投票，选举出新的Leader，且选举期间整个集群不可用。</p>
<ul>
<li>(2)Eureka保证可用性(Availability)和分区容错性Partition Tolerance。
<ul>
<li>Eureka以对等复制的方式进行数据同步，集群节点都是平等的，即使部分节点挂掉（只要还有一台Eureka在），剩余的节点依然可以提供注册和查询服务。</li>
</ul>
</li>
</ul>
<h4 id="188-zookeeper-atomic-broadcast协议">
  1.8.8 ZooKeeper Atomic Broadcast协议
  <a class="anchor" href="#188-zookeeper-atomic-broadcast%e5%8d%8f%e8%ae%ae">#</a>
</h4>
<h3 id="19-dubbo">
  1.9 Dubbo
  <a class="anchor" href="#19-dubbo">#</a>
</h3>
<h4 id="191-dubbo架构简述">
  1.9.1 Dubbo架构简述
  <a class="anchor" href="#191-dubbo%e6%9e%b6%e6%9e%84%e7%ae%80%e8%bf%b0">#</a>
</h4>
<ul>
<li>Dubbo整体架构由消费者(Consumer)、服务者(Provider)、注册中心(Registry)以及监控器(Monitor)组成。其中，服务者注册服务地址到注册中心，消费者从注册中心读取和订阅服务者地址列表，消费者在发起调用前进行路由选择、负载均衡策略，然后调用至服务者服务器，调用失败则进行集群容错。监控器对调用量、性能指标进行采集上报。</li>
</ul>
<h4 id="192-路由机制">
  1.9.2 路由机制
  <a class="anchor" href="#192-%e8%b7%af%e7%94%b1%e6%9c%ba%e5%88%b6">#</a>
</h4>
<ul>
<li>Dubbo路由机制实现了动态指定服务的提供者，如图1-149所示。admin管理后台动态添加路由的规则，并将它们存储在注册中心${service}/routers目录下，基于注册中心的事件机制最新路由会通知服务消费者（调用方）；服务消费者发起调用前，Dubbo依据配置的路由规则计算出哪些服务提供者可以处理本次请求，然后使用负载均衡策略选择其中一个服务实例来处理本次请求；当服务调用发生异常时，会有一些集群容错的策略。这就是服务调用的基本流程，从中也可以看出路由选择优先级高于集群容错和负载均衡策略。</li>
</ul>
<h4 id="193-负载均衡">
  1.9.3 负载均衡
  <a class="anchor" href="#193-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1">#</a>
</h4>
<ul>
<li>Dubbo负载均衡机制决定了一次请求调用哪个服务提供者</li>
<li>1 RandomLoadBalance：随机负载均衡算法</li>
<li>2 RoundRobinLoadBalance：轮询负载均衡算法</li>
<li>3 LeastActiveLoadBalance：最少活跃数负载均衡算法</li>
<li>4 ConsistentHashLoadBalance：一致性哈希</li>
</ul>
<h4 id="194-集群容错">
  1.9.4 集群容错
  <a class="anchor" href="#194-%e9%9b%86%e7%be%a4%e5%ae%b9%e9%94%99">#</a>
</h4>
<ul>
<li>集群容错是指消费者在调用服务提供者集群发生异常时的处理策略。</li>
<li>1 failover cluster
<ul>
<li>若服务调用失败则自动重试到其他的可用节点。</li>
</ul>
</li>
<li>2 failfast cluster
<ul>
<li>快速失败，即一次调用失败就立即失败，常见于非幂等性的写操作。</li>
</ul>
</li>
<li>3 failsafe cluster
<ul>
<li>快速失败，出现异常时直接忽略，通常用于写入审计日志等不重要的操作。</li>
</ul>
</li>
<li>4 failback cluster
<ul>
<li>失败后定时重试。</li>
</ul>
</li>
<li>5 forking cluster
<ul>
<li>并行调用多个服务提供者，只要有一个成功就立即返回。通常用于实时性要求比较高的读操作。</li>
</ul>
</li>
</ul>
<h4 id="195-dubbo的序列化">
  1.9.5 Dubbo的序列化
  <a class="anchor" href="#195-dubbo%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96">#</a>
</h4>
<p>-(1)Hessian2序列化：Hessian是一种跨语言的高效二进制序列化方式。Dubbo默认启用此序列化方式。
-(2)JSON序列化：易于解析阅读，但这种文本序列化性能一般不如二进制序列化。
-(3)Java序列化：JDK自带的序列化实现，无须引入任何依赖，但性能不理想。</p>
<ul>
<li>(4)Protobuf序列化：Protobuf是由Google设计的一种高效、轻量级的信息描述格式，优点是与语言无关，编码长度更短，传输效率更高，编解码速度更快；缺点是缺乏自描述，可读性差。</li>
</ul>
<h4 id="196-有了http请求为什么还需要rpc调用">
  1.9.6 有了HTTP请求为什么还需要RPC调用
  <a class="anchor" href="#196-%e6%9c%89%e4%ba%86http%e8%af%b7%e6%b1%82%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%98%e9%9c%80%e8%a6%81rpc%e8%b0%83%e7%94%a8">#</a>
</h4>
<p>-(1)HTTP信息效率低，包含了大量的HTTP头等冗余信息</p>
<ul>
<li>(2)业内成熟的RPC框架是面向服务的更高级的封装，其内涵包括了路由策略、负载均衡、集群容错、服务发现、数据统计以及数据看板等，更适用于一个分布式的大型系统内部之间的通信。</li>
</ul>
<h4 id="197-dubbo的spi机制">
  1.9.7 Dubbo的SPI机制
  <a class="anchor" href="#197-dubbo%e7%9a%84spi%e6%9c%ba%e5%88%b6">#</a>
</h4>
<h2 id="第2章-算法题目">
  第2章 算法题目
  <a class="anchor" href="#%e7%ac%ac2%e7%ab%a0-%e7%ae%97%e6%b3%95%e9%a2%98%e7%9b%ae">#</a>
</h2>
<h3 id="21-递归">
  2.1 递归
  <a class="anchor" href="#21-%e9%80%92%e5%bd%92">#</a>
</h3>
<p>2.1.1 算法解释 180
2.1.2 经典题目—爬楼梯 181</p>
<h3 id="22-双指针">
  2.2 双指针
  <a class="anchor" href="#22-%e5%8f%8c%e6%8c%87%e9%92%88">#</a>
</h3>
<p>2.2.1 算法解释 182
2.2.2 经典题目—寻找链表的中间节点（快慢指针） 182
2.2.3 经典题目—有序数组两数之和（对撞指针） 183</p>
<h3 id="23-滑动窗口-184">
  2.3 滑动窗口 184
  <a class="anchor" href="#23-%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3-184">#</a>
</h3>
<p>2.3.1 算法解释 184
2.3.2 经典题目—长度为k的连续子数组的最大和 184</p>
<h3 id="24-二分搜索-185">
  2.4 二分搜索 185
  <a class="anchor" href="#24-%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2-185">#</a>
</h3>
<p>2.4.1 算法解释 185
2.4.2 经典题目——n的算术平方根 185</p>
<h3 id="25-动态规划-186">
  2.5 动态规划 186
  <a class="anchor" href="#25-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92-186">#</a>
</h3>
<p>2.5.1 算法解释 186
2.5.2 经典题目—最小路径和 186</p>
<h3 id="26-回溯-188">
  2.6 回溯 188
  <a class="anchor" href="#26-%e5%9b%9e%e6%ba%af-188">#</a>
</h3>
<p>2.6.1 算法解释 188
2.6.2 经典题目—n皇后问题 188</p>
<h3 id="27-广度深度优先搜索-192">
  2.7 广度/深度优先搜索 192
  <a class="anchor" href="#27-%e5%b9%bf%e5%ba%a6%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2-192">#</a>
</h3>
<p>2.7.1 算法解释 192
2.7.2 经典题目—深度优先搜索岛屿数量 193
2.7.3 经典题目—广度优先搜索层序遍历 194</p>
<h2 id="第3章-设计题-197">
  第3章 设计题 197
  <a class="anchor" href="#%e7%ac%ac3%e7%ab%a0-%e8%ae%be%e8%ae%a1%e9%a2%98-197">#</a>
</h2>
<h3 id="31-秒杀系统-197">
  3.1 秒杀系统 197
  <a class="anchor" href="#31-%e7%a7%92%e6%9d%80%e7%b3%bb%e7%bb%9f-197">#</a>
</h3>
<p>3.1.1 抢购商品允许超卖 197
3.1.2 抢购商品不允许超卖 198
3.1.3 异步消费控制用户并发数避免热点更新 200
3.1.4 用户交互设计角度的兜底考虑 201</p>
<h3 id="32-分布式定时任务-201">
  3.2 分布式定时任务 201
  <a class="anchor" href="#32-%e5%88%86%e5%b8%83%e5%bc%8f%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1-201">#</a>
</h3>
<p>3.2.1 设计思想 202
3.2.2 定时任务具体功能点的实现 203</p>
<h3 id="33-其他高频出现的经典方案设计题目-205">
  3.3 其他高频出现的经典方案设计题目 205
  <a class="anchor" href="#33-%e5%85%b6%e4%bb%96%e9%ab%98%e9%a2%91%e5%87%ba%e7%8e%b0%e7%9a%84%e7%bb%8f%e5%85%b8%e6%96%b9%e6%a1%88%e8%ae%be%e8%ae%a1%e9%a2%98%e7%9b%ae-205">#</a>
</h3>
<h2 id="第4章-一个项目案例分析合约广告库存预估-206">
  第4章 一个项目案例分析：合约广告库存预估 206
  <a class="anchor" href="#%e7%ac%ac4%e7%ab%a0-%e4%b8%80%e4%b8%aa%e9%a1%b9%e7%9b%ae%e6%a1%88%e4%be%8b%e5%88%86%e6%9e%90%e5%90%88%e7%ba%a6%e5%b9%bf%e5%91%8a%e5%ba%93%e5%ad%98%e9%a2%84%e4%bc%b0-206">#</a>
</h2>
<h3 id="41-项目背景-207">
  4.1 项目背景 207
  <a class="anchor" href="#41-%e9%a1%b9%e7%9b%ae%e8%83%8c%e6%99%af-207">#</a>
</h3>
<h3 id="42-系统领域划分与自己所在的位置-207">
  4.2 系统领域划分与自己所在的位置 207
  <a class="anchor" href="#42-%e7%b3%bb%e7%bb%9f%e9%a2%86%e5%9f%9f%e5%88%92%e5%88%86%e4%b8%8e%e8%87%aa%e5%b7%b1%e6%89%80%e5%9c%a8%e7%9a%84%e4%bd%8d%e7%bd%ae-207">#</a>
</h3>
<h3 id="43-发现或者定义一个问题-207">
  4.3 发现或者定义一个问题 207
  <a class="anchor" href="#43-%e5%8f%91%e7%8e%b0%e6%88%96%e8%80%85%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aa%e9%97%ae%e9%a2%98-207">#</a>
</h3>
<h3 id="44-可量化的正向结果-208">
  4.4 可量化的正向结果 208
  <a class="anchor" href="#44-%e5%8f%af%e9%87%8f%e5%8c%96%e7%9a%84%e6%ad%a3%e5%90%91%e7%bb%93%e6%9e%9c-208">#</a>
</h3>
<h3 id="45-未来改进点-209">
  4.5 未来改进点 209
  <a class="anchor" href="#45-%e6%9c%aa%e6%9d%a5%e6%94%b9%e8%bf%9b%e7%82%b9-209">#</a>
</h3>
<h2 id="第5章-一个完整的后端系统-211">
  第5章 一个完整的后端系统 211
  <a class="anchor" href="#%e7%ac%ac5%e7%ab%a0-%e4%b8%80%e4%b8%aa%e5%ae%8c%e6%95%b4%e7%9a%84%e5%90%8e%e7%ab%af%e7%b3%bb%e7%bb%9f-211">#</a>
</h2>
<h3 id="51-接入层nginx与网关-212">
  5.1 接入层（Nginx与网关） 212
  <a class="anchor" href="#51-%e6%8e%a5%e5%85%a5%e5%b1%82nginx%e4%b8%8e%e7%bd%91%e5%85%b3-212">#</a>
</h3>
<h3 id="52-业务层-212">
  5.2 业务层 212
  <a class="anchor" href="#52-%e4%b8%9a%e5%8a%a1%e5%b1%82-212">#</a>
</h3>
<h3 id="53-数据层db分布式缓存本地内存-213">
  5.3 数据层（DB→分布式缓存→本地内存） 213
  <a class="anchor" href="#53-%e6%95%b0%e6%8d%ae%e5%b1%82db%e5%88%86%e5%b8%83%e5%bc%8f%e7%bc%93%e5%ad%98%e6%9c%ac%e5%9c%b0%e5%86%85%e5%ad%98-213">#</a>
</h3>
<h2 id="第6章-hr面试技巧头部大厂hr访谈-215">
  第6章 HR面试技巧——头部大厂HR访谈 215
  <a class="anchor" href="#%e7%ac%ac6%e7%ab%a0-hr%e9%9d%a2%e8%af%95%e6%8a%80%e5%b7%a7%e5%a4%b4%e9%83%a8%e5%a4%a7%e5%8e%82hr%e8%ae%bf%e8%b0%88-215">#</a>
</h2>
<h3 id="61-面试的全流程不要以为通过技术hr面试就能拿offer-215">
  6.1 面试的全流程—不要以为通过技术&amp;HR面试就能拿Offer 215
  <a class="anchor" href="#61-%e9%9d%a2%e8%af%95%e7%9a%84%e5%85%a8%e6%b5%81%e7%a8%8b%e4%b8%8d%e8%a6%81%e4%bb%a5%e4%b8%ba%e9%80%9a%e8%bf%87%e6%8a%80%e6%9c%afhr%e9%9d%a2%e8%af%95%e5%b0%b1%e8%83%bd%e6%8b%bfoffer-215">#</a>
</h3>
<h3 id="62-跳槽时找谁内推更容易通过面试-216">
  6.2 跳槽时找谁内推更容易通过面试 216
  <a class="anchor" href="#62-%e8%b7%b3%e6%a7%bd%e6%97%b6%e6%89%be%e8%b0%81%e5%86%85%e6%8e%a8%e6%9b%b4%e5%ae%b9%e6%98%93%e9%80%9a%e8%bf%87%e9%9d%a2%e8%af%95-216">#</a>
</h3>
<h3 id="63-谈薪技巧-217">
  6.3 谈薪技巧 217
  <a class="anchor" href="#63-%e8%b0%88%e8%96%aa%e6%8a%80%e5%b7%a7-217">#</a>
</h3>
<h3 id="64-反问环节怎么提问能加分-217">
  6.4 反问环节—怎么提问能加分 217
  <a class="anchor" href="#64-%e5%8f%8d%e9%97%ae%e7%8e%af%e8%8a%82%e6%80%8e%e4%b9%88%e6%8f%90%e9%97%ae%e8%83%bd%e5%8a%a0%e5%88%86-217">#</a>
</h3>
<h3 id="65-你的职业规划-218">
  6.5 你的职业规划 218
  <a class="anchor" href="#65-%e4%bd%a0%e7%9a%84%e8%81%8c%e4%b8%9a%e8%a7%84%e5%88%92-218">#</a>
</h3>
<h3 id="66-为什么要跳槽-218">
  6.6 为什么要跳槽 218
  <a class="anchor" href="#66-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%b7%b3%e6%a7%bd-218">#</a>
</h3>
<h3 id="67-你的优点和缺点-218">
  6.7 你的优点和缺点 218
  <a class="anchor" href="#67-%e4%bd%a0%e7%9a%84%e4%bc%98%e7%82%b9%e5%92%8c%e7%bc%ba%e7%82%b9-218">#</a>
</h3>
<h3 id="68-过往工作中取得的成果-219">
  6.8 过往工作中取得的成果 219
  <a class="anchor" href="#68-%e8%bf%87%e5%be%80%e5%b7%a5%e4%bd%9c%e4%b8%ad%e5%8f%96%e5%be%97%e7%9a%84%e6%88%90%e6%9e%9c-219">#</a>
</h3>
<h3 id="69-过往工作中遇到的困难是怎么解决的-219">
  6.9 过往工作中遇到的困难是怎么解决的 219
  <a class="anchor" href="#69-%e8%bf%87%e5%be%80%e5%b7%a5%e4%bd%9c%e4%b8%ad%e9%81%87%e5%88%b0%e7%9a%84%e5%9b%b0%e9%9a%be%e6%98%af%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3%e7%9a%84-219">#</a>
</h3>
<h3 id="610-行业薪酬水平-219">
  6.10 行业薪酬水平 219
  <a class="anchor" href="#610-%e8%a1%8c%e4%b8%9a%e8%96%aa%e9%85%ac%e6%b0%b4%e5%b9%b3-219">#</a>
</h3>
<h3 id="611-没有做出算法题是否一定会被淘汰-224">
  6.11 没有做出算法题是否一定会被淘汰 224
  <a class="anchor" href="#611-%e6%b2%a1%e6%9c%89%e5%81%9a%e5%87%ba%e7%ae%97%e6%b3%95%e9%a2%98%e6%98%af%e5%90%a6%e4%b8%80%e5%ae%9a%e4%bc%9a%e8%a2%ab%e6%b7%98%e6%b1%b0-224">#</a>
</h3>
<h3 id="612-能不能短时间内频繁面试同一家公司-224">
  6.12 能不能短时间内频繁面试同一家公司 224
  <a class="anchor" href="#612-%e8%83%bd%e4%b8%8d%e8%83%bd%e7%9f%ad%e6%97%b6%e9%97%b4%e5%86%85%e9%a2%91%e7%b9%81%e9%9d%a2%e8%af%95%e5%90%8c%e4%b8%80%e5%ae%b6%e5%85%ac%e5%8f%b8-224">#</a>
</h3>
<h3 id="613-毕业季应选择什么样的公司-225">
  6.13 “毕业季”应选择什么样的公司 225
  <a class="anchor" href="#613-%e6%af%95%e4%b8%9a%e5%ad%a3%e5%ba%94%e9%80%89%e6%8b%a9%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e5%85%ac%e5%8f%b8-225">#</a>
</h3>
<h3 id="614-国内互联网面试为什么要刷题-225">
  6.14 国内互联网面试为什么要刷题 225
  <a class="anchor" href="#614-%e5%9b%bd%e5%86%85%e4%ba%92%e8%81%94%e7%bd%91%e9%9d%a2%e8%af%95%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%88%b7%e9%a2%98-225">#</a>
</h3>
<h3 id="615-薪酬报高了会不会被hr直接淘汰-225">
  6.15 薪酬报高了会不会被HR直接淘汰 225
  <a class="anchor" href="#615-%e8%96%aa%e9%85%ac%e6%8a%a5%e9%ab%98%e4%ba%86%e4%bc%9a%e4%b8%8d%e4%bc%9a%e8%a2%abhr%e7%9b%b4%e6%8e%a5%e6%b7%98%e6%b1%b0-225">#</a>
</h3>
<h3 id="616-几年一跳算频繁-226">
  6.16 几年一跳算频繁 226
  <a class="anchor" href="#616-%e5%87%a0%e5%b9%b4%e4%b8%80%e8%b7%b3%e7%ae%97%e9%a2%91%e7%b9%81-226">#</a>
</h3>
<h3 id="617-你是如何学习技术的-226">
  6.17 你是如何学习技术的 226
  <a class="anchor" href="#617-%e4%bd%a0%e6%98%af%e5%a6%82%e4%bd%95%e5%ad%a6%e4%b9%a0%e6%8a%80%e6%9c%af%e7%9a%84-226">#</a>
</h3>
<h3 id="618-思维发散题目-227">
  6.18 思维发散题目 227
  <a class="anchor" href="#618-%e6%80%9d%e7%bb%b4%e5%8f%91%e6%95%a3%e9%a2%98%e7%9b%ae-227">#</a>
</h3>
<h2 id="参考文献-229">
  参考文献 229
  <a class="anchor" href="#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae-229">#</a>
</h2>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第1章-八股文">第1章 八股文</a>
      <ul>
        <li><a href="#11-综合知识">1.1 综合知识</a>
          <ul>
            <li><a href="#111-单元化高可用架构演进历程">1.1.1 单元化高可用架构演进历程</a></li>
            <li><a href="#112-java中5种重要的队列">1.1.2 Java中5种重要的队列</a></li>
            <li><a href="#113-io多路复用">1.1.3 IO多路复用</a></li>
            <li><a href="#114-reentrantlock锁与syschronized锁">1.1.4 ReentrantLock锁与Syschronized锁</a></li>
            <li><a href="#115-java-spi机制">1.1.5 Java SPI机制</a></li>
            <li><a href="#116-限流算法">1.1.6 限流算法</a></li>
            <li><a href="#117-领域驱动设计">1.1.7 领域驱动设计</a></li>
            <li><a href="#118-hashmap的底层原理">1.1.8 HashMap的底层原理</a></li>
            <li><a href="#119-jvm垃圾回收机制">1.1.9 JVM垃圾回收机制</a></li>
            <li><a href="#1110-零复制">1.1.10 零复制</a></li>
            <li><a href="#1111-tcc柔性事务">1.1.11 TCC柔性事务</a></li>
            <li><a href="#1112-cap与base">1.1.12 CAP与BASE</a></li>
            <li><a href="#1113-volatile关键字">1.1.13 Volatile关键字</a></li>
            <li><a href="#1114-双亲委派类加载器">1.1.14 双亲委派类加载器</a></li>
            <li><a href="#1115-从微服务到service-mesh">1.1.15 从微服务到Service Mesh</a></li>
            <li><a href="#1116-进程线程与协程">1.1.16 进程、线程与协程</a></li>
            <li><a href="#1117-强引用软引用弱引用虚引用">1.1.17 强引用、软引用、弱引用、虚引用</a></li>
            <li><a href="#1118-threadlocal">1.1.18 ThreadLocal</a></li>
            <li><a href="#1119-线程池">1.1.19 线程池</a></li>
            <li><a href="#1120-控制访问某个资源或方法的并发数">1.1.20 控制访问某个资源或方法的并发数</a></li>
            <li><a href="#1121-happens-before">1.1.21 Happens-Before</a></li>
            <li><a href="#1122-对java的理解">1.1.22 对Java的理解</a></li>
            <li><a href="#1123-缓存穿透雪崩击穿">1.1.23 缓存穿透、雪崩、击穿</a></li>
            <li><a href="#1124-虚拟机与容器对比">1.1.24 虚拟机与容器对比</a></li>
            <li><a href="#1125-保障系统高可用的一般方法">1.1.25 保障系统高可用的一般方法</a></li>
            <li><a href="#1126-伪共享">1.1.26 伪共享</a></li>
            <li><a href="#1127-caffeine缓存高性能分析">1.1.27 Caffeine缓存高性能分析</a></li>
            <li><a href="#1128-请自我介绍一下">1.1.28 请自我介绍一下</a></li>
          </ul>
        </li>
        <li><a href="#12-数据库">1.2 数据库</a>
          <ul>
            <li><a href="#121-一次sql查询的执行过程">1.2.1 一次SQL查询的执行过程</a></li>
            <li><a href="#122-binlog日志备份的3种模式">1.2.2 binlog日志备份的3种模式</a></li>
            <li><a href="#123-事务的两阶段提交">1.2.3 事务的两阶段提交</a></li>
            <li><a href="#124-二叉搜索树平衡树红黑树b树b树的区别">1.2.4 二叉搜索树、平衡树、红黑树、B树、B+树的区别</a></li>
            <li><a href="#125-mysql存储引擎innodb与myisam的区别">1.2.5 MySQL存储引擎InnoDB与MyISAM的区别</a></li>
            <li><a href="#126-聚集索引与非聚集索引的区别">1.2.6 聚集索引与非聚集索引的区别</a></li>
            <li><a href="#127-数据库事务的4大特性">1.2.7 数据库事务的4大特性</a></li>
            <li><a href="#128-事务隔离级别与脏读不可重复读幻读">1.2.8 事务隔离级别与脏读、不可重复读、幻读</a></li>
            <li><a href="#129-redoundobinlog数据库日志的作用">1.2.9 redo、undo、binlog数据库日志的作用</a></li>
            <li><a href="#1210-多版本并发控制">1.2.10 多版本并发控制</a></li>
            <li><a href="#1211-数据库行锁表锁乐观锁与悲观锁">1.2.11 数据库行锁、表锁、乐观锁与悲观锁</a></li>
            <li><a href="#1212-当前读与快照读">1.2.12 当前读与快照读</a></li>
            <li><a href="#1213-幻读是怎么解决的">1.2.13 幻读是怎么解决的</a></li>
            <li><a href="#1214-sql索引优化">1.2.14 SQL索引优化</a></li>
            <li><a href="#1215-dao层缓存先更新缓存还是先更新数据库">1.2.15 Dao层缓存先更新缓存还是先更新数据库</a></li>
            <li><a href="#1216-mysql高可用架构">1.2.16 MySQL高可用架构</a></li>
            <li><a href="#1217-为什么遇到范围查询会停止索引的最左匹配">1.2.17 为什么遇到范围查询会停止索引的最左匹配</a></li>
            <li><a href="#1218-索引下推">1.2.18 索引下推</a></li>
            <li><a href="#1219-索引覆盖">1.2.19 索引覆盖</a></li>
            <li><a href="#1220-经典sql语句考察group-byjoinhaving">1.2.20 经典SQL语句考察：group by、join、having</a></li>
            <li><a href="#1221-避免数据库热点更新">1.2.21 避免数据库热点更新</a></li>
            <li><a href="#1222-线上环境如何修改表结构">1.2.22 线上环境如何修改表结构</a></li>
          </ul>
        </li>
        <li><a href="#13-redis">1.3 Redis</a>
          <ul>
            <li><a href="#131-redis的5种基本数据类型及对应底层实现">1.3.1 Redis的5种基本数据类型及对应底层实现</a></li>
            <li><a href="#132-redis为什么这么快">1.3.2 Redis为什么这么快</a></li>
            <li><a href="#133-redis持久化之rdb与aof">1.3.3 Redis持久化之RDB与AOF</a></li>
            <li><a href="#134-redis实现分布式锁的关键点">1.3.4 Redis实现分布式锁的关键点</a></li>
            <li><a href="#135-redis与memcache的区别">1.3.5 Redis与Memcache的区别</a></li>
            <li><a href="#136-redis主从复制原理之sync与psync">1.3.6 Redis主从复制原理之SYNC与PSYNC</a></li>
            <li><a href="#137-过期删除策略">1.3.7 过期删除策略</a></li>
            <li><a href="#138-redis哈希槽-113">1.3.8 Redis哈希槽 113</a></li>
            <li><a href="#139-redis-gossip协议-114">1.3.9 Redis Gossip协议 114</a></li>
            <li><a href="#1310-重定向moved与ask-115">1.3.10 重定向moved与ask 115</a></li>
            <li><a href="#1311-pipeline有什么好处-116">1.3.11 Pipeline有什么好处 116</a></li>
          </ul>
        </li>
        <li><a href="#14-rocketmq">1.4 RocketMQ</a>
          <ul>
            <li><a href="#141-rocketmq的整体架构">1.4.1 RocketMQ的整体架构</a></li>
            <li><a href="#142-消息队列典型的适用场景">1.4.2 消息队列典型的适用场景</a></li>
            <li><a href="#143-消费者消费者组队列之间的关系">1.4.3 消费者、消费者组、队列之间的关系</a></li>
            <li><a href="#144-rocketmq消息发送与消费流程">1.4.4 RocketMQ消息发送与消费流程</a></li>
            <li><a href="#145-消息刷盘策略">1.4.5 消息刷盘策略</a></li>
            <li><a href="#146-底层文件存储设计">1.4.6 底层文件存储设计</a></li>
            <li><a href="#147-事务消息">1.4.7 事务消息</a></li>
            <li><a href="#148-延迟消息">1.4.8 延迟消息</a></li>
            <li><a href="#149-如何保证消息不丢失">1.4.9 如何保证消息不丢失</a></li>
            <li><a href="#1410-消息过滤-128">1.4.10 消息过滤 128</a></li>
            <li><a href="#1411-顺序消息-128">1.4.11 顺序消息 128</a></li>
            <li><a href="#1412-消费者offset管理">1.4.12 消费者offset管理</a></li>
            <li><a href="#1413-rebalance的危害">1.4.13 Rebalance的危害</a></li>
            <li><a href="#1414-rocketmq与kafka的对比">1.4.14 RocketMQ与Kafka的对比</a></li>
          </ul>
        </li>
        <li><a href="#15-操作系统">1.5 操作系统</a>
          <ul>
            <li><a href="#151-进程与线程的区别">1.5.1 进程与线程的区别</a></li>
            <li><a href="#152-为什么页内存大小是4kb">1.5.2 为什么页内存大小是4KB</a></li>
            <li><a href="#153-进程间的通信方式">1.5.3 进程间的通信方式</a></li>
            <li><a href="#154-页面置换算法">1.5.4 页面置换算法</a></li>
            <li><a href="#155-虚拟内存">1.5.5 虚拟内存</a></li>
            <li><a href="#156-为什么多级页表可以节省内存">1.5.6 为什么多级页表可以节省内存</a></li>
            <li><a href="#157-死锁及其产生的条件">1.5.7 死锁及其产生的条件</a></li>
            <li><a href="#158-线程状态转换">1.5.8 线程状态转换</a></li>
            <li><a href="#159-进程调度策略">1.5.9 进程调度策略</a></li>
            <li><a href="#1510-线程同步有哪几种方式">1.5.10 线程同步有哪几种方式</a></li>
            <li><a href="#1511-内存颠簸">1.5.11 内存颠簸</a></li>
            <li><a href="#1512-局部性原理">1.5.12 局部性原理</a></li>
          </ul>
        </li>
        <li><a href="#16-计算机网络">1.6 计算机网络</a>
          <ul>
            <li><a href="#161-tcp与udp的区别">1.6.1 TCP与UDP的区别</a></li>
            <li><a href="#162-滑动窗口">1.6.2 滑动窗口</a></li>
            <li><a href="#163-拥塞控制">1.6.3 拥塞控制</a></li>
            <li><a href="#164-重传机制">1.6.4 重传机制</a></li>
            <li><a href="#165-流量控制">1.6.5 流量控制</a></li>
            <li><a href="#166-三次握手与四次挥手">1.6.6 三次握手与四次挥手</a></li>
            <li><a href="#167-tcp四次挥手为什么要等待2msl">1.6.7 TCP四次挥手为什么要等待2MSL</a></li>
            <li><a href="#168-一次完整的http请求">1.6.8 一次完整的HTTP请求</a></li>
            <li><a href="#169-https加密过程">1.6.9 HTTPS加密过程</a></li>
            <li><a href="#1610-tcp粘包与拆包">1.6.10 TCP粘包与拆包</a></li>
            <li><a href="#1611-nagle算法">1.6.11 Nagle算法</a></li>
          </ul>
        </li>
        <li><a href="#17-spring">1.7 Spring</a>
          <ul>
            <li><a href="#171-spring-bean的作用域">1.7.1 Spring Bean的作用域</a></li>
            <li><a href="#172-spring-bean的生命周期">1.7.2 Spring Bean的生命周期</a></li>
            <li><a href="#173-spring-ioc">1.7.3 Spring IoC</a></li>
            <li><a href="#174-spring-aop">1.7.4 Spring AOP</a></li>
            <li><a href="#175-spring三级缓存解决bean循环依赖">1.7.5 Spring三级缓存解决Bean循环依赖</a></li>
            <li><a href="#176-spring事务实现">1.7.6 Spring事务实现</a></li>
            <li><a href="#177-spring事务失效的典型场景">1.7.7 Spring事务失效的典型场景</a></li>
            <li><a href="#178-spring中beanfactory和applicationcontext的区别">1.7.8 Spring中BeanFactory和ApplicationContext的区别</a></li>
          </ul>
        </li>
        <li><a href="#18-zookeeper">1.8 ZooKeeper</a>
          <ul>
            <li><a href="#181-zookeeper典型使用场景">1.8.1 ZooKeeper典型使用场景</a></li>
            <li><a href="#182-zookeeper四种节点类型">1.8.2 ZooKeeper四种节点类型</a></li>
            <li><a href="#183-zookeeper的顺序一致性">1.8.3 ZooKeeper的顺序一致性</a></li>
            <li><a href="#184-zookeeper集群节点为什么是奇数个">1.8.4 ZooKeeper集群节点为什么是奇数个</a></li>
            <li><a href="#185-zookeeper集群中的三种角色">1.8.5 ZooKeeper集群中的三种角色</a></li>
            <li><a href="#186-zookeeper的选主机制">1.8.6 ZooKeeper的选主机制</a></li>
            <li><a href="#187-zookeeper与eureka的区别">1.8.7 ZooKeeper与Eureka的区别</a></li>
            <li><a href="#188-zookeeper-atomic-broadcast协议">1.8.8 ZooKeeper Atomic Broadcast协议</a></li>
          </ul>
        </li>
        <li><a href="#19-dubbo">1.9 Dubbo</a>
          <ul>
            <li><a href="#191-dubbo架构简述">1.9.1 Dubbo架构简述</a></li>
            <li><a href="#192-路由机制">1.9.2 路由机制</a></li>
            <li><a href="#193-负载均衡">1.9.3 负载均衡</a></li>
            <li><a href="#194-集群容错">1.9.4 集群容错</a></li>
            <li><a href="#195-dubbo的序列化">1.9.5 Dubbo的序列化</a></li>
            <li><a href="#196-有了http请求为什么还需要rpc调用">1.9.6 有了HTTP请求为什么还需要RPC调用</a></li>
            <li><a href="#197-dubbo的spi机制">1.9.7 Dubbo的SPI机制</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第2章-算法题目">第2章 算法题目</a>
      <ul>
        <li><a href="#21-递归">2.1 递归</a></li>
        <li><a href="#22-双指针">2.2 双指针</a></li>
        <li><a href="#23-滑动窗口-184">2.3 滑动窗口 184</a></li>
        <li><a href="#24-二分搜索-185">2.4 二分搜索 185</a></li>
        <li><a href="#25-动态规划-186">2.5 动态规划 186</a></li>
        <li><a href="#26-回溯-188">2.6 回溯 188</a></li>
        <li><a href="#27-广度深度优先搜索-192">2.7 广度/深度优先搜索 192</a></li>
      </ul>
    </li>
    <li><a href="#第3章-设计题-197">第3章 设计题 197</a>
      <ul>
        <li><a href="#31-秒杀系统-197">3.1 秒杀系统 197</a></li>
        <li><a href="#32-分布式定时任务-201">3.2 分布式定时任务 201</a></li>
        <li><a href="#33-其他高频出现的经典方案设计题目-205">3.3 其他高频出现的经典方案设计题目 205</a></li>
      </ul>
    </li>
    <li><a href="#第4章-一个项目案例分析合约广告库存预估-206">第4章 一个项目案例分析：合约广告库存预估 206</a>
      <ul>
        <li><a href="#41-项目背景-207">4.1 项目背景 207</a></li>
        <li><a href="#42-系统领域划分与自己所在的位置-207">4.2 系统领域划分与自己所在的位置 207</a></li>
        <li><a href="#43-发现或者定义一个问题-207">4.3 发现或者定义一个问题 207</a></li>
        <li><a href="#44-可量化的正向结果-208">4.4 可量化的正向结果 208</a></li>
        <li><a href="#45-未来改进点-209">4.5 未来改进点 209</a></li>
      </ul>
    </li>
    <li><a href="#第5章-一个完整的后端系统-211">第5章 一个完整的后端系统 211</a>
      <ul>
        <li><a href="#51-接入层nginx与网关-212">5.1 接入层（Nginx与网关） 212</a></li>
        <li><a href="#52-业务层-212">5.2 业务层 212</a></li>
        <li><a href="#53-数据层db分布式缓存本地内存-213">5.3 数据层（DB→分布式缓存→本地内存） 213</a></li>
      </ul>
    </li>
    <li><a href="#第6章-hr面试技巧头部大厂hr访谈-215">第6章 HR面试技巧——头部大厂HR访谈 215</a>
      <ul>
        <li><a href="#61-面试的全流程不要以为通过技术hr面试就能拿offer-215">6.1 面试的全流程—不要以为通过技术&amp;HR面试就能拿Offer 215</a></li>
        <li><a href="#62-跳槽时找谁内推更容易通过面试-216">6.2 跳槽时找谁内推更容易通过面试 216</a></li>
        <li><a href="#63-谈薪技巧-217">6.3 谈薪技巧 217</a></li>
        <li><a href="#64-反问环节怎么提问能加分-217">6.4 反问环节—怎么提问能加分 217</a></li>
        <li><a href="#65-你的职业规划-218">6.5 你的职业规划 218</a></li>
        <li><a href="#66-为什么要跳槽-218">6.6 为什么要跳槽 218</a></li>
        <li><a href="#67-你的优点和缺点-218">6.7 你的优点和缺点 218</a></li>
        <li><a href="#68-过往工作中取得的成果-219">6.8 过往工作中取得的成果 219</a></li>
        <li><a href="#69-过往工作中遇到的困难是怎么解决的-219">6.9 过往工作中遇到的困难是怎么解决的 219</a></li>
        <li><a href="#610-行业薪酬水平-219">6.10 行业薪酬水平 219</a></li>
        <li><a href="#611-没有做出算法题是否一定会被淘汰-224">6.11 没有做出算法题是否一定会被淘汰 224</a></li>
        <li><a href="#612-能不能短时间内频繁面试同一家公司-224">6.12 能不能短时间内频繁面试同一家公司 224</a></li>
        <li><a href="#613-毕业季应选择什么样的公司-225">6.13 “毕业季”应选择什么样的公司 225</a></li>
        <li><a href="#614-国内互联网面试为什么要刷题-225">6.14 国内互联网面试为什么要刷题 225</a></li>
        <li><a href="#615-薪酬报高了会不会被hr直接淘汰-225">6.15 薪酬报高了会不会被HR直接淘汰 225</a></li>
        <li><a href="#616-几年一跳算频繁-226">6.16 几年一跳算频繁 226</a></li>
        <li><a href="#617-你是如何学习技术的-226">6.17 你是如何学习技术的 226</a></li>
        <li><a href="#618-思维发散题目-227">6.18 思维发散题目 227</a></li>
      </ul>
    </li>
    <li><a href="#参考文献-229">参考文献 229</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












