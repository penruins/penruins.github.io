<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Penruins</title>
    <link>/zh/post/books/computer-science/</link>
    <description>Recent content on Penruins</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="/zh/post/books/computer-science/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java并发编程实战</title>
      <link>/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/10484692/&#34;&gt;Java并发编程实战&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第1章-简介&#34;&gt;&#xA;  第1章 简介&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac1%e7%ab%a0-%e7%ae%80%e4%bb%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-并发简史&#34;&gt;&#xA;  1.1 并发简史&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#11-%e5%b9%b6%e5%8f%91%e7%ae%80%e5%8f%b2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;12-线程的优势&#34;&gt;&#xA;  1.2 线程的优势&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#12-%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%bc%98%e5%8a%bf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;13-线程带来的风险&#34;&gt;&#xA;  1.3 线程带来的风险&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#13-%e7%ba%bf%e7%a8%8b%e5%b8%a6%e6%9d%a5%e7%9a%84%e9%a3%8e%e9%99%a9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;14-线程无处不在&#34;&gt;&#xA;  1.4 线程无处不在&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#14-%e7%ba%bf%e7%a8%8b%e6%97%a0%e5%a4%84%e4%b8%8d%e5%9c%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;开发线程安全的类比开发非线程安全的类要更加谨慎和细致&lt;/li&gt;&#xA;&lt;li&gt;每个Java应用程序都会使用线程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当JVM启动时，它将为JVM的内部任务（例如，&lt;strong&gt;垃圾收集&lt;/strong&gt;、&lt;strong&gt;终结操作&lt;/strong&gt;等）创建后台线程，并创建一个&lt;strong&gt;主线程&lt;/strong&gt;来运行main方法。&lt;/li&gt;&#xA;&lt;li&gt;AWT（Abstract Window Toolkit，抽象窗口工具库）和Swing的用户界面框架将创建线程来管理&lt;strong&gt;用户界面事件&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;Timer将创建线程来&lt;strong&gt;执行延迟任务&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;一些组件框架，例如Servlet和RMI，都会创建线程池并调用这些线程中的方法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;当某个框架在应用程序中引入并发性时，&lt;strong&gt;通常不可能将并发性仅局限于框架代码&lt;/strong&gt;，因为框架本身会回调（Callback）应用程序的代码，而这些代码将访问应用程序的状态。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;对线程安全性的需求也不能局限于被调用的代码，而是要延伸到需要访问这些代码所访问的程序状态的所有代码路径&lt;/strong&gt;。因此，对线程安全性的需求将在程序中蔓延开来。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第2章-线程安全性&#34;&gt;&#xA;  第2章 线程安全性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac2%e7%ab%a0-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;要编写线程安全的代码，其核心在于要&lt;strong&gt;对状态访问操作进行管理&lt;/strong&gt;，特别是对&lt;strong&gt;共享的（Shared）和可变的（Mutable）状态&lt;/strong&gt;的访问。&lt;/li&gt;&#xA;&lt;li&gt;“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。&lt;/li&gt;&#xA;&lt;li&gt;一个对象是否需要是线程安全的，取决于它是否被多个线程访问&lt;/li&gt;&#xA;&lt;li&gt;当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java中的主要同步机制是关键字&lt;strong&gt;synchronized&lt;/strong&gt;，它提供了一种独占的加锁方式，但“同步”这个术语还包括&lt;strong&gt;volatile类型的变量&lt;/strong&gt;，&lt;strong&gt;显式锁（Explicit Lock）&lt;strong&gt;以及&lt;/strong&gt;原子变量&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;21-什么是线程安全性&#34;&gt;&#xA;  2.1 什么是线程安全性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#21-%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在线程安全性的定义中，最核心的概念就是&lt;strong&gt;正确性&lt;/strong&gt;。如果对线程安全性的定义是模糊的，那么就是因为缺乏对正确性的清晰定义。&lt;/li&gt;&#xA;&lt;li&gt;正确性的含义是，&lt;strong&gt;某个类的行为与其规范完全一致&lt;/strong&gt;。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件（Postcondition）来描述对象操作的结果。&lt;/li&gt;&#xA;&lt;li&gt;线程安全性：&lt;strong&gt;当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的&lt;/strong&gt;。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当多个线程访问某个类时，不管运行时环境&lt;strong&gt;采用何种调度方式&lt;/strong&gt;或者这些&lt;strong&gt;线程将如何交替执行&lt;/strong&gt;，并且&lt;strong&gt;在主调代码中不需要任何额外的同步或协同&lt;/strong&gt;，这个类都能表现出正确的行为，那么就称这个类是线程安全的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。&lt;/li&gt;&#xA;&lt;li&gt;无状态对象一定是线程安全的&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大多数Servlet都是无状态的，从而极大地降低了在实现Servlet线程安全性时的复杂性。只有当Servlet在处理请求时需要保存一些信息，线程安全性才会成为一个问题。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;22-原子性&#34;&gt;&#xA;  2.2 原子性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#22-%e5%8e%9f%e5%ad%90%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：&lt;strong&gt;竞态条件（Race Condition）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;221-竞态条件&#34;&gt;&#xA;  2.2.1 竞态条件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#221-%e7%ab%9e%e6%80%81%e6%9d%a1%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件&lt;/strong&gt;。换句话说，就是正确的结果要取决于运气&lt;/li&gt;&#xA;&lt;li&gt;“先检查后执行”：首先观察到某个条件为真（例如文件X不存在），然后根据这个观察结果采用相应的动作（创建文件X），但事实上，&lt;strong&gt;在你观察到这个结果以及开始创建文件之间，观察结果可能变得无效&lt;/strong&gt;（另一个线程在这期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;222-示例延迟初始化中的竞态条件&#34;&gt;&#xA;  2.2.2 示例：延迟初始化中的竞态条件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#222-%e7%a4%ba%e4%be%8b%e5%bb%b6%e8%bf%9f%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%ad%e7%9a%84%e7%ab%9e%e6%80%81%e6%9d%a1%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。&lt;/li&gt;&#xA;&lt;li&gt;假定线程A和线程B同时执行getInstance。A看到instance为空，因而创建一个新的ExpensiveObject实例。B同样需要判断instance是否为空。此时的instance是否为空，要取决于不可预测的时序，包括线程的调度方式，以及A需要花多长时间来初始化ExpensiveObject并设置instance。如果当B检查时，instance为空，那么在两次调用getInstance时可能会得到不同的结果，即使getInstance通常被认为是返回相同的实例。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;223-复合操作&#34;&gt;&#xA;  2.2.3 复合操作&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#223-%e5%a4%8d%e5%90%88%e6%93%8d%e4%bd%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。&lt;/li&gt;&#xA;&lt;li&gt;假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是&lt;strong&gt;原子的&lt;/strong&gt;。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;在&lt;strong&gt;java.util.concurrent.atomic&lt;/strong&gt;包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。通过用AtomicLong来代替long类型的计数器，能够确保所有对计数器状态的访问操作都是原子的。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的&lt;/li&gt;&#xA;&lt;li&gt;当状态变量的数量由一个变为多个时，并不会像状态变量数量由零个变为一个那样简单&lt;/li&gt;&#xA;&lt;li&gt;在实际情况中，应尽可能地使用现有的线程安全对象（例如AtomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;23-加锁机制&#34;&gt;&#xA;  2.3 加锁机制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#23-%e5%8a%a0%e9%94%81%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;231-内置锁&#34;&gt;&#xA;  2.3.1 内置锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#231-%e5%86%85%e7%bd%ae%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。&lt;/li&gt;&#xA;&lt;li&gt;每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;232-重入&#34;&gt;&#xA;  2.3.2 重入&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#232-%e9%87%8d%e5%85%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”&lt;/li&gt;&#xA;&lt;li&gt;重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。&lt;/li&gt;&#xA;&lt;li&gt;当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;24-用锁来保护状态&#34;&gt;&#xA;  2.4 用锁来保护状态&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#24-%e7%94%a8%e9%94%81%e6%9d%a5%e4%bf%9d%e6%8a%a4%e7%8a%b6%e6%80%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。&lt;/li&gt;&#xA;&lt;li&gt;之所以每个对象都有一个内置锁，只是为了免去显式地创建锁对象。&lt;/li&gt;&#xA;&lt;li&gt;每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。&lt;/li&gt;&#xA;&lt;li&gt;一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。&lt;/li&gt;&#xA;&lt;li&gt;并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;25-活跃性与性能&#34;&gt;&#xA;  2.5 活跃性与性能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#25-%e6%b4%bb%e8%b7%83%e6%80%a7%e4%b8%8e%e6%80%a7%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不良并发（Poor Concurrency）应用程序：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。&lt;/li&gt;&#xA;&lt;li&gt;当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。&lt;/li&gt;&#xA;&lt;li&gt;无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第3章-对象的共享&#34;&gt;&#xA;  第3章 对象的共享&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac3%e7%ab%a0-%e5%af%b9%e8%b1%a1%e7%9a%84%e5%85%b1%e4%ba%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;31-可见性&#34;&gt;&#xA;  3.1 可见性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#31-%e5%8f%af%e8%a7%81%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;311-失效数据&#34;&gt;&#xA;  3.1.1 失效数据&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#311-%e5%a4%b1%e6%95%88%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;312非原子的64位操作&#34;&gt;&#xA;  3.1.2　非原子的64位操作&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#312%e9%9d%9e%e5%8e%9f%e5%ad%90%e7%9a%8464%e4%bd%8d%e6%93%8d%e4%bd%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-air safety）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量（double和long，请参见3.1.4节）。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位￼。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;313加锁与可见性&#34;&gt;&#xA;  3.1.3　加锁与可见性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#313%e5%8a%a0%e9%94%81%e4%b8%8e%e5%8f%af%e8%a7%81%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;314volatile变量&#34;&gt;&#xA;  3.1.4　Volatile变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#314volatile%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。&lt;/li&gt;&#xA;&lt;li&gt;在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在当前大多数处理器架构上，读取volatile变量的开销只比读取非volatile变量的开销略高一些。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;我们并不建议过度依赖volatile变量提供的可见性。如果在代码中依赖volatile变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。&lt;/li&gt;&#xA;&lt;li&gt;如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;volatile的语义不足以确保递增操作（count++）的原子性，除非你能确保只有一个线程对变量执行写操作。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;当且仅当满足以下所有条件时，才应该使用volatile变量&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。&lt;/li&gt;&#xA;&lt;li&gt;该变量不会与其他状态变量一起纳入不变性条件中。&lt;/li&gt;&#xA;&lt;li&gt;在访问变量时不需要加锁。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;调试小提示：对于服务器应用程序，无论在开发阶段还是在测试阶段，当启动JVM时一定都要指定-server命令行选项。server模式的JVM将比client模式的JVM进行更多的优化，例如将循环中未被修改的变量提升到循环外部，因此在开发环境（client模式的JVM）中能正确运行的代码，可能会在部署环境（server模式的JVM）中运行失败。例如，如果在程序清单3-4中“忘记”把asleep变量声明为volatile类型，那么server模式的JVM会将asleep的判断条件提升到循环体外部（这将导致一个无限循环），但client模式的JVM不会这么做。在解决开发环境中出现无限循环问题时，解决这个问题的开销远小于解决在应用环境出现无限循环的开销。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;32-发布与逸出&#34;&gt;&#xA;  3.2 发布与逸出&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#32-%e5%8f%91%e5%b8%83%e4%b8%8e%e9%80%b8%e5%87%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;“发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。在许多情况中，我们要确保对象及其内部状态不被发布。而在某些情况下，我们又需要发布某个对象，但如果在发布时要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象构造完成之前就发布该对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）。&lt;/li&gt;&#xA;&lt;li&gt;发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。&lt;/li&gt;&#xA;&lt;li&gt;当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。这正是需要使用封装的最主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。&lt;/li&gt;&#xA;&lt;li&gt;安全的对象构造过程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不要在构造过程中使this引用逸出&lt;/li&gt;&#xA;&lt;li&gt;在构造过程中使this引用逸出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。&lt;/li&gt;&#xA;&lt;li&gt;在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动&lt;/li&gt;&#xA;&lt;li&gt;在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），同样会导致this引用在构造过程中逸出。&lt;/li&gt;&#xA;&lt;li&gt;如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法（Factory Method），从而避免不正确的构造过程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;33-线程封闭&#34;&gt;&#xA;  3.3 线程封闭&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#33-%e7%ba%bf%e7%a8%8b%e5%b0%81%e9%97%ad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Swing应用程序的许多并发错误都是由于错误地在另一个线程中使用了这些被封闭的对象。&lt;/li&gt;&#xA;&lt;li&gt;线程封闭是在程序设计中的一个考虑因素，必须在程序中实现。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;331-ad-hoc线程封闭&#34;&gt;&#xA;  3.3.1 Ad-hoc线程封闭&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#331-ad-hoc%e7%ba%bf%e7%a8%8b%e5%b0%81%e9%97%ad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在volatile变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竞态条件，并且volatile变量的可见性保证还确保了其他线程能看到最新的值。&lt;/li&gt;&#xA;&lt;li&gt;由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭或ThreadLocal类）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;332-栈封闭&#34;&gt;&#xA;  3.3.2 栈封闭&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#332-%e6%a0%88%e5%b0%81%e9%97%ad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。&lt;/li&gt;&#xA;&lt;li&gt;由于任何方法都无法获得对基本类型的引用，因此Java语言的这种语义就确保了基本类型的局部变量始终封闭在线程内。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;333-threadlocal-类&#34;&gt;&#xA;  3.3.3 ThreadLocal 类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#333-threadlocal-%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。&lt;/li&gt;&#xA;&lt;li&gt;假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象（如果全局变量的语义允许），可以维持线程安全性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;34-不变性&#34;&gt;&#xA;  3.4 不变性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#34-%e4%b8%8d%e5%8f%98%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。&lt;/li&gt;&#xA;&lt;li&gt;不可变对象一定是线程安全的&lt;/li&gt;&#xA;&lt;li&gt;虽然在Java语言规范和Java内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。&lt;/li&gt;&#xA;&lt;li&gt;当满足以下条件时，对象才是不可变的：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对象创建以后其状态就不能修改。&lt;/li&gt;&#xA;&lt;li&gt;对象的所有域都是final类型。&lt;/li&gt;&#xA;&lt;li&gt;对象是正确创建的（在对象的创建期间，this引用没有逸出）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;341-final域&#34;&gt;&#xA;  3.4.1 Final域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#341-final%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;关键字final可以视为C++中const机制的一种受限版本，用于构造不可变性对象。final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。&lt;/li&gt;&#xA;&lt;li&gt;即使对象是可变的，通过将对象的某些域声明为final类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。&lt;/li&gt;&#xA;&lt;li&gt;正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”[EJ Item 12]是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;342-示例使用volatile类型来发布不可变对象&#34;&gt;&#xA;  3.4.2 示例：使用volatile类型来发布不可变对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#342-%e7%a4%ba%e4%be%8b%e4%bd%bf%e7%94%a8volatile%e7%b1%bb%e5%9e%8b%e6%9d%a5%e5%8f%91%e5%b8%83%e4%b8%8d%e5%8f%af%e5%8f%98%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过使用包含多个状态变量的容器对象来维持不变性条件，并使用一个volatile类型的引用来确保可见性，使得Volatile Cached Factorizer在没有显式地使用锁的情况下仍然是线程安全的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;35-安全发布&#34;&gt;&#xA;  3.5 安全发布&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#35-%e5%ae%89%e5%85%a8%e5%8f%91%e5%b8%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;351-不正确的发布正确的对象被破坏&#34;&gt;&#xA;  3.5.1 不正确的发布：正确的对象被破坏&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#351-%e4%b8%8d%e6%ad%a3%e7%a1%ae%e7%9a%84%e5%8f%91%e5%b8%83%e6%ad%a3%e7%a1%ae%e7%9a%84%e5%af%b9%e8%b1%a1%e8%a2%ab%e7%a0%b4%e5%9d%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;你不能指望一个尚未被完全创建的对象拥有完整性。某个观察该对象的线程将看到对象处于不一致的状态，然后看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;352-不可变对象与初始化安全性&#34;&gt;&#xA;  3.5.2 不可变对象与初始化安全性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#352-%e4%b8%8d%e5%8f%af%e5%8f%98%e5%af%b9%e8%b1%a1%e4%b8%8e%e5%88%9d%e5%a7%8b%e5%8c%96%e5%ae%89%e5%85%a8%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;我们已经知道，即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一致的视图，就必须使用同步。&lt;/li&gt;&#xA;&lt;li&gt;任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。&lt;/li&gt;&#xA;&lt;li&gt;在没有额外同步的情况下，也可以安全地访问final类型的域。然而，如果final类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;353-安全发布的常用模式&#34;&gt;&#xA;  3.5.3 安全发布的常用模式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#353-%e5%ae%89%e5%85%a8%e5%8f%91%e5%b8%83%e7%9a%84%e5%b8%b8%e7%94%a8%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时都必须使用同步。&lt;/li&gt;&#xA;&lt;li&gt;要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在静态初始化函数中初始化一个对象引用。&lt;/li&gt;&#xA;&lt;li&gt;将对象的引用保存到volatile类型的域或者AtomicReferance对象中。&lt;/li&gt;&#xA;&lt;li&gt;将对象的引用保存到某个正确构造对象的final类型域中。&lt;/li&gt;&#xA;&lt;li&gt;将对象的引用保存到一个由锁保护的域中。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;在线程安全容器内部的同步意味着，在将对象放入到某个容器，例如Vector或synchronizedList时，将满足上述最后一条需求。如果线程A将对象X放入一个线程安全的容器，随后线程B读取这个对象，那么可以确保B看到A设置的X状态，即便在这段读/写X的应用程序代码中没有包含显式的同步。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程安全库中的容器类提供了以下的安全发布保证&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。&lt;/li&gt;&#xA;&lt;li&gt;通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。&lt;/li&gt;&#xA;&lt;li&gt;通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器 &lt;code&gt;public static Holder holder=new Holder（42）&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;354-事实不可变对象&#34;&gt;&#xA;  3.5.4 事实不可变对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#354-%e4%ba%8b%e5%ae%9e%e4%b8%8d%e5%8f%af%e5%8f%98%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全地访问这些对象的线程来说，安全发布是足够的。&lt;/li&gt;&#xA;&lt;li&gt;如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）”&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过使用事实不可变对象，不仅可以简化开发过程，而且还能由于减少了同步而提高性能。&lt;/li&gt;&#xA;&lt;li&gt;例如，Date本身是可变的￼，但如果将它作为不可变对象来使用，那么在多个线程之间共享Date对象时，就可以省去对锁的使用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;355-可变对象&#34;&gt;&#xA;  3.5.5 可变对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#355-%e5%8f%af%e5%8f%98%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。&lt;/li&gt;&#xA;&lt;li&gt;在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。&lt;/li&gt;&#xA;&lt;li&gt;只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。&lt;/li&gt;&#xA;&lt;li&gt;线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。&lt;/li&gt;&#xA;&lt;li&gt;保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;356-安全地共享对象&#34;&gt;&#xA;  3.5.6 安全地共享对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#356-%e5%ae%89%e5%85%a8%e5%9c%b0%e5%85%b1%e4%ba%ab%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h2 id=&#34;第4章-对象的组合&#34;&gt;&#xA;  第4章 对象的组合&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac4%e7%ab%a0-%e5%af%b9%e8%b1%a1%e7%9a%84%e7%bb%84%e5%90%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;41-设计线程安全的类&#34;&gt;&#xA;  4.1 设计线程安全的类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#41-%e8%ae%be%e8%ae%a1%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;42-实例封闭&#34;&gt;&#xA;  4.2 实例封闭&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#42-%e5%ae%9e%e4%be%8b%e5%b0%81%e9%97%ad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;43-线程安全性的委托&#34;&gt;&#xA;  4.3 线程安全性的委托&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#43-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e6%80%a7%e7%9a%84%e5%a7%94%e6%89%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;44-在现有的线程安全类中添加功能&#34;&gt;&#xA;  4.4 在现有的线程安全类中添加功能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#44-%e5%9c%a8%e7%8e%b0%e6%9c%89%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%b1%bb%e4%b8%ad%e6%b7%bb%e5%8a%a0%e5%8a%9f%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;45-将同步策略文档化&#34;&gt;&#xA;  4.5 将同步策略文档化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#45-%e5%b0%86%e5%90%8c%e6%ad%a5%e7%ad%96%e7%95%a5%e6%96%87%e6%a1%a3%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;第5章-基础构建模块&#34;&gt;&#xA;  第5章 基础构建模块&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac5%e7%ab%a0-%e5%9f%ba%e7%a1%80%e6%9e%84%e5%bb%ba%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;51-同步容器类&#34;&gt;&#xA;  5.1 同步容器类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#51-%e5%90%8c%e6%ad%a5%e5%ae%b9%e5%99%a8%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;52-并发容器&#34;&gt;&#xA;  5.2 并发容器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#52-%e5%b9%b6%e5%8f%91%e5%ae%b9%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;53-阻塞队列和生产者-消费者模式&#34;&gt;&#xA;  5.3 阻塞队列和生产者-消费者模式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#53-%e9%98%bb%e5%a1%9e%e9%98%9f%e5%88%97%e5%92%8c%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;54-阻塞方法与中断方法&#34;&gt;&#xA;  5.4 阻塞方法与中断方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#54-%e9%98%bb%e5%a1%9e%e6%96%b9%e6%b3%95%e4%b8%8e%e4%b8%ad%e6%96%ad%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;55-同步工具类&#34;&gt;&#xA;  5.5 同步工具类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#55-%e5%90%8c%e6%ad%a5%e5%b7%a5%e5%85%b7%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;56-构建高效且可伸缩的结果缓存&#34;&gt;&#xA;  5.6 构建高效且可伸缩的结果缓存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#56-%e6%9e%84%e5%bb%ba%e9%ab%98%e6%95%88%e4%b8%94%e5%8f%af%e4%bc%b8%e7%bc%a9%e7%9a%84%e7%bb%93%e6%9e%9c%e7%bc%93%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;第6章-任务执行&#34;&gt;&#xA;  第6章 任务执行&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac6%e7%ab%a0-%e4%bb%bb%e5%8a%a1%e6%89%a7%e8%a1%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;61-在线程中执行任务&#34;&gt;&#xA;  6.1 在线程中执行任务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#61-%e5%9c%a8%e7%ba%bf%e7%a8%8b%e4%b8%ad%e6%89%a7%e8%a1%8c%e4%bb%bb%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;62-executor框架&#34;&gt;&#xA;  6.2 Executor框架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#62-executor%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;63-找出可利用的并行性&#34;&gt;&#xA;  6.3 找出可利用的并行性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#63-%e6%89%be%e5%87%ba%e5%8f%af%e5%88%a9%e7%94%a8%e7%9a%84%e5%b9%b6%e8%a1%8c%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;第7章-取消与关闭&#34;&gt;&#xA;  第7章 取消与关闭&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac7%e7%ab%a0-%e5%8f%96%e6%b6%88%e4%b8%8e%e5%85%b3%e9%97%ad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;71-任务取消&#34;&gt;&#xA;  7.1 任务取消&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#71-%e4%bb%bb%e5%8a%a1%e5%8f%96%e6%b6%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;72-停止基于线程的服务&#34;&gt;&#xA;  7.2 停止基于线程的服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#72-%e5%81%9c%e6%ad%a2%e5%9f%ba%e4%ba%8e%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;73-处理非正常的线程终止&#34;&gt;&#xA;  7.3 处理非正常的线程终止&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#73-%e5%a4%84%e7%90%86%e9%9d%9e%e6%ad%a3%e5%b8%b8%e7%9a%84%e7%ba%bf%e7%a8%8b%e7%bb%88%e6%ad%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;74-jvm关闭&#34;&gt;&#xA;  7.4 JVM关闭&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#74-jvm%e5%85%b3%e9%97%ad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;第8章-线程池的使用&#34;&gt;&#xA;  第8章 线程池的使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac8%e7%ab%a0-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;81-在任务与执行策略之间的隐性耦合&#34;&gt;&#xA;  8.1 在任务与执行策略之间的隐性耦合&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#81-%e5%9c%a8%e4%bb%bb%e5%8a%a1%e4%b8%8e%e6%89%a7%e8%a1%8c%e7%ad%96%e7%95%a5%e4%b9%8b%e9%97%b4%e7%9a%84%e9%9a%90%e6%80%a7%e8%80%a6%e5%90%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;82-设置线程池的大小&#34;&gt;&#xA;  8.2 设置线程池的大小&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#82-%e8%ae%be%e7%bd%ae%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%a4%a7%e5%b0%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;83-配置threadpoolexecutor&#34;&gt;&#xA;  8.3 配置ThreadPoolExecutor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#83-%e9%85%8d%e7%bd%aethreadpoolexecutor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;84-扩展threadpoolexecutor&#34;&gt;&#xA;  8.4 扩展ThreadPoolExecutor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#84-%e6%89%a9%e5%b1%95threadpoolexecutor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;85-递归算法的并行化&#34;&gt;&#xA;  8.5 递归算法的并行化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#85-%e9%80%92%e5%bd%92%e7%ae%97%e6%b3%95%e7%9a%84%e5%b9%b6%e8%a1%8c%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;第9章-图形用户界面应用程序&#34;&gt;&#xA;  第9章 图形用户界面应用程序&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac9%e7%ab%a0-%e5%9b%be%e5%bd%a2%e7%94%a8%e6%88%b7%e7%95%8c%e9%9d%a2%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;91-为什么gui是单线程的&#34;&gt;&#xA;  9.1 为什么GUI是单线程的&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#91-%e4%b8%ba%e4%bb%80%e4%b9%88gui%e6%98%af%e5%8d%95%e7%ba%bf%e7%a8%8b%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;92-短时间的gui任务&#34;&gt;&#xA;  9.2 短时间的GUI任务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#92-%e7%9f%ad%e6%97%b6%e9%97%b4%e7%9a%84gui%e4%bb%bb%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;93-长时间的gui任务&#34;&gt;&#xA;  9.3 长时间的GUI任务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#93-%e9%95%bf%e6%97%b6%e9%97%b4%e7%9a%84gui%e4%bb%bb%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;94-共享数据模型&#34;&gt;&#xA;  9.4 共享数据模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#94-%e5%85%b1%e4%ba%ab%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;95-其他形式的单线程子系统&#34;&gt;&#xA;  9.5 其他形式的单线程子系统&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#95-%e5%85%b6%e4%bb%96%e5%bd%a2%e5%bc%8f%e7%9a%84%e5%8d%95%e7%ba%bf%e7%a8%8b%e5%ad%90%e7%b3%bb%e7%bb%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;第10章-避免活跃性危险&#34;&gt;&#xA;  第10章 避免活跃性危险&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac10%e7%ab%a0-%e9%81%bf%e5%85%8d%e6%b4%bb%e8%b7%83%e6%80%a7%e5%8d%b1%e9%99%a9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;101-死锁&#34;&gt;&#xA;  10.1 死锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#101-%e6%ad%bb%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;102-死锁的避免与诊断&#34;&gt;&#xA;  10.2 死锁的避免与诊断&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#102-%e6%ad%bb%e9%94%81%e7%9a%84%e9%81%bf%e5%85%8d%e4%b8%8e%e8%af%8a%e6%96%ad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;103-其他活跃性危险&#34;&gt;&#xA;  10.3 其他活跃性危险&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#103-%e5%85%b6%e4%bb%96%e6%b4%bb%e8%b7%83%e6%80%a7%e5%8d%b1%e9%99%a9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;第11章-性能与可伸缩性&#34;&gt;&#xA;  第11章 性能与可伸缩性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac11%e7%ab%a0-%e6%80%a7%e8%83%bd%e4%b8%8e%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;111-对性能的思考&#34;&gt;&#xA;  11.1 对性能的思考&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#111-%e5%af%b9%e6%80%a7%e8%83%bd%e7%9a%84%e6%80%9d%e8%80%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;112-amdahl定律&#34;&gt;&#xA;  11.2 Amdahl定律&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#112-amdahl%e5%ae%9a%e5%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;113-线程引入的开销&#34;&gt;&#xA;  11.3 线程引入的开销&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#113-%e7%ba%bf%e7%a8%8b%e5%bc%95%e5%85%a5%e7%9a%84%e5%bc%80%e9%94%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;114-减少锁的竞争&#34;&gt;&#xA;  11.4 减少锁的竞争&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#114-%e5%87%8f%e5%b0%91%e9%94%81%e7%9a%84%e7%ab%9e%e4%ba%89&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;115-示例比较map的性能&#34;&gt;&#xA;  11.5 示例：比较Map的性能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#115-%e7%a4%ba%e4%be%8b%e6%af%94%e8%be%83map%e7%9a%84%e6%80%a7%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;116-减少上下文切换的开销&#34;&gt;&#xA;  11.6 减少上下文切换的开销&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#116-%e5%87%8f%e5%b0%91%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e7%9a%84%e5%bc%80%e9%94%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;第12章-并发程序的测试&#34;&gt;&#xA;  第12章 并发程序的测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac12%e7%ab%a0-%e5%b9%b6%e5%8f%91%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;121-正确性测试&#34;&gt;&#xA;  12.1 正确性测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#121-%e6%ad%a3%e7%a1%ae%e6%80%a7%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;122-性能测试&#34;&gt;&#xA;  12.2 性能测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#122-%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;123-避免性能测试的陷阱&#34;&gt;&#xA;  12.3 避免性能测试的陷阱&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#123-%e9%81%bf%e5%85%8d%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e7%9a%84%e9%99%b7%e9%98%b1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;124-其他的测试方法&#34;&gt;&#xA;  12.4 其他的测试方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#124-%e5%85%b6%e4%bb%96%e7%9a%84%e6%b5%8b%e8%af%95%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;第13章-显式锁&#34;&gt;&#xA;  第13章 显式锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac13%e7%ab%a0-%e6%98%be%e5%bc%8f%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;131-lock与reentrantlock&#34;&gt;&#xA;  13.1 Lock与ReentrantLock&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#131-lock%e4%b8%8ereentrantlock&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;132-性能考虑因素&#34;&gt;&#xA;  13.2 性能考虑因素&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#132-%e6%80%a7%e8%83%bd%e8%80%83%e8%99%91%e5%9b%a0%e7%b4%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;133-公平性&#34;&gt;&#xA;  13.3 公平性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#133-%e5%85%ac%e5%b9%b3%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;134-在synchronized和reentrantlock之间进行选择&#34;&gt;&#xA;  13.4 在synchronized和ReentrantLock之间进行选择&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#134-%e5%9c%a8synchronized%e5%92%8creentrantlock%e4%b9%8b%e9%97%b4%e8%bf%9b%e8%a1%8c%e9%80%89%e6%8b%a9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;135-读-写锁&#34;&gt;&#xA;  13.5 读-写锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#135-%e8%af%bb-%e5%86%99%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;第14章-构建自定义的同步工具&#34;&gt;&#xA;  第14章 构建自定义的同步工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac14%e7%ab%a0-%e6%9e%84%e5%bb%ba%e8%87%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e5%90%8c%e6%ad%a5%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;141-状态依赖性的管理&#34;&gt;&#xA;  14.1 状态依赖性的管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#141-%e7%8a%b6%e6%80%81%e4%be%9d%e8%b5%96%e6%80%a7%e7%9a%84%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;142-使用条件队列&#34;&gt;&#xA;  14.2 使用条件队列&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#142-%e4%bd%bf%e7%94%a8%e6%9d%a1%e4%bb%b6%e9%98%9f%e5%88%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;143-显式的condition对象&#34;&gt;&#xA;  14.3 显式的Condition对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#143-%e6%98%be%e5%bc%8f%e7%9a%84condition%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;144-synchronizer剖析&#34;&gt;&#xA;  14.4 Synchronizer剖析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#144-synchronizer%e5%89%96%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;145-abstractqueuedsynchronizer&#34;&gt;&#xA;  14.5 AbstractQueuedSynchronizer&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#145-abstractqueuedsynchronizer&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;146-javautilconcurrent同步器类中的aqs&#34;&gt;&#xA;  14.6 java.util.concurrent同步器类中的AQS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#146-javautilconcurrent%e5%90%8c%e6%ad%a5%e5%99%a8%e7%b1%bb%e4%b8%ad%e7%9a%84aqs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;第15章-原子变量与非阻塞同步机制&#34;&gt;&#xA;  第15章 原子变量与非阻塞同步机制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac15%e7%ab%a0-%e5%8e%9f%e5%ad%90%e5%8f%98%e9%87%8f%e4%b8%8e%e9%9d%9e%e9%98%bb%e5%a1%9e%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;151-锁的劣势&#34;&gt;&#xA;  15.1 锁的劣势&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#151-%e9%94%81%e7%9a%84%e5%8a%a3%e5%8a%bf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;152-硬件对并发的支持&#34;&gt;&#xA;  15.2 硬件对并发的支持&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#152-%e7%a1%ac%e4%bb%b6%e5%af%b9%e5%b9%b6%e5%8f%91%e7%9a%84%e6%94%af%e6%8c%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;153-原子变量类&#34;&gt;&#xA;  15.3 原子变量类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#153-%e5%8e%9f%e5%ad%90%e5%8f%98%e9%87%8f%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;154-非阻塞算法&#34;&gt;&#xA;  15.4 非阻塞算法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#154-%e9%9d%9e%e9%98%bb%e5%a1%9e%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;第16章-java内存模型&#34;&gt;&#xA;  第16章 Java内存模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac16%e7%ab%a0-java%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;161-什么是内存模型为什么需要它&#34;&gt;&#xA;  16.1 什么是内存模型，为什么需要它&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#161-%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%ae%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;162-发布&#34;&gt;&#xA;  16.2 发布&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#162-%e5%8f%91%e5%b8%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;163-初始化过程中的安全性&#34;&gt;&#xA;  16.3 初始化过程中的安全性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#163-%e5%88%9d%e5%a7%8b%e5%8c%96%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%ae%89%e5%85%a8%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>Java实战</title>
      <link>/zh/post/books/computer-science/java%E5%AE%9E%E6%88%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/books/computer-science/java%E5%AE%9E%E6%88%98/</guid>
      <description>&lt;h1 id=&#34;java实战&#34;&gt;&#xA;  Java实战&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e5%ae%9e%e6%88%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/34895968/&#34;&gt;Java实战（第2版）&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第一部分-基础知识&#34;&gt;&#xA;  第一部分 基础知识&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86-%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;第1章java-8910以及11的变化2&#34;&gt;&#xA;  第1章　Java 8、9、10以及11的变化　　2&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac1%e7%ab%a0java-8910%e4%bb%a5%e5%8f%8a11%e7%9a%84%e5%8f%98%e5%8c%962&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;11-为什么要关心java的变化-2&#34;&gt;&#xA;  1.1 为什么要关心Java的变化 2&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#11-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%85%b3%e5%bf%83java%e7%9a%84%e5%8f%98%e5%8c%96-2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;12-java怎么还在变-4&#34;&gt;&#xA;  1.2 Java怎么还在变 4&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#12-java%e6%80%8e%e4%b9%88%e8%bf%98%e5%9c%a8%e5%8f%98-4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.2.1 Java在编程语言生态系统中的位置 5&lt;/li&gt;&#xA;&lt;li&gt;1.2.2 流处理 6&lt;/li&gt;&#xA;&lt;li&gt;1.2.3 用行为参数化把代码传递给方法 7&lt;/li&gt;&#xA;&lt;li&gt;1.2.4 并行与共享的可变数据 8&lt;/li&gt;&#xA;&lt;li&gt;1.2.5 Java需要演变 9&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;13-java中的函数-9&#34;&gt;&#xA;  1.3 Java中的函数 9&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#13-java%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0-9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.3.1 方法和Lambda作为一等值 10&lt;/li&gt;&#xA;&lt;li&gt;1.3.2 传递代码：一个例子 11&lt;/li&gt;&#xA;&lt;li&gt;1.3.3 从传递方法到Lambda 13&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;14-流-14&#34;&gt;&#xA;  1.4 流 14&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#14-%e6%b5%81-14&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;15-默认方法及java模块-17&#34;&gt;&#xA;  1.5 默认方法及Java模块 17&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#15-%e9%bb%98%e8%ae%a4%e6%96%b9%e6%b3%95%e5%8f%8ajava%e6%a8%a1%e5%9d%97-17&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;16-来自函数式编程的其他好思想-19&#34;&gt;&#xA;  1.6 来自函数式编程的其他好思想 19&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#16-%e6%9d%a5%e8%87%aa%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e7%9a%84%e5%85%b6%e4%bb%96%e5%a5%bd%e6%80%9d%e6%83%b3-19&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;17-小结-20&#34;&gt;&#xA;  1.7 小结 20&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#17-%e5%b0%8f%e7%bb%93-20&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第2章通过行为参数化传递代码22&#34;&gt;&#xA;  第2章　通过行为参数化传递代码　　22&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac2%e7%ab%a0%e9%80%9a%e8%bf%87%e8%a1%8c%e4%b8%ba%e5%8f%82%e6%95%b0%e5%8c%96%e4%bc%a0%e9%80%92%e4%bb%a3%e7%a0%8122&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;21-应对不断变化的需求-23&#34;&gt;&#xA;  2.1 应对不断变化的需求 23&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#21-%e5%ba%94%e5%af%b9%e4%b8%8d%e6%96%ad%e5%8f%98%e5%8c%96%e7%9a%84%e9%9c%80%e6%b1%82-23&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2.1.1 初试牛刀：筛选绿苹果 23&lt;/li&gt;&#xA;&lt;li&gt;2.1.2 再展身手：把颜色作为参数 23&lt;/li&gt;&#xA;&lt;li&gt;2.1.3 第三次尝试：对你能想到的每个属性做筛选 24&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;22-行为参数化-25&#34;&gt;&#xA;  2.2 行为参数化 25&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#22-%e8%a1%8c%e4%b8%ba%e5%8f%82%e6%95%b0%e5%8c%96-25&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;23-对付啰唆-30&#34;&gt;&#xA;  2.3 对付啰唆 30&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#23-%e5%af%b9%e4%bb%98%e5%95%b0%e5%94%86-30&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2.3.1 匿名类 30&lt;/li&gt;&#xA;&lt;li&gt;2.3.2 第五次尝试：使用匿名类 31&lt;/li&gt;&#xA;&lt;li&gt;2.3.3 第六次尝试：使用Lambda表达式 32&lt;/li&gt;&#xA;&lt;li&gt;2.3.4 第七次尝试：将List类型抽象化 33&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;24-真实的例子-33&#34;&gt;&#xA;  2.4 真实的例子 33&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#24-%e7%9c%9f%e5%ae%9e%e7%9a%84%e4%be%8b%e5%ad%90-33&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2.4.1 用Comparator来排序 33&lt;/li&gt;&#xA;&lt;li&gt;2.4.2 用Runnable执行代码块 34&lt;/li&gt;&#xA;&lt;li&gt;2.4.3 通过Callable返回结果 35&lt;/li&gt;&#xA;&lt;li&gt;2.4.4 GUI事件处理 35&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;25-小结-36&#34;&gt;&#xA;  2.5 小结 36&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#25-%e5%b0%8f%e7%bb%93-36&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第3章lambda表达式37&#34;&gt;&#xA;  第3章　Lambda表达式　　37&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac3%e7%ab%a0lambda%e8%a1%a8%e8%be%be%e5%bc%8f37&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;31-lambda管中窥豹-37&#34;&gt;&#xA;  3.1 Lambda管中窥豹 37&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#31-lambda%e7%ae%a1%e4%b8%ad%e7%aa%a5%e8%b1%b9-37&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;32-在哪里以及如何使用lambda-40&#34;&gt;&#xA;  3.2 在哪里以及如何使用Lambda 40&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#32-%e5%9c%a8%e5%93%aa%e9%87%8c%e4%bb%a5%e5%8f%8a%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8lambda-40&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;3.2.1 函数式接口 40&lt;/li&gt;&#xA;&lt;li&gt;3.2.2 函数描述符 42&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;33-把lambda付诸实践环绕执行模式-44&#34;&gt;&#xA;  3.3 把Lambda付诸实践：环绕执行模式 44&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#33-%e6%8a%8alambda%e4%bb%98%e8%af%b8%e5%ae%9e%e8%b7%b5%e7%8e%af%e7%bb%95%e6%89%a7%e8%a1%8c%e6%a8%a1%e5%bc%8f-44&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;3.3.1 第1 步：记得行为参数化 44&lt;/li&gt;&#xA;&lt;li&gt;3.3.2 第2 步：使用函数式接口来传递行为 45&lt;/li&gt;&#xA;&lt;li&gt;3.3.3 第3 步：执行一个行为 45&lt;/li&gt;&#xA;&lt;li&gt;3.3.4 第4 步：传递Lambda 46&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;34-使用函数式接口-47&#34;&gt;&#xA;  3.4 使用函数式接口 47&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#34-%e4%bd%bf%e7%94%a8%e5%87%bd%e6%95%b0%e5%bc%8f%e6%8e%a5%e5%8f%a3-47&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;3.4.1 Predicate 47&lt;/li&gt;&#xA;&lt;li&gt;3.4.2 Consumer 47&lt;/li&gt;&#xA;&lt;li&gt;3.4.3 Function 48&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;35-类型检查类型推断以及限制-52&#34;&gt;&#xA;  3.5 类型检查、类型推断以及限制 52&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#35-%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%9f%a5%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%ad%e4%bb%a5%e5%8f%8a%e9%99%90%e5%88%b6-52&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;3.5.1 类型检查 52&lt;/li&gt;&#xA;&lt;li&gt;3.5.2 同样的Lambda，不同的函数式接口 53&lt;/li&gt;&#xA;&lt;li&gt;3.5.3 类型推断 55&lt;/li&gt;&#xA;&lt;li&gt;3.5.4 使用局部变量 56&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;36-方法引用-57&#34;&gt;&#xA;  3.6 方法引用 57&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#36-%e6%96%b9%e6%b3%95%e5%bc%95%e7%94%a8-57&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;3.6.1 管中窥豹 57&lt;/li&gt;&#xA;&lt;li&gt;3.6.2 构造函数引用 60&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;37-lambda和方法引用实战-62&#34;&gt;&#xA;  3.7 Lambda和方法引用实战 62&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#37-lambda%e5%92%8c%e6%96%b9%e6%b3%95%e5%bc%95%e7%94%a8%e5%ae%9e%e6%88%98-62&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;3.7.1 第1 步：传递代码 62&lt;/li&gt;&#xA;&lt;li&gt;3.7.2 第2 步：使用匿名类 62&lt;/li&gt;&#xA;&lt;li&gt;3.7.3 第3 步：使用Lambda表达式 62&lt;/li&gt;&#xA;&lt;li&gt;3.7.4 第4 步：使用方法引用 63&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;38-复合lambda表达式的有用方法-63&#34;&gt;&#xA;  3.8 复合Lambda表达式的有用方法 63&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#38-%e5%a4%8d%e5%90%88lambda%e8%a1%a8%e8%be%be%e5%bc%8f%e7%9a%84%e6%9c%89%e7%94%a8%e6%96%b9%e6%b3%95-63&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;3.8.1 比较器复合 64&lt;/li&gt;&#xA;&lt;li&gt;3.8.2 谓词复合 64&lt;/li&gt;&#xA;&lt;li&gt;3.8.3 函数复合 65&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;39-数学中的类似思想-66&#34;&gt;&#xA;  3.9 数学中的类似思想 66&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#39-%e6%95%b0%e5%ad%a6%e4%b8%ad%e7%9a%84%e7%b1%bb%e4%bc%bc%e6%80%9d%e6%83%b3-66&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;3.9.1 积分 66&lt;/li&gt;&#xA;&lt;li&gt;3.9.2 与Java 8的Lambda联系起来 68&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;310-小结-68&#34;&gt;&#xA;  3.10 小结 68&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#310-%e5%b0%8f%e7%bb%93-68&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h2 id=&#34;第二部分-使用流进行函数式数据处理&#34;&gt;&#xA;  第二部分 使用流进行函数式数据处理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e4%ba%8c%e9%83%a8%e5%88%86-%e4%bd%bf%e7%94%a8%e6%b5%81%e8%bf%9b%e8%a1%8c%e5%87%bd%e6%95%b0%e5%bc%8f%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;第4章引入流72&#34;&gt;&#xA;  第4章　引入流　　72&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac4%e7%ab%a0%e5%bc%95%e5%85%a5%e6%b5%8172&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;41-流是什么-72&#34;&gt;&#xA;  4.1 流是什么 72&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#41-%e6%b5%81%e6%98%af%e4%bb%80%e4%b9%88-72&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;42-流简介-76&#34;&gt;&#xA;  4.2 流简介 76&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#42-%e6%b5%81%e7%ae%80%e4%bb%8b-76&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;43-流与集合-78&#34;&gt;&#xA;  4.3 流与集合 78&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#43-%e6%b5%81%e4%b8%8e%e9%9b%86%e5%90%88-78&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;4.3.1 只能遍历一次 79&lt;/li&gt;&#xA;&lt;li&gt;4.3.2 外部迭代与内部迭代 80&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;44-流操作-82&#34;&gt;&#xA;  4.4 流操作 82&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#44-%e6%b5%81%e6%93%8d%e4%bd%9c-82&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;4.4.1 中间操作 83&lt;/li&gt;&#xA;&lt;li&gt;4.4.2 终端操作 84&lt;/li&gt;&#xA;&lt;li&gt;4.4.3 使用流 84&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;45-路线图-85&#34;&gt;&#xA;  4.5 路线图 85&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#45-%e8%b7%af%e7%ba%bf%e5%9b%be-85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;46-小结-85&#34;&gt;&#xA;  4.6 小结 85&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#46-%e5%b0%8f%e7%bb%93-85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第5章使用流86&#34;&gt;&#xA;  第5章　使用流　　86&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac5%e7%ab%a0%e4%bd%bf%e7%94%a8%e6%b5%8186&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;51-筛选-87&#34;&gt;&#xA;  5.1 筛选 87&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#51-%e7%ad%9b%e9%80%89-87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5.1.1 用谓词筛选 87&lt;/li&gt;&#xA;&lt;li&gt;5.1.2 筛选各异的元素 87&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;52-流的切片-88&#34;&gt;&#xA;  5.2 流的切片 88&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#52-%e6%b5%81%e7%9a%84%e5%88%87%e7%89%87-88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5.2.1 使用谓词对流进行切片 88&lt;/li&gt;&#xA;&lt;li&gt;5.2.2 截短流 90&lt;/li&gt;&#xA;&lt;li&gt;5.2.3 跳过元素 90&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;53-映射-91&#34;&gt;&#xA;  5.3 映射 91&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#53-%e6%98%a0%e5%b0%84-91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5.3.1 对流中每一个元素应用函数 91&lt;/li&gt;&#xA;&lt;li&gt;5.3.2 流的扁平化 92&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;54-查找和匹配-95&#34;&gt;&#xA;  5.4 查找和匹配 95&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#54-%e6%9f%a5%e6%89%be%e5%92%8c%e5%8c%b9%e9%85%8d-95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5.4.1 检查谓词是否至少匹配一个元素 95&lt;/li&gt;&#xA;&lt;li&gt;5.4.2 检查谓词是否匹配所有元素 96&lt;/li&gt;&#xA;&lt;li&gt;5.4.3 查找元素 96&lt;/li&gt;&#xA;&lt;li&gt;5.4.4 查找第一个元素 97&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;55-归约-98&#34;&gt;&#xA;  5.5 归约 98&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#55-%e5%bd%92%e7%ba%a6-98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5.5.1 元素求和 98&lt;/li&gt;&#xA;&lt;li&gt;5.5.2 最大值和最小值 100&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;56-付诸实践-103&#34;&gt;&#xA;  5.6 付诸实践 103&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#56-%e4%bb%98%e8%af%b8%e5%ae%9e%e8%b7%b5-103&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5.6.1 领域：交易员和交易 103&lt;/li&gt;&#xA;&lt;li&gt;5.6.2 解答 104&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;57-数值流-106&#34;&gt;&#xA;  5.7 数值流 106&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#57-%e6%95%b0%e5%80%bc%e6%b5%81-106&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5.7.1 原始类型流特化 107&lt;/li&gt;&#xA;&lt;li&gt;5.7.2 数值范围 108&lt;/li&gt;&#xA;&lt;li&gt;5.7.3 数值流应用：勾股数 108&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;58-构建流-111&#34;&gt;&#xA;  5.8 构建流 111&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#58-%e6%9e%84%e5%bb%ba%e6%b5%81-111&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5.8.1 由值创建流 111&lt;/li&gt;&#xA;&lt;li&gt;5.8.2 由可空对象创建流 111&lt;/li&gt;&#xA;&lt;li&gt;5.8.3 由数组创建流 112&lt;/li&gt;&#xA;&lt;li&gt;5.8.4 由文件生成流 112&lt;/li&gt;&#xA;&lt;li&gt;5.8.5 由函数生成流：创建无限流 113&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;59-概述-116&#34;&gt;&#xA;  5.9 概述 116&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#59-%e6%a6%82%e8%bf%b0-116&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;510-小结-116&#34;&gt;&#xA;  5.10 小结 116&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#510-%e5%b0%8f%e7%bb%93-116&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第6章用流收集数据118&#34;&gt;&#xA;  第6章　用流收集数据　　118&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac6%e7%ab%a0%e7%94%a8%e6%b5%81%e6%94%b6%e9%9b%86%e6%95%b0%e6%8d%ae118&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;61-收集器简介-119&#34;&gt;&#xA;  6.1 收集器简介 119&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#61-%e6%94%b6%e9%9b%86%e5%99%a8%e7%ae%80%e4%bb%8b-119&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;6.1.1 收集器用作高级归约 119&lt;/li&gt;&#xA;&lt;li&gt;6.1.2 预定义收集器 120&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;62-归约和汇总-121&#34;&gt;&#xA;  6.2 归约和汇总 121&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#62-%e5%bd%92%e7%ba%a6%e5%92%8c%e6%b1%87%e6%80%bb-121&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;6.2.1 查找流中的最大值和最小值 121&lt;/li&gt;&#xA;&lt;li&gt;6.2.2 汇总 122&lt;/li&gt;&#xA;&lt;li&gt;6.2.3 连接字符串 123&lt;/li&gt;&#xA;&lt;li&gt;6.2.4 广义的归约汇总 124&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;63-分组-127&#34;&gt;&#xA;  6.3 分组 127&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#63-%e5%88%86%e7%bb%84-127&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;6.3.1 操作分组的元素 128&lt;/li&gt;&#xA;&lt;li&gt;6.3.2 多级分组 130&lt;/li&gt;&#xA;&lt;li&gt;6.3.3 按子组收集数据 131&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;64-分区-134&#34;&gt;&#xA;  6.4 分区 134&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#64-%e5%88%86%e5%8c%ba-134&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;6.4.1 分区的优势 135&lt;/li&gt;&#xA;&lt;li&gt;6.4.2 将数字按质数和非质数分区 136&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;65-收集器接口-138&#34;&gt;&#xA;  6.5 收集器接口 138&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#65-%e6%94%b6%e9%9b%86%e5%99%a8%e6%8e%a5%e5%8f%a3-138&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;6.5.1 理解Collector接口声明的方法 139&lt;/li&gt;&#xA;&lt;li&gt;6.5.2 全部融合到一起 143&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;66-开发你自己的收集器以获得更好的性能-144&#34;&gt;&#xA;  6.6 开发你自己的收集器以获得更好的性能 144&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#66-%e5%bc%80%e5%8f%91%e4%bd%a0%e8%87%aa%e5%b7%b1%e7%9a%84%e6%94%b6%e9%9b%86%e5%99%a8%e4%bb%a5%e8%8e%b7%e5%be%97%e6%9b%b4%e5%a5%bd%e7%9a%84%e6%80%a7%e8%83%bd-144&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;6.6.1 仅用质数做除数 145&lt;/li&gt;&#xA;&lt;li&gt;6.6.2 比较收集器的性能 148&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;67-小结-150&#34;&gt;&#xA;  6.7 小结 150&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#67-%e5%b0%8f%e7%bb%93-150&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第7章并行数据处理与性能151&#34;&gt;&#xA;  第7章　并行数据处理与性能　　151&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac7%e7%ab%a0%e5%b9%b6%e8%a1%8c%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86%e4%b8%8e%e6%80%a7%e8%83%bd151&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;71-并行流-152&#34;&gt;&#xA;  7.1 并行流 152&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#71-%e5%b9%b6%e8%a1%8c%e6%b5%81-152&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;7.1.1 将顺序流转换为并行流 52&lt;/li&gt;&#xA;&lt;li&gt;7.1.2 测量流性能 154&lt;/li&gt;&#xA;&lt;li&gt;7.1.3 正确使用并行流 158&lt;/li&gt;&#xA;&lt;li&gt;7.1.4 高效使用并行流 159&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;72-分支合并框架-161&#34;&gt;&#xA;  7.2 分支/合并框架 161&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#72-%e5%88%86%e6%94%af%e5%90%88%e5%b9%b6%e6%a1%86%e6%9e%b6-161&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;7.2.1 使用RecursiveTask 161&lt;/li&gt;&#xA;&lt;li&gt;7.2.2 使用分支/合并框架的最佳做法 164&lt;/li&gt;&#xA;&lt;li&gt;7.2.3 工作窃取 165&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;73-spliterator-166&#34;&gt;&#xA;  7.3 Spliterator 166&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#73-spliterator-166&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;7.3.1 拆分过程 167&lt;/li&gt;&#xA;&lt;li&gt;7.3.2 实现你自己的Spliterator 168&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;74-小结-173&#34;&gt;&#xA;  7.4 小结 173&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#74-%e5%b0%8f%e7%bb%93-173&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h2 id=&#34;第三部分-使用流和lambda进行高效编程&#34;&gt;&#xA;  第三部分 使用流和Lambda进行高效编程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e4%b8%89%e9%83%a8%e5%88%86-%e4%bd%bf%e7%94%a8%e6%b5%81%e5%92%8clambda%e8%bf%9b%e8%a1%8c%e9%ab%98%e6%95%88%e7%bc%96%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;第8章collection-api的增强功能176&#34;&gt;&#xA;  第8章　Collection API的增强功能　　176&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac8%e7%ab%a0collection-api%e7%9a%84%e5%a2%9e%e5%bc%ba%e5%8a%9f%e8%83%bd176&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;81-集合工厂-176&#34;&gt;&#xA;  8.1 集合工厂 176&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#81-%e9%9b%86%e5%90%88%e5%b7%a5%e5%8e%82-176&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;8.1.1 List工厂 177&lt;/li&gt;&#xA;&lt;li&gt;8.1.2 Set工厂 178&lt;/li&gt;&#xA;&lt;li&gt;8.1.3 Map工厂 179&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;82-使用list和set-180&#34;&gt;&#xA;  8.2 使用List和Set 180&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#82-%e4%bd%bf%e7%94%a8list%e5%92%8cset-180&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;8.2.1 removeIf方法 180&lt;/li&gt;&#xA;&lt;li&gt;8.2.2 replaceAll方法 181&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;83-使用map-181&#34;&gt;&#xA;  8.3 使用Map 181&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#83-%e4%bd%bf%e7%94%a8map-181&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;8.3.1 forEach方法 182&lt;/li&gt;&#xA;&lt;li&gt;8.3.2 排序 182&lt;/li&gt;&#xA;&lt;li&gt;8.3.3 getOrDefault方法 183&lt;/li&gt;&#xA;&lt;li&gt;8.3.4 计算模式 183&lt;/li&gt;&#xA;&lt;li&gt;8.3.5 删除模式 184&lt;/li&gt;&#xA;&lt;li&gt;8.3.6 替换模式 185&lt;/li&gt;&#xA;&lt;li&gt;8.3.7 merge方法 185&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;84-改进的concurrenthashmap-187&#34;&gt;&#xA;  8.4 改进的ConcurrentHashMap 187&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#84-%e6%94%b9%e8%bf%9b%e7%9a%84concurrenthashmap-187&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;8.4.1 归约和搜索 187&lt;/li&gt;&#xA;&lt;li&gt;8.4.2 计数 188&lt;/li&gt;&#xA;&lt;li&gt;8.4.3 Set视图 188&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;85-小结-188&#34;&gt;&#xA;  8.5 小结 188&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#85-%e5%b0%8f%e7%bb%93-188&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第9章重构测试和调试189&#34;&gt;&#xA;  第9章　重构、测试和调试　　189&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac9%e7%ab%a0%e9%87%8d%e6%9e%84%e6%b5%8b%e8%af%95%e5%92%8c%e8%b0%83%e8%af%95189&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;91-为改善可读性和灵活性重构代码-189&#34;&gt;&#xA;  9.1 为改善可读性和灵活性重构代码 189&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#91-%e4%b8%ba%e6%94%b9%e5%96%84%e5%8f%af%e8%af%bb%e6%80%a7%e5%92%8c%e7%81%b5%e6%b4%bb%e6%80%a7%e9%87%8d%e6%9e%84%e4%bb%a3%e7%a0%81-189&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;9.1.1 改善代码的可读性 190&lt;/li&gt;&#xA;&lt;li&gt;9.1.2 从匿名类到Lambda表达式的转换 190&lt;/li&gt;&#xA;&lt;li&gt;9.1.3 从Lambda表达式到方法引用的转换 191&lt;/li&gt;&#xA;&lt;li&gt;9.1.4 从命令式的数据处理切换到Stream 193&lt;/li&gt;&#xA;&lt;li&gt;9.1.5 增加代码的灵活性 193&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;92-使用lambda重构面向对象的设计模式-195&#34;&gt;&#xA;  9.2 使用Lambda重构面向对象的设计模式 195&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#92-%e4%bd%bf%e7%94%a8lambda%e9%87%8d%e6%9e%84%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f-195&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;9.2.1 策略模式 196&lt;/li&gt;&#xA;&lt;li&gt;9.2.2 模板方法 197&lt;/li&gt;&#xA;&lt;li&gt;9.2.3 观察者模式 198&lt;/li&gt;&#xA;&lt;li&gt;9.2.4 责任链模式 201&lt;/li&gt;&#xA;&lt;li&gt;9.2.5 工厂模式 202&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;93-测试lambda表达式-204&#34;&gt;&#xA;  9.3 测试Lambda表达式 204&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#93-%e6%b5%8b%e8%af%95lambda%e8%a1%a8%e8%be%be%e5%bc%8f-204&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;9.3.1 测试可见Lambda函数的行为 204&lt;/li&gt;&#xA;&lt;li&gt;9.3.2 测试使用Lambda的方法的行为 205&lt;/li&gt;&#xA;&lt;li&gt;9.3.3 将复杂的Lambda表达式分为不同的方法 205&lt;/li&gt;&#xA;&lt;li&gt;9.3.4 高阶函数的测试 206&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;94-调试-206&#34;&gt;&#xA;  9.4 调试 206&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#94-%e8%b0%83%e8%af%95-206&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;9.4.1 查看栈跟踪 206&lt;/li&gt;&#xA;&lt;li&gt;9.4.2 使用日志调试 208&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;95-小结-209&#34;&gt;&#xA;  9.5 小结 209&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#95-%e5%b0%8f%e7%bb%93-209&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第10章基于lambda的领域特定语言210&#34;&gt;&#xA;  第10章　基于Lambda的领域特定语言　　210&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac10%e7%ab%a0%e5%9f%ba%e4%ba%8elambda%e7%9a%84%e9%a2%86%e5%9f%9f%e7%89%b9%e5%ae%9a%e8%af%ad%e8%a8%80210&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;101-领域特定语言-212&#34;&gt;&#xA;  10.1 领域特定语言 212&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#101-%e9%a2%86%e5%9f%9f%e7%89%b9%e5%ae%9a%e8%af%ad%e8%a8%80-212&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;10.1.1 DSL的优点和弊端 212&lt;/li&gt;&#xA;&lt;li&gt;10.1.2 JVM中已提供的DSL解决方案 214&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;102-现代java-api中的小型dsl-217&#34;&gt;&#xA;  10.2 现代Java API中的小型DSL 217&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#102-%e7%8e%b0%e4%bb%a3java-api%e4%b8%ad%e7%9a%84%e5%b0%8f%e5%9e%8bdsl-217&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;10.2.1 把Stream API当成DSL去操作集合 219&lt;/li&gt;&#xA;&lt;li&gt;10.2.2 将Collectors作为DSL汇总数据 220&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;103-使用java创建dsl的模式与技巧-221&#34;&gt;&#xA;  10.3 使用Java创建DSL的模式与技巧 221&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#103-%e4%bd%bf%e7%94%a8java%e5%88%9b%e5%bb%badsl%e7%9a%84%e6%a8%a1%e5%bc%8f%e4%b8%8e%e6%8a%80%e5%b7%a7-221&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;10.3.1 方法链接 224&lt;/li&gt;&#xA;&lt;li&gt;10.3.2 使用嵌套函数 226&lt;/li&gt;&#xA;&lt;li&gt;10.3.3 使用Lambda表达式的函数序列 228&lt;/li&gt;&#xA;&lt;li&gt;10.3.4 把它们都放到一起 230&lt;/li&gt;&#xA;&lt;li&gt;10.3.5 在DSL中使用方法引用 232&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;104-java-8-dsl的实际应用-234&#34;&gt;&#xA;  10.4 Java 8 DSL的实际应用 234&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#104-java-8-dsl%e7%9a%84%e5%ae%9e%e9%99%85%e5%ba%94%e7%94%a8-234&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;10.4.1 jOOQ 235&lt;/li&gt;&#xA;&lt;li&gt;10.4.2 Cucumber 236&lt;/li&gt;&#xA;&lt;li&gt;10.4.3 Spring Integration 238&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;105-小结-239&#34;&gt;&#xA;  10.5 小结 239&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#105-%e5%b0%8f%e7%bb%93-239&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h2 id=&#34;第四部分-无所不在的java&#34;&gt;&#xA;  第四部分 无所不在的Java&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e5%9b%9b%e9%83%a8%e5%88%86-%e6%97%a0%e6%89%80%e4%b8%8d%e5%9c%a8%e7%9a%84java&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;第11章用optional取代null242&#34;&gt;&#xA;  第11章　用Optional取代null　　242&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac11%e7%ab%a0%e7%94%a8optional%e5%8f%96%e4%bb%a3null242&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;111-如何为缺失的值建模-243&#34;&gt;&#xA;  11.1 如何为缺失的值建模 243&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#111-%e5%a6%82%e4%bd%95%e4%b8%ba%e7%bc%ba%e5%a4%b1%e7%9a%84%e5%80%bc%e5%bb%ba%e6%a8%a1-243&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;11.1.1 采用防御式检查减少NullPointerException 243&lt;/li&gt;&#xA;&lt;li&gt;11.1.2 null带来的种种问题 245&lt;/li&gt;&#xA;&lt;li&gt;11.1.3 其他语言中null的替代品 245&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;112-optional类入门-246&#34;&gt;&#xA;  11.2 Optional类入门 246&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#112-optional%e7%b1%bb%e5%85%a5%e9%97%a8-246&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;113-应用optional的几种模式-248&#34;&gt;&#xA;  11.3 应用Optional的几种模式 248&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#113-%e5%ba%94%e7%94%a8optional%e7%9a%84%e5%87%a0%e7%a7%8d%e6%a8%a1%e5%bc%8f-248&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;11.3.1 创建Optional对象 248&lt;/li&gt;&#xA;&lt;li&gt;11.3.2 使用map从Optional对象中提取和转换值 248&lt;/li&gt;&#xA;&lt;li&gt;11.3.3 使用flatMap链接Optional对象 249&lt;/li&gt;&#xA;&lt;li&gt;11.3.4 操纵由Optional对象构成的Stream 253&lt;/li&gt;&#xA;&lt;li&gt;11.3.5 默认行为及解引用Optional对象 254&lt;/li&gt;&#xA;&lt;li&gt;11.3.6 两个Optional对象的组合 255&lt;/li&gt;&#xA;&lt;li&gt;11.3.7 使用filter剔除特定的值 257&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;114-使用optional的实战示例-258&#34;&gt;&#xA;  11.4 使用Optional的实战示例 258&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#114-%e4%bd%bf%e7%94%a8optional%e7%9a%84%e5%ae%9e%e6%88%98%e7%a4%ba%e4%be%8b-258&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;11.4.1 用Optional 封装可能为null的值 259&lt;/li&gt;&#xA;&lt;li&gt;11.4.2 异常与Optional的对比 259&lt;/li&gt;&#xA;&lt;li&gt;11.4.3 基础类型的Optional对象，以及为什么应该避免使用它们 260&lt;/li&gt;&#xA;&lt;li&gt;11.4.4 把所有内容整合起来 260&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;115-小结-262&#34;&gt;&#xA;  11.5 小结 262&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#115-%e5%b0%8f%e7%bb%93-262&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第12章新的日期和时间api263&#34;&gt;&#xA;  第12章　新的日期和时间API　　263&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac12%e7%ab%a0%e6%96%b0%e7%9a%84%e6%97%a5%e6%9c%9f%e5%92%8c%e6%97%b6%e9%97%b4api263&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;121-localdatelocaltimelocaldatetimeinstantduration以及period-264&#34;&gt;&#xA;  12.1 LocalDate、LocalTime、LocalDateTime、Instant、Duration以及Period 264&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#121-localdatelocaltimelocaldatetimeinstantduration%e4%bb%a5%e5%8f%8aperiod-264&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;12.1.1 使用LocalDate和LocalTime 264&lt;/li&gt;&#xA;&lt;li&gt;12.1.2 合并日期和时间 265&lt;/li&gt;&#xA;&lt;li&gt;12.1.3 机器的日期和时间格式 266&lt;/li&gt;&#xA;&lt;li&gt;12.1.4 定义Duration或Period 267&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;122-操纵解析和格式化日期-268&#34;&gt;&#xA;  12.2 操纵、解析和格式化日期 268&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#122-%e6%93%8d%e7%ba%b5%e8%a7%a3%e6%9e%90%e5%92%8c%e6%a0%bc%e5%bc%8f%e5%8c%96%e6%97%a5%e6%9c%9f-268&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;12.2.1 使用TemporalAdjuster 270&lt;/li&gt;&#xA;&lt;li&gt;12.2.2 打印输出及解析日期–时间对象 272&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;123-处理不同的时区和历法-274&#34;&gt;&#xA;  12.3 处理不同的时区和历法 274&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#123-%e5%a4%84%e7%90%86%e4%b8%8d%e5%90%8c%e7%9a%84%e6%97%b6%e5%8c%ba%e5%92%8c%e5%8e%86%e6%b3%95-274&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;12.3.1 使用时区 274&lt;/li&gt;&#xA;&lt;li&gt;12.3.2 利用和UTC/格林尼治时间的固定偏差计算时区 275&lt;/li&gt;&#xA;&lt;li&gt;12.3.3 使用别的日历系统 276&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;124-小结-277&#34;&gt;&#xA;  12.4 小结 277&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#124-%e5%b0%8f%e7%bb%93-277&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第13章默认方法278&#34;&gt;&#xA;  第13章　默认方法　　278&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac13%e7%ab%a0%e9%bb%98%e8%ae%a4%e6%96%b9%e6%b3%95278&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;131-不断演进的api-280&#34;&gt;&#xA;  13.1 不断演进的API 280&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#131-%e4%b8%8d%e6%96%ad%e6%bc%94%e8%bf%9b%e7%9a%84api-280&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;13.1.1 初始版本的API 281&lt;/li&gt;&#xA;&lt;li&gt;13.1.2 第二版API 281&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;132-概述默认方法-283&#34;&gt;&#xA;  13.2 概述默认方法 283&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#132-%e6%a6%82%e8%bf%b0%e9%bb%98%e8%ae%a4%e6%96%b9%e6%b3%95-283&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;133-默认方法的使用模式-285&#34;&gt;&#xA;  13.3 默认方法的使用模式 285&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#133-%e9%bb%98%e8%ae%a4%e6%96%b9%e6%b3%95%e7%9a%84%e4%bd%bf%e7%94%a8%e6%a8%a1%e5%bc%8f-285&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;13.3.1 可选方法 285&lt;/li&gt;&#xA;&lt;li&gt;13.3.2 行为的多继承 286&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;134-解决冲突的规则-289&#34;&gt;&#xA;  13.4 解决冲突的规则 289&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#134-%e8%a7%a3%e5%86%b3%e5%86%b2%e7%aa%81%e7%9a%84%e8%a7%84%e5%88%99-289&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;13.4.1 解决问题的三条规则 289&lt;/li&gt;&#xA;&lt;li&gt;13.4.2 选择提供了最具体实现的默认方法的接口 290&lt;/li&gt;&#xA;&lt;li&gt;13.4.3 冲突及如何显式地消除歧义 291&lt;/li&gt;&#xA;&lt;li&gt;13.4.4 菱形继承问题 293&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;135-小结-294&#34;&gt;&#xA;  13.5 小结 294&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#135-%e5%b0%8f%e7%bb%93-294&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第14章java模块系统295&#34;&gt;&#xA;  第14章　Java模块系统　　295&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac14%e7%ab%a0java%e6%a8%a1%e5%9d%97%e7%b3%bb%e7%bb%9f295&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;141-模块化的驱动力软件的推理-295&#34;&gt;&#xA;  14.1 模块化的驱动力：软件的推理 295&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#141-%e6%a8%a1%e5%9d%97%e5%8c%96%e7%9a%84%e9%a9%b1%e5%8a%a8%e5%8a%9b%e8%bd%af%e4%bb%b6%e7%9a%84%e6%8e%a8%e7%90%86-295&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;14.1.1 关注点分离 295&lt;/li&gt;&#xA;&lt;li&gt;14.1.2 信息隐藏 296&lt;/li&gt;&#xA;&lt;li&gt;14.1.3 Java软件 296&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;142-为什么要设计java模块系统-297&#34;&gt;&#xA;  14.2 为什么要设计Java模块系统 297&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#142-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%ae%be%e8%ae%a1java%e6%a8%a1%e5%9d%97%e7%b3%bb%e7%bb%9f-297&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;14.2.1 模块化的局限性 297&lt;/li&gt;&#xA;&lt;li&gt;14.2.2 单体型的JDK 298&lt;/li&gt;&#xA;&lt;li&gt;14.2.3 与OSGi的比较 299&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;143-java模块全局视图-300&#34;&gt;&#xA;  14.3 Java模块：全局视图 300&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#143-java%e6%a8%a1%e5%9d%97%e5%85%a8%e5%b1%80%e8%a7%86%e5%9b%be-300&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;144-使用java模块系统开发应用-301&#34;&gt;&#xA;  14.4 使用Java模块系统开发应用 301&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#144-%e4%bd%bf%e7%94%a8java%e6%a8%a1%e5%9d%97%e7%b3%bb%e7%bb%9f%e5%bc%80%e5%8f%91%e5%ba%94%e7%94%a8-301&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;14.4.1 从头开始搭建一个应用 302&lt;/li&gt;&#xA;&lt;li&gt;14.4.2 细粒度和粗粒度的模块化 303&lt;/li&gt;&#xA;&lt;li&gt;14.4.3 Java模块系统基础 303&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;145-使用多个模块-304&#34;&gt;&#xA;  14.5 使用多个模块 304&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#145-%e4%bd%bf%e7%94%a8%e5%a4%9a%e4%b8%aa%e6%a8%a1%e5%9d%97-304&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;14.5.1 exports子句 304&lt;/li&gt;&#xA;&lt;li&gt;14.5.2 requires子句 305&lt;/li&gt;&#xA;&lt;li&gt;14.5.3 命名 306&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;146-编译及打包-306&#34;&gt;&#xA;  14.6 编译及打包 306&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#146-%e7%bc%96%e8%af%91%e5%8f%8a%e6%89%93%e5%8c%85-306&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;147-自动模块-310&#34;&gt;&#xA;  14.7 自动模块 310&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#147-%e8%87%aa%e5%8a%a8%e6%a8%a1%e5%9d%97-310&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;148-模块声明及子句-311&#34;&gt;&#xA;  14.8 模块声明及子句 311&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#148-%e6%a8%a1%e5%9d%97%e5%a3%b0%e6%98%8e%e5%8f%8a%e5%ad%90%e5%8f%a5-311&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;14.8.1 requires 311&lt;/li&gt;&#xA;&lt;li&gt;14.8.2 exports 311&lt;/li&gt;&#xA;&lt;li&gt;14.8.3 requires的传递 311&lt;/li&gt;&#xA;&lt;li&gt;14.8.4 exports to 312&lt;/li&gt;&#xA;&lt;li&gt;14.8.5 open和opens 312&lt;/li&gt;&#xA;&lt;li&gt;14.8.6 uses和provides 313&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;149-通过一个更复杂的例子了解更多-313&#34;&gt;&#xA;  14.9 通过一个更复杂的例子了解更多 313&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#149-%e9%80%9a%e8%bf%87%e4%b8%80%e4%b8%aa%e6%9b%b4%e5%a4%8d%e6%9d%82%e7%9a%84%e4%be%8b%e5%ad%90%e4%ba%86%e8%a7%a3%e6%9b%b4%e5%a4%9a-313&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;1410-小结-314&#34;&gt;&#xA;  14.10 小结 314&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1410-%e5%b0%8f%e7%bb%93-314&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h2 id=&#34;第五部分-提升java的并发性&#34;&gt;&#xA;  第五部分 提升Java的并发性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e4%ba%94%e9%83%a8%e5%88%86-%e6%8f%90%e5%8d%87java%e7%9a%84%e5%b9%b6%e5%8f%91%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;第15章completablefuture及反应式编程背后的概念316&#34;&gt;&#xA;  第15章　CompletableFuture及反应式编程背后的概念　　316&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac15%e7%ab%a0completablefuture%e5%8f%8a%e5%8f%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e8%83%8c%e5%90%8e%e7%9a%84%e6%a6%82%e5%bf%b5316&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;151-为支持并发而不断演进的java-318&#34;&gt;&#xA;  15.1 为支持并发而不断演进的Java 318&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#151-%e4%b8%ba%e6%94%af%e6%8c%81%e5%b9%b6%e5%8f%91%e8%80%8c%e4%b8%8d%e6%96%ad%e6%bc%94%e8%bf%9b%e7%9a%84java-318&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;15.1.1 线程以及更高层的抽象 319&lt;/li&gt;&#xA;&lt;li&gt;15.1.2 执行器和线程池 320&lt;/li&gt;&#xA;&lt;li&gt;15.1.3 其他的线程抽象：非嵌套方法调用 322&lt;/li&gt;&#xA;&lt;li&gt;15.1.4 你希望线程为你带来什么 324&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;152-同步及异步api-324&#34;&gt;&#xA;  15.2 同步及异步API 324&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#152-%e5%90%8c%e6%ad%a5%e5%8f%8a%e5%bc%82%e6%ad%a5api-324&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;15.2.1 Future风格的API 326&lt;/li&gt;&#xA;&lt;li&gt;15.2.2 反应式风格的API 327&lt;/li&gt;&#xA;&lt;li&gt;15.2.3 有害的睡眠及其他阻塞式操作 328&lt;/li&gt;&#xA;&lt;li&gt;15.2.4 实战验证 329&lt;/li&gt;&#xA;&lt;li&gt;15.2.5 如何使用异步API进行异常处理 330&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;153-线框管道模型-331&#34;&gt;&#xA;  15.3 “线框–管道”模型 331&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#153-%e7%ba%bf%e6%a1%86%e7%ae%a1%e9%81%93%e6%a8%a1%e5%9e%8b-331&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;154-为并发而生的completablefuture和结合器-332&#34;&gt;&#xA;  15.4 为并发而生的CompletableFuture和结合器 332&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#154-%e4%b8%ba%e5%b9%b6%e5%8f%91%e8%80%8c%e7%94%9f%e7%9a%84completablefuture%e5%92%8c%e7%bb%93%e5%90%88%e5%99%a8-332&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;155-发布订阅以及反应式编程-335&#34;&gt;&#xA;  15.5 “发布–订阅”以及反应式编程 335&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#155-%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%e4%bb%a5%e5%8f%8a%e5%8f%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b-335&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;15.5.1 示例：对两个流求和 337&lt;/li&gt;&#xA;&lt;li&gt;15.5.2 背压 341&lt;/li&gt;&#xA;&lt;li&gt;15.5.3 一种简单的真实背压 341&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;156-反应式系统和反应式编程-342&#34;&gt;&#xA;  15.6 反应式系统和反应式编程 342&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#156-%e5%8f%8d%e5%ba%94%e5%bc%8f%e7%b3%bb%e7%bb%9f%e5%92%8c%e5%8f%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b-342&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;157-路线图-342&#34;&gt;&#xA;  15.7 路线图 342&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#157-%e8%b7%af%e7%ba%bf%e5%9b%be-342&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;158-小结-343&#34;&gt;&#xA;  15.8 小结 343&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#158-%e5%b0%8f%e7%bb%93-343&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第16章completablefuture组合式异步编程344&#34;&gt;&#xA;  第16章　CompletableFuture：组合式异步编程　　344&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac16%e7%ab%a0completablefuture%e7%bb%84%e5%90%88%e5%bc%8f%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b344&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;161-future接口-344&#34;&gt;&#xA;  16.1 Future接口 344&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#161-future%e6%8e%a5%e5%8f%a3-344&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;16.1.1 Future接口的局限性 346&lt;/li&gt;&#xA;&lt;li&gt;16.1.2 使用CompletableFuture构建异步应用 346&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;162-实现异步api-347&#34;&gt;&#xA;  16.2 实现异步API 347&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#162-%e5%ae%9e%e7%8e%b0%e5%bc%82%e6%ad%a5api-347&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;16.2.1 将同步方法转换为异步方法 348&lt;/li&gt;&#xA;&lt;li&gt;16.2.2 错误处理 350&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;163-让你的代码免受阻塞之苦-352&#34;&gt;&#xA;  16.3 让你的代码免受阻塞之苦 352&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#163-%e8%ae%a9%e4%bd%a0%e7%9a%84%e4%bb%a3%e7%a0%81%e5%85%8d%e5%8f%97%e9%98%bb%e5%a1%9e%e4%b9%8b%e8%8b%a6-352&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;16.3.1 使用并行流对请求进行并行操作 353&lt;/li&gt;&#xA;&lt;li&gt;16.3.2 使用CompletableFuture发起异步请求 353&lt;/li&gt;&#xA;&lt;li&gt;16.3.3 寻找更好的方案 355&lt;/li&gt;&#xA;&lt;li&gt;16.3.4 使用定制的执行器 356&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;164-对多个异步任务进行流水线操作-358&#34;&gt;&#xA;  16.4 对多个异步任务进行流水线操作 358&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#164-%e5%af%b9%e5%a4%9a%e4%b8%aa%e5%bc%82%e6%ad%a5%e4%bb%bb%e5%8a%a1%e8%bf%9b%e8%a1%8c%e6%b5%81%e6%b0%b4%e7%ba%bf%e6%93%8d%e4%bd%9c-358&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;16.4.1 实现折扣服务 358&lt;/li&gt;&#xA;&lt;li&gt;16.4.2 使用Discount服务 359&lt;/li&gt;&#xA;&lt;li&gt;16.4.3 构造同步和异步操作 360&lt;/li&gt;&#xA;&lt;li&gt;16.4.4 将两个CompletableFuture对象整合起来，无论它们是否存在依赖 363&lt;/li&gt;&#xA;&lt;li&gt;16.4.5 对Future和Completable-Future 的回顾 364&lt;/li&gt;&#xA;&lt;li&gt;16.4.6 高效地使用超时机制 365&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;165-响应completablefuture的completion事件-366&#34;&gt;&#xA;  16.5 响应CompletableFuture的completion事件 366&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#165-%e5%93%8d%e5%ba%94completablefuture%e7%9a%84completion%e4%ba%8b%e4%bb%b6-366&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;16.5.1 对最佳价格查询器应用的优化 367&lt;/li&gt;&#xA;&lt;li&gt;16.5.2 付诸实践 368&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;166-路线图-369&#34;&gt;&#xA;  16.6 路线图 369&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#166-%e8%b7%af%e7%ba%bf%e5%9b%be-369&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;167-小结-369&#34;&gt;&#xA;  16.7 小结 369&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#167-%e5%b0%8f%e7%bb%93-369&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第17章反应式编程370&#34;&gt;&#xA;  第17章　反应式编程　　370&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac17%e7%ab%a0%e5%8f%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b370&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;171-反应式宣言-371&#34;&gt;&#xA;  17.1 反应式宣言 371&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#171-%e5%8f%8d%e5%ba%94%e5%bc%8f%e5%ae%a3%e8%a8%80-371&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;17.1.1 应用层的反应式编程 371&lt;/li&gt;&#xA;&lt;li&gt;17.1.2 反应式系统 373&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;172-反应式流以及flow-api-373&#34;&gt;&#xA;  17.2 反应式流以及Flow API 373&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#172-%e5%8f%8d%e5%ba%94%e5%bc%8f%e6%b5%81%e4%bb%a5%e5%8f%8aflow-api-373&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;17.2.1 Flow类 374&lt;/li&gt;&#xA;&lt;li&gt;17.2.2 创建你的第一个反应式应用 377&lt;/li&gt;&#xA;&lt;li&gt;17.2.3 使用Processor转换数据 381&lt;/li&gt;&#xA;&lt;li&gt;17.2.4 为什么Java并未提供Flow API的实现 383&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;173-使用反应式库rxjava-384&#34;&gt;&#xA;  17.3 使用反应式库RxJava 384&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#173-%e4%bd%bf%e7%94%a8%e5%8f%8d%e5%ba%94%e5%bc%8f%e5%ba%93rxjava-384&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;17.3.1 创建和使用Observable 385&lt;/li&gt;&#xA;&lt;li&gt;17.3.2 转换及整合多个Observable 392&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第六部分-函数式编程以及java未来的演进&#34;&gt;&#xA;  第六部分 函数式编程以及Java未来的演进&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e5%85%ad%e9%83%a8%e5%88%86-%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e4%bb%a5%e5%8f%8ajava%e6%9c%aa%e6%9d%a5%e7%9a%84%e6%bc%94%e8%bf%9b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;第18章函数式的思考396&#34;&gt;&#xA;  第18章　函数式的思考　　396&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac18%e7%ab%a0%e5%87%bd%e6%95%b0%e5%bc%8f%e7%9a%84%e6%80%9d%e8%80%83396&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;181-实现和维护系统-396&#34;&gt;&#xA;  18.1 实现和维护系统 396&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#181-%e5%ae%9e%e7%8e%b0%e5%92%8c%e7%bb%b4%e6%8a%a4%e7%b3%bb%e7%bb%9f-396&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;18.1.1 共享的可变数据 397&lt;/li&gt;&#xA;&lt;li&gt;18.1.2 声明式编程 398&lt;/li&gt;&#xA;&lt;li&gt;18.1.3 为什么要采用函数式编程 399&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;182-什么是函数式编程-399&#34;&gt;&#xA;  18.2 什么是函数式编程 399&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#182-%e4%bb%80%e4%b9%88%e6%98%af%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b-399&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;18.2.1 函数式Java编程 400&lt;/li&gt;&#xA;&lt;li&gt;18.2.2 引用透明性 402&lt;/li&gt;&#xA;&lt;li&gt;18.2.3 面向对象的编程和函数式编程的对比 402&lt;/li&gt;&#xA;&lt;li&gt;18.2.4 函数式编程实战 403&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;183-递归和迭代-405&#34;&gt;&#xA;  18.3 递归和迭代 405&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#183-%e9%80%92%e5%bd%92%e5%92%8c%e8%bf%ad%e4%bb%a3-405&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;184-小结-408&#34;&gt;&#xA;  18.4 小结 408&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#184-%e5%b0%8f%e7%bb%93-408&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第19章函数式编程的技巧409&#34;&gt;&#xA;  第19章　函数式编程的技巧　　409&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac19%e7%ab%a0%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e7%9a%84%e6%8a%80%e5%b7%a7409&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;191-无处不在的函数-409&#34;&gt;&#xA;  19.1 无处不在的函数 409&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#191-%e6%97%a0%e5%a4%84%e4%b8%8d%e5%9c%a8%e7%9a%84%e5%87%bd%e6%95%b0-409&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;19.1.1 高阶函数 410&lt;/li&gt;&#xA;&lt;li&gt;19.1.2 柯里化 411&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;192-持久化数据结构-412&#34;&gt;&#xA;  19.2 持久化数据结构 412&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#192-%e6%8c%81%e4%b9%85%e5%8c%96%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-412&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;19.2.1 破坏式更新和函数式更新的比较 413&lt;/li&gt;&#xA;&lt;li&gt;19.2.2 另一个使用Tree的例子 415&lt;/li&gt;&#xA;&lt;li&gt;19.2.3 采用函数式的方法 416&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;193-stream的延迟计算-418&#34;&gt;&#xA;  19.3 Stream的延迟计算 418&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#193-stream%e7%9a%84%e5%bb%b6%e8%bf%9f%e8%ae%a1%e7%ae%97-418&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;19.3.1 自定义的Stream 418&lt;/li&gt;&#xA;&lt;li&gt;19.3.2 创建你自己的延迟列表 420&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;194-模式匹配-425&#34;&gt;&#xA;  19.4 模式匹配 425&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#194-%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d-425&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;19.4.1 访问者模式 425&lt;/li&gt;&#xA;&lt;li&gt;19.4.2 用模式匹配力挽狂澜 426&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;195-杂项-429&#34;&gt;&#xA;  19.5 杂项 429&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#195-%e6%9d%82%e9%a1%b9-429&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;19.5.1 缓存或记忆表 429&lt;/li&gt;&#xA;&lt;li&gt;19.5.2 “返回同样的对象”意味着什么 430&lt;/li&gt;&#xA;&lt;li&gt;19.5.3 结合器 431&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;196-小结-432&#34;&gt;&#xA;  19.6 小结 432&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#196-%e5%b0%8f%e7%bb%93-432&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第20章面向对象和函数式编程的混合java和scala的比较433&#34;&gt;&#xA;  第20章　面向对象和函数式编程的混合：Java和Scala的比较　　433&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac20%e7%ab%a0%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e5%92%8c%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e7%9a%84%e6%b7%b7%e5%90%88java%e5%92%8cscala%e7%9a%84%e6%af%94%e8%be%83433&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;201-scala简介-434&#34;&gt;&#xA;  20.1 Scala简介 434&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#201-scala%e7%ae%80%e4%bb%8b-434&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;20.1.1 你好，啤酒 434&lt;/li&gt;&#xA;&lt;li&gt;20.1.2 基础数据结构：List、Set、Map、Tuple、Stream以及Option 436&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;202-函数-440&#34;&gt;&#xA;  20.2 函数 440&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#202-%e5%87%bd%e6%95%b0-440&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;20.2.1 Scala中的一等函数 441&lt;/li&gt;&#xA;&lt;li&gt;20.2.2 匿名函数和闭包 442&lt;/li&gt;&#xA;&lt;li&gt;20.2.3 柯里化 443&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;203-类和trait-444&#34;&gt;&#xA;  20.3 类和trait 444&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#203-%e7%b1%bb%e5%92%8ctrait-444&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;20.3.1 更加简洁的Scala类 445&lt;/li&gt;&#xA;&lt;li&gt;20.3.2 Scala的trait与Java 8的接口对比 446&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;204-小结-447&#34;&gt;&#xA;  20.4 小结 447&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#204-%e5%b0%8f%e7%bb%93-447&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;第21章结论以及java的未来448&#34;&gt;&#xA;  第21章　结论以及Java的未来　　448&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac21%e7%ab%a0%e7%bb%93%e8%ae%ba%e4%bb%a5%e5%8f%8ajava%e7%9a%84%e6%9c%aa%e6%9d%a5448&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;211-回顾java-8的语言特性-448&#34;&gt;&#xA;  21.1 回顾Java 8的语言特性 448&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#211-%e5%9b%9e%e9%a1%bejava-8%e7%9a%84%e8%af%ad%e8%a8%80%e7%89%b9%e6%80%a7-448&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;21.1.1 行为参数化（Lambda以及方法引用） 449&lt;/li&gt;&#xA;&lt;li&gt;21.1.2 流 449&lt;/li&gt;&#xA;&lt;li&gt;21.1.3 CompletableFuture 450&lt;/li&gt;&#xA;&lt;li&gt;21.1.4 Optional 450&lt;/li&gt;&#xA;&lt;li&gt;21.1.5 Flow API 451&lt;/li&gt;&#xA;&lt;li&gt;21.1.6 默认方法 451&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;212-java-9的模块系统-451&#34;&gt;&#xA;  21.2 Java 9的模块系统 451&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#212-java-9%e7%9a%84%e6%a8%a1%e5%9d%97%e7%b3%bb%e7%bb%9f-451&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;213-java-10的局部变量类型推断-453&#34;&gt;&#xA;  21.3 Java 10的局部变量类型推断 453&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#213-java-10%e7%9a%84%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%ad-453&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;214-java的未来-454&#34;&gt;&#xA;  21.4 Java的未来 454&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#214-java%e7%9a%84%e6%9c%aa%e6%9d%a5-454&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;21.4.1 声明处型变 454&lt;/li&gt;&#xA;&lt;li&gt;21.4.2 模式匹配 454&lt;/li&gt;&#xA;&lt;li&gt;21.4.3 更加丰富的泛型形式 455&lt;/li&gt;&#xA;&lt;li&gt;21.4.4 对不变性的更深层支持 457&lt;/li&gt;&#xA;&lt;li&gt;21.4.5 值类型 458&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;215-让java发展得更快-461&#34;&gt;&#xA;  21.5 让Java发展得更快 461&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#215-%e8%ae%a9java%e5%8f%91%e5%b1%95%e5%be%97%e6%9b%b4%e5%bf%ab-461&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;216-写在最后的话-462&#34;&gt;&#xA;  21.6 写在最后的话 462&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#216-%e5%86%99%e5%9c%a8%e6%9c%80%e5%90%8e%e7%9a%84%e8%af%9d-462&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;附录A 其他语言特性的更新 463&lt;/li&gt;&#xA;&lt;li&gt;附录B 其他类库的更新 467&lt;/li&gt;&#xA;&lt;li&gt;附录C 如何以并发方式在同一个流上执行多种操作 475&lt;/li&gt;&#xA;&lt;li&gt;附录D Lambda表达式和JVM字节码 483&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Python神经网络编程</title>
      <link>/zh/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;第1章-神经网络如何工作&#34;&gt;&#xA;  第1章 神经网络如何工作&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac1%e7%ab%a0-%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Redis设计与实现</title>
      <link>/zh/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;h2 id=&#34;第2章-简单动态字符串&#34;&gt;&#xA;  第2章 简单动态字符串&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac2%e7%ab%a0-%e7%ae%80%e5%8d%95%e5%8a%a8%e6%80%81%e5%ad%97%e7%ac%a6%e4%b8%b2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS（Simple Dynamic String，简单动态字符串）作为字符串表示。&lt;/li&gt;&#xA;&lt;li&gt;比起C字符串，SDS具有以下优点：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1）常数复杂度获取字符串长度。&lt;/li&gt;&#xA;&lt;li&gt;2）杜绝缓冲区溢出。&lt;/li&gt;&#xA;&lt;li&gt;3）减少修改字符串长度时所需的内存重分配次数。&lt;/li&gt;&#xA;&lt;li&gt;4）二进制安全。&lt;/li&gt;&#xA;&lt;li&gt;5）兼容部分C字符串函数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第3章-链表&#34;&gt;&#xA;  第3章 链表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac3%e7%ab%a0-%e9%93%be%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。&lt;/li&gt;&#xA;&lt;li&gt;每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是&lt;strong&gt;双端链表&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;每个链表使用一个list结构来表示，这个结构带有&lt;strong&gt;表头节点指针&lt;/strong&gt;、&lt;strong&gt;表尾节点指针&lt;/strong&gt;，以及&lt;strong&gt;链表长度&lt;/strong&gt;等信息。&lt;/li&gt;&#xA;&lt;li&gt;因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是&lt;strong&gt;无环链表&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;通过为链表设置不同的类型特定函数，Redis的链表可以用于&lt;strong&gt;保存各种不同类型的值&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第4章-字典&#34;&gt;&#xA;  第4章 字典&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac4%e7%ab%a0-%e5%ad%97%e5%85%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。&lt;/li&gt;&#xA;&lt;li&gt;Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。&lt;/li&gt;&#xA;&lt;li&gt;当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用&lt;strong&gt;MurmurHash2&lt;/strong&gt;算法来计算键的哈希值。&lt;/li&gt;&#xA;&lt;li&gt;哈希表使用&lt;strong&gt;链地址法&lt;/strong&gt;来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。&lt;/li&gt;&#xA;&lt;li&gt;在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是&lt;strong&gt;渐进式&lt;/strong&gt;地完成的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第5章-跳跃表&#34;&gt;&#xA;  第5章 跳跃表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac5%e7%ab%a0-%e8%b7%b3%e8%b7%83%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;跳跃表是有序集合的底层实现之一。&lt;/li&gt;&#xA;&lt;li&gt;Redis的跳跃表实现由&lt;code&gt;zskiplist&lt;/code&gt;和&lt;code&gt;zskiplistNode&lt;/code&gt;两个结构组成，其中&lt;code&gt;zskiplist&lt;/code&gt;用于保存跳跃表信息（比如表头节点、表尾节点、长度），而&lt;code&gt;zskiplistNode&lt;/code&gt;则用于表示跳跃表节点。&lt;/li&gt;&#xA;&lt;li&gt;每个跳跃表节点的层高都是1至32之间的随机数。&lt;/li&gt;&#xA;&lt;li&gt;在同一个跳跃表中，多个节点可以包含相同的&lt;code&gt;分值&lt;/code&gt;，但每个节点的&lt;code&gt;成员对象&lt;/code&gt;必须是唯一的。&lt;/li&gt;&#xA;&lt;li&gt;跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第6章-整数集合&#34;&gt;&#xA;  第6章 整数集合&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac6%e7%ab%a0-%e6%95%b4%e6%95%b0%e9%9b%86%e5%90%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;整数集合是集合键的底层实现之一&lt;/li&gt;&#xA;&lt;li&gt;整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型&lt;/li&gt;&#xA;&lt;li&gt;升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存&lt;/li&gt;&#xA;&lt;li&gt;整数集合只支持升级操作，不支持降级操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第7章-压缩列表&#34;&gt;&#xA;  第7章 压缩列表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac7%e7%ab%a0-%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;压缩列表是一种为&lt;strong&gt;节约内存&lt;/strong&gt;而开发的顺序型数据结构&lt;/li&gt;&#xA;&lt;li&gt;压缩列表被用作列表键和哈希键的底层实现之一&lt;/li&gt;&#xA;&lt;li&gt;压缩列表可以包含多个节点，每个节点可以保存一个&lt;strong&gt;字节数组&lt;/strong&gt;或者&lt;strong&gt;整数值&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发&lt;strong&gt;连锁更新&lt;/strong&gt;操作，但这种操作出现的几率并不高&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第8章-对象&#34;&gt;&#xA;  第8章 对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac8%e7%ab%a0-%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）&lt;/li&gt;&#xA;&lt;li&gt;对象的类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;字符串对象 &lt;code&gt;REDIS_STRING&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;列表对象 &lt;code&gt;REDIS_LIST&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;哈希对象 &lt;code&gt;REDIS_HASH&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;集合对象 &lt;code&gt;REDIS_SET&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;有序集合对象 &lt;code&gt;REDIS_ZSET&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”&lt;/li&gt;&#xA;&lt;li&gt;当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;因为键的类型始终为字符串&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Spring Cloud微服务：入门、实战与进阶</title>
      <link>/zh/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/</guid>
      <description>&lt;h3 id=&#34;13-什么是spring-cloud&#34;&gt;&#xA;  1.3 什么是Spring Cloud&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#13-%e4%bb%80%e4%b9%88%e6%98%afspring-cloud&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Eureka&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务注册中心，用于服务管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Ribbon&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于客户端的负载均衡组件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Hystrix&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;容错框架，能够防止服务的雪崩效应&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Feign&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Web服务客户端，能够简化HTTP接口的调用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Zuul&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;API网关，提供路由转发、请求过滤等功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Config&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分布式配置管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Sleuth&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务跟踪&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Stream&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;构建消息驱动的微服务应用程序的框架&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Bus&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;消息代理的集群消息总线。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第3章eureka注册中心&#34;&gt;&#xA;  第3章　Eureka注册中心&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac3%e7%ab%a0eureka%e6%b3%a8%e5%86%8c%e4%b8%ad%e5%bf%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring Cloud Eureka是一个基于REST的服务，并且提供了基于Java的客户端组件，能够非常方便地&lt;strong&gt;将服务注册到Spring Cloud Eureka中进行统一管理&lt;/strong&gt;。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;服务治理&lt;/strong&gt;是微服务架构中必不可少的一部分，阿里开源的Dubbo框架就是针对服务治理的。服务治理必须要有一个注册中心，除了用Eureka作为注册中心外，我们还可以使用Consul、Etcd、Zookeeper等来作为服务的注册中心。&lt;/li&gt;&#xA;&lt;li&gt;用过Dubbo的读者应该清楚，Dubbo中也有几种注册中心，比如基于Zookeeper、基于Redis等，不过用得最多的还是Zookeeper方式。至于使用哪种方式都是可以的，&lt;strong&gt;注册中心无非就是管理所有服务的信息和状态&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;程序也是一样，&lt;strong&gt;当你需要调用某一个服务的时候，你会先去Eureka中去拉取服务列表，查看你调用的服务在不在其中，在的话就拿到服务地址、端口等信息，然后调用&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;为什么Eureka比Zookeeper更适合作为注册中心呢？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主要是因为&lt;strong&gt;Eureka是基于AP原则构建的，而ZooKeeper是基于CP原则构建的&lt;/strong&gt;。在分布式系统领域有个著名的CAP定理，即&lt;strong&gt;C为数据一致性；A为服务可用性；P为服务对网络分区故障的容错性&lt;/strong&gt;。这三个特性在任何分布式系统中都不能同时满足，最多同时满足两个。&lt;/li&gt;&#xA;&lt;li&gt;Zookeeper有一个Leader，而且在这个Leader无法使用的时候通过Paxos(ZAB)算法选举出一个新的Leader。这个Leader的任务就是保证写数据的时候只向这个Leader写入，Leader会同步信息到其他节点。通过这个操作就可以保证数据的一致性。&lt;/li&gt;&#xA;&lt;li&gt;总而言之，想要保证AP就要用Eureka，想要保证CP就要用Zookeeper。Dubbo中大部分都是基于Zookeeper作为注册中心的。Spring Cloud中当然首选Eureka。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第4章客户端负载均衡ribbon&#34;&gt;&#xA;  第4章　客户端负载均衡Ribbon&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac4%e7%ab%a0%e5%ae%a2%e6%88%b7%e7%ab%af%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1ribbon&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目前主流的负载方案分为两种：一种是&lt;strong&gt;集中式负载均衡&lt;/strong&gt;，在消费者和服务提供方中间使用独立的代理方式进行负载，有硬件的（比如F5），也有软件的（比如Nginx）。另一种则是客户端自己做负载均衡，根据自己的请求情况做负载，&lt;strong&gt;Ribbon就属于客户端自己做负载&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;Ribbon作为一款客户端负载均衡框架，&lt;strong&gt;默认的负载策略是轮询&lt;/strong&gt;，同时也提供了很多其他的策略，能够让用户根据自身的业务需求进行选择。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第6章hystrix服务容错处理&#34;&gt;&#xA;  第6章　Hystrix服务容错处理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac6%e7%ab%a0hystrix%e6%9c%8d%e5%8a%a1%e5%ae%b9%e9%94%99%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在微服务架构中存在多个可直接调用的服务，这些服务若在调用时出现故障会导致连锁效应，也就是可能会让整个系统变得不可用，这种情况我们称之为&lt;strong&gt;服务雪崩效应&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;Hystrix是Netflix针对微服务分布式系统采用的&lt;strong&gt;熔断保护中间件&lt;/strong&gt;，相当于电路中的保险丝。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>深入浅出HTTPS：从原理到实战</title>
      <link>/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;2015年百度搜索引擎完成其历史上最大的系统性升级——全面由HTTP升级到HTTPS&lt;/li&gt;&#xA;&lt;li&gt;2016年苹果公告要求App Store中的所有应用在2017年1月1日之后都必须使用HTTPS加密连接&lt;/li&gt;&#xA;&lt;li&gt;2017年1月9日微信上线小程序后，要求开发者的所有服务端请求必须为HTTPS&lt;/li&gt;&#xA;&lt;li&gt;同时Google已调整搜索引擎算法，让采用HTTPS的网站在搜索结果中排名更靠前，并宣布从2018年7月开始所有的HTTP网站将标记为“不安全”&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第1章-http介绍&#34;&gt;&#xA;  第1章 HTTP介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac1%e7%ab%a0-http%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTP的特点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;客户端/服务器模型&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;客户端和服务器是否正确传输依赖于TCP这个协议。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HTTP是无状态的&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所谓的无状态就是每次请求完成后，不会在客户端和服务器上保存任何的信息，对于客户端和服务器来说，根本不知道上一次请求的信息是什么，甚至不知道本次连接的对端是不是上次连接的那一端，它的生命周期随着TCP/IP连接的关闭结束了&lt;/li&gt;&#xA;&lt;li&gt;无状态的设计已经不能适应新的情况，为了保持状态，出现了Cookie和Session技术，但是Cookie技术设计得非常不严谨，引发了很多安全问题。&lt;/li&gt;&#xA;&lt;li&gt;介绍下Cookie是如何进行会话保持的，客户端第一次请求完成后，服务器会发送Cookie信息到客户端的计算机上，客户端下次请求的时候会携带该Cookie信息，这样服务器就知道该用户就是上一次请求的用户了。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HTTP是跨平台的&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过上面的讲解，读者知道HTTP就是具备一定规则的纯文本信息，任何开发语言都可以实现HTTP或者基于HTTP进行开发，开发出来的软件也很容易移植，受系统环境的影响非常少。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HTTP用途很广泛&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;13-网络模型&#34;&gt;&#xA;  1.3 网络模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#13-%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTP是应用层协议，应用层协议是TCP/IP的一部分&lt;/li&gt;&#xA;&lt;li&gt;OSI模型是一个通用的网络协议标准，但实际使用的标准却是TCP/IP标准，TCP/IP包含的不仅仅是TCP或者IP，它是一个协议族，网络应用开发都需要掌握TCP/IP。&lt;/li&gt;&#xA;&lt;li&gt;TCP/IP有两个最大的特点，分别是分层和封包/拆包机制&lt;/li&gt;&#xA;&lt;li&gt;每一层和它的上下层都有标准的接口规范，每一层无须关心上下层是如何工作的，它只关心上下层是否正确基于规范实现了接口&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果没有应用层，那么网络中传输的数据没有任何意义，因为人类无法理解数据的含义。而有了应用层，软件就能解释应用层数据的含义。在Web应用中，有了HTTP和HTML标准，浏览器才能呈现对用户有意义的内容。&lt;/li&gt;&#xA;&lt;li&gt;应用层协议有很多，比如HTTP、FTP、邮件协议，开发者开发的软件一般都是应用层协议软件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;网络层&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;网络层主要是IP这个协议，客户端和服务器传输的时候，会经过很多节点，IP就是选择一条最优的路径。每个终端上都有一张路由表，路由表负责将数据传输到下一个节点，下一个节点再传输到下下个节点，最终到达目的地址。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;链路层&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应用层、传输层、网络层都是虚拟的，只有链路层才是实体设备，包括光纤、网卡等设备。基于这些设备，数据最终才能到达终端。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;接下来简单描述封包/拆包机制，对于客户端请求来说，传输层接收到应用层消息后，在HTTP数据包前面增加TCP包头，然后发送给网络层；网络层在TCP数据包前面加上IP包头发送给链路层；链路层在IP数据包前面加上以太网包头；最终服务器接收到完整的数据包。&lt;/li&gt;&#xA;&lt;li&gt;然后服务器进行拆包：首先在网络层去除链路层包头；在传输层去除IP包头；在应用层去除TCP包头；最终得到完整的HTTP应用层数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;14-协议安全分析&#34;&gt;&#xA;  1.4 协议安全分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#14-%e5%8d%8f%e8%ae%ae%e5%ae%89%e5%85%a8%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;协议不安全的根本原因&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据没有加密&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;无法验证身份&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据易篡改&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第2章-密码学&#34;&gt;&#xA;  第2章 密码学&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac2%e7%ab%a0-%e5%af%86%e7%a0%81%e5%ad%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;21-对于密码学的认知&#34;&gt;&#xA;  2.1 对于密码学的认知&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#21-%e5%af%b9%e4%ba%8e%e5%af%86%e7%a0%81%e5%ad%a6%e7%9a%84%e8%ae%a4%e7%9f%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OpenSSL&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OpenSSL命令行功能非常强大，有很多的子命令和参数，如果不理解密码学算法，根本无法理解子命令和参数的含义，这是难学习的根本原因，也说明学习OpenSSL之前必须先掌握密码学算法。&lt;/li&gt;&#xA;&lt;li&gt;不同版本的OpenSSL命令行工具在使用的时候有一些差别，同样一条命令，读者会发现在特定版本下可能无法正确运行。&lt;/li&gt;&#xA;&lt;li&gt;OpenSSL命令行的帮助手册和文档描写得不是很通俗，很难进行系统的学习。&lt;/li&gt;&#xA;&lt;li&gt;完成同样一个操作，OpenSSL命令行有许多方法实现，这可能会干扰读者的学习。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;22-随机数&#34;&gt;&#xA;  2.2 随机数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#22-%e9%9a%8f%e6%9c%ba%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;而对于PRNG来说，内部状态的数值来自于模拟的数值，称为种子（seed）。随机数生成器每次生成随机数的时候，内部状态的值都会变化，这样才能产生不一样的随机数，如果每次熵和种子是一样的，生成的随机数也是相同的，所以熵和种子对于随机数生成器非常重要。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;23-hash算法&#34;&gt;&#xA;  2.3 Hash算法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#23-hash%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于Hash算法有很多功能，所以Hash算法有多种称呼，比如&lt;strong&gt;摘要算法（Message Digest Algorithms）&lt;/strong&gt;、&lt;strong&gt;单向散列函数（Cryptographic One-way Hash Functions）&lt;/strong&gt;。输出值也有多种称呼，比如&lt;strong&gt;摘要值&lt;/strong&gt;、&lt;strong&gt;散列&lt;/strong&gt;、&lt;strong&gt;指纹&lt;/strong&gt;。读者看到这些名词的时候，都可以理解为Hash算法&lt;/li&gt;&#xA;&lt;li&gt;密码学Hash算法的主要特性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;相同的消息总是能得到同样的摘要值，特定的Hash算法，不管消息长度是多少，最终的摘要值长度是相同的。&lt;/li&gt;&#xA;&lt;li&gt;不管多长的消息，Hash运算非常快速，这是非常重要的特性。&lt;/li&gt;&#xA;&lt;li&gt;通过摘要值很难逆向计算出原始消息，Hash算法具备单向性，摘要值是不可逆的，这也是非常重要的特性。为了逆向计算出原始消息，唯一的方法就是采用暴力攻击、字典攻击、彩虹表，对不同的消息组合进行迭代运算，运算的结果如果匹配该消息的摘要值，表示该Hash算法不应该用于密码学。&lt;/li&gt;&#xA;&lt;li&gt;原始消息一旦修改，即使是很轻微的修改，最终的摘要值也会产生变化。&lt;/li&gt;&#xA;&lt;li&gt;很难找出两个不同的消息，并且它们的摘要值是相同的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Hash算法的用途&#xA;&lt;ul&gt;&#xA;&lt;li&gt;文件比较&lt;/li&gt;&#xA;&lt;li&gt;身份校验&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;密码学Hash算法的分类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MD5&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MD5是一种比较常用的Hash算法，摘要值长度固定是128比特，MD5算法目前被证明已经不安全了，MD5算法违反了强抗碰撞性原则，但是还没有破坏单一性原则。&lt;/li&gt;&#xA;&lt;li&gt;理论上经过2^80次运算就能产生碰撞，但目前最快只要经过2^63次运算就能破坏强抗碰撞性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SHA&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SHA（Secure Hash Algorithms）算法是美国国家标准与技术研究院（NIST）指定的算法，SHA算法不是一个算法，而是一组算法，主要分为三类算法。&lt;/li&gt;&#xA;&lt;li&gt;SHA-1&lt;/li&gt;&#xA;&lt;li&gt;SHA-2&lt;/li&gt;&#xA;&lt;li&gt;SHA-3&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;24-对称加密算法&#34;&gt;&#xA;  2.4 对称加密算法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#24-%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;建议使用AES算法，该算法是对称加密算法的标准算法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;美国国家标准与技术研究院（National Institute of Standards and Technology, NIST）对众多的对称加密算法进行了考核，从安全性和效率进行了多方面评测，最终选取Rijndael算法作为对称加密算法的标准。以Rijndael算法为原型，创建了AES（Advanced Encryption Standard）算法，AES就是最终的对称加密算法标准。Rijndael算法和AES算法略微不同，但在理解的时候可以认为是相同的算法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;流密码算法&lt;/li&gt;&#xA;&lt;li&gt;块密码算法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;迭代模式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECB模式（Electronic Codebook）是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECB模式（Electronic Codebook）是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CBC模式（Cipher Block Chaining）是比较常见的一种迭代模式，解决了ECB模式的安全问题。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;迭代运算数据块不能并行处理，只有处理完第n个数据块，才能继续处理第n+1个数据块。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CTR模式（counter）在迭代的时候，相当于是一个流密码的运行模式。每次迭代运算的时候要生成一个密钥流（keystream），生成密钥流的方法可以是任意的，但是各个密钥流之间是有关系的，最简单的方式就是密钥流不断递增，所以才叫作计数器模式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;25-消息验证码&#34;&gt;&#xA;  2.5 消息验证码&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#25-%e6%b6%88%e6%81%af%e9%aa%8c%e8%af%81%e7%a0%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MAC值一般和原始消息一起传输，原始消息可以选择加密，也可以选择不加密，通信双方会以相同的方式生成MAC值，然后进行比较&lt;/li&gt;&#xA;&lt;li&gt;CBC-MAC算法&lt;/li&gt;&#xA;&lt;li&gt;HMAC算法 Hash-based Message Authentication Code&lt;/li&gt;&#xA;&lt;li&gt;加密算法不能提供完整性，加密的同时必须引入MAC算法避免消息被篡改&lt;/li&gt;&#xA;&lt;li&gt;使用者结合对称加密算法和MAC算法，提供机密性和完整性的模式也叫作Authenticated Encryption（AE）加密模式，主要有三种&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Encrypt-and-MAC (E&amp;amp;M)&lt;/li&gt;&#xA;&lt;li&gt;MAC-then-Encrypt (MtE)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这种模式（图2-12）先对消息进行MAC计算，然后将消息和MAC值组合在一起再进行加密，最终的加密值再发送给接收方。在HTTPS中，一般使用这种模式进行处理，比如AES-128-CBC#PKCS7-HMAC-SHA256模式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Encrypt-then-MAC (EtM)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;不管是Encrypt-and-MAC模式还是MAC-then-Encrypt模式，使用不当的话都会存在安全问题，目前建议使用Encrypt-then-MAC模式。需要强调的是，这三种模式使用者必须分别处理，一旦处理不当，就可能会存在安全风险，那有没有一种方法在底层直接提供加密和MAC运算呢？无须使用者分别处理加密和MAC运算，这就是接下来讲解的AEAD模式。&lt;/li&gt;&#xA;&lt;li&gt;AEAD加密模式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CCM模式&lt;/li&gt;&#xA;&lt;li&gt;GCM模式&lt;/li&gt;&#xA;&lt;li&gt;ChaCha20-Poly1305&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;26-公开密钥算法&#34;&gt;&#xA;  2.6 公开密钥算法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#26-%e5%85%ac%e5%bc%80%e5%af%86%e9%92%a5%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;相比对称加密算法来说，公开密钥算法尤其是RSA算法运算非常缓慢，一般情况下，需要加密的明文数据都非常大，如果使用公开密钥算法进行加密，运算性能会惨不忍睹。公开密钥算法在密码学中一般进行密钥协商或者数字签名，因为这两者运算的数据相对较小。&lt;/li&gt;&#xA;&lt;li&gt;公开密钥算法最重要和最广泛使用的算法就是RSA算法，该算法是Ron Rivest、Adi Shamir、Leonard Adleman三个人创建的，以三个人名字的首字母命名。&lt;/li&gt;&#xA;&lt;li&gt;和对称密钥算法一样，公开密钥算法也有使用标准，公开密钥算法的标准称为PKCS（Public Key Cryptography Standards），这个标准由很多的子标准组成，指导使用者正确地使用公开密钥算法。&lt;/li&gt;&#xA;&lt;li&gt;RSA加密算法的应用场景&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单步加密&lt;/li&gt;&#xA;&lt;li&gt;双向加密&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;27-密钥&#34;&gt;&#xA;  2.7 密钥&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#27-%e5%af%86%e9%92%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;口令（password或者passphrase）也可以认为是一种密钥，都需要保密，不能泄露。口令和密钥最大的区别在于口令更容易生成、更容易记忆，一般情况下口令记录在人脑中，口令可以认为是一种弱密钥，由固定的字母、数字、符号组成，长度也有一定的限制。&lt;/li&gt;&#xA;&lt;li&gt;在密码学中很少直接用口令进行加密，容易受到暴力攻击和字典攻击，暴力攻击的原理在于口令都是由固定的字母、数字、符号组成的，攻击者可以生成所有可能的口令，然后使用口令迭代去解密，一旦成功解密，就表示口令被暴力破解了。&lt;/li&gt;&#xA;&lt;li&gt;字典攻击本质上也是一种暴力攻击，只是能够加快破解效率（时间和空间），人类一般使用常见的字母、数字、符号组合成口令（比如很多人喜欢用字母password作为口令），攻击者可以将常见的口令保存在一张字典中，然后用字典中的口令迭代去解密密文。除了字典攻击，还有彩虹表攻击方式，破解的关键点就在于口令相对容易猜测和预测。&lt;/li&gt;&#xA;&lt;li&gt;密钥存储和传输&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;28-密钥协商算法&#34;&gt;&#xA;  2.8 密钥协商算法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#28-%e5%af%86%e9%92%a5%e5%8d%8f%e5%95%86%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RSA密钥协商算法&lt;/li&gt;&#xA;&lt;li&gt;DH密钥协商算法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Diffie-Hellman算法，简称DH算法，是Whitfield Diffie和Martin Hellman在1976年公布的一个公开密钥算法，它的历史比RSA公开密钥算法更悠久。&lt;/li&gt;&#xA;&lt;li&gt;使用RSA密钥协商算法传输会话密钥的时候，会话密钥完全由客户端控制，并没有服务器的参与，所以叫作密钥传输。&lt;/li&gt;&#xA;&lt;li&gt;而DH算法确切地说，实现的是密钥交换或者密钥协商，DH算法在进行密钥协商的时候，通信双方的任何一方无法独自计算出一个会话密钥，通信双方各自保留一部分关键信息，再将另外一部分信息告诉对方，双方有了全部信息才能共同计算出相同的会话密钥。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;29-椭圆曲线密码学&#34;&gt;&#xA;  2.9 椭圆曲线密码学&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#29-%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e5%af%86%e7%a0%81%e5%ad%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为了保证DH的密钥对不被破解，提升安全性的主要手段就是增加密钥对的长度，但是长度越长，性能越低。公开密钥算法是一个O(n)操作，n就是密钥对的长度，n越小，操作越快。为了解决性能问题，需要了解下椭圆曲线密码学（Elliptic Curve Cryptography），简称为ECC。&lt;/p&gt;</description>
    </item>
    <item>
      <title>一本书讲透 ElasticSearch：原理、进阶与工程实践</title>
      <link>/zh/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h2 id=&#34;第1章-elastic-stack全景&#34;&gt;&#xA;  第1章 Elastic Stack全景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac1%e7%ab%a0-elastic-stack%e5%85%a8%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;首先，Elasticsearch支持各类应用、网站等的全文搜索，包括淘宝、京东等电商平台的搜索，360手机助手、豌豆荚等应用市场平台的搜索，以及腾讯文档、石墨文档等平台的&lt;strong&gt;全文检索服务&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;许多知名企业，如58集团、唯品会、日志易、国投瑞银等，都使用Elasticsearch来&lt;strong&gt;快速分析和处理大量的日志数据&lt;/strong&gt;，从而对业务运行状况进行实时的监控和故障排查。&lt;/li&gt;&#xA;&lt;li&gt;许多知名企业的商业智能系统，如睿思BI、百度数据可视化Sugar BI、永洪BI等，都借助Elasticsearch的&lt;strong&gt;高效、实时的数据分析和可视化能力&lt;/strong&gt;，帮助企业更好地理解市场趋势、优化决策过程。&lt;/li&gt;&#xA;&lt;li&gt;ClickHouse&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ClickHouse是一款由俄罗斯搜索引擎Yandex开发并开源的&lt;strong&gt;列式存储数据库&lt;/strong&gt;，专为**OLAP（在线分析处理）**场景设计。ClickHouse具有高速查询分析的能力，支持实时添加数据和修改结构，并且能够实现高度数据压缩比，从而有效节省存储空间。此外，ClickHouse支持SQL查询，易于使用和集成。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第2章-elasticsearch基础知识&#34;&gt;&#xA;  第2章 Elasticsearch基础知识&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac2%e7%ab%a0-elasticsearch%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;倒排索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一本C语言图书末页的索引结构。这种结构揭示了核心关键词与页码之间的对应关系。这种关系模式可以视为倒排索引的实际例证。在此结构中，我们可以&lt;strong&gt;根据关键词快速找到包含这个关键词的内容的页码&lt;/strong&gt;。这与倒排索引在接收关键词输入后能够迅速定位包含该关键词的文档的性质是一致的。借由这种类比，我们可以更为直观地理解倒排索引在数据查询中的关键作用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;数据索引化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据索引化指的是数据在写入搜索引擎（本书中主要指Elasticsearch）的过程中，&lt;strong&gt;扫描文档中的每一个词项，结合分词器和词典对必要的词项建立倒排索引&lt;/strong&gt;，同时指明该词项在文章中出现的&lt;strong&gt;次数&lt;/strong&gt;和&lt;strong&gt;位置&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;全文检索的前提是待检索的数据已经索引化，当用户查询时能根据建立的倒排索引进行查找。&lt;/li&gt;&#xA;&lt;li&gt;全文检索的特点如下&#xA;&lt;ul&gt;&#xA;&lt;li&gt;只处理文本，不处理语义。&lt;/li&gt;&#xA;&lt;li&gt;结果列表有相关度排序。&lt;/li&gt;&#xA;&lt;li&gt;支持高亮显示结果数据。&lt;/li&gt;&#xA;&lt;li&gt;原始的文本被切分为单个单词、短语或特殊标记后进行存储。&lt;/li&gt;&#xA;&lt;li&gt;给定词与它的&lt;strong&gt;变体&lt;/strong&gt;（如近义词）会被折叠为一个词，如electrification和ectric、mice和mouse、“土豆”和“马铃薯”、“西红柿”和“番茄”等，每组词均被视为同一个词。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;22-elasticsearch的核心概念&#34;&gt;&#xA;  2.2 Elasticsearch的核心概念&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#22-elasticsearch%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;集群&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Elasticsearch集群常用于处理大规模数据集，目的是实现&lt;strong&gt;容错&lt;/strong&gt;和&lt;strong&gt;高可用&lt;/strong&gt;。Elasticsearch集群需要一个&lt;strong&gt;唯一标识&lt;/strong&gt;的集群名称来防止不必要的节点加入。集群大小从单个节点到数千个节点不等，具体大小取决于实际业务场景。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;节点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;节点是指&lt;strong&gt;一个Elasticsearch实例&lt;/strong&gt;，更确切地说，它是一个Elasticsearch进程。节点可以部署到物理机或者虚拟机上。每当Elasticsearch启动时，节点就会开始运行。&lt;strong&gt;每个节点都有唯一标识的名称&lt;/strong&gt;，在部署多节点集群环境的时候我们要注意不要写错节点名称。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;索引可以看作&lt;strong&gt;数据库中的一个表&lt;/strong&gt;，它包含了一组具有相似结构的文档&lt;/li&gt;&#xA;&lt;li&gt;在Elasticsearch中，数据以&lt;strong&gt;JSON格式的文档&lt;/strong&gt;存储在索引内。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;每个索引具有唯一的名称&lt;/strong&gt;，以便在执行搜索、更新和删除操作时进行引用。&lt;/li&gt;&#xA;&lt;li&gt;索引的名称可以由&lt;strong&gt;用户自定义&lt;/strong&gt;，但必须全部小写。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;分片&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在了解分片是什么之前，让我们谈谈为什么需要分片。假设你有一个包含超大规模文档的索引，有总计1TB的数据。当前集群中有两个节点，每个节点有512GB的空间可用于存储数据。显然，&lt;strong&gt;整个索引无法存储在任何一个节点上，因此有必要以某种方式拆分索引的数据，否则会导致数据存储不完整&lt;/strong&gt;。在这种情况下，索引的大小超过了单个节点的硬件限制，分片就派上用场了。分片通过将索引分成更小的部分来解决这个问题。&lt;/li&gt;&#xA;&lt;li&gt;当处理涉及多个数据分片的查询时，Elasticsearch会&lt;strong&gt;将查询请求分发到各个相关的分片&lt;/strong&gt;，并将它们的结果集进行聚合。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;副本&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分片可以被复制，被复制的分片称为“主分片”，如图2-3中的主分片1～4；主分片的复制版本称为“副本分片”或简称为“副本”，如图2-3中的副本1～4&lt;/li&gt;&#xA;&lt;li&gt;创建索引时需要指定主分片，且主分片数一经指定就不支持动态更新了。而副本同样需要在创建索引时指定，每个分片可以有0或多个副本，副本数支持动态更新。&lt;/li&gt;&#xA;&lt;li&gt;当某主分片所在的数据节点不可用时，会导致主分片丢失现象，若短时间内不对此采取补救措施，集群会将该分片对应的副本提升为新的主分片。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;文档&#xA;&lt;ul&gt;&#xA;&lt;li&gt;关系型数据库将数据以行或元组为单位存储在数据库表中，而Elasticsearch将数据以文档为单位存储在索引中。&lt;/li&gt;&#xA;&lt;li&gt;作为Elasticsearch的基本存储单元，&lt;strong&gt;文档是指存储在Elasticsearch索引中的JSON对象&lt;/strong&gt;。文档中的数据由键值对构成。键是字段的名称，值是不同数据类型的字段。不同的数据类型包含但不限于字符串类型、数字类型、布尔类型、对象类型等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;字段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;字段是Elasticsearch中最小的单个数据单元，类似于关系型数据库表中的字段。一般实战项目前期的设计环节都是根据业务需求拆分、定义字段，并且敲定字段类型。在上面航空类索引的示例中，“FlightNum”是字段，其含义为“航班号”，字段类型为keyword。&lt;/li&gt;&#xA;&lt;li&gt;与关系型数据库不同的是，&lt;strong&gt;Elasticsearch的一个字段可以设定两种或两种以上的数据类型&lt;/strong&gt;，通过定义multi-field来灵活地满足复杂的业务需求。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;映射&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不少初学者对映射(Mapping)这个概念会感觉不好理解。映射类似于关系型数据库中的Schema，可以近似地理解为**“表结构”**。&lt;/li&gt;&#xA;&lt;li&gt;我们拿到一个业务需求后，往往会将业务细分会几个索引。每个索引都需要一个相对固定的表结构，包含但不限于字段名称、字段类型、是否需要分词、是否需要索引、是否需要存储、是否需要多字段类型等。这些都是设计映射时要考虑的问题。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;分词&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在英文文本中，空格就是切分语句或短语的“屏障”。但中文文本中则没有了这道“屏障”，于是分词就变得就不那么简单，需要由专门的分词算法构建的分词器来实现。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第3章-elasticsearch集群部署&#34;&gt;&#xA;  第3章 Elasticsearch集群部署&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac3%e7%ab%a0-elasticsearch%e9%9b%86%e7%be%a4%e9%83%a8%e7%bd%b2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;什么是堆内存&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java中的堆是JVM所管理的最大的一块内存空间，主要用于&lt;strong&gt;存放各种类的实例对象&lt;/strong&gt;。在Java中，堆被划分成两个不同的区域：新生代(Young)和老年代(Old)。新生代又被划分为3个区域：Eden、From Survivor、To Survivor。&lt;/li&gt;&#xA;&lt;li&gt;这样划分的目的是使JVM更好地管理堆内存中的对象，包括内存的分配以及回收。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;堆内存的作用是什么&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;堆内存的唯一目的就是&lt;strong&gt;创建对象实例&lt;/strong&gt;，所有的对象实例和数组都要在堆上分配。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;堆内存如何配置&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;默认情况下，Elasticsearch JVM使用的堆内存最小和最大值均为4 GB（8.X版本以上）&lt;/li&gt;&#xA;&lt;li&gt;在转移到生产环境时，配置足够容量的堆大小以确保Elasticsearch功能和性能是必要的。&lt;/li&gt;&#xA;&lt;li&gt;Elasticsearch将通过对Xms（最小堆大小）和Xmx（最大堆大小）的设置来分配jvm.options中指定的整个堆。&lt;/li&gt;&#xA;&lt;li&gt;堆内存的值取决于服务器上可用的内存大小。Elasticsearch堆内存设置对其性能表现来说十分关键。&lt;strong&gt;建议将堆大小配置为服务器可用内存的50%，上限为32GB，且预留足够的内存给操作系统以提升缓存效率&lt;/strong&gt;。合理调整堆内存大小可减轻垃圾回收工作的压力，优化查询速度和索引效率。请务必进行监控并根据实际需求来调整堆内存大小。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为什么堆内存不能超过物理机内存的一半&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
