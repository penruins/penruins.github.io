<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
Java并发编程实战


  第1章 简介
  #


  1.1 并发简史
  #


  1.2 线程的优势
  #


  1.3 线程带来的风险
  #


  1.4 线程无处不在
  #


开发线程安全的类比开发非线程安全的类要更加谨慎和细致
每个Java应用程序都会使用线程

当JVM启动时，它将为JVM的内部任务（例如，垃圾收集、终结操作等）创建后台线程，并创建一个主线程来运行main方法。
AWT（Abstract Window Toolkit，抽象窗口工具库）和Swing的用户界面框架将创建线程来管理用户界面事件。
Timer将创建线程来执行延迟任务。
一些组件框架，例如Servlet和RMI，都会创建线程池并调用这些线程中的方法。


当某个框架在应用程序中引入并发性时，通常不可能将并发性仅局限于框架代码，因为框架本身会回调（Callback）应用程序的代码，而这些代码将访问应用程序的状态。
对线程安全性的需求也不能局限于被调用的代码，而是要延伸到需要访问这些代码所访问的程序状态的所有代码路径。因此，对线程安全性的需求将在程序中蔓延开来。


  第2章 线程安全性
  #


要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的（Shared）和可变的（Mutable）状态的访问。
“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。
一个对象是否需要是线程安全的，取决于它是否被多个线程访问
当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。

Java中的主要同步机制是关键字synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括volatile类型的变量，显式锁（Explicit Lock）以及原子变量。




  2.1 什么是线程安全性
  #


在线程安全性的定义中，最核心的概念就是正确性。如果对线程安全性的定义是模糊的，那么就是因为缺乏对正确性的清晰定义。
正确性的含义是，某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件（Postcondition）来描述对象操作的结果。
线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。


在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。
无状态对象一定是线程安全的

大多数Servlet都是无状态的，从而极大地降低了在实现Servlet线程安全性时的复杂性。只有当Servlet在处理请求时需要保存一些信息，线程安全性才会成为一个问题。




  2.2 原子性
  #


在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件（Race Condition）


  2.2.1 竞态条件
  #


当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。换句话说，就是正确的结果要取决于运气
“先检查后执行”：首先观察到某个条件为真（例如文件X不存在），然后根据这个观察结果采用相应的动作（创建文件X），但事实上，在你观察到这个结果以及开始创建文件之间，观察结果可能变得无效（另一个线程在这期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。


  2.2.2 示例：延迟初始化中的竞态条件
  #


延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。
假定线程A和线程B同时执行getInstance。A看到instance为空，因而创建一个新的ExpensiveObject实例。B同样需要判断instance是否为空。此时的instance是否为空，要取决于不可预测的时序，包括线程的调度方式，以及A需要花多长时间来初始化ExpensiveObject并设置instance。如果当B检查时，instance为空，那么在两次调用getInstance时可能会得到不同的结果，即使getInstance通常被认为是返回相同的实例。


  2.2.3 复合操作
  #


要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。
假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。

原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。


在java.util.concurrent.atomic包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。通过用AtomicLong来代替long类型的计数器，能够确保所有对计数器状态的访问操作都是原子的。

当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的
当状态变量的数量由一个变为多个时，并不会像状态变量数量由零个变为一个那样简单
在实际情况中，应尽可能地使用现有的线程安全对象（例如AtomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。




  2.3 加锁机制
  #


要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。


  2.3.1 内置锁
  #


Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。

以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。
每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）




  2.3.2 重入
  #


当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞

由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”
重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。
当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。




  2.4 用锁来保护状态
  #


对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。
之所以每个对象都有一个内置锁，只是为了免去显式地创建锁对象。
每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。
一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。
并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。


  2.5 活跃性与性能
  #


不良并发（Poor Concurrency）应用程序：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。
当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。
无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。

当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。




  第3章 对象的共享
  #


同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。


  3.1 可见性
  #


在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。


  3.1.1 失效数据
  #


  3.1.2　非原子的64位操作
  #


当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-air safety）

最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量（double和long，请参见3.1.4节）。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位￼。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。




  3.1.3　加锁与可见性
  #


加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。


  3.1.4　Volatile变量
  #


Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。
在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。

在当前大多数处理器架构上，读取volatile变量的开销只比读取非volatile变量的开销略高一些。


我们并不建议过度依赖volatile变量提供的可见性。如果在代码中依赖volatile变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。

仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。
如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。


volatile的语义不足以确保递增操作（count&#43;&#43;）的原子性，除非你能确保只有一个线程对变量执行写操作。

加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。


当且仅当满足以下所有条件时，才应该使用volatile变量

对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
该变量不会与其他状态变量一起纳入不变性条件中。
在访问变量时不需要加锁。


调试小提示：对于服务器应用程序，无论在开发阶段还是在测试阶段，当启动JVM时一定都要指定-server命令行选项。server模式的JVM将比client模式的JVM进行更多的优化，例如将循环中未被修改的变量提升到循环外部，因此在开发环境（client模式的JVM）中能正确运行的代码，可能会在部署环境（server模式的JVM）中运行失败。例如，如果在程序清单3-4中“忘记”把asleep变量声明为volatile类型，那么server模式的JVM会将asleep的判断条件提升到循环体外部（这将导致一个无限循环），但client模式的JVM不会这么做。在解决开发环境中出现无限循环问题时，解决这个问题的开销远小于解决在应用环境出现无限循环的开销。


  3.2 发布与逸出
  #


“发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。

将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。在许多情况中，我们要确保对象及其内部状态不被发布。而在某些情况下，我们又需要发布某个对象，但如果在发布时要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象构造完成之前就发布该对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）。
发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象


一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。
当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。这正是需要使用封装的最主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。
安全的对象构造过程

不要在构造过程中使this引用逸出
在构造过程中使this引用逸出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。
在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动
在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），同样会导致this引用在构造过程中逸出。
如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法（Factory Method），从而避免不正确的构造过程




  3.3 线程封闭
  #


Swing应用程序的许多并发错误都是由于错误地在另一个线程中使用了这些被封闭的对象。
线程封闭是在程序设计中的一个考虑因素，必须在程序中实现。


  3.3.1 Ad-hoc线程封闭
  #


在volatile变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竞态条件，并且volatile变量的可见性保证还确保了其他线程能看到最新的值。
由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭或ThreadLocal类）。


  3.3.2 栈封闭
  #


栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。
由于任何方法都无法获得对基本类型的引用，因此Java语言的这种语义就确保了基本类型的局部变量始终封闭在线程内。


  3.3.3 ThreadLocal 类
  #


ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。
假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象（如果全局变量的语义允许），可以维持线程安全性。


  3.4 不变性
  #


如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。
不可变对象一定是线程安全的
虽然在Java语言规范和Java内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。
当满足以下条件时，对象才是不可变的：

对象创建以后其状态就不能修改。
对象的所有域都是final类型。
对象是正确创建的（在对象的创建期间，this引用没有逸出）。




  3.4.1 Final域
  #


关键字final可以视为C&#43;&#43;中const机制的一种受限版本，用于构造不可变性对象。final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。
即使对象是可变的，通过将对象的某些域声明为final类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。
正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”[EJ Item 12]是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。


  3.4.2 示例：使用volatile类型来发布不可变对象
  #


通过使用包含多个状态变量的容器对象来维持不变性条件，并使用一个volatile类型的引用来确保可见性，使得Volatile Cached Factorizer在没有显式地使用锁的情况下仍然是线程安全的


  3.5 安全发布
  #


  3.5.1 不正确的发布：正确的对象被破坏
  #


你不能指望一个尚未被完全创建的对象拥有完整性。某个观察该对象的线程将看到对象处于不一致的状态，然后看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。


  3.5.2 不可变对象与初始化安全性
  #


我们已经知道，即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一致的视图，就必须使用同步。
任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。
在没有额外同步的情况下，也可以安全地访问final类型的域。然而，如果final类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。


  3.5.3 安全发布的常用模式
  #


可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时都必须使用同步。
要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见

在静态初始化函数中初始化一个对象引用。
将对象的引用保存到volatile类型的域或者AtomicReferance对象中。
将对象的引用保存到某个正确构造对象的final类型域中。
将对象的引用保存到一个由锁保护的域中。


在线程安全容器内部的同步意味着，在将对象放入到某个容器，例如Vector或synchronizedList时，将满足上述最后一条需求。如果线程A将对象X放入一个线程安全的容器，随后线程B读取这个对象，那么可以确保B看到A设置的X状态，即便在这段读/写X的应用程序代码中没有包含显式的同步。

线程安全库中的容器类提供了以下的安全发布保证

通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。
通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。
通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。




要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器 public static Holder holder=new Holder（42）

静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布




  3.5.4 事实不可变对象
  #


如果对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全地访问这些对象的线程来说，安全发布是足够的。
如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）”

通过使用事实不可变对象，不仅可以简化开发过程，而且还能由于减少了同步而提高性能。
例如，Date本身是可变的￼，但如果将它作为不可变对象来使用，那么在多个线程之间共享Date对象时，就可以省去对锁的使用




  3.5.5 可变对象
  #


如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。
在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：

线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。
线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。




  3.5.6 安全地共享对象
  #


  第4章 对象的组合
  #


  4.1 设计线程安全的类
  #


  4.2 实例封闭
  #


  4.3 线程安全性的委托
  #


  4.4 在现有的线程安全类中添加功能
  #


  4.5 将同步策略文档化
  #


  第5章 基础构建模块
  #


  5.1 同步容器类
  #


  5.2 并发容器
  #


  5.3 阻塞队列和生产者-消费者模式
  #


  5.4 阻塞方法与中断方法
  #


  5.5 同步工具类
  #


  5.6 构建高效且可伸缩的结果缓存
  #


  第6章 任务执行
  #


  6.1 在线程中执行任务
  #


  6.2 Executor框架
  #


  6.3 找出可利用的并行性
  #


  第7章 取消与关闭
  #


  7.1 任务取消
  #


  7.2 停止基于线程的服务
  #


  7.3 处理非正常的线程终止
  #


  7.4 JVM关闭
  #


  第8章 线程池的使用
  #


  8.1 在任务与执行策略之间的隐性耦合
  #


  8.2 设置线程池的大小
  #


  8.3 配置ThreadPoolExecutor
  #


  8.4 扩展ThreadPoolExecutor
  #


  8.5 递归算法的并行化
  #


  第9章 图形用户界面应用程序
  #


  9.1 为什么GUI是单线程的
  #


  9.2 短时间的GUI任务
  #


  9.3 长时间的GUI任务
  #


  9.4 共享数据模型
  #


  9.5 其他形式的单线程子系统
  #


  第10章 避免活跃性危险
  #


  10.1 死锁
  #


  10.2 死锁的避免与诊断
  #


  10.3 其他活跃性危险
  #


  第11章 性能与可伸缩性
  #


  11.1 对性能的思考
  #


  11.2 Amdahl定律
  #


  11.3 线程引入的开销
  #


  11.4 减少锁的竞争
  #


  11.5 示例：比较Map的性能
  #


  11.6 减少上下文切换的开销
  #


  第12章 并发程序的测试
  #


  12.1 正确性测试
  #


  12.2 性能测试
  #


  12.3 避免性能测试的陷阱
  #


  12.4 其他的测试方法
  #


  第13章 显式锁
  #


  13.1 Lock与ReentrantLock
  #


  13.2 性能考虑因素
  #


  13.3 公平性
  #


  13.4 在synchronized和ReentrantLock之间进行选择
  #


  13.5 读-写锁
  #


  第14章 构建自定义的同步工具
  #


  14.1 状态依赖性的管理
  #


  14.2 使用条件队列
  #


  14.3 显式的Condition对象
  #


  14.4 Synchronizer剖析
  #


  14.5 AbstractQueuedSynchronizer
  #


  14.6 java.util.concurrent同步器类中的AQS
  #


  第15章 原子变量与非阻塞同步机制
  #


  15.1 锁的劣势
  #


  15.2 硬件对并发的支持
  #


  15.3 原子变量类
  #


  15.4 非阻塞算法
  #


  第16章 Java内存模型
  #


  16.1 什么是内存模型，为什么需要它
  #


  16.2 发布
  #


  16.3 初始化过程中的安全性
  #
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">
  <meta property="og:site_name" content="Penruins">
  <meta property="og:title" content="Java并发编程实战">
  <meta property="og:description" content="Java并发编程实战 第1章 简介 # 1.1 并发简史 # 1.2 线程的优势 # 1.3 线程带来的风险 # 1.4 线程无处不在 # 开发线程安全的类比开发非线程安全的类要更加谨慎和细致 每个Java应用程序都会使用线程 当JVM启动时，它将为JVM的内部任务（例如，垃圾收集、终结操作等）创建后台线程，并创建一个主线程来运行main方法。 AWT（Abstract Window Toolkit，抽象窗口工具库）和Swing的用户界面框架将创建线程来管理用户界面事件。 Timer将创建线程来执行延迟任务。 一些组件框架，例如Servlet和RMI，都会创建线程池并调用这些线程中的方法。 当某个框架在应用程序中引入并发性时，通常不可能将并发性仅局限于框架代码，因为框架本身会回调（Callback）应用程序的代码，而这些代码将访问应用程序的状态。 对线程安全性的需求也不能局限于被调用的代码，而是要延伸到需要访问这些代码所访问的程序状态的所有代码路径。因此，对线程安全性的需求将在程序中蔓延开来。 第2章 线程安全性 # 要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的（Shared）和可变的（Mutable）状态的访问。 “共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。 一个对象是否需要是线程安全的，取决于它是否被多个线程访问 当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。 Java中的主要同步机制是关键字synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括volatile类型的变量，显式锁（Explicit Lock）以及原子变量。 2.1 什么是线程安全性 # 在线程安全性的定义中，最核心的概念就是正确性。如果对线程安全性的定义是模糊的，那么就是因为缺乏对正确性的清晰定义。 正确性的含义是，某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件（Postcondition）来描述对象操作的结果。 线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。 在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。 无状态对象一定是线程安全的 大多数Servlet都是无状态的，从而极大地降低了在实现Servlet线程安全性时的复杂性。只有当Servlet在处理请求时需要保存一些信息，线程安全性才会成为一个问题。 2.2 原子性 # 在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件（Race Condition） 2.2.1 竞态条件 # 当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。换句话说，就是正确的结果要取决于运气 “先检查后执行”：首先观察到某个条件为真（例如文件X不存在），然后根据这个观察结果采用相应的动作（创建文件X），但事实上，在你观察到这个结果以及开始创建文件之间，观察结果可能变得无效（另一个线程在这期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。 2.2.2 示例：延迟初始化中的竞态条件 # 延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。 假定线程A和线程B同时执行getInstance。A看到instance为空，因而创建一个新的ExpensiveObject实例。B同样需要判断instance是否为空。此时的instance是否为空，要取决于不可预测的时序，包括线程的调度方式，以及A需要花多长时间来初始化ExpensiveObject并设置instance。如果当B检查时，instance为空，那么在两次调用getInstance时可能会得到不同的结果，即使getInstance通常被认为是返回相同的实例。 2.2.3 复合操作 # 要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。 原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。 在java.util.concurrent.atomic包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。通过用AtomicLong来代替long类型的计数器，能够确保所有对计数器状态的访问操作都是原子的。 当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的 当状态变量的数量由一个变为多个时，并不会像状态变量数量由零个变为一个那样简单 在实际情况中，应尽可能地使用现有的线程安全对象（例如AtomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。 2.3 加锁机制 # 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。 2.3.1 内置锁 # Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。 以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。 每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock） 2.3.2 重入 # 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞 由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用” 重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。 当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。 2.4 用锁来保护状态 # 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。 之所以每个对象都有一个内置锁，只是为了免去显式地创建锁对象。 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。 一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。 并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。 2.5 活跃性与性能 # 不良并发（Poor Concurrency）应用程序：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。 当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。 无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。 当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。 第3章 对象的共享 # 同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。 3.1 可见性 # 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。 3.1.1 失效数据 # 3.1.2　非原子的64位操作 # 当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-air safety） 最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量（double和long，请参见3.1.4节）。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位￼。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。 3.1.3　加锁与可见性 # 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。 3.1.4　Volatile变量 # Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 在当前大多数处理器架构上，读取volatile变量的开销只比读取非volatile变量的开销略高一些。 我们并不建议过度依赖volatile变量提供的可见性。如果在代码中依赖volatile变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。 如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。 volatile的语义不足以确保递增操作（count&#43;&#43;）的原子性，除非你能确保只有一个线程对变量执行写操作。 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。 当且仅当满足以下所有条件时，才应该使用volatile变量 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。 该变量不会与其他状态变量一起纳入不变性条件中。 在访问变量时不需要加锁。 调试小提示：对于服务器应用程序，无论在开发阶段还是在测试阶段，当启动JVM时一定都要指定-server命令行选项。server模式的JVM将比client模式的JVM进行更多的优化，例如将循环中未被修改的变量提升到循环外部，因此在开发环境（client模式的JVM）中能正确运行的代码，可能会在部署环境（server模式的JVM）中运行失败。例如，如果在程序清单3-4中“忘记”把asleep变量声明为volatile类型，那么server模式的JVM会将asleep的判断条件提升到循环体外部（这将导致一个无限循环），但client模式的JVM不会这么做。在解决开发环境中出现无限循环问题时，解决这个问题的开销远小于解决在应用环境出现无限循环的开销。 3.2 发布与逸出 # “发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。 将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。在许多情况中，我们要确保对象及其内部状态不被发布。而在某些情况下，我们又需要发布某个对象，但如果在发布时要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象构造完成之前就发布该对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）。 发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象 一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。 当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。这正是需要使用封装的最主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。 安全的对象构造过程 不要在构造过程中使this引用逸出 在构造过程中使this引用逸出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。 在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动 在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），同样会导致this引用在构造过程中逸出。 如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法（Factory Method），从而避免不正确的构造过程 3.3 线程封闭 # Swing应用程序的许多并发错误都是由于错误地在另一个线程中使用了这些被封闭的对象。 线程封闭是在程序设计中的一个考虑因素，必须在程序中实现。 3.3.1 Ad-hoc线程封闭 # 在volatile变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竞态条件，并且volatile变量的可见性保证还确保了其他线程能看到最新的值。 由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭或ThreadLocal类）。 3.3.2 栈封闭 # 栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。 由于任何方法都无法获得对基本类型的引用，因此Java语言的这种语义就确保了基本类型的局部变量始终封闭在线程内。 3.3.3 ThreadLocal 类 # ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。 假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象（如果全局变量的语义允许），可以维持线程安全性。 3.4 不变性 # 如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。 不可变对象一定是线程安全的 虽然在Java语言规范和Java内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。 当满足以下条件时，对象才是不可变的： 对象创建以后其状态就不能修改。 对象的所有域都是final类型。 对象是正确创建的（在对象的创建期间，this引用没有逸出）。 3.4.1 Final域 # 关键字final可以视为C&#43;&#43;中const机制的一种受限版本，用于构造不可变性对象。final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。 即使对象是可变的，通过将对象的某些域声明为final类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。 正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”[EJ Item 12]是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。 3.4.2 示例：使用volatile类型来发布不可变对象 # 通过使用包含多个状态变量的容器对象来维持不变性条件，并使用一个volatile类型的引用来确保可见性，使得Volatile Cached Factorizer在没有显式地使用锁的情况下仍然是线程安全的 3.5 安全发布 # 3.5.1 不正确的发布：正确的对象被破坏 # 你不能指望一个尚未被完全创建的对象拥有完整性。某个观察该对象的线程将看到对象处于不一致的状态，然后看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。 3.5.2 不可变对象与初始化安全性 # 我们已经知道，即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一致的视图，就必须使用同步。 任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。 在没有额外同步的情况下，也可以安全地访问final类型的域。然而，如果final类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。 3.5.3 安全发布的常用模式 # 可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时都必须使用同步。 要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见 在静态初始化函数中初始化一个对象引用。 将对象的引用保存到volatile类型的域或者AtomicReferance对象中。 将对象的引用保存到某个正确构造对象的final类型域中。 将对象的引用保存到一个由锁保护的域中。 在线程安全容器内部的同步意味着，在将对象放入到某个容器，例如Vector或synchronizedList时，将满足上述最后一条需求。如果线程A将对象X放入一个线程安全的容器，随后线程B读取这个对象，那么可以确保B看到A设置的X状态，即便在这段读/写X的应用程序代码中没有包含显式的同步。 线程安全库中的容器类提供了以下的安全发布保证 通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。 通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。 通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。 要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器 public static Holder holder=new Holder（42） 静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布 3.5.4 事实不可变对象 # 如果对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全地访问这些对象的线程来说，安全发布是足够的。 如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）” 通过使用事实不可变对象，不仅可以简化开发过程，而且还能由于减少了同步而提高性能。 例如，Date本身是可变的￼，但如果将它作为不可变对象来使用，那么在多个线程之间共享Date对象时，就可以省去对锁的使用 3.5.5 可变对象 # 如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。 在并发程序中使用和共享对象时，可以使用一些实用的策略，包括： 线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。 只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。 保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。 3.5.6 安全地共享对象 # 第4章 对象的组合 # 4.1 设计线程安全的类 # 4.2 实例封闭 # 4.3 线程安全性的委托 # 4.4 在现有的线程安全类中添加功能 # 4.5 将同步策略文档化 # 第5章 基础构建模块 # 5.1 同步容器类 # 5.2 并发容器 # 5.3 阻塞队列和生产者-消费者模式 # 5.4 阻塞方法与中断方法 # 5.5 同步工具类 # 5.6 构建高效且可伸缩的结果缓存 # 第6章 任务执行 # 6.1 在线程中执行任务 # 6.2 Executor框架 # 6.3 找出可利用的并行性 # 第7章 取消与关闭 # 7.1 任务取消 # 7.2 停止基于线程的服务 # 7.3 处理非正常的线程终止 # 7.4 JVM关闭 # 第8章 线程池的使用 # 8.1 在任务与执行策略之间的隐性耦合 # 8.2 设置线程池的大小 # 8.3 配置ThreadPoolExecutor # 8.4 扩展ThreadPoolExecutor # 8.5 递归算法的并行化 # 第9章 图形用户界面应用程序 # 9.1 为什么GUI是单线程的 # 9.2 短时间的GUI任务 # 9.3 长时间的GUI任务 # 9.4 共享数据模型 # 9.5 其他形式的单线程子系统 # 第10章 避免活跃性危险 # 10.1 死锁 # 10.2 死锁的避免与诊断 # 10.3 其他活跃性危险 # 第11章 性能与可伸缩性 # 11.1 对性能的思考 # 11.2 Amdahl定律 # 11.3 线程引入的开销 # 11.4 减少锁的竞争 # 11.5 示例：比较Map的性能 # 11.6 减少上下文切换的开销 # 第12章 并发程序的测试 # 12.1 正确性测试 # 12.2 性能测试 # 12.3 避免性能测试的陷阱 # 12.4 其他的测试方法 # 第13章 显式锁 # 13.1 Lock与ReentrantLock # 13.2 性能考虑因素 # 13.3 公平性 # 13.4 在synchronized和ReentrantLock之间进行选择 # 13.5 读-写锁 # 第14章 构建自定义的同步工具 # 14.1 状态依赖性的管理 # 14.2 使用条件队列 # 14.3 显式的Condition对象 # 14.4 Synchronizer剖析 # 14.5 AbstractQueuedSynchronizer # 14.6 java.util.concurrent同步器类中的AQS # 第15章 原子变量与非阻塞同步机制 # 15.1 锁的劣势 # 15.2 硬件对并发的支持 # 15.3 原子变量类 # 15.4 非阻塞算法 # 第16章 Java内存模型 # 16.1 什么是内存模型，为什么需要它 # 16.2 发布 # 16.3 初始化过程中的安全性 #">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
<title>Java并发编程实战 | Penruins</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">
<link rel="stylesheet" href="/book.min.26e661cf8028ea69ebe162050990c3a07de74e5bfe9389e880f2d6a7e5fa587c.css" >
  <script defer src="/fuse.min.js"></script>
  <script defer src="/zh.search.min.213ef4922f9d2a4ada03c9ce167f2b53d2a3b88e0c4a314e80884bfd96671a52.js" ></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/zh/"><span>Penruins</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>



  



  
    
  
    
  



<ul class="book-languages">
  <li>
    <input type="checkbox" id="languages" class="toggle" />
    <label for="languages" class="flex justify-between">
      <a role="button" class="flex align-center">
        <img src="/svg/translate.svg" class="book-icon" alt="Languages" />
        中文
      </a>
    </label>

    <ul>
      
      <li>
        <a href="/cn/">
          
        </a>
      </li>
      
      <li>
        <a href="/en/">
          English
        </a>
      </li>
      
    </ul>
  </li>
</ul>














  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Life</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/movies-log/" class="">观影记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/bilibili/" class="">bilibili</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/books/" class="">books</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/cycling/" class="">cycling</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/hiking/" class="">hiking</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/life-recommend/" class="">life recommand</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/learning-others-log/" class="">other learning</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/podcast/" class="">podcast</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/politics/" class="">politics</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/goal/" class="">goal</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/accumulation/" class="">accumulation</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/coffee/" class="">coffee</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Computer Science</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-855531983528655844a29f37632e7e30" class="toggle"  />
    <label for="section-855531983528655844a29f37632e7e30" class="flex justify-between">
      <a role="button" class="">Java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/java/" class="">java</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/mybatis/" class="">Mybatis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/jvm/" class="">jvm</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-recommend/" class="">推荐</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-learning-log/" class="">学习记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/database/" class="">database</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/echarts/" class="">echarts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/github/" class="">github</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/ios/" class="">ios</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/job/" class="">job</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/mac/" class="">mac</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/raspberrypi/" class="">raspberry pi</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/security/" class="">security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/vue/" class="">vue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/algorithm/" class="">Algorithm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/linux/" class="">linux</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Others</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/about-me/" class="">about me</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/english-learning/" class="">English Learning</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Books</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-70696d57febbe00561bcceac2d174d7c" class="toggle" checked />
    <label for="section-70696d57febbe00561bcceac2d174d7c" class="flex justify-between">
      <a role="button" class="">Computer Science</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" class="active">Java并发编程实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%AE%9E%E6%88%98/" class="">Java实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="">Python神经网络编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="">Redis设计与实现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/" class="">Spring Cloud微服务：入门、实战与进阶</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E5%89%91%E6%8C%87offer/" class="">剑指Offer</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/" class="">深入浅出HTTPS：从原理到实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" class="">一本书讲透 ElasticSearch：原理、进阶与工程实践</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E7%AC%AC%E4%B8%89%E7%89%88/" class="">宏观经济学 第三版</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E7%BE%8E%E5%9B%BD%E5%9B%B0%E5%B1%80/" class="">美国困局</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E8%8B%B1%E4%BC%9F%E8%BE%BE-%E9%BB%84%E4%BB%81%E5%8B%8B%E4%B9%8B%E8%8A%AF/" class="">英伟达-黄仁勋之芯</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E7%94%A8%E5%9C%B0%E5%9B%BE%E7%9C%8B%E6%87%82%E4%B8%96%E7%95%8C%E6%A0%BC%E5%B1%80/" class="">用地图看懂世界格局</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Java并发编程实战</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第1章-简介">第1章 简介</a>
      <ul>
        <li><a href="#11-并发简史">1.1 并发简史</a></li>
        <li><a href="#12-线程的优势">1.2 线程的优势</a></li>
        <li><a href="#13-线程带来的风险">1.3 线程带来的风险</a></li>
        <li><a href="#14-线程无处不在">1.4 线程无处不在</a></li>
      </ul>
    </li>
    <li><a href="#第2章-线程安全性">第2章 线程安全性</a>
      <ul>
        <li><a href="#21-什么是线程安全性">2.1 什么是线程安全性</a></li>
        <li><a href="#22-原子性">2.2 原子性</a>
          <ul>
            <li><a href="#221-竞态条件">2.2.1 竞态条件</a></li>
            <li><a href="#222-示例延迟初始化中的竞态条件">2.2.2 示例：延迟初始化中的竞态条件</a></li>
            <li><a href="#223-复合操作">2.2.3 复合操作</a></li>
          </ul>
        </li>
        <li><a href="#23-加锁机制">2.3 加锁机制</a>
          <ul>
            <li><a href="#231-内置锁">2.3.1 内置锁</a></li>
            <li><a href="#232-重入">2.3.2 重入</a></li>
          </ul>
        </li>
        <li><a href="#24-用锁来保护状态">2.4 用锁来保护状态</a></li>
        <li><a href="#25-活跃性与性能">2.5 活跃性与性能</a></li>
      </ul>
    </li>
    <li><a href="#第3章-对象的共享">第3章 对象的共享</a>
      <ul>
        <li><a href="#31-可见性">3.1 可见性</a>
          <ul>
            <li><a href="#311-失效数据">3.1.1 失效数据</a></li>
            <li><a href="#312非原子的64位操作">3.1.2　非原子的64位操作</a></li>
            <li><a href="#313加锁与可见性">3.1.3　加锁与可见性</a></li>
            <li><a href="#314volatile变量">3.1.4　Volatile变量</a></li>
          </ul>
        </li>
        <li><a href="#32-发布与逸出">3.2 发布与逸出</a></li>
        <li><a href="#33-线程封闭">3.3 线程封闭</a>
          <ul>
            <li><a href="#331-ad-hoc线程封闭">3.3.1 Ad-hoc线程封闭</a></li>
            <li><a href="#332-栈封闭">3.3.2 栈封闭</a></li>
            <li><a href="#333-threadlocal-类">3.3.3 ThreadLocal 类</a></li>
          </ul>
        </li>
        <li><a href="#34-不变性">3.4 不变性</a>
          <ul>
            <li><a href="#341-final域">3.4.1 Final域</a></li>
            <li><a href="#342-示例使用volatile类型来发布不可变对象">3.4.2 示例：使用volatile类型来发布不可变对象</a></li>
          </ul>
        </li>
        <li><a href="#35-安全发布">3.5 安全发布</a>
          <ul>
            <li><a href="#351-不正确的发布正确的对象被破坏">3.5.1 不正确的发布：正确的对象被破坏</a></li>
            <li><a href="#352-不可变对象与初始化安全性">3.5.2 不可变对象与初始化安全性</a></li>
            <li><a href="#353-安全发布的常用模式">3.5.3 安全发布的常用模式</a></li>
            <li><a href="#354-事实不可变对象">3.5.4 事实不可变对象</a></li>
            <li><a href="#355-可变对象">3.5.5 可变对象</a></li>
            <li><a href="#356-安全地共享对象">3.5.6 安全地共享对象</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第4章-对象的组合">第4章 对象的组合</a>
      <ul>
        <li><a href="#41-设计线程安全的类">4.1 设计线程安全的类</a></li>
        <li><a href="#42-实例封闭">4.2 实例封闭</a></li>
        <li><a href="#43-线程安全性的委托">4.3 线程安全性的委托</a></li>
        <li><a href="#44-在现有的线程安全类中添加功能">4.4 在现有的线程安全类中添加功能</a></li>
        <li><a href="#45-将同步策略文档化">4.5 将同步策略文档化</a></li>
      </ul>
    </li>
    <li><a href="#第5章-基础构建模块">第5章 基础构建模块</a>
      <ul>
        <li><a href="#51-同步容器类">5.1 同步容器类</a></li>
        <li><a href="#52-并发容器">5.2 并发容器</a></li>
        <li><a href="#53-阻塞队列和生产者-消费者模式">5.3 阻塞队列和生产者-消费者模式</a></li>
        <li><a href="#54-阻塞方法与中断方法">5.4 阻塞方法与中断方法</a></li>
        <li><a href="#55-同步工具类">5.5 同步工具类</a></li>
        <li><a href="#56-构建高效且可伸缩的结果缓存">5.6 构建高效且可伸缩的结果缓存</a></li>
      </ul>
    </li>
    <li><a href="#第6章-任务执行">第6章 任务执行</a>
      <ul>
        <li><a href="#61-在线程中执行任务">6.1 在线程中执行任务</a></li>
        <li><a href="#62-executor框架">6.2 Executor框架</a></li>
        <li><a href="#63-找出可利用的并行性">6.3 找出可利用的并行性</a></li>
      </ul>
    </li>
    <li><a href="#第7章-取消与关闭">第7章 取消与关闭</a>
      <ul>
        <li><a href="#71-任务取消">7.1 任务取消</a></li>
        <li><a href="#72-停止基于线程的服务">7.2 停止基于线程的服务</a></li>
        <li><a href="#73-处理非正常的线程终止">7.3 处理非正常的线程终止</a></li>
        <li><a href="#74-jvm关闭">7.4 JVM关闭</a></li>
      </ul>
    </li>
    <li><a href="#第8章-线程池的使用">第8章 线程池的使用</a>
      <ul>
        <li><a href="#81-在任务与执行策略之间的隐性耦合">8.1 在任务与执行策略之间的隐性耦合</a></li>
        <li><a href="#82-设置线程池的大小">8.2 设置线程池的大小</a></li>
        <li><a href="#83-配置threadpoolexecutor">8.3 配置ThreadPoolExecutor</a></li>
        <li><a href="#84-扩展threadpoolexecutor">8.4 扩展ThreadPoolExecutor</a></li>
        <li><a href="#85-递归算法的并行化">8.5 递归算法的并行化</a></li>
      </ul>
    </li>
    <li><a href="#第9章-图形用户界面应用程序">第9章 图形用户界面应用程序</a>
      <ul>
        <li><a href="#91-为什么gui是单线程的">9.1 为什么GUI是单线程的</a></li>
        <li><a href="#92-短时间的gui任务">9.2 短时间的GUI任务</a></li>
        <li><a href="#93-长时间的gui任务">9.3 长时间的GUI任务</a></li>
        <li><a href="#94-共享数据模型">9.4 共享数据模型</a></li>
        <li><a href="#95-其他形式的单线程子系统">9.5 其他形式的单线程子系统</a></li>
      </ul>
    </li>
    <li><a href="#第10章-避免活跃性危险">第10章 避免活跃性危险</a>
      <ul>
        <li><a href="#101-死锁">10.1 死锁</a></li>
        <li><a href="#102-死锁的避免与诊断">10.2 死锁的避免与诊断</a></li>
        <li><a href="#103-其他活跃性危险">10.3 其他活跃性危险</a></li>
      </ul>
    </li>
    <li><a href="#第11章-性能与可伸缩性">第11章 性能与可伸缩性</a>
      <ul>
        <li><a href="#111-对性能的思考">11.1 对性能的思考</a></li>
        <li><a href="#112-amdahl定律">11.2 Amdahl定律</a></li>
        <li><a href="#113-线程引入的开销">11.3 线程引入的开销</a></li>
        <li><a href="#114-减少锁的竞争">11.4 减少锁的竞争</a></li>
        <li><a href="#115-示例比较map的性能">11.5 示例：比较Map的性能</a></li>
        <li><a href="#116-减少上下文切换的开销">11.6 减少上下文切换的开销</a></li>
      </ul>
    </li>
    <li><a href="#第12章-并发程序的测试">第12章 并发程序的测试</a>
      <ul>
        <li><a href="#121-正确性测试">12.1 正确性测试</a></li>
        <li><a href="#122-性能测试">12.2 性能测试</a></li>
        <li><a href="#123-避免性能测试的陷阱">12.3 避免性能测试的陷阱</a></li>
        <li><a href="#124-其他的测试方法">12.4 其他的测试方法</a></li>
      </ul>
    </li>
    <li><a href="#第13章-显式锁">第13章 显式锁</a>
      <ul>
        <li><a href="#131-lock与reentrantlock">13.1 Lock与ReentrantLock</a></li>
        <li><a href="#132-性能考虑因素">13.2 性能考虑因素</a></li>
        <li><a href="#133-公平性">13.3 公平性</a></li>
        <li><a href="#134-在synchronized和reentrantlock之间进行选择">13.4 在synchronized和ReentrantLock之间进行选择</a></li>
        <li><a href="#135-读-写锁">13.5 读-写锁</a></li>
      </ul>
    </li>
    <li><a href="#第14章-构建自定义的同步工具">第14章 构建自定义的同步工具</a>
      <ul>
        <li><a href="#141-状态依赖性的管理">14.1 状态依赖性的管理</a></li>
        <li><a href="#142-使用条件队列">14.2 使用条件队列</a></li>
        <li><a href="#143-显式的condition对象">14.3 显式的Condition对象</a></li>
        <li><a href="#144-synchronizer剖析">14.4 Synchronizer剖析</a></li>
        <li><a href="#145-abstractqueuedsynchronizer">14.5 AbstractQueuedSynchronizer</a></li>
        <li><a href="#146-javautilconcurrent同步器类中的aqs">14.6 java.util.concurrent同步器类中的AQS</a></li>
      </ul>
    </li>
    <li><a href="#第15章-原子变量与非阻塞同步机制">第15章 原子变量与非阻塞同步机制</a>
      <ul>
        <li><a href="#151-锁的劣势">15.1 锁的劣势</a></li>
        <li><a href="#152-硬件对并发的支持">15.2 硬件对并发的支持</a></li>
        <li><a href="#153-原子变量类">15.3 原子变量类</a></li>
        <li><a href="#154-非阻塞算法">15.4 非阻塞算法</a></li>
      </ul>
    </li>
    <li><a href="#第16章-java内存模型">第16章 Java内存模型</a>
      <ul>
        <li><a href="#161-什么是内存模型为什么需要它">16.1 什么是内存模型，为什么需要它</a></li>
        <li><a href="#162-发布">16.2 发布</a></li>
        <li><a href="#163-初始化过程中的安全性">16.3 初始化过程中的安全性</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><ul>
<li><a href="https://book.douban.com/subject/10484692/">Java并发编程实战</a></li>
</ul>
<h2 id="第1章-简介">
  第1章 简介
  <a class="anchor" href="#%e7%ac%ac1%e7%ab%a0-%e7%ae%80%e4%bb%8b">#</a>
</h2>
<h3 id="11-并发简史">
  1.1 并发简史
  <a class="anchor" href="#11-%e5%b9%b6%e5%8f%91%e7%ae%80%e5%8f%b2">#</a>
</h3>
<h3 id="12-线程的优势">
  1.2 线程的优势
  <a class="anchor" href="#12-%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%bc%98%e5%8a%bf">#</a>
</h3>
<h3 id="13-线程带来的风险">
  1.3 线程带来的风险
  <a class="anchor" href="#13-%e7%ba%bf%e7%a8%8b%e5%b8%a6%e6%9d%a5%e7%9a%84%e9%a3%8e%e9%99%a9">#</a>
</h3>
<h3 id="14-线程无处不在">
  1.4 线程无处不在
  <a class="anchor" href="#14-%e7%ba%bf%e7%a8%8b%e6%97%a0%e5%a4%84%e4%b8%8d%e5%9c%a8">#</a>
</h3>
<ul>
<li>开发线程安全的类比开发非线程安全的类要更加谨慎和细致</li>
<li>每个Java应用程序都会使用线程
<ul>
<li>当JVM启动时，它将为JVM的内部任务（例如，<strong>垃圾收集</strong>、<strong>终结操作</strong>等）创建后台线程，并创建一个<strong>主线程</strong>来运行main方法。</li>
<li>AWT（Abstract Window Toolkit，抽象窗口工具库）和Swing的用户界面框架将创建线程来管理<strong>用户界面事件</strong>。</li>
<li>Timer将创建线程来<strong>执行延迟任务</strong>。</li>
<li>一些组件框架，例如Servlet和RMI，都会创建线程池并调用这些线程中的方法。</li>
</ul>
</li>
<li>当某个框架在应用程序中引入并发性时，<strong>通常不可能将并发性仅局限于框架代码</strong>，因为框架本身会回调（Callback）应用程序的代码，而这些代码将访问应用程序的状态。</li>
<li><strong>对线程安全性的需求也不能局限于被调用的代码，而是要延伸到需要访问这些代码所访问的程序状态的所有代码路径</strong>。因此，对线程安全性的需求将在程序中蔓延开来。</li>
</ul>
<h2 id="第2章-线程安全性">
  第2章 线程安全性
  <a class="anchor" href="#%e7%ac%ac2%e7%ab%a0-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e6%80%a7">#</a>
</h2>
<ul>
<li>要编写线程安全的代码，其核心在于要<strong>对状态访问操作进行管理</strong>，特别是对<strong>共享的（Shared）和可变的（Mutable）状态</strong>的访问。</li>
<li>“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。</li>
<li>一个对象是否需要是线程安全的，取决于它是否被多个线程访问</li>
<li>当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。
<ul>
<li>Java中的主要同步机制是关键字<strong>synchronized</strong>，它提供了一种独占的加锁方式，但“同步”这个术语还包括<strong>volatile类型的变量</strong>，<strong>显式锁（Explicit Lock）<strong>以及</strong>原子变量</strong>。</li>
</ul>
</li>
</ul>
<h3 id="21-什么是线程安全性">
  2.1 什么是线程安全性
  <a class="anchor" href="#21-%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e6%80%a7">#</a>
</h3>
<ul>
<li>在线程安全性的定义中，最核心的概念就是<strong>正确性</strong>。如果对线程安全性的定义是模糊的，那么就是因为缺乏对正确性的清晰定义。</li>
<li>正确性的含义是，<strong>某个类的行为与其规范完全一致</strong>。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件（Postcondition）来描述对象操作的结果。</li>
<li>线程安全性：<strong>当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的</strong>。
<ul>
<li>当多个线程访问某个类时，不管运行时环境<strong>采用何种调度方式</strong>或者这些<strong>线程将如何交替执行</strong>，并且<strong>在主调代码中不需要任何额外的同步或协同</strong>，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</li>
</ul>
</li>
<li>在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。</li>
<li>无状态对象一定是线程安全的
<ul>
<li>大多数Servlet都是无状态的，从而极大地降低了在实现Servlet线程安全性时的复杂性。只有当Servlet在处理请求时需要保存一些信息，线程安全性才会成为一个问题。</li>
</ul>
</li>
</ul>
<h3 id="22-原子性">
  2.2 原子性
  <a class="anchor" href="#22-%e5%8e%9f%e5%ad%90%e6%80%a7">#</a>
</h3>
<ul>
<li>在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：<strong>竞态条件（Race Condition）</strong></li>
</ul>
<h4 id="221-竞态条件">
  2.2.1 竞态条件
  <a class="anchor" href="#221-%e7%ab%9e%e6%80%81%e6%9d%a1%e4%bb%b6">#</a>
</h4>
<ul>
<li><strong>当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件</strong>。换句话说，就是正确的结果要取决于运气</li>
<li>“先检查后执行”：首先观察到某个条件为真（例如文件X不存在），然后根据这个观察结果采用相应的动作（创建文件X），但事实上，<strong>在你观察到这个结果以及开始创建文件之间，观察结果可能变得无效</strong>（另一个线程在这期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。</li>
</ul>
<h4 id="222-示例延迟初始化中的竞态条件">
  2.2.2 示例：延迟初始化中的竞态条件
  <a class="anchor" href="#222-%e7%a4%ba%e4%be%8b%e5%bb%b6%e8%bf%9f%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%ad%e7%9a%84%e7%ab%9e%e6%80%81%e6%9d%a1%e4%bb%b6">#</a>
</h4>
<ul>
<li>延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。</li>
<li>假定线程A和线程B同时执行getInstance。A看到instance为空，因而创建一个新的ExpensiveObject实例。B同样需要判断instance是否为空。此时的instance是否为空，要取决于不可预测的时序，包括线程的调度方式，以及A需要花多长时间来初始化ExpensiveObject并设置instance。如果当B检查时，instance为空，那么在两次调用getInstance时可能会得到不同的结果，即使getInstance通常被认为是返回相同的实例。</li>
</ul>
<h4 id="223-复合操作">
  2.2.3 复合操作
  <a class="anchor" href="#223-%e5%a4%8d%e5%90%88%e6%93%8d%e4%bd%9c">#</a>
</h4>
<ul>
<li>要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。</li>
<li>假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是<strong>原子的</strong>。
<ul>
<li>原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。</li>
</ul>
</li>
<li>在<strong>java.util.concurrent.atomic</strong>包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。通过用AtomicLong来代替long类型的计数器，能够确保所有对计数器状态的访问操作都是原子的。
<ul>
<li>当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的</li>
<li>当状态变量的数量由一个变为多个时，并不会像状态变量数量由零个变为一个那样简单</li>
<li>在实际情况中，应尽可能地使用现有的线程安全对象（例如AtomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。</li>
</ul>
</li>
</ul>
<h3 id="23-加锁机制">
  2.3 加锁机制
  <a class="anchor" href="#23-%e5%8a%a0%e9%94%81%e6%9c%ba%e5%88%b6">#</a>
</h3>
<ul>
<li>要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</li>
</ul>
<h4 id="231-内置锁">
  2.3.1 内置锁
  <a class="anchor" href="#231-%e5%86%85%e7%bd%ae%e9%94%81">#</a>
</h4>
<ul>
<li>Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。
<ul>
<li>以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。</li>
<li>每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）</li>
</ul>
</li>
</ul>
<h4 id="232-重入">
  2.3.2 重入
  <a class="anchor" href="#232-%e9%87%8d%e5%85%a5">#</a>
</h4>
<ul>
<li>当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞
<ul>
<li>由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”</li>
<li>重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。</li>
<li>当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。</li>
</ul>
</li>
</ul>
<h3 id="24-用锁来保护状态">
  2.4 用锁来保护状态
  <a class="anchor" href="#24-%e7%94%a8%e9%94%81%e6%9d%a5%e4%bf%9d%e6%8a%a4%e7%8a%b6%e6%80%81">#</a>
</h3>
<ul>
<li>对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。</li>
<li>之所以每个对象都有一个内置锁，只是为了免去显式地创建锁对象。</li>
<li>每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。</li>
<li>一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。</li>
<li>并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。</li>
</ul>
<h3 id="25-活跃性与性能">
  2.5 活跃性与性能
  <a class="anchor" href="#25-%e6%b4%bb%e8%b7%83%e6%80%a7%e4%b8%8e%e6%80%a7%e8%83%bd">#</a>
</h3>
<ul>
<li>不良并发（Poor Concurrency）应用程序：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。</li>
<li>当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。</li>
<li>无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。
<ul>
<li>当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。</li>
</ul>
</li>
</ul>
<h2 id="第3章-对象的共享">
  第3章 对象的共享
  <a class="anchor" href="#%e7%ac%ac3%e7%ab%a0-%e5%af%b9%e8%b1%a1%e7%9a%84%e5%85%b1%e4%ba%ab">#</a>
</h2>
<ul>
<li>同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</li>
</ul>
<h3 id="31-可见性">
  3.1 可见性
  <a class="anchor" href="#31-%e5%8f%af%e8%a7%81%e6%80%a7">#</a>
</h3>
<ul>
<li>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。</li>
</ul>
<h4 id="311-失效数据">
  3.1.1 失效数据
  <a class="anchor" href="#311-%e5%a4%b1%e6%95%88%e6%95%b0%e6%8d%ae">#</a>
</h4>
<h4 id="312非原子的64位操作">
  3.1.2　非原子的64位操作
  <a class="anchor" href="#312%e9%9d%9e%e5%8e%9f%e5%ad%90%e7%9a%8464%e4%bd%8d%e6%93%8d%e4%bd%9c">#</a>
</h4>
<ul>
<li>当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-air safety）
<ul>
<li>最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量（double和long，请参见3.1.4节）。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位￼。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。</li>
</ul>
</li>
</ul>
<h4 id="313加锁与可见性">
  3.1.3　加锁与可见性
  <a class="anchor" href="#313%e5%8a%a0%e9%94%81%e4%b8%8e%e5%8f%af%e8%a7%81%e6%80%a7">#</a>
</h4>
<ul>
<li>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</li>
</ul>
<h4 id="314volatile变量">
  3.1.4　Volatile变量
  <a class="anchor" href="#314volatile%e5%8f%98%e9%87%8f">#</a>
</h4>
<ul>
<li>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</li>
<li>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。
<ul>
<li>在当前大多数处理器架构上，读取volatile变量的开销只比读取非volatile变量的开销略高一些。</li>
</ul>
</li>
<li>我们并不建议过度依赖volatile变量提供的可见性。如果在代码中依赖volatile变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。
<ul>
<li>仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。</li>
<li>如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。</li>
</ul>
</li>
<li>volatile的语义不足以确保递增操作（count++）的原子性，除非你能确保只有一个线程对变量执行写操作。
<ul>
<li>加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。</li>
</ul>
</li>
<li>当且仅当满足以下所有条件时，才应该使用volatile变量
<ul>
<li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中。</li>
<li>在访问变量时不需要加锁。</li>
</ul>
</li>
<li>调试小提示：对于服务器应用程序，无论在开发阶段还是在测试阶段，当启动JVM时一定都要指定-server命令行选项。server模式的JVM将比client模式的JVM进行更多的优化，例如将循环中未被修改的变量提升到循环外部，因此在开发环境（client模式的JVM）中能正确运行的代码，可能会在部署环境（server模式的JVM）中运行失败。例如，如果在程序清单3-4中“忘记”把asleep变量声明为volatile类型，那么server模式的JVM会将asleep的判断条件提升到循环体外部（这将导致一个无限循环），但client模式的JVM不会这么做。在解决开发环境中出现无限循环问题时，解决这个问题的开销远小于解决在应用环境出现无限循环的开销。</li>
</ul>
<h3 id="32-发布与逸出">
  3.2 发布与逸出
  <a class="anchor" href="#32-%e5%8f%91%e5%b8%83%e4%b8%8e%e9%80%b8%e5%87%ba">#</a>
</h3>
<ul>
<li>“发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。
<ul>
<li>将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。在许多情况中，我们要确保对象及其内部状态不被发布。而在某些情况下，我们又需要发布某个对象，但如果在发布时要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象构造完成之前就发布该对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）。</li>
<li>发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象</li>
</ul>
</li>
<li>一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。</li>
<li>当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。这正是需要使用封装的最主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。</li>
<li>安全的对象构造过程
<ul>
<li>不要在构造过程中使this引用逸出</li>
<li>在构造过程中使this引用逸出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。</li>
<li>在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动</li>
<li>在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），同样会导致this引用在构造过程中逸出。</li>
<li>如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法（Factory Method），从而避免不正确的构造过程</li>
</ul>
</li>
</ul>
<h3 id="33-线程封闭">
  3.3 线程封闭
  <a class="anchor" href="#33-%e7%ba%bf%e7%a8%8b%e5%b0%81%e9%97%ad">#</a>
</h3>
<ul>
<li>Swing应用程序的许多并发错误都是由于错误地在另一个线程中使用了这些被封闭的对象。</li>
<li>线程封闭是在程序设计中的一个考虑因素，必须在程序中实现。</li>
</ul>
<h4 id="331-ad-hoc线程封闭">
  3.3.1 Ad-hoc线程封闭
  <a class="anchor" href="#331-ad-hoc%e7%ba%bf%e7%a8%8b%e5%b0%81%e9%97%ad">#</a>
</h4>
<ul>
<li>在volatile变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竞态条件，并且volatile变量的可见性保证还确保了其他线程能看到最新的值。</li>
<li>由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭或ThreadLocal类）。</li>
</ul>
<h4 id="332-栈封闭">
  3.3.2 栈封闭
  <a class="anchor" href="#332-%e6%a0%88%e5%b0%81%e9%97%ad">#</a>
</h4>
<ul>
<li>栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。</li>
<li>由于任何方法都无法获得对基本类型的引用，因此Java语言的这种语义就确保了基本类型的局部变量始终封闭在线程内。</li>
</ul>
<h4 id="333-threadlocal-类">
  3.3.3 ThreadLocal 类
  <a class="anchor" href="#333-threadlocal-%e7%b1%bb">#</a>
</h4>
<ul>
<li>ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。</li>
<li>假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象（如果全局变量的语义允许），可以维持线程安全性。</li>
</ul>
<h3 id="34-不变性">
  3.4 不变性
  <a class="anchor" href="#34-%e4%b8%8d%e5%8f%98%e6%80%a7">#</a>
</h3>
<ul>
<li>如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。</li>
<li>不可变对象一定是线程安全的</li>
<li>虽然在Java语言规范和Java内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。</li>
<li>当满足以下条件时，对象才是不可变的：
<ul>
<li>对象创建以后其状态就不能修改。</li>
<li>对象的所有域都是final类型。</li>
<li>对象是正确创建的（在对象的创建期间，this引用没有逸出）。</li>
</ul>
</li>
</ul>
<h4 id="341-final域">
  3.4.1 Final域
  <a class="anchor" href="#341-final%e5%9f%9f">#</a>
</h4>
<ul>
<li>关键字final可以视为C++中const机制的一种受限版本，用于构造不可变性对象。final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。</li>
<li>即使对象是可变的，通过将对象的某些域声明为final类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。</li>
<li>正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”[EJ Item 12]是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。</li>
</ul>
<h4 id="342-示例使用volatile类型来发布不可变对象">
  3.4.2 示例：使用volatile类型来发布不可变对象
  <a class="anchor" href="#342-%e7%a4%ba%e4%be%8b%e4%bd%bf%e7%94%a8volatile%e7%b1%bb%e5%9e%8b%e6%9d%a5%e5%8f%91%e5%b8%83%e4%b8%8d%e5%8f%af%e5%8f%98%e5%af%b9%e8%b1%a1">#</a>
</h4>
<ul>
<li>通过使用包含多个状态变量的容器对象来维持不变性条件，并使用一个volatile类型的引用来确保可见性，使得Volatile Cached Factorizer在没有显式地使用锁的情况下仍然是线程安全的</li>
</ul>
<h3 id="35-安全发布">
  3.5 安全发布
  <a class="anchor" href="#35-%e5%ae%89%e5%85%a8%e5%8f%91%e5%b8%83">#</a>
</h3>
<h4 id="351-不正确的发布正确的对象被破坏">
  3.5.1 不正确的发布：正确的对象被破坏
  <a class="anchor" href="#351-%e4%b8%8d%e6%ad%a3%e7%a1%ae%e7%9a%84%e5%8f%91%e5%b8%83%e6%ad%a3%e7%a1%ae%e7%9a%84%e5%af%b9%e8%b1%a1%e8%a2%ab%e7%a0%b4%e5%9d%8f">#</a>
</h4>
<ul>
<li>你不能指望一个尚未被完全创建的对象拥有完整性。某个观察该对象的线程将看到对象处于不一致的状态，然后看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。</li>
</ul>
<h4 id="352-不可变对象与初始化安全性">
  3.5.2 不可变对象与初始化安全性
  <a class="anchor" href="#352-%e4%b8%8d%e5%8f%af%e5%8f%98%e5%af%b9%e8%b1%a1%e4%b8%8e%e5%88%9d%e5%a7%8b%e5%8c%96%e5%ae%89%e5%85%a8%e6%80%a7">#</a>
</h4>
<ul>
<li>我们已经知道，即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一致的视图，就必须使用同步。</li>
<li>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。</li>
<li>在没有额外同步的情况下，也可以安全地访问final类型的域。然而，如果final类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。</li>
</ul>
<h4 id="353-安全发布的常用模式">
  3.5.3 安全发布的常用模式
  <a class="anchor" href="#353-%e5%ae%89%e5%85%a8%e5%8f%91%e5%b8%83%e7%9a%84%e5%b8%b8%e7%94%a8%e6%a8%a1%e5%bc%8f">#</a>
</h4>
<ul>
<li>可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时都必须使用同步。</li>
<li>要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见
<ul>
<li>在静态初始化函数中初始化一个对象引用。</li>
<li>将对象的引用保存到volatile类型的域或者AtomicReferance对象中。</li>
<li>将对象的引用保存到某个正确构造对象的final类型域中。</li>
<li>将对象的引用保存到一个由锁保护的域中。</li>
</ul>
</li>
<li>在线程安全容器内部的同步意味着，在将对象放入到某个容器，例如Vector或synchronizedList时，将满足上述最后一条需求。如果线程A将对象X放入一个线程安全的容器，随后线程B读取这个对象，那么可以确保B看到A设置的X状态，即便在这段读/写X的应用程序代码中没有包含显式的同步。
<ul>
<li>线程安全库中的容器类提供了以下的安全发布保证
<ul>
<li>通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。</li>
<li>通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。</li>
<li>通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。</li>
</ul>
</li>
</ul>
</li>
<li>要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器 <code>public static Holder holder=new Holder（42）</code>
<ul>
<li>静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布</li>
</ul>
</li>
</ul>
<h4 id="354-事实不可变对象">
  3.5.4 事实不可变对象
  <a class="anchor" href="#354-%e4%ba%8b%e5%ae%9e%e4%b8%8d%e5%8f%af%e5%8f%98%e5%af%b9%e8%b1%a1">#</a>
</h4>
<ul>
<li>如果对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全地访问这些对象的线程来说，安全发布是足够的。</li>
<li>如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）”
<ul>
<li>通过使用事实不可变对象，不仅可以简化开发过程，而且还能由于减少了同步而提高性能。</li>
<li>例如，Date本身是可变的￼，但如果将它作为不可变对象来使用，那么在多个线程之间共享Date对象时，就可以省去对锁的使用</li>
</ul>
</li>
</ul>
<h4 id="355-可变对象">
  3.5.5 可变对象
  <a class="anchor" href="#355-%e5%8f%af%e5%8f%98%e5%af%b9%e8%b1%a1">#</a>
</h4>
<ul>
<li>如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。</li>
<li>在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
<ul>
<li>线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。</li>
<li>只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。</li>
<li>线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。</li>
<li>保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li>
</ul>
</li>
</ul>
<h4 id="356-安全地共享对象">
  3.5.6 安全地共享对象
  <a class="anchor" href="#356-%e5%ae%89%e5%85%a8%e5%9c%b0%e5%85%b1%e4%ba%ab%e5%af%b9%e8%b1%a1">#</a>
</h4>
<h2 id="第4章-对象的组合">
  第4章 对象的组合
  <a class="anchor" href="#%e7%ac%ac4%e7%ab%a0-%e5%af%b9%e8%b1%a1%e7%9a%84%e7%bb%84%e5%90%88">#</a>
</h2>
<h3 id="41-设计线程安全的类">
  4.1 设计线程安全的类
  <a class="anchor" href="#41-%e8%ae%be%e8%ae%a1%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e7%b1%bb">#</a>
</h3>
<h3 id="42-实例封闭">
  4.2 实例封闭
  <a class="anchor" href="#42-%e5%ae%9e%e4%be%8b%e5%b0%81%e9%97%ad">#</a>
</h3>
<h3 id="43-线程安全性的委托">
  4.3 线程安全性的委托
  <a class="anchor" href="#43-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e6%80%a7%e7%9a%84%e5%a7%94%e6%89%98">#</a>
</h3>
<h3 id="44-在现有的线程安全类中添加功能">
  4.4 在现有的线程安全类中添加功能
  <a class="anchor" href="#44-%e5%9c%a8%e7%8e%b0%e6%9c%89%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%b1%bb%e4%b8%ad%e6%b7%bb%e5%8a%a0%e5%8a%9f%e8%83%bd">#</a>
</h3>
<h3 id="45-将同步策略文档化">
  4.5 将同步策略文档化
  <a class="anchor" href="#45-%e5%b0%86%e5%90%8c%e6%ad%a5%e7%ad%96%e7%95%a5%e6%96%87%e6%a1%a3%e5%8c%96">#</a>
</h3>
<h2 id="第5章-基础构建模块">
  第5章 基础构建模块
  <a class="anchor" href="#%e7%ac%ac5%e7%ab%a0-%e5%9f%ba%e7%a1%80%e6%9e%84%e5%bb%ba%e6%a8%a1%e5%9d%97">#</a>
</h2>
<h3 id="51-同步容器类">
  5.1 同步容器类
  <a class="anchor" href="#51-%e5%90%8c%e6%ad%a5%e5%ae%b9%e5%99%a8%e7%b1%bb">#</a>
</h3>
<h3 id="52-并发容器">
  5.2 并发容器
  <a class="anchor" href="#52-%e5%b9%b6%e5%8f%91%e5%ae%b9%e5%99%a8">#</a>
</h3>
<h3 id="53-阻塞队列和生产者-消费者模式">
  5.3 阻塞队列和生产者-消费者模式
  <a class="anchor" href="#53-%e9%98%bb%e5%a1%9e%e9%98%9f%e5%88%97%e5%92%8c%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e6%a8%a1%e5%bc%8f">#</a>
</h3>
<h3 id="54-阻塞方法与中断方法">
  5.4 阻塞方法与中断方法
  <a class="anchor" href="#54-%e9%98%bb%e5%a1%9e%e6%96%b9%e6%b3%95%e4%b8%8e%e4%b8%ad%e6%96%ad%e6%96%b9%e6%b3%95">#</a>
</h3>
<h3 id="55-同步工具类">
  5.5 同步工具类
  <a class="anchor" href="#55-%e5%90%8c%e6%ad%a5%e5%b7%a5%e5%85%b7%e7%b1%bb">#</a>
</h3>
<h3 id="56-构建高效且可伸缩的结果缓存">
  5.6 构建高效且可伸缩的结果缓存
  <a class="anchor" href="#56-%e6%9e%84%e5%bb%ba%e9%ab%98%e6%95%88%e4%b8%94%e5%8f%af%e4%bc%b8%e7%bc%a9%e7%9a%84%e7%bb%93%e6%9e%9c%e7%bc%93%e5%ad%98">#</a>
</h3>
<h2 id="第6章-任务执行">
  第6章 任务执行
  <a class="anchor" href="#%e7%ac%ac6%e7%ab%a0-%e4%bb%bb%e5%8a%a1%e6%89%a7%e8%a1%8c">#</a>
</h2>
<h3 id="61-在线程中执行任务">
  6.1 在线程中执行任务
  <a class="anchor" href="#61-%e5%9c%a8%e7%ba%bf%e7%a8%8b%e4%b8%ad%e6%89%a7%e8%a1%8c%e4%bb%bb%e5%8a%a1">#</a>
</h3>
<h3 id="62-executor框架">
  6.2 Executor框架
  <a class="anchor" href="#62-executor%e6%a1%86%e6%9e%b6">#</a>
</h3>
<h3 id="63-找出可利用的并行性">
  6.3 找出可利用的并行性
  <a class="anchor" href="#63-%e6%89%be%e5%87%ba%e5%8f%af%e5%88%a9%e7%94%a8%e7%9a%84%e5%b9%b6%e8%a1%8c%e6%80%a7">#</a>
</h3>
<h2 id="第7章-取消与关闭">
  第7章 取消与关闭
  <a class="anchor" href="#%e7%ac%ac7%e7%ab%a0-%e5%8f%96%e6%b6%88%e4%b8%8e%e5%85%b3%e9%97%ad">#</a>
</h2>
<h3 id="71-任务取消">
  7.1 任务取消
  <a class="anchor" href="#71-%e4%bb%bb%e5%8a%a1%e5%8f%96%e6%b6%88">#</a>
</h3>
<h3 id="72-停止基于线程的服务">
  7.2 停止基于线程的服务
  <a class="anchor" href="#72-%e5%81%9c%e6%ad%a2%e5%9f%ba%e4%ba%8e%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%9c%8d%e5%8a%a1">#</a>
</h3>
<h3 id="73-处理非正常的线程终止">
  7.3 处理非正常的线程终止
  <a class="anchor" href="#73-%e5%a4%84%e7%90%86%e9%9d%9e%e6%ad%a3%e5%b8%b8%e7%9a%84%e7%ba%bf%e7%a8%8b%e7%bb%88%e6%ad%a2">#</a>
</h3>
<h3 id="74-jvm关闭">
  7.4 JVM关闭
  <a class="anchor" href="#74-jvm%e5%85%b3%e9%97%ad">#</a>
</h3>
<h2 id="第8章-线程池的使用">
  第8章 线程池的使用
  <a class="anchor" href="#%e7%ac%ac8%e7%ab%a0-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e4%bd%bf%e7%94%a8">#</a>
</h2>
<h3 id="81-在任务与执行策略之间的隐性耦合">
  8.1 在任务与执行策略之间的隐性耦合
  <a class="anchor" href="#81-%e5%9c%a8%e4%bb%bb%e5%8a%a1%e4%b8%8e%e6%89%a7%e8%a1%8c%e7%ad%96%e7%95%a5%e4%b9%8b%e9%97%b4%e7%9a%84%e9%9a%90%e6%80%a7%e8%80%a6%e5%90%88">#</a>
</h3>
<h3 id="82-设置线程池的大小">
  8.2 设置线程池的大小
  <a class="anchor" href="#82-%e8%ae%be%e7%bd%ae%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%a4%a7%e5%b0%8f">#</a>
</h3>
<h3 id="83-配置threadpoolexecutor">
  8.3 配置ThreadPoolExecutor
  <a class="anchor" href="#83-%e9%85%8d%e7%bd%aethreadpoolexecutor">#</a>
</h3>
<h3 id="84-扩展threadpoolexecutor">
  8.4 扩展ThreadPoolExecutor
  <a class="anchor" href="#84-%e6%89%a9%e5%b1%95threadpoolexecutor">#</a>
</h3>
<h3 id="85-递归算法的并行化">
  8.5 递归算法的并行化
  <a class="anchor" href="#85-%e9%80%92%e5%bd%92%e7%ae%97%e6%b3%95%e7%9a%84%e5%b9%b6%e8%a1%8c%e5%8c%96">#</a>
</h3>
<h2 id="第9章-图形用户界面应用程序">
  第9章 图形用户界面应用程序
  <a class="anchor" href="#%e7%ac%ac9%e7%ab%a0-%e5%9b%be%e5%bd%a2%e7%94%a8%e6%88%b7%e7%95%8c%e9%9d%a2%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f">#</a>
</h2>
<h3 id="91-为什么gui是单线程的">
  9.1 为什么GUI是单线程的
  <a class="anchor" href="#91-%e4%b8%ba%e4%bb%80%e4%b9%88gui%e6%98%af%e5%8d%95%e7%ba%bf%e7%a8%8b%e7%9a%84">#</a>
</h3>
<h3 id="92-短时间的gui任务">
  9.2 短时间的GUI任务
  <a class="anchor" href="#92-%e7%9f%ad%e6%97%b6%e9%97%b4%e7%9a%84gui%e4%bb%bb%e5%8a%a1">#</a>
</h3>
<h3 id="93-长时间的gui任务">
  9.3 长时间的GUI任务
  <a class="anchor" href="#93-%e9%95%bf%e6%97%b6%e9%97%b4%e7%9a%84gui%e4%bb%bb%e5%8a%a1">#</a>
</h3>
<h3 id="94-共享数据模型">
  9.4 共享数据模型
  <a class="anchor" href="#94-%e5%85%b1%e4%ba%ab%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b">#</a>
</h3>
<h3 id="95-其他形式的单线程子系统">
  9.5 其他形式的单线程子系统
  <a class="anchor" href="#95-%e5%85%b6%e4%bb%96%e5%bd%a2%e5%bc%8f%e7%9a%84%e5%8d%95%e7%ba%bf%e7%a8%8b%e5%ad%90%e7%b3%bb%e7%bb%9f">#</a>
</h3>
<h2 id="第10章-避免活跃性危险">
  第10章 避免活跃性危险
  <a class="anchor" href="#%e7%ac%ac10%e7%ab%a0-%e9%81%bf%e5%85%8d%e6%b4%bb%e8%b7%83%e6%80%a7%e5%8d%b1%e9%99%a9">#</a>
</h2>
<h3 id="101-死锁">
  10.1 死锁
  <a class="anchor" href="#101-%e6%ad%bb%e9%94%81">#</a>
</h3>
<h3 id="102-死锁的避免与诊断">
  10.2 死锁的避免与诊断
  <a class="anchor" href="#102-%e6%ad%bb%e9%94%81%e7%9a%84%e9%81%bf%e5%85%8d%e4%b8%8e%e8%af%8a%e6%96%ad">#</a>
</h3>
<h3 id="103-其他活跃性危险">
  10.3 其他活跃性危险
  <a class="anchor" href="#103-%e5%85%b6%e4%bb%96%e6%b4%bb%e8%b7%83%e6%80%a7%e5%8d%b1%e9%99%a9">#</a>
</h3>
<h2 id="第11章-性能与可伸缩性">
  第11章 性能与可伸缩性
  <a class="anchor" href="#%e7%ac%ac11%e7%ab%a0-%e6%80%a7%e8%83%bd%e4%b8%8e%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7">#</a>
</h2>
<h3 id="111-对性能的思考">
  11.1 对性能的思考
  <a class="anchor" href="#111-%e5%af%b9%e6%80%a7%e8%83%bd%e7%9a%84%e6%80%9d%e8%80%83">#</a>
</h3>
<h3 id="112-amdahl定律">
  11.2 Amdahl定律
  <a class="anchor" href="#112-amdahl%e5%ae%9a%e5%be%8b">#</a>
</h3>
<h3 id="113-线程引入的开销">
  11.3 线程引入的开销
  <a class="anchor" href="#113-%e7%ba%bf%e7%a8%8b%e5%bc%95%e5%85%a5%e7%9a%84%e5%bc%80%e9%94%80">#</a>
</h3>
<h3 id="114-减少锁的竞争">
  11.4 减少锁的竞争
  <a class="anchor" href="#114-%e5%87%8f%e5%b0%91%e9%94%81%e7%9a%84%e7%ab%9e%e4%ba%89">#</a>
</h3>
<h3 id="115-示例比较map的性能">
  11.5 示例：比较Map的性能
  <a class="anchor" href="#115-%e7%a4%ba%e4%be%8b%e6%af%94%e8%be%83map%e7%9a%84%e6%80%a7%e8%83%bd">#</a>
</h3>
<h3 id="116-减少上下文切换的开销">
  11.6 减少上下文切换的开销
  <a class="anchor" href="#116-%e5%87%8f%e5%b0%91%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e7%9a%84%e5%bc%80%e9%94%80">#</a>
</h3>
<h2 id="第12章-并发程序的测试">
  第12章 并发程序的测试
  <a class="anchor" href="#%e7%ac%ac12%e7%ab%a0-%e5%b9%b6%e5%8f%91%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%b5%8b%e8%af%95">#</a>
</h2>
<h3 id="121-正确性测试">
  12.1 正确性测试
  <a class="anchor" href="#121-%e6%ad%a3%e7%a1%ae%e6%80%a7%e6%b5%8b%e8%af%95">#</a>
</h3>
<h3 id="122-性能测试">
  12.2 性能测试
  <a class="anchor" href="#122-%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95">#</a>
</h3>
<h3 id="123-避免性能测试的陷阱">
  12.3 避免性能测试的陷阱
  <a class="anchor" href="#123-%e9%81%bf%e5%85%8d%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e7%9a%84%e9%99%b7%e9%98%b1">#</a>
</h3>
<h3 id="124-其他的测试方法">
  12.4 其他的测试方法
  <a class="anchor" href="#124-%e5%85%b6%e4%bb%96%e7%9a%84%e6%b5%8b%e8%af%95%e6%96%b9%e6%b3%95">#</a>
</h3>
<h2 id="第13章-显式锁">
  第13章 显式锁
  <a class="anchor" href="#%e7%ac%ac13%e7%ab%a0-%e6%98%be%e5%bc%8f%e9%94%81">#</a>
</h2>
<h3 id="131-lock与reentrantlock">
  13.1 Lock与ReentrantLock
  <a class="anchor" href="#131-lock%e4%b8%8ereentrantlock">#</a>
</h3>
<h3 id="132-性能考虑因素">
  13.2 性能考虑因素
  <a class="anchor" href="#132-%e6%80%a7%e8%83%bd%e8%80%83%e8%99%91%e5%9b%a0%e7%b4%a0">#</a>
</h3>
<h3 id="133-公平性">
  13.3 公平性
  <a class="anchor" href="#133-%e5%85%ac%e5%b9%b3%e6%80%a7">#</a>
</h3>
<h3 id="134-在synchronized和reentrantlock之间进行选择">
  13.4 在synchronized和ReentrantLock之间进行选择
  <a class="anchor" href="#134-%e5%9c%a8synchronized%e5%92%8creentrantlock%e4%b9%8b%e9%97%b4%e8%bf%9b%e8%a1%8c%e9%80%89%e6%8b%a9">#</a>
</h3>
<h3 id="135-读-写锁">
  13.5 读-写锁
  <a class="anchor" href="#135-%e8%af%bb-%e5%86%99%e9%94%81">#</a>
</h3>
<h2 id="第14章-构建自定义的同步工具">
  第14章 构建自定义的同步工具
  <a class="anchor" href="#%e7%ac%ac14%e7%ab%a0-%e6%9e%84%e5%bb%ba%e8%87%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e5%90%8c%e6%ad%a5%e5%b7%a5%e5%85%b7">#</a>
</h2>
<h3 id="141-状态依赖性的管理">
  14.1 状态依赖性的管理
  <a class="anchor" href="#141-%e7%8a%b6%e6%80%81%e4%be%9d%e8%b5%96%e6%80%a7%e7%9a%84%e7%ae%a1%e7%90%86">#</a>
</h3>
<h3 id="142-使用条件队列">
  14.2 使用条件队列
  <a class="anchor" href="#142-%e4%bd%bf%e7%94%a8%e6%9d%a1%e4%bb%b6%e9%98%9f%e5%88%97">#</a>
</h3>
<h3 id="143-显式的condition对象">
  14.3 显式的Condition对象
  <a class="anchor" href="#143-%e6%98%be%e5%bc%8f%e7%9a%84condition%e5%af%b9%e8%b1%a1">#</a>
</h3>
<h3 id="144-synchronizer剖析">
  14.4 Synchronizer剖析
  <a class="anchor" href="#144-synchronizer%e5%89%96%e6%9e%90">#</a>
</h3>
<h3 id="145-abstractqueuedsynchronizer">
  14.5 AbstractQueuedSynchronizer
  <a class="anchor" href="#145-abstractqueuedsynchronizer">#</a>
</h3>
<h3 id="146-javautilconcurrent同步器类中的aqs">
  14.6 java.util.concurrent同步器类中的AQS
  <a class="anchor" href="#146-javautilconcurrent%e5%90%8c%e6%ad%a5%e5%99%a8%e7%b1%bb%e4%b8%ad%e7%9a%84aqs">#</a>
</h3>
<h2 id="第15章-原子变量与非阻塞同步机制">
  第15章 原子变量与非阻塞同步机制
  <a class="anchor" href="#%e7%ac%ac15%e7%ab%a0-%e5%8e%9f%e5%ad%90%e5%8f%98%e9%87%8f%e4%b8%8e%e9%9d%9e%e9%98%bb%e5%a1%9e%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6">#</a>
</h2>
<h3 id="151-锁的劣势">
  15.1 锁的劣势
  <a class="anchor" href="#151-%e9%94%81%e7%9a%84%e5%8a%a3%e5%8a%bf">#</a>
</h3>
<h3 id="152-硬件对并发的支持">
  15.2 硬件对并发的支持
  <a class="anchor" href="#152-%e7%a1%ac%e4%bb%b6%e5%af%b9%e5%b9%b6%e5%8f%91%e7%9a%84%e6%94%af%e6%8c%81">#</a>
</h3>
<h3 id="153-原子变量类">
  15.3 原子变量类
  <a class="anchor" href="#153-%e5%8e%9f%e5%ad%90%e5%8f%98%e9%87%8f%e7%b1%bb">#</a>
</h3>
<h3 id="154-非阻塞算法">
  15.4 非阻塞算法
  <a class="anchor" href="#154-%e9%9d%9e%e9%98%bb%e5%a1%9e%e7%ae%97%e6%b3%95">#</a>
</h3>
<h2 id="第16章-java内存模型">
  第16章 Java内存模型
  <a class="anchor" href="#%e7%ac%ac16%e7%ab%a0-java%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b">#</a>
</h2>
<h3 id="161-什么是内存模型为什么需要它">
  16.1 什么是内存模型，为什么需要它
  <a class="anchor" href="#161-%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%ae%83">#</a>
</h3>
<h3 id="162-发布">
  16.2 发布
  <a class="anchor" href="#162-%e5%8f%91%e5%b8%83">#</a>
</h3>
<h3 id="163-初始化过程中的安全性">
  16.3 初始化过程中的安全性
  <a class="anchor" href="#163-%e5%88%9d%e5%a7%8b%e5%8c%96%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%ae%89%e5%85%a8%e6%80%a7">#</a>
</h3>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第1章-简介">第1章 简介</a>
      <ul>
        <li><a href="#11-并发简史">1.1 并发简史</a></li>
        <li><a href="#12-线程的优势">1.2 线程的优势</a></li>
        <li><a href="#13-线程带来的风险">1.3 线程带来的风险</a></li>
        <li><a href="#14-线程无处不在">1.4 线程无处不在</a></li>
      </ul>
    </li>
    <li><a href="#第2章-线程安全性">第2章 线程安全性</a>
      <ul>
        <li><a href="#21-什么是线程安全性">2.1 什么是线程安全性</a></li>
        <li><a href="#22-原子性">2.2 原子性</a>
          <ul>
            <li><a href="#221-竞态条件">2.2.1 竞态条件</a></li>
            <li><a href="#222-示例延迟初始化中的竞态条件">2.2.2 示例：延迟初始化中的竞态条件</a></li>
            <li><a href="#223-复合操作">2.2.3 复合操作</a></li>
          </ul>
        </li>
        <li><a href="#23-加锁机制">2.3 加锁机制</a>
          <ul>
            <li><a href="#231-内置锁">2.3.1 内置锁</a></li>
            <li><a href="#232-重入">2.3.2 重入</a></li>
          </ul>
        </li>
        <li><a href="#24-用锁来保护状态">2.4 用锁来保护状态</a></li>
        <li><a href="#25-活跃性与性能">2.5 活跃性与性能</a></li>
      </ul>
    </li>
    <li><a href="#第3章-对象的共享">第3章 对象的共享</a>
      <ul>
        <li><a href="#31-可见性">3.1 可见性</a>
          <ul>
            <li><a href="#311-失效数据">3.1.1 失效数据</a></li>
            <li><a href="#312非原子的64位操作">3.1.2　非原子的64位操作</a></li>
            <li><a href="#313加锁与可见性">3.1.3　加锁与可见性</a></li>
            <li><a href="#314volatile变量">3.1.4　Volatile变量</a></li>
          </ul>
        </li>
        <li><a href="#32-发布与逸出">3.2 发布与逸出</a></li>
        <li><a href="#33-线程封闭">3.3 线程封闭</a>
          <ul>
            <li><a href="#331-ad-hoc线程封闭">3.3.1 Ad-hoc线程封闭</a></li>
            <li><a href="#332-栈封闭">3.3.2 栈封闭</a></li>
            <li><a href="#333-threadlocal-类">3.3.3 ThreadLocal 类</a></li>
          </ul>
        </li>
        <li><a href="#34-不变性">3.4 不变性</a>
          <ul>
            <li><a href="#341-final域">3.4.1 Final域</a></li>
            <li><a href="#342-示例使用volatile类型来发布不可变对象">3.4.2 示例：使用volatile类型来发布不可变对象</a></li>
          </ul>
        </li>
        <li><a href="#35-安全发布">3.5 安全发布</a>
          <ul>
            <li><a href="#351-不正确的发布正确的对象被破坏">3.5.1 不正确的发布：正确的对象被破坏</a></li>
            <li><a href="#352-不可变对象与初始化安全性">3.5.2 不可变对象与初始化安全性</a></li>
            <li><a href="#353-安全发布的常用模式">3.5.3 安全发布的常用模式</a></li>
            <li><a href="#354-事实不可变对象">3.5.4 事实不可变对象</a></li>
            <li><a href="#355-可变对象">3.5.5 可变对象</a></li>
            <li><a href="#356-安全地共享对象">3.5.6 安全地共享对象</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第4章-对象的组合">第4章 对象的组合</a>
      <ul>
        <li><a href="#41-设计线程安全的类">4.1 设计线程安全的类</a></li>
        <li><a href="#42-实例封闭">4.2 实例封闭</a></li>
        <li><a href="#43-线程安全性的委托">4.3 线程安全性的委托</a></li>
        <li><a href="#44-在现有的线程安全类中添加功能">4.4 在现有的线程安全类中添加功能</a></li>
        <li><a href="#45-将同步策略文档化">4.5 将同步策略文档化</a></li>
      </ul>
    </li>
    <li><a href="#第5章-基础构建模块">第5章 基础构建模块</a>
      <ul>
        <li><a href="#51-同步容器类">5.1 同步容器类</a></li>
        <li><a href="#52-并发容器">5.2 并发容器</a></li>
        <li><a href="#53-阻塞队列和生产者-消费者模式">5.3 阻塞队列和生产者-消费者模式</a></li>
        <li><a href="#54-阻塞方法与中断方法">5.4 阻塞方法与中断方法</a></li>
        <li><a href="#55-同步工具类">5.5 同步工具类</a></li>
        <li><a href="#56-构建高效且可伸缩的结果缓存">5.6 构建高效且可伸缩的结果缓存</a></li>
      </ul>
    </li>
    <li><a href="#第6章-任务执行">第6章 任务执行</a>
      <ul>
        <li><a href="#61-在线程中执行任务">6.1 在线程中执行任务</a></li>
        <li><a href="#62-executor框架">6.2 Executor框架</a></li>
        <li><a href="#63-找出可利用的并行性">6.3 找出可利用的并行性</a></li>
      </ul>
    </li>
    <li><a href="#第7章-取消与关闭">第7章 取消与关闭</a>
      <ul>
        <li><a href="#71-任务取消">7.1 任务取消</a></li>
        <li><a href="#72-停止基于线程的服务">7.2 停止基于线程的服务</a></li>
        <li><a href="#73-处理非正常的线程终止">7.3 处理非正常的线程终止</a></li>
        <li><a href="#74-jvm关闭">7.4 JVM关闭</a></li>
      </ul>
    </li>
    <li><a href="#第8章-线程池的使用">第8章 线程池的使用</a>
      <ul>
        <li><a href="#81-在任务与执行策略之间的隐性耦合">8.1 在任务与执行策略之间的隐性耦合</a></li>
        <li><a href="#82-设置线程池的大小">8.2 设置线程池的大小</a></li>
        <li><a href="#83-配置threadpoolexecutor">8.3 配置ThreadPoolExecutor</a></li>
        <li><a href="#84-扩展threadpoolexecutor">8.4 扩展ThreadPoolExecutor</a></li>
        <li><a href="#85-递归算法的并行化">8.5 递归算法的并行化</a></li>
      </ul>
    </li>
    <li><a href="#第9章-图形用户界面应用程序">第9章 图形用户界面应用程序</a>
      <ul>
        <li><a href="#91-为什么gui是单线程的">9.1 为什么GUI是单线程的</a></li>
        <li><a href="#92-短时间的gui任务">9.2 短时间的GUI任务</a></li>
        <li><a href="#93-长时间的gui任务">9.3 长时间的GUI任务</a></li>
        <li><a href="#94-共享数据模型">9.4 共享数据模型</a></li>
        <li><a href="#95-其他形式的单线程子系统">9.5 其他形式的单线程子系统</a></li>
      </ul>
    </li>
    <li><a href="#第10章-避免活跃性危险">第10章 避免活跃性危险</a>
      <ul>
        <li><a href="#101-死锁">10.1 死锁</a></li>
        <li><a href="#102-死锁的避免与诊断">10.2 死锁的避免与诊断</a></li>
        <li><a href="#103-其他活跃性危险">10.3 其他活跃性危险</a></li>
      </ul>
    </li>
    <li><a href="#第11章-性能与可伸缩性">第11章 性能与可伸缩性</a>
      <ul>
        <li><a href="#111-对性能的思考">11.1 对性能的思考</a></li>
        <li><a href="#112-amdahl定律">11.2 Amdahl定律</a></li>
        <li><a href="#113-线程引入的开销">11.3 线程引入的开销</a></li>
        <li><a href="#114-减少锁的竞争">11.4 减少锁的竞争</a></li>
        <li><a href="#115-示例比较map的性能">11.5 示例：比较Map的性能</a></li>
        <li><a href="#116-减少上下文切换的开销">11.6 减少上下文切换的开销</a></li>
      </ul>
    </li>
    <li><a href="#第12章-并发程序的测试">第12章 并发程序的测试</a>
      <ul>
        <li><a href="#121-正确性测试">12.1 正确性测试</a></li>
        <li><a href="#122-性能测试">12.2 性能测试</a></li>
        <li><a href="#123-避免性能测试的陷阱">12.3 避免性能测试的陷阱</a></li>
        <li><a href="#124-其他的测试方法">12.4 其他的测试方法</a></li>
      </ul>
    </li>
    <li><a href="#第13章-显式锁">第13章 显式锁</a>
      <ul>
        <li><a href="#131-lock与reentrantlock">13.1 Lock与ReentrantLock</a></li>
        <li><a href="#132-性能考虑因素">13.2 性能考虑因素</a></li>
        <li><a href="#133-公平性">13.3 公平性</a></li>
        <li><a href="#134-在synchronized和reentrantlock之间进行选择">13.4 在synchronized和ReentrantLock之间进行选择</a></li>
        <li><a href="#135-读-写锁">13.5 读-写锁</a></li>
      </ul>
    </li>
    <li><a href="#第14章-构建自定义的同步工具">第14章 构建自定义的同步工具</a>
      <ul>
        <li><a href="#141-状态依赖性的管理">14.1 状态依赖性的管理</a></li>
        <li><a href="#142-使用条件队列">14.2 使用条件队列</a></li>
        <li><a href="#143-显式的condition对象">14.3 显式的Condition对象</a></li>
        <li><a href="#144-synchronizer剖析">14.4 Synchronizer剖析</a></li>
        <li><a href="#145-abstractqueuedsynchronizer">14.5 AbstractQueuedSynchronizer</a></li>
        <li><a href="#146-javautilconcurrent同步器类中的aqs">14.6 java.util.concurrent同步器类中的AQS</a></li>
      </ul>
    </li>
    <li><a href="#第15章-原子变量与非阻塞同步机制">第15章 原子变量与非阻塞同步机制</a>
      <ul>
        <li><a href="#151-锁的劣势">15.1 锁的劣势</a></li>
        <li><a href="#152-硬件对并发的支持">15.2 硬件对并发的支持</a></li>
        <li><a href="#153-原子变量类">15.3 原子变量类</a></li>
        <li><a href="#154-非阻塞算法">15.4 非阻塞算法</a></li>
      </ul>
    </li>
    <li><a href="#第16章-java内存模型">第16章 Java内存模型</a>
      <ul>
        <li><a href="#161-什么是内存模型为什么需要它">16.1 什么是内存模型，为什么需要它</a></li>
        <li><a href="#162-发布">16.2 发布</a></li>
        <li><a href="#163-初始化过程中的安全性">16.3 初始化过程中的安全性</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












