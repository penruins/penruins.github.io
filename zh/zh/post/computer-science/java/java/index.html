<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  String
  #


  StringBuffer 是怎么保证线程安全的？
  #

StringBuffer 是通过 同步机制 来保证线程安全的。具体来说，它的所有关键方法（如 append()、insert()、delete()、reverse() 等）都使用了 synchronized 关键字进行修饰，确保同一时间只有一个线程可以执行这些方法127。

  1. 同步方法
  #

StringBuffer 的方法在设计时都加了 synchronized 关键字，例如：
public synchronized StringBuffer append(String str) {
    // 方法实现
}
这种机制确保了在多线程环境下，只有一个线程可以访问和修改 StringBuffer 的内容，避免了竞态条件（Race Condition）和数据不一致的问题12。

  2. 锁机制
  #

StringBuffer 内部使用了一个锁对象（即 this 锁），当一个线程调用 StringBuffer 的同步方法时，会获取这个锁，其他线程必须等待锁释放后才能继续执行。这种锁机制保证了线程间的同步17。

  3. 性能影响
  #

虽然 StringBuffer 的同步机制确保了线程安全，但也带来了性能开销。因为在多线程环境下，每次只能有一个线程操作 StringBuffer，其他线程会被阻塞。因此，在单线程环境下，推荐使用性能更高的 StringBuilder，它没有同步机制158。

  4. 适用场景
  #


多线程环境：如果需要在多线程环境下对字符串进行操作，StringBuffer 是合适的选择，因为它确保了线程安全29。
单线程环境：在单线程环境下，建议使用 StringBuilder，因为它没有同步开销，性能更高18。


  总结
  #

StringBuffer 通过 synchronized 关键字实现的同步机制，确保了多线程环境下的线程安全性。虽然这种机制带来了性能开销，但在需要线程安全的场景下，它是一个可靠的选择127。

  StringBuffer 和 StringBuilder 字符串在底层是以什么数据结构保存的
  #

StringBuffer 和 StringBuilder 在底层都是使用 字符数组（char[]） 来保存字符串数据的。具体来说，它们继承了 AbstractStringBuilder 类，而 AbstractStringBuilder 类中定义了一个 char[] value 数组，用于存储字符序列134。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="/zh/zh/post/computer-science/java/java/">
  <meta property="og:site_name" content="Penruins">
  <meta property="og:title" content="java">
  <meta property="og:description" content="String # StringBuffer 是怎么保证线程安全的？ # StringBuffer 是通过 同步机制 来保证线程安全的。具体来说，它的所有关键方法（如 append()、insert()、delete()、reverse() 等）都使用了 synchronized 关键字进行修饰，确保同一时间只有一个线程可以执行这些方法127。
1. 同步方法 # StringBuffer 的方法在设计时都加了 synchronized 关键字，例如：
public synchronized StringBuffer append(String str) { // 方法实现 } 这种机制确保了在多线程环境下，只有一个线程可以访问和修改 StringBuffer 的内容，避免了竞态条件（Race Condition）和数据不一致的问题12。
2. 锁机制 # StringBuffer 内部使用了一个锁对象（即 this 锁），当一个线程调用 StringBuffer 的同步方法时，会获取这个锁，其他线程必须等待锁释放后才能继续执行。这种锁机制保证了线程间的同步17。
3. 性能影响 # 虽然 StringBuffer 的同步机制确保了线程安全，但也带来了性能开销。因为在多线程环境下，每次只能有一个线程操作 StringBuffer，其他线程会被阻塞。因此，在单线程环境下，推荐使用性能更高的 StringBuilder，它没有同步机制158。
4. 适用场景 # 多线程环境：如果需要在多线程环境下对字符串进行操作，StringBuffer 是合适的选择，因为它确保了线程安全29。 单线程环境：在单线程环境下，建议使用 StringBuilder，因为它没有同步开销，性能更高18。 总结 # StringBuffer 通过 synchronized 关键字实现的同步机制，确保了多线程环境下的线程安全性。虽然这种机制带来了性能开销，但在需要线程安全的场景下，它是一个可靠的选择127。
StringBuffer 和 StringBuilder 字符串在底层是以什么数据结构保存的 # StringBuffer 和 StringBuilder 在底层都是使用 字符数组（char[]） 来保存字符串数据的。具体来说，它们继承了 AbstractStringBuilder 类，而 AbstractStringBuilder 类中定义了一个 char[] value 数组，用于存储字符序列134。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="zh">
    <meta property="article:modified_time" content="2025-03-02T20:00:30+08:00">
<title>java | Penruins</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="/zh/zh/post/computer-science/java/java/">
<link rel="stylesheet" href="/book.min.26e661cf8028ea69ebe162050990c3a07de74e5bfe9389e880f2d6a7e5fa587c.css" >
  <script defer src="/fuse.min.js"></script>
  <script defer src="/zh.search.min.4946cd39effd184e508172a63bb32fab0055e36ac787a6629588b74aa095d3bd.js" ></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/zh/"><span>Penruins</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>



  



  
    
  
    
  



<ul class="book-languages">
  <li>
    <input type="checkbox" id="languages" class="toggle" />
    <label for="languages" class="flex justify-between">
      <a role="button" class="flex align-center">
        <img src="/svg/translate.svg" class="book-icon" alt="Languages" />
        中文
      </a>
    </label>

    <ul>
      
      <li>
        <a href="/cn/">
          
        </a>
      </li>
      
      <li>
        <a href="/en/">
          English
        </a>
      </li>
      
    </ul>
  </li>
</ul>














  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Life</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/movies-log/" class="">观影记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/bilibili/" class="">bilibili</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/cycling/" class="">cycling</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/hiking/" class="">hiking</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/life-recommend/" class="">life recommand</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/learning-others-log/" class="">other learning</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/podcast/" class="">podcast</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/politics/" class="">politics</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/goal/" class="">goal</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/coffee/" class="">coffee</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Computer Science</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-855531983528655844a29f37632e7e30" class="toggle"  />
    <label for="section-855531983528655844a29f37632e7e30" class="flex justify-between">
      <a role="button" class="">Java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/java/" class="">java</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/mybatis/" class="">Mybatis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/jvm/" class="">jvm</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-recommend/" class="">推荐</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-learning-log/" class="">学习记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/database/" class="">database</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/echarts/" class="">echarts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/github/" class="">github</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/ios/" class="">ios</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/job/" class="">job</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/mac/" class="">mac</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/raspberrypi/" class="">raspberry pi</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/security/" class="">security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/vue/" class="">vue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/algorithm/" class="">Algorithm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/linux/" class="">linux</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Others</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/about-me/" class="">about me</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/english-learning/" class="">English Learning</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Books</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-70696d57febbe00561bcceac2d174d7c" class="toggle"  />
    <label for="section-70696d57febbe00561bcceac2d174d7c" class="flex justify-between">
      <a role="button" class="">Computer Science</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" class="">Java并发编程实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="">Python神经网络编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="">Redis设计与实现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/" class="">Spring Cloud微服务：入门、实战与进阶</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" class="">一本书讲透 ElasticSearch：原理、进阶与工程实践</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E7%AC%AC%E4%B8%89%E7%89%88/" class="">宏观经济学 第三版</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E8%8B%B1%E4%BC%9F%E8%BE%BE-%E9%BB%84%E4%BB%81%E5%8B%8B%E4%B9%8B%E8%8A%AF/" class="">英伟达-黄仁勋之芯</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>java</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#stringbuffer-是怎么保证线程安全的">StringBuffer 是怎么保证线程安全的？</a>
      <ul>
        <li><a href="#1-同步方法">1. <strong>同步方法</strong></a></li>
        <li><a href="#2-锁机制">2. <strong>锁机制</strong></a></li>
        <li><a href="#3-性能影响">3. <strong>性能影响</strong></a></li>
        <li><a href="#4-适用场景">4. <strong>适用场景</strong></a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#stringbuffer-和-stringbuilder-字符串在底层是以什么数据结构保存的">StringBuffer 和 StringBuilder 字符串在底层是以什么数据结构保存的</a>
      <ul>
        <li><a href="#1-底层数据结构">1. <strong>底层数据结构</strong></a></li>
        <li><a href="#2-初始容量">2. <strong>初始容量</strong></a></li>
        <li><a href="#3-扩容机制">3. <strong>扩容机制</strong></a></li>
        <li><a href="#4-示例代码">4. <strong>示例代码</strong></a></li>
        <li><a href="#5-总结">5. <strong>总结</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#响应式编程和虚拟线程都能提高程序的并发量它们的差异是什么">响应式编程和虚拟线程都能提高程序的并发量，它们的差异是什么</a>
      <ul>
        <li><a href="#1-实现原理">1. <strong>实现原理</strong></a></li>
        <li><a href="#2-编程模型">2. <strong>编程模型</strong></a></li>
        <li><a href="#3-适用场景">3. <strong>适用场景</strong></a></li>
        <li><a href="#4-开发体验">4. <strong>开发体验</strong></a></li>
        <li><a href="#5-性能优化">5. <strong>性能优化</strong></a></li>
        <li><a href="#总结-1">总结</a></li>
      </ul>
    </li>
    <li><a href="#虚拟线程在jvm中的内存模型是怎样的">虚拟线程在jvm中的内存模型是怎样的</a>
      <ul>
        <li><a href="#1-虚拟线程的内存结构">1. <strong>虚拟线程的内存结构</strong></a></li>
        <li><a href="#2-虚拟线程与jvm内存模型的关系">2. <strong>虚拟线程与JVM内存模型的关系</strong></a></li>
        <li><a href="#3-虚拟线程的调度与内存使用">3. <strong>虚拟线程的调度与内存使用</strong></a></li>
        <li><a href="#4-虚拟线程与垃圾回收">4. <strong>虚拟线程与垃圾回收</strong></a></li>
        <li><a href="#5-虚拟线程的适用场景">5. <strong>虚拟线程的适用场景</strong></a></li>
        <li><a href="#总结-2">总结</a></li>
      </ul>
    </li>
    <li><a href="#虚拟线程会增加jvm的性能消耗吗">虚拟线程会增加jvm的性能消耗吗</a>
      <ul>
        <li><a href="#1-虚拟线程的资源消耗">1. <strong>虚拟线程的资源消耗</strong></a></li>
        <li><a href="#2-性能优势">2. <strong>性能优势</strong></a></li>
        <li><a href="#3-cpu密集型任务的限制">3. <strong>CPU密集型任务的限制</strong></a></li>
        <li><a href="#4-jvm的性能消耗">4. <strong>JVM的性能消耗</strong></a></li>
        <li><a href="#5-适用场景">5. <strong>适用场景</strong></a></li>
        <li><a href="#总结-3">总结</a></li>
      </ul>
    </li>
    <li><a href="#在-springboot-项目中虚拟线程可以怎么使用">在 springboot 项目中虚拟线程可以怎么使用</a>
      <ul>
        <li><a href="#1-启用虚拟线程处理-http-请求">1. <strong>启用虚拟线程处理 HTTP 请求</strong></a>
          <ul>
            <li><a href="#配置代码">配置代码：</a></li>
            <li><a href="#说明">说明：</a></li>
          </ul>
        </li>
        <li><a href="#2-使用虚拟线程执行异步任务">2. <strong>使用虚拟线程执行异步任务</strong></a>
          <ul>
            <li><a href="#配置代码-1">配置代码：</a></li>
            <li><a href="#使用示例">使用示例：</a></li>
            <li><a href="#说明-1">说明：</a></li>
          </ul>
        </li>
        <li><a href="#3-使用虚拟线程执行定时任务">3. <strong>使用虚拟线程执行定时任务</strong></a>
          <ul>
            <li><a href="#配置代码-2">配置代码：</a></li>
            <li><a href="#使用示例-1">使用示例：</a></li>
            <li><a href="#说明-2">说明：</a></li>
          </ul>
        </li>
        <li><a href="#4-使用虚拟线程执行自定义任务">4. <strong>使用虚拟线程执行自定义任务</strong></a>
          <ul>
            <li><a href="#示例代码">示例代码：</a></li>
            <li><a href="#说明-3">说明：</a></li>
          </ul>
        </li>
        <li><a href="#5-虚拟线程的最佳实践">5. <strong>虚拟线程的最佳实践</strong></a></li>
        <li><a href="#6-环境要求">6. <strong>环境要求</strong></a></li>
      </ul>
    </li>
    <li><a href="#虚拟线程的mn模型具体是如何工作的">虚拟线程的M:N模型具体是如何工作的？</a>
      <ul>
        <li><a href="#1-基本概念">1. <strong>基本概念</strong></a></li>
        <li><a href="#2-mn-模型的核心思想">2. <strong>M:N 模型的核心思想</strong></a></li>
        <li><a href="#3-具体工作流程">3. <strong>具体工作流程</strong></a></li>
        <li><a href="#4-mn-模型的优势">4. <strong>M:N 模型的优势</strong></a></li>
        <li><a href="#5-mn-模型的实现细节">5. <strong>M:N 模型的实现细节</strong></a></li>
        <li><a href="#6-示例">6. <strong>示例</strong></a></li>
        <li><a href="#7-与传统线程模型的对比">7. <strong>与传统线程模型的对比</strong></a></li>
        <li><a href="#总结-4">总结</a></li>
      </ul>
    </li>
    <li><a href="#java虚拟线程和传统线程有什么区别">Java虚拟线程和传统线程有什么区别</a>
      <ul>
        <li><a href="#1-实现方式">1. <strong>实现方式</strong></a></li>
        <li><a href="#2-线程模型">2. <strong>线程模型</strong></a></li>
        <li><a href="#3-性能">3. <strong>性能</strong></a></li>
        <li><a href="#4-适用场景-1">4. <strong>适用场景</strong></a></li>
        <li><a href="#5-编程模型">5. <strong>编程模型</strong></a></li>
        <li><a href="#6-资源占用">6. <strong>资源占用</strong></a></li>
        <li><a href="#7-兼容性">7. <strong>兼容性</strong></a></li>
        <li><a href="#8-示例对比">8. <strong>示例对比</strong></a></li>
        <li><a href="#总结-5">总结</a></li>
      </ul>
    </li>
    <li><a href="#可以生成一个java使用虚拟线程的例子吗">可以生成一个java使用虚拟线程的例子吗</a>
      <ul>
        <li><a href="#示例代码-1">示例代码</a></li>
        <li><a href="#代码说明">代码说明</a></li>
        <li><a href="#运行说明">运行说明</a></li>
        <li><a href="#运行命令">运行命令</a></li>
        <li><a href="#注意事项">注意事项</a></li>
      </ul>
    </li>
    <li><a href="#学习资料">学习资料</a></li>
    <li><a href="#basic">basic</a>
      <ul>
        <li><a href="#java-array-转-list">java array 转 list</a>
          <ul>
            <li><a href="#创建一个固定大小的列表">创建一个固定大小的列表</a></li>
            <li><a href="#创建一个可变大小的列表">创建一个可变大小的列表</a></li>
          </ul>
        </li>
        <li><a href="#java-怎么用二进制打印int">java， 怎么用二进制打印int</a>
          <ul>
            <li><a href="#使用-integertobinarystring">使用 <code>Integer.toBinaryString()</code></a></li>
            <li><a href="#打印包含前导零的完整32位">打印包含前导零的完整32位</a></li>
            <li><a href="#使用位运算手动构建二进制字符串">使用位运算手动构建二进制字符串</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#concurrent">concurrent</a></li>
    <li><a href="#每一个java的版本的主要更新">每一个java的版本的主要更新</a>
      <ul>
        <li><a href="#java-10-1996">Java 1.0 (1996)</a></li>
        <li><a href="#java-11-1997">Java 1.1 (1997)</a></li>
        <li><a href="#java-12-1998">Java 1.2 (1998)</a></li>
        <li><a href="#java-13-2000">Java 1.3 (2000)</a></li>
        <li><a href="#java-14-2002">Java 1.4 (2002)</a></li>
        <li><a href="#java-5-2004">Java 5 (2004)</a></li>
        <li><a href="#java-6-2006">Java 6 (2006)</a></li>
        <li><a href="#java-7-2011">Java 7 (2011)</a></li>
        <li><a href="#java-8-2014">Java 8 (2014)</a></li>
        <li><a href="#java-9-2017">Java 9 (2017)</a></li>
        <li><a href="#java-10-2018">Java 10 (2018)</a></li>
        <li><a href="#java-11-2018">Java 11 (2018)</a></li>
        <li><a href="#java-12-2019">Java 12 (2019)</a></li>
        <li><a href="#java-13-2019">Java 13 (2019)</a></li>
        <li><a href="#java-14-2020">Java 14 (2020)</a></li>
        <li><a href="#java-15-2020">Java 15 (2020)</a></li>
        <li><a href="#java-16-2021">Java 16 (2021)</a></li>
        <li><a href="#java-17-2021">Java 17 (2021)</a></li>
        <li><a href="#java-18-2022">Java 18 (2022)</a></li>
        <li><a href="#java-19-2022">Java 19 (2022)</a></li>
        <li><a href="#java-20-2023">Java 20 (2023)</a></li>
        <li><a href="#java-21-2023">Java 21 (2023)</a></li>
        <li><a href="#总结-6">总结</a></li>
      </ul>
    </li>
    <li><a href="#面试java的时候可能会问到有没有了解最新的技术这个我该怎么准备提前了解哪些知识">面试java的时候可能会问到有没有了解最新的技术，这个我该怎么准备，提前了解哪些知识</a>
      <ul>
        <li><a href="#1-java最新版本特性">1. <strong>Java最新版本特性</strong></a></li>
        <li><a href="#2-微服务与云原生技术">2. <strong>微服务与云原生技术</strong></a></li>
        <li><a href="#3-数据库与缓存技术">3. <strong>数据库与缓存技术</strong></a></li>
        <li><a href="#4-性能优化与jvm调优">4. <strong>性能优化与JVM调优</strong></a></li>
        <li><a href="#5-前沿技术与趋势">5. <strong>前沿技术与趋势</strong></a></li>
        <li><a href="#6-实践与项目结合">6. <strong>实践与项目结合</strong></a></li>
        <li><a href="#7-面试中的表达技巧">7. <strong>面试中的表达技巧</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#为什么hashmap要使用红黑树而不使用其他的树结构">为什么HashMap要使用红黑树而不使用其他的树结构？</a>
      <ul>
        <li><a href="#一红黑树的特性优势">一、<strong>红黑树的特性优势</strong></a></li>
        <li><a href="#二与其他树结构的对比">二、<strong>与其他树结构的对比</strong></a>
          <ul>
            <li><a href="#1-与-avl-树的对比">1. <strong>与 AVL 树的对比</strong></a></li>
            <li><a href="#2-与普通二叉搜索树的对比">2. <strong>与普通二叉搜索树的对比</strong></a></li>
            <li><a href="#3-与-b-树b-树的对比">3. <strong>与 B 树/B+ 树的对比</strong></a></li>
          </ul>
        </li>
        <li><a href="#三hashmap-的特定需求">三、<strong>HashMap 的特定需求</strong></a></li>
        <li><a href="#四总结">四、<strong>总结</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#我有这样一个开发场景服务端需要和多个客户端进行tcp连接服务端会发送指令给客户端客户端会返回指令执行结果客户端会定时返回心跳报文上报状态客户端会不定时上报事件报文我该怎么实现上述功能">我有这样一个开发场景，服务端需要和多个客户端进行tcp连接，服务端会发送指令给客户端，客户端会返回指令执行结果；客户端会定时返回心跳报文上报状态；客户端会不定时上报事件报文。我该怎么实现上述功能？</a>
      <ul>
        <li><a href="#1-服务端设计">1. 服务端设计</a>
          <ul>
            <li><a href="#11-建立tcp连接">1.1 建立TCP连接</a></li>
            <li><a href="#12-指令发送">1.2 指令发送</a></li>
            <li><a href="#13-处理客户端返回">1.3 处理客户端返回</a></li>
            <li><a href="#14-心跳处理">1.4 心跳处理</a></li>
            <li><a href="#15-事件处理">1.5 事件处理</a></li>
          </ul>
        </li>
        <li><a href="#2-客户端设计">2. 客户端设计</a>
          <ul>
            <li><a href="#21-连接服务端">2.1 连接服务端</a></li>
            <li><a href="#22-指令执行">2.2 指令执行</a></li>
            <li><a href="#23-心跳发送">2.3 心跳发送</a></li>
            <li><a href="#24-事件上报">2.4 事件上报</a></li>
          </ul>
        </li>
        <li><a href="#3-协议设计">3. 协议设计</a></li>
        <li><a href="#4-实现示例">4. 实现示例</a>
          <ul>
            <li><a href="#服务端示例python伪代码">服务端示例（Python伪代码）</a></li>
            <li><a href="#客户端示例python伪代码">客户端示例（Python伪代码）</a></li>
          </ul>
        </li>
        <li><a href="#5-注意事项">5. 注意事项</a></li>
      </ul>
    </li>
    <li><a href="#如果我使用io多路复用来实现给我一个java版本代码示例">如果我使用IO多路复用来实现，给我一个java版本代码示例</a>
      <ul>
        <li><a href="#服务端代码示例">服务端代码示例</a></li>
        <li><a href="#客户端代码示例">客户端代码示例</a></li>
        <li><a href="#代码说明-1">代码说明</a></li>
        <li><a href="#运行方式">运行方式</a></li>
        <li><a href="#扩展建议">扩展建议</a></li>
      </ul>
    </li>
    <li><a href="#我有一个服务端需要连接多个服务端进行tcp连接给我一个java的代码示例">我有一个服务端，需要连接多个服务端进行tcp连接，给我一个java的代码示例</a>
      <ul>
        <li><a href="#代码示例">代码示例</a></li>
        <li><a href="#代码说明-2">代码说明</a></li>
        <li><a href="#运行方式-1">运行方式</a></li>
        <li><a href="#参考">参考</a></li>
        <li><a href="#扩展建议-1">扩展建议</a></li>
      </ul>
    </li>
    <li><a href="#我在tcp连接的过程中可能会新增连接修改连接信息ip或端口号或者删除连接这个该怎么实现">我在tcp连接的过程中，可能会新增连接，修改连接信息（ip或端口号）或者删除连接，这个该怎么实现</a>
      <ul>
        <li><a href="#设计思路">设计思路</a></li>
        <li><a href="#代码实现">代码实现</a></li>
        <li><a href="#代码说明-3">代码说明</a></li>
        <li><a href="#运行方式-2">运行方式</a></li>
        <li><a href="#扩展建议-2">扩展建议</a></li>
      </ul>
    </li>
    <li><a href="#使用-socketchannel-的-close-方法是否会导致tcp连接还在传输数据的时候意外断开的情况">使用 socketChannel 的 close 方法，是否会导致tcp连接还在传输数据的时候意外断开的情况</a>
      <ul>
        <li><a href="#1-socketchannelclose">1. <strong><code>SocketChannel.close</code> 的行为</strong></a></li>
        <li><a href="#2-数据传输中的关闭">2. <strong>数据传输中的关闭</strong></a></li>
        <li><a href="#3-异常情况">3. <strong>异常情况</strong></a></li>
        <li><a href="#4-最佳实践">4. <strong>最佳实践</strong></a></li>
        <li><a href="#总结-7">总结</a></li>
      </ul>
    </li>
    <li><a href="#我还需要实现对特定连接发送命令报文">我还需要实现对特定连接发送命令报文</a>
      <ul>
        <li><a href="#代码实现-1">代码实现</a></li>
        <li><a href="#代码说明-4">代码说明</a></li>
        <li><a href="#运行方式-3">运行方式</a></li>
        <li><a href="#扩展建议-3">扩展建议</a></li>
      </ul>
    </li>
    <li><a href="#发送完命令之后我需要等待收到一个回复的报文命令执行才算完成">发送完命令之后我需要等待收到一个回复的报文，命令执行才算完成</a>
      <ul>
        <li><a href="#设计思路-1">设计思路</a></li>
        <li><a href="#代码实现-2">代码实现</a></li>
        <li><a href="#代码说明-5">代码说明</a></li>
        <li><a href="#运行方式-4">运行方式</a></li>
        <li><a href="#扩展建议-4">扩展建议</a></li>
      </ul>
    </li>
    <li><a href="#如果连接的tcp数量很多使用一个selector接收有点慢该怎么优化">如果连接的tcp数量很多，使用一个selector接收有点慢，该怎么优化</a>
      <ul>
        <li><a href="#1-优化思路">1. <strong>优化思路</strong></a>
          <ul>
            <li><a href="#11-使用多个-selector">1.1 <strong>使用多个 Selector</strong></a></li>
            <li><a href="#12-分离连接处理和数据处理">1.2 <strong>分离连接处理和数据处理</strong></a></li>
            <li><a href="#13-调整缓冲区大小">1.3 <strong>调整缓冲区大小</strong></a></li>
            <li><a href="#14-使用非阻塞-io">1.4 <strong>使用非阻塞 I/O</strong></a></li>
            <li><a href="#15-减少事件处理的耗时">1.5 <strong>减少事件处理的耗时</strong></a></li>
          </ul>
        </li>
        <li><a href="#2-实现示例">2. <strong>实现示例</strong></a></li>
        <li><a href="#3-优化建议">3. <strong>优化建议</strong></a></li>
        <li><a href="#4-参考外部资料">4. <strong>参考外部资料</strong></a></li>
      </ul>
    </li>
    <li><a href="#如果我需要维护100个tcp连接使用一个selector够吗">如果我需要维护100个tcp连接，使用一个selector够吗</a>
      <ul>
        <li><a href="#1-单个">1. <strong>单个 <code>Selector</code> 的局限性</strong></a></li>
        <li><a href="#2-优化方案">2. <strong>优化方案</strong></a>
          <ul>
            <li><a href="#21-使用多个">2.1 <strong>使用多个 <code>Selector</code></strong></a></li>
            <li><a href="#22-分离连接处理和数据处理">2.2 <strong>分离连接处理和数据处理</strong></a></li>
            <li><a href="#23-调整缓冲区大小">2.3 <strong>调整缓冲区大小</strong></a></li>
            <li><a href="#24-使用非阻塞-io">2.4 <strong>使用非阻塞 I/O</strong></a></li>
            <li><a href="#25-减少事件处理的耗时">2.5 <strong>减少事件处理的耗时</strong></a></li>
          </ul>
        </li>
        <li><a href="#3-参考外部资料">3. <strong>参考外部资料</strong></a></li>
        <li><a href="#4-示例代码-1">4. <strong>示例代码</strong></a></li>
        <li><a href="#5-总结-1">5. <strong>总结</strong></a></li>
      </ul>
    </li>
    <li><a href="#在java中一个tcp连接使用一个socket连接多个tcp这样占用很多内存吗">在java中，一个tcp连接使用一个socket，连接多个tcp，这样占用很多内存吗</a></li>
    <li><a href="#在java中创建线程的内存开销">在java中创建线程的内存开销</a>
      <ul>
        <li><a href="#1-线程栈的内存开销">1. <strong>线程栈的内存开销</strong></a></li>
        <li><a href="#2-其他内存开销">2. <strong>其他内存开销</strong></a></li>
        <li><a href="#3-线程创建和销毁的开销">3. <strong>线程创建和销毁的开销</strong></a></li>
        <li><a href="#4-线程池的优化">4. <strong>线程池的优化</strong></a></li>
        <li><a href="#5-如何减少线程内存开销">5. <strong>如何减少线程内存开销</strong></a></li>
        <li><a href="#总结-8">总结</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="string">
  String
  <a class="anchor" href="#string">#</a>
</h1>
<h2 id="stringbuffer-是怎么保证线程安全的">
  StringBuffer 是怎么保证线程安全的？
  <a class="anchor" href="#stringbuffer-%e6%98%af%e6%80%8e%e4%b9%88%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84">#</a>
</h2>
<p><code>StringBuffer</code> 是通过 <strong>同步机制</strong> 来保证线程安全的。具体来说，它的所有关键方法（如 <code>append()</code>、<code>insert()</code>、<code>delete()</code>、<code>reverse()</code> 等）都使用了 <code>synchronized</code> 关键字进行修饰，确保同一时间只有一个线程可以执行这些方法<a href="@ref">1</a><a href="@ref">2</a><a href="@ref">7</a>。</p>
<h3 id="1-同步方法">
  1. <strong>同步方法</strong>
  <a class="anchor" href="#1-%e5%90%8c%e6%ad%a5%e6%96%b9%e6%b3%95">#</a>
</h3>
<p><code>StringBuffer</code> 的方法在设计时都加了 <code>synchronized</code> 关键字，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> StringBuffer <span style="color:#a6e22e">append</span>(String str) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 方法实现</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这种机制确保了在多线程环境下，只有一个线程可以访问和修改 <code>StringBuffer</code> 的内容，避免了竞态条件（Race Condition）和数据不一致的问题<a href="@ref">1</a><a href="@ref">2</a>。</p>
<h3 id="2-锁机制">
  2. <strong>锁机制</strong>
  <a class="anchor" href="#2-%e9%94%81%e6%9c%ba%e5%88%b6">#</a>
</h3>
<p><code>StringBuffer</code> 内部使用了一个锁对象（即 <code>this</code> 锁），当一个线程调用 <code>StringBuffer</code> 的同步方法时，会获取这个锁，其他线程必须等待锁释放后才能继续执行。这种锁机制保证了线程间的同步<a href="@ref">1</a><a href="@ref">7</a>。</p>
<h3 id="3-性能影响">
  3. <strong>性能影响</strong>
  <a class="anchor" href="#3-%e6%80%a7%e8%83%bd%e5%bd%b1%e5%93%8d">#</a>
</h3>
<p>虽然 <code>StringBuffer</code> 的同步机制确保了线程安全，但也带来了性能开销。因为在多线程环境下，每次只能有一个线程操作 <code>StringBuffer</code>，其他线程会被阻塞。因此，在单线程环境下，推荐使用性能更高的 <code>StringBuilder</code>，它没有同步机制<a href="@ref">1</a><a href="@ref">5</a><a href="@ref">8</a>。</p>
<h3 id="4-适用场景">
  4. <strong>适用场景</strong>
  <a class="anchor" href="#4-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h3>
<ul>
<li><strong>多线程环境</strong>：如果需要在多线程环境下对字符串进行操作，<code>StringBuffer</code> 是合适的选择，因为它确保了线程安全<a href="@ref">2</a><a href="@ref">9</a>。</li>
<li><strong>单线程环境</strong>：在单线程环境下，建议使用 <code>StringBuilder</code>，因为它没有同步开销，性能更高<a href="@ref">1</a><a href="@ref">8</a>。</li>
</ul>
<h3 id="总结">
  总结
  <a class="anchor" href="#%e6%80%bb%e7%bb%93">#</a>
</h3>
<p><code>StringBuffer</code> 通过 <code>synchronized</code> 关键字实现的同步机制，确保了多线程环境下的线程安全性。虽然这种机制带来了性能开销，但在需要线程安全的场景下，它是一个可靠的选择<a href="@ref">1</a><a href="@ref">2</a><a href="@ref">7</a>。</p>
<h2 id="stringbuffer-和-stringbuilder-字符串在底层是以什么数据结构保存的">
  StringBuffer 和 StringBuilder 字符串在底层是以什么数据结构保存的
  <a class="anchor" href="#stringbuffer-%e5%92%8c-stringbuilder-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%9c%a8%e5%ba%95%e5%b1%82%e6%98%af%e4%bb%a5%e4%bb%80%e4%b9%88%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%bf%9d%e5%ad%98%e7%9a%84">#</a>
</h2>
<p><code>StringBuffer</code> 和 <code>StringBuilder</code> 在底层都是使用 <strong>字符数组（<code>char[]</code>）</strong> 来保存字符串数据的。具体来说，它们继承了 <code>AbstractStringBuilder</code> 类，而 <code>AbstractStringBuilder</code> 类中定义了一个 <code>char[] value</code> 数组，用于存储字符序列<a href="@ref">1</a><a href="@ref">3</a><a href="@ref">4</a>。</p>
<h3 id="1-底层数据结构">
  1. <strong>底层数据结构</strong>
  <a class="anchor" href="#1-%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h3>
<ul>
<li><code>StringBuffer</code> 和 <code>StringBuilder</code> 的底层数据结构是一个动态的 <code>char[]</code> 数组，数组名为 <code>value</code>。</li>
<li><code>value</code> 数组的长度会根据字符串的长度动态扩容，以适应字符串的修改操作<a href="@ref">3</a><a href="@ref">4</a>。</li>
</ul>
<h3 id="2-初始容量">
  2. <strong>初始容量</strong>
  <a class="anchor" href="#2-%e5%88%9d%e5%a7%8b%e5%ae%b9%e9%87%8f">#</a>
</h3>
<ul>
<li>如果使用无参构造函数创建 <code>StringBuffer</code> 或 <code>StringBuilder</code>，默认的初始容量为 <strong>16</strong>。</li>
<li>如果使用带参构造函数（如 <code>new StringBuilder(&quot;abc&quot;)</code>），初始容量为 <strong>字符串长度 + 16</strong><a href="@ref">3</a><a href="@ref">4</a>。</li>
</ul>
<h3 id="3-扩容机制">
  3. <strong>扩容机制</strong>
  <a class="anchor" href="#3-%e6%89%a9%e5%ae%b9%e6%9c%ba%e5%88%b6">#</a>
</h3>
<ul>
<li>当 <code>value</code> 数组的容量不足以容纳新的字符时，会触发扩容操作。</li>
<li>扩容的规则是：<strong>新容量 = 原容量 * 2 + 2</strong>。如果仍然不足，则直接扩容到所需的最小容量<a href="@ref">3</a><a href="@ref">4</a>。</li>
</ul>
<h3 id="4-示例代码">
  4. <strong>示例代码</strong>
  <a class="anchor" href="#4-%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81">#</a>
</h3>
<p>以下是 <code>AbstractStringBuilder</code> 类中定义 <code>value</code> 数组的部分源码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractStringBuilder</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> value; <span style="color:#75715e">// 用于存储字符序列的数组</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> count;    <span style="color:#75715e">// 当前字符数</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="5-总结">
  5. <strong>总结</strong>
  <a class="anchor" href="#5-%e6%80%bb%e7%bb%93">#</a>
</h3>
<p><code>StringBuffer</code> 和 <code>StringBuilder</code> 的底层数据结构是 <code>char[]</code> 数组，通过动态扩容机制支持字符串的修改操作。两者的主要区别在于线程安全性：</p>
<ul>
<li><code>StringBuffer</code> 是线程安全的，所有方法都加了 <code>synchronized</code> 修饰。</li>
<li><code>StringBuilder</code> 是线程不安全的，但性能更高<a href="@ref">5</a><a href="@ref">6</a><a href="@ref">7</a>。</li>
</ul>
<p>如果需要在多线程环境下操作字符串，建议使用 <code>StringBuffer</code>；在单线程环境下，建议使用 <code>StringBuilder</code> 以获得更好的性能<a href="@ref">5</a><a href="@ref">6</a><a href="@ref">7</a>。</p>
<h1 id="java">
  java
  <a class="anchor" href="#java">#</a>
</h1>
<h2 id="响应式编程和虚拟线程都能提高程序的并发量它们的差异是什么">
  响应式编程和虚拟线程都能提高程序的并发量，它们的差异是什么
  <a class="anchor" href="#%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%92%8c%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e9%83%bd%e8%83%bd%e6%8f%90%e9%ab%98%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%b9%b6%e5%8f%91%e9%87%8f%e5%ae%83%e4%bb%ac%e7%9a%84%e5%b7%ae%e5%bc%82%e6%98%af%e4%bb%80%e4%b9%88">#</a>
</h2>
<p>响应式编程和虚拟线程虽然都能提高程序的并发量，但它们的实现方式、适用场景以及开发体验存在显著差异。以下是两者的主要区别：</p>
<hr>
<h3 id="1-实现原理">
  1. <strong>实现原理</strong>
  <a class="anchor" href="#1-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">#</a>
</h3>
<ul>
<li><strong>响应式编程</strong>：<br>
响应式编程基于异步数据流和事件驱动模型，使用发布/订阅模式（如 <code>Flux</code> 和 <code>Mono</code>）来处理异步任务。它通过非阻塞 I/O 和回调机制，确保线程在等待 I/O 操作时不会阻塞，而是继续处理其他任务。响应式编程的核心是“<strong>非阻塞</strong>”和“<strong>事件驱动</strong>”<a href="@ref">1</a><a href="@ref">2</a>。</li>
<li><strong>虚拟线程</strong>：<br>
虚拟线程是 JVM 管理的轻量级线程，底层仍然依赖于操作系统的平台线程（内核线程），但虚拟线程的创建和切换开销远低于传统线程。当虚拟线程遇到阻塞操作时，JVM 会将其挂起并切换到其他虚拟线程，从而避免线程资源的浪费<a href="@ref">3</a><a href="@ref">7</a>。</li>
</ul>
<hr>
<h3 id="2-编程模型">
  2. <strong>编程模型</strong>
  <a class="anchor" href="#2-%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b">#</a>
</h3>
<ul>
<li><strong>响应式编程</strong>：<br>
响应式编程采用声明式编程范式，代码通常由一系列操作符（如 <code>map</code>、<code>flatMap</code>）组成，形成数据流的转换管道。这种模型需要开发者熟悉函数式编程和响应式 API，代码可读性较差，调试难度较高<a href="@ref">1</a><a href="@ref">4</a>。</li>
<li><strong>虚拟线程</strong>：<br>
虚拟线程保留了传统的阻塞式编程模型，开发者可以像使用平台线程一样编写代码，无需改变编程习惯。虚拟线程的引入使得高并发编程更加简单和直观<a href="@ref">3</a><a href="@ref">7</a>。</li>
</ul>
<hr>
<h3 id="3-适用场景">
  3. <strong>适用场景</strong>
  <a class="anchor" href="#3-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h3>
<ul>
<li><strong>响应式编程</strong>：<br>
适用于 I/O 密集型任务，如网络请求、数据库操作等。它通过非阻塞 I/O 和事件驱动机制，最大化线程的利用率。但在 CPU 密集型任务中，响应式编程的性能提升有限，甚至可能适得其反<a href="@ref">2</a><a href="@ref">4</a>。</li>
<li><strong>虚拟线程</strong>：<br>
同样适用于 I/O 密集型任务，能够显著提高并发性能。虚拟线程的优势在于其轻量化和低开销，适合处理大量并发请求。但对于 CPU 密集型任务，虚拟线程的性能提升有限，因为虚拟线程的调度仍然依赖于平台线程<a href="@ref">3</a><a href="@ref">7</a>。</li>
</ul>
<hr>
<h3 id="4-开发体验">
  4. <strong>开发体验</strong>
  <a class="anchor" href="#4-%e5%bc%80%e5%8f%91%e4%bd%93%e9%aa%8c">#</a>
</h3>
<ul>
<li><strong>响应式编程</strong>：<br>
响应式编程的代码通常难以理解和调试，尤其是回调嵌套和复杂的操作符链。开发者需要具备函数式编程和响应式编程的知识，学习成本较高。</li>
<li><strong>虚拟线程</strong>：<br>
虚拟线程的使用与传统的线程编程类似，开发者无需学习新的编程范式，代码更直观且易于维护。虚拟线程的引入降低了高并发编程的门槛。</li>
</ul>
<hr>
<h3 id="5-性能优化">
  5. <strong>性能优化</strong>
  <a class="anchor" href="#5-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96">#</a>
</h3>
<ul>
<li><strong>响应式编程</strong>：<br>
通过减少线程阻塞和上下文切换，响应式编程能够提高 CPU 和内存的利用率。但它依赖于开发者正确使用非阻塞 API 和操作符。</li>
<li><strong>虚拟线程</strong>：<br>
虚拟线程通过轻量化的线程管理和高效的调度机制，减少了线程创建和上下文切换的开销。虚拟线程的性能优化由 JVM 自动完成，开发者无需额外干预。</li>
</ul>
<hr>
<h3 id="总结-1">
  总结
  <a class="anchor" href="#%e6%80%bb%e7%bb%93-1">#</a>
</h3>
<ul>
<li><strong>响应式编程</strong>和<strong>虚拟线程</strong>的目标都是提高程序的并发性能，但它们的实现方式和适用场景不同。</li>
<li>响应式编程适合需要高度优化的 I/O 密集型任务，但代码复杂且学习成本高。</li>
<li>虚拟线程提供了一种更简单、直观的方式来实现高并发，特别适合需要快速开发和维护的场景</li>
</ul>
<p>如果需要更深入的技术细节，可以参考相关文档或实践案例。</p>
<h2 id="虚拟线程在jvm中的内存模型是怎样的">
  虚拟线程在jvm中的内存模型是怎样的
  <a class="anchor" href="#%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e5%9c%a8jvm%e4%b8%ad%e7%9a%84%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84">#</a>
</h2>
<p>虚拟线程（Virtual Threads）是Java 19引入并在Java 21中正式发布的一项新特性，旨在提高I/O密集型任务的性能。虚拟线程的内存模型与传统平台线程（Platform Threads）有所不同，主要体现在以下几个方面：</p>
<h3 id="1-虚拟线程的内存结构">
  1. <strong>虚拟线程的内存结构</strong>
  <a class="anchor" href="#1-%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84">#</a>
</h3>
<p>虚拟线程由JVM管理，而不是操作系统，因此它们的内存占用远小于平台线程。每个虚拟线程通常只占用几KB的内存，而平台线程则需要1MB左右的内存<a href="@ref">4</a>。虚拟线程的轻量化设计使得JVM能够轻松支持数百万个虚拟线程，而不会显著增加内存负担。</p>
<h3 id="2-虚拟线程与jvm内存模型的关系">
  2. <strong>虚拟线程与JVM内存模型的关系</strong>
  <a class="anchor" href="#2-%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e4%b8%8ejvm%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%85%b3%e7%b3%bb">#</a>
</h3>
<p>虚拟线程仍然依赖于JVM的内存模型，包括程序计数器、虚拟机栈、本地方法栈、堆和方法区等<a href="@ref">1</a><a href="@ref">2</a>。具体来说：</p>
<ul>
<li><strong>程序计数器</strong>：每个虚拟线程都有自己的程序计数器，用于记录当前执行的字节码指令位置。</li>
<li><strong>虚拟机栈</strong>：虚拟线程的栈帧存储在JVM的栈内存中，但由于虚拟线程的轻量化设计，栈帧的创建和销毁开销较小。</li>
<li><strong>堆</strong>：虚拟线程创建的对象实例仍然存储在堆中，与平台线程共享堆内存<a href="@ref">2</a><a href="@ref">6</a>。</li>
</ul>
<h3 id="3-虚拟线程的调度与内存使用">
  3. <strong>虚拟线程的调度与内存使用</strong>
  <a class="anchor" href="#3-%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e7%9a%84%e8%b0%83%e5%ba%a6%e4%b8%8e%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8">#</a>
</h3>
<p>虚拟线程的调度由JVM负责，而不是操作系统。当虚拟线程遇到I/O阻塞时，JVM会将其挂起并切换到其他虚拟线程，从而避免CPU资源的浪费。这种机制减少了线程上下文切换的开销，并提高了内存的利用率<a href="@ref">4</a><a href="@ref">5</a>。</p>
<h3 id="4-虚拟线程与垃圾回收">
  4. <strong>虚拟线程与垃圾回收</strong>
  <a class="anchor" href="#4-%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e4%b8%8e%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6">#</a>
</h3>
<p>虚拟线程创建的对象实例仍然受到JVM垃圾回收机制的管理。虚拟线程的轻量化设计不会增加垃圾回收的负担，反而通过减少线程阻塞和上下文切换，提高了垃圾回收的效率<a href="@ref">5</a><a href="@ref">6</a>。</p>
<h3 id="5-虚拟线程的适用场景">
  5. <strong>虚拟线程的适用场景</strong>
  <a class="anchor" href="#5-%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e7%9a%84%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h3>
<p>虚拟线程特别适用于高并发、I/O密集型任务，例如网络请求、文件读写等。在这些场景下，虚拟线程可以显著减少线程阻塞带来的性能损失，从而提高整体吞吐量<a href="@ref">4</a><a href="@ref">5</a>。</p>
<h3 id="总结-2">
  总结
  <a class="anchor" href="#%e6%80%bb%e7%bb%93-2">#</a>
</h3>
<p>虚拟线程在JVM中的内存模型与传统平台线程类似，但由于其轻量化设计和由JVM管理的特性，虚拟线程的内存占用和调度开销显著降低。虚拟线程的内存模型仍然依赖于JVM的程序计数器、虚拟机栈、堆等结构，但其高效的调度机制和轻量化的内存占用使其在处理高并发任务时表现出色<a href="@ref">1</a><a href="@ref">2</a><a href="@ref">4</a>。</p>
<h2 id="虚拟线程会增加jvm的性能消耗吗">
  虚拟线程会增加jvm的性能消耗吗
  <a class="anchor" href="#%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e4%bc%9a%e5%a2%9e%e5%8a%a0jvm%e7%9a%84%e6%80%a7%e8%83%bd%e6%b6%88%e8%80%97%e5%90%97">#</a>
</h2>
<p>虚拟线程在JVM中的性能消耗相对较低，尤其是在处理I/O密集型任务时，它们通过提高CPU利用率来优化性能。以下是具体分析：</p>
<h3 id="1-虚拟线程的资源消耗">
  1. <strong>虚拟线程的资源消耗</strong>
  <a class="anchor" href="#1-%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e7%9a%84%e8%b5%84%e6%ba%90%e6%b6%88%e8%80%97">#</a>
</h3>
<p>虚拟线程由JVM管理，而不是操作系统，因此它们的创建和切换开销远低于传统的平台线程。每个虚拟线程仅占用几KB的内存，而平台线程通常需要1MB左右的内存<a href="@ref">5</a>。这种轻量化设计使得JVM能够轻松支持数百万个虚拟线程，而不会显著增加内存负担<a href="@ref">6</a>。</p>
<h3 id="2-性能优势">
  2. <strong>性能优势</strong>
  <a class="anchor" href="#2-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8a%bf">#</a>
</h3>
<p>虚拟线程的主要优势在于处理I/O密集型任务时的高效性。当虚拟线程遇到I/O阻塞时，JVM会将其挂起并切换到其他虚拟线程，从而避免CPU资源的浪费。这种机制显著提高了CPU的利用率，尤其是在高并发场景下<a href="@ref">1</a><a href="@ref">2</a>。</p>
<h3 id="3-cpu密集型任务的限制">
  3. <strong>CPU密集型任务的限制</strong>
  <a class="anchor" href="#3-cpu%e5%af%86%e9%9b%86%e5%9e%8b%e4%bb%bb%e5%8a%a1%e7%9a%84%e9%99%90%e5%88%b6">#</a>
</h3>
<p>对于CPU密集型任务，虚拟线程的性能与平台线程相当，因为它们并没有增加实际的CPU资源。虚拟线程的优势主要体现在I/O阻塞时的任务切换上，而不是计算能力的提升<a href="@ref">1</a><a href="@ref">5</a>。</p>
<h3 id="4-jvm的性能消耗">
  4. <strong>JVM的性能消耗</strong>
  <a class="anchor" href="#4-jvm%e7%9a%84%e6%80%a7%e8%83%bd%e6%b6%88%e8%80%97">#</a>
</h3>
<p>虚拟线程的管理由JVM负责，虽然这会增加一定的调度开销，但由于虚拟线程的轻量化设计，这种开销通常可以忽略不计。尤其是在高并发场景下，虚拟线程的资源消耗远低于平台线程<a href="@ref">5</a><a href="@ref">6</a>。</p>
<h3 id="5-适用场景">
  5. <strong>适用场景</strong>
  <a class="anchor" href="#5-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h3>
<p>虚拟线程特别适用于高并发、I/O密集型任务，例如网络请求、文件读写等。在这些场景下，虚拟线程可以显著减少线程阻塞带来的性能损失，从而提高整体吞吐量<a href="@ref">2</a><a href="@ref">5</a>。</p>
<h3 id="总结-3">
  总结
  <a class="anchor" href="#%e6%80%bb%e7%bb%93-3">#</a>
</h3>
<p>虚拟线程不会显著增加JVM的性能消耗，反而通过优化任务调度和减少线程阻塞来提高性能。然而，对于CPU密集型任务，虚拟线程的性能提升有限<a href="@ref">1</a><a href="@ref">5</a><a href="@ref">6</a>。</p>
<h2 id="在-springboot-项目中虚拟线程可以怎么使用">
  在 springboot 项目中虚拟线程可以怎么使用
  <a class="anchor" href="#%e5%9c%a8-springboot-%e9%a1%b9%e7%9b%ae%e4%b8%ad%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e5%8f%af%e4%bb%a5%e6%80%8e%e4%b9%88%e4%bd%bf%e7%94%a8">#</a>
</h2>
<p>在 Spring Boot 项目中使用虚拟线程可以显著提升应用的并发性能，尤其是在 I/O 密集型场景中。以下是几种常见的虚拟线程使用方式及其配置方法：</p>
<hr>
<h3 id="1-启用虚拟线程处理-http-请求">
  1. <strong>启用虚拟线程处理 HTTP 请求</strong>
  <a class="anchor" href="#1-%e5%90%af%e7%94%a8%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e5%a4%84%e7%90%86-http-%e8%af%b7%e6%b1%82">#</a>
</h3>
<p>Spring Boot 默认使用 Tomcat 作为 Web 容器，通常使用平台线程处理请求。可以通过配置将 Tomcat 的线程池替换为虚拟线程池。</p>
<h4 id="配置代码">
  配置代码：
  <a class="anchor" href="#%e9%85%8d%e7%bd%ae%e4%bb%a3%e7%a0%81">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> org.apache.coyote.ProtocolHandler;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.boot.web.embedded.tomcat.TomcatProtocolHandlerCustomizer;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.annotation.Bean;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.annotation.Configuration;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Executors;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Configuration</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TomcatConfig</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> TomcatProtocolHandlerCustomizer<span style="color:#f92672">&lt;?&gt;</span> protocolHandlerVirtualThreadExecutorCustomizer() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> protocolHandler <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            protocolHandler.<span style="color:#a6e22e">setExecutor</span>(Executors.<span style="color:#a6e22e">newVirtualThreadPerTaskExecutor</span>());
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="说明">
  说明：
  <a class="anchor" href="#%e8%af%b4%e6%98%8e">#</a>
</h4>
<ul>
<li>该配置将 Tomcat 的线程池替换为虚拟线程池，所有 HTTP 请求将在虚拟线程中处理</li>
</ul>
<hr>
<h3 id="2-使用虚拟线程执行异步任务">
  2. <strong>使用虚拟线程执行异步任务</strong>
  <a class="anchor" href="#2-%e4%bd%bf%e7%94%a8%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e6%89%a7%e8%a1%8c%e5%bc%82%e6%ad%a5%e4%bb%bb%e5%8a%a1">#</a>
</h3>
<p>Spring Boot 中的 <code>@Async</code> 注解通常用于异步执行任务。可以通过配置将异步任务的线程池替换为虚拟线程池。</p>
<h4 id="配置代码-1">
  配置代码：
  <a class="anchor" href="#%e9%85%8d%e7%bd%ae%e4%bb%a3%e7%a0%81-1">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.annotation.Bean;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.annotation.Configuration;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.core.task.TaskExecutor;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.scheduling.annotation.EnableAsync;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.scheduling.concurrent.TaskExecutorAdapter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Executors;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Configuration</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@EnableAsync</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AsyncConfig</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> TaskExecutor <span style="color:#a6e22e">asyncTaskExecutor</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> TaskExecutorAdapter(Executors.<span style="color:#a6e22e">newVirtualThreadPerTaskExecutor</span>());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="使用示例">
  使用示例：
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AsyncService</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Async</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doSomething</span>() <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>        Thread.<span style="color:#a6e22e">sleep</span>(1000); <span style="color:#75715e">// 模拟耗时操作</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;任务完成&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="说明-1">
  说明：
  <a class="anchor" href="#%e8%af%b4%e6%98%8e-1">#</a>
</h4>
<ul>
<li>通过 <code>@Async</code> 注解执行的任务将在虚拟线程中运行</li>
</ul>
<hr>
<h3 id="3-使用虚拟线程执行定时任务">
  3. <strong>使用虚拟线程执行定时任务</strong>
  <a class="anchor" href="#3-%e4%bd%bf%e7%94%a8%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e6%89%a7%e8%a1%8c%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1">#</a>
</h3>
<p>Spring Boot 中的 <code>@Scheduled</code> 注解用于定时任务。可以通过配置将定时任务的线程池替换为虚拟线程池。</p>
<h4 id="配置代码-2">
  配置代码：
  <a class="anchor" href="#%e9%85%8d%e7%bd%ae%e4%bb%a3%e7%a0%81-2">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.annotation.Bean;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.annotation.Configuration;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.scheduling.TaskScheduler;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.scheduling.annotation.EnableScheduling;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.scheduling.concurrent.ConcurrentTaskScheduler;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Executors;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Configuration</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@EnableScheduling</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SchedulingConfig</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> TaskScheduler <span style="color:#a6e22e">taskScheduler</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ConcurrentTaskScheduler(Executors.<span style="color:#a6e22e">newScheduledThreadPool</span>(0, Thread.<span style="color:#a6e22e">ofVirtual</span>().<span style="color:#a6e22e">factory</span>()));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="使用示例-1">
  使用示例：
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b-1">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScheduledService</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Scheduled</span>(fixedRate <span style="color:#f92672">=</span> 1000)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">runTask</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;定时任务执行&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="说明-2">
  说明：
  <a class="anchor" href="#%e8%af%b4%e6%98%8e-2">#</a>
</h4>
<ul>
<li>定时任务将在虚拟线程中执行<a href="@ref">5</a>。</li>
</ul>
<hr>
<h3 id="4-使用虚拟线程执行自定义任务">
  4. <strong>使用虚拟线程执行自定义任务</strong>
  <a class="anchor" href="#4-%e4%bd%bf%e7%94%a8%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e6%89%a7%e8%a1%8c%e8%87%aa%e5%ae%9a%e4%b9%89%e4%bb%bb%e5%8a%a1">#</a>
</h3>
<p>可以通过 <code>Executors.newVirtualThreadPerTaskExecutor()</code> 创建一个虚拟线程池，用于执行自定义任务。</p>
<h4 id="示例代码">
  示例代码：
  <a class="anchor" href="#%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ExecutorService;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Executors;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomTaskExecutor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        ExecutorService executor <span style="color:#f92672">=</span> Executors.<span style="color:#a6e22e">newVirtualThreadPerTaskExecutor</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 1000; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            executor.<span style="color:#a6e22e">submit</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;任务执行&#34;</span>);
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        executor.<span style="color:#a6e22e">shutdown</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="说明-3">
  说明：
  <a class="anchor" href="#%e8%af%b4%e6%98%8e-3">#</a>
</h4>
<ul>
<li>该方式适合在非 Spring 管理的环境中使用虚拟线程<a href="@ref">1</a><a href="@ref">5</a>。</li>
</ul>
<hr>
<h3 id="5-虚拟线程的最佳实践">
  5. <strong>虚拟线程的最佳实践</strong>
  <a class="anchor" href="#5-%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5">#</a>
</h3>
<ul>
<li><strong>避免池化虚拟线程</strong>：虚拟线程的创建和销毁成本极低，无需池化<a href="@ref">1</a>。</li>
<li><strong>适合 I/O 密集型任务</strong>：虚拟线程在 I/O 阻塞时自动挂起，适合网络请求、数据库操作等场景<a href="@ref">2</a>。</li>
<li><strong>逐步迁移</strong>：可以在现有项目中逐步启用虚拟线程，无需一次性替换所有线程<a href="@ref">3</a>。</li>
</ul>
<hr>
<h3 id="6-环境要求">
  6. <strong>环境要求</strong>
  <a class="anchor" href="#6-%e7%8e%af%e5%a2%83%e8%a6%81%e6%b1%82">#</a>
</h3>
<ul>
<li><strong>JDK 版本</strong>：Java 19+（预览功能），Java 21+（正式功能）。</li>
<li><strong>Spring Boot 版本</strong>：Spring Boot 3.2+ 开始支持虚拟线程<a href="@ref">2</a><a href="@ref">5</a>。</li>
</ul>
<hr>
<p>通过以上方式，可以在 Spring Boot 项目中充分利用虚拟线程提升并发性能，同时保持代码简洁。</p>
<h2 id="虚拟线程的mn模型具体是如何工作的">
  虚拟线程的M:N模型具体是如何工作的？
  <a class="anchor" href="#%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e7%9a%84mn%e6%a8%a1%e5%9e%8b%e5%85%b7%e4%bd%93%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84">#</a>
</h2>
<p>虚拟线程的 <strong>M:N 模型</strong> 是一种线程调度机制，它将 <strong>M 个虚拟线程</strong> 映射到 <strong>N 个操作系统线程</strong> 上执行。这种模型的目的是在保持轻量级线程的同时，充分利用操作系统的线程资源。以下是 M:N 模型的具体工作原理：</p>
<hr>
<h3 id="1-基本概念">
  1. <strong>基本概念</strong>
  <a class="anchor" href="#1-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">#</a>
</h3>
<ul>
<li><strong>虚拟线程（Virtual Threads）</strong>：
<ul>
<li>由 JVM 管理的轻量级线程。</li>
<li>内存占用小，创建和销毁成本低。</li>
<li>数量可以非常多（数百万个）。</li>
</ul>
</li>
<li><strong>操作系统线程（Platform Threads）</strong>：
<ul>
<li>由操作系统管理的线程。</li>
<li>内存占用大（默认 1MB 栈空间），创建和销毁成本高。</li>
<li>数量有限（通常数千个）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-mn-模型的核心思想">
  2. <strong>M:N 模型的核心思想</strong>
  <a class="anchor" href="#2-mn-%e6%a8%a1%e5%9e%8b%e7%9a%84%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3">#</a>
</h3>
<ul>
<li>将大量虚拟线程（M）映射到少量操作系统线程（N）上执行。</li>
<li>虚拟线程在执行任务时，由 JVM 调度到可用的操作系统线程上运行。</li>
<li>当虚拟线程遇到阻塞操作（如 I/O）时，JVM 会将其挂起，并释放操作系统线程去执行其他虚拟线程。</li>
</ul>
<hr>
<h3 id="3-具体工作流程">
  3. <strong>具体工作流程</strong>
  <a class="anchor" href="#3-%e5%85%b7%e4%bd%93%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b">#</a>
</h3>
<ol>
<li><strong>虚拟线程创建</strong>：
<ul>
<li>当创建一个虚拟线程时，JVM 会为其分配一个轻量级的上下文（如栈、程序计数器等）。</li>
<li>虚拟线程不会直接绑定到操作系统线程，而是由 JVM 管理。</li>
</ul>
</li>
<li><strong>任务调度</strong>：
<ul>
<li>当虚拟线程需要执行任务时，JVM 会将其调度到一个可用的操作系统线程上运行。</li>
<li>操作系统线程是实际执行任务的载体。</li>
</ul>
</li>
<li><strong>阻塞操作处理</strong>：
<ul>
<li>如果虚拟线程执行了阻塞操作（如 I/O 或等待锁），JVM 会将其挂起。</li>
<li>挂起后，操作系统线程会被释放，并可以执行其他虚拟线程。</li>
</ul>
</li>
<li><strong>任务恢复</strong>：
<ul>
<li>当阻塞操作完成后，JVM 会重新调度该虚拟线程到某个操作系统线程上继续执行。</li>
</ul>
</li>
<li><strong>线程切换</strong>：
<ul>
<li>虚拟线程的切换由 JVM 管理，不需要操作系统介入。</li>
<li>切换开销极小，因为虚拟线程的上下文是轻量级的。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-mn-模型的优势">
  4. <strong>M:N 模型的优势</strong>
  <a class="anchor" href="#4-mn-%e6%a8%a1%e5%9e%8b%e7%9a%84%e4%bc%98%e5%8a%bf">#</a>
</h3>
<ul>
<li><strong>高并发</strong>：
<ul>
<li>可以轻松创建数百万个虚拟线程，适合高并发场景。</li>
</ul>
</li>
<li><strong>资源高效利用</strong>：
<ul>
<li>少量操作系统线程可以服务大量虚拟线程，避免线程资源浪费。</li>
</ul>
</li>
<li><strong>简化编程</strong>：
<ul>
<li>开发者可以使用同步编程模型，同时获得异步性能。</li>
</ul>
</li>
<li><strong>低延迟</strong>：
<ul>
<li>虚拟线程的切换开销极小，任务可以快速恢复执行。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-mn-模型的实现细节">
  5. <strong>M:N 模型的实现细节</strong>
  <a class="anchor" href="#5-mn-%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82">#</a>
</h3>
<ul>
<li><strong>调度器（Scheduler）</strong>：
<ul>
<li>JVM 内置了一个调度器，负责将虚拟线程分配到操作系统线程上执行。</li>
<li>调度器会根据任务的状态（如运行、阻塞、就绪）动态管理虚拟线程。</li>
</ul>
</li>
<li><strong>栈管理</strong>：
<ul>
<li>虚拟线程的栈是动态分配的，可以根据需要扩展或收缩。</li>
<li>挂起时，栈状态会被保存；恢复时，栈状态会被恢复。</li>
</ul>
</li>
<li><strong>阻塞操作感知</strong>：
<ul>
<li>JVM 会识别虚拟线程的阻塞操作（如 I/O、锁等待），并自动挂起和恢复线程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-示例">
  6. <strong>示例</strong>
  <a class="anchor" href="#6-%e7%a4%ba%e4%be%8b">#</a>
</h3>
<p>以下是一个简单的示例，展示了虚拟线程的 M:N 模型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ExecutorService;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Executors;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VirtualThreadExample</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建一个虚拟线程调度器（M:N 模型）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> (ExecutorService executor <span style="color:#f92672">=</span> Executors.<span style="color:#a6e22e">newVirtualThreadPerTaskExecutor</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 提交 1000 个任务</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 1000; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> taskId <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                executor.<span style="color:#a6e22e">submit</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>                    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;任务 &#34;</span> <span style="color:#f92672">+</span> taskId <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; 开始运行...&#34;</span>);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                        Thread.<span style="color:#a6e22e">sleep</span>(1000); <span style="color:#75715e">// 模拟 I/O 阻塞操作</span>
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                        e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;任务 &#34;</span> <span style="color:#f92672">+</span> taskId <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; 结束运行。&#34;</span>);
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这个例子中：</p>
<ul>
<li>1000 个虚拟线程被创建并提交到虚拟线程调度器。</li>
<li>这些虚拟线程会被映射到少量的操作系统线程上执行。</li>
<li>当虚拟线程执行 <code>Thread.sleep</code> 时，JVM 会将其挂起，并释放操作系统线程去执行其他虚拟线程。</li>
</ul>
<hr>
<h3 id="7-与传统线程模型的对比">
  7. <strong>与传统线程模型的对比</strong>
  <a class="anchor" href="#7-%e4%b8%8e%e4%bc%a0%e7%bb%9f%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%af%b9%e6%af%94">#</a>
</h3>
<table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>传统线程（1:1 模型）</strong></th>
          <th><strong>虚拟线程（M:N 模型）</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>线程数量</td>
          <td>受操作系统限制（通常数千个）</td>
          <td>可轻松创建数百万个</td>
      </tr>
      <tr>
          <td>内存占用</td>
          <td>高（默认 1MB 栈空间）</td>
          <td>低（动态分配栈空间）</td>
      </tr>
      <tr>
          <td>线程切换</td>
          <td>操作系统介入，开销大</td>
          <td>JVM 管理，开销小</td>
      </tr>
      <tr>
          <td>阻塞操作处理</td>
          <td>操作系统线程被占用</td>
          <td>虚拟线程挂起，操作系统线程释放</td>
      </tr>
      <tr>
          <td>适用场景</td>
          <td>CPU 密集型任务</td>
          <td>I/O 密集型任务</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="总结-4">
  总结
  <a class="anchor" href="#%e6%80%bb%e7%bb%93-4">#</a>
</h3>
<p>M:N 模型通过将大量轻量级虚拟线程映射到少量操作系统线程上，实现了高并发、低资源占用的线程管理。这种模型特别适合现代高并发、I/O 密集型的应用场景，同时简化了开发者的编程复杂度。</p>
<h2 id="java虚拟线程和传统线程有什么区别">
  Java虚拟线程和传统线程有什么区别
  <a class="anchor" href="#java%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e5%92%8c%e4%bc%a0%e7%bb%9f%e7%ba%bf%e7%a8%8b%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">#</a>
</h2>
<p>Java 虚拟线程（Virtual Threads）与传统线程（Platform Threads）在实现、性能和适用场景上有显著区别。以下是两者的主要对比：</p>
<hr>
<h3 id="1-实现方式">
  1. <strong>实现方式</strong>
  <a class="anchor" href="#1-%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f">#</a>
</h3>
<ul>
<li><strong>传统线程</strong>：
<ul>
<li>直接映射到操作系统的线程（内核线程）。</li>
<li>每个线程都需要分配一个固定的栈空间（默认 1MB）。</li>
<li>创建和销毁成本较高，线程数量受操作系统限制。</li>
</ul>
</li>
<li><strong>虚拟线程</strong>：
<ul>
<li>由 JVM 管理，不直接映射到操作系统线程。</li>
<li>虚拟线程的栈空间是动态分配的，内存占用更小。</li>
<li>创建和销毁成本极低，可以轻松创建数百万个虚拟线程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-线程模型">
  2. <strong>线程模型</strong>
  <a class="anchor" href="#2-%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b">#</a>
</h3>
<ul>
<li><strong>传统线程</strong>：
<ul>
<li>采用 &ldquo;1:1&rdquo; 模型，即一个 Java 线程对应一个操作系统线程。</li>
<li>线程在执行 I/O 或阻塞操作时会一直占用操作系统线程。</li>
</ul>
</li>
<li><strong>虚拟线程</strong>：
<ul>
<li>采用 &ldquo;M:N&rdquo; 模型，即多个虚拟线程映射到少数操作系统线程。</li>
<li>虚拟线程在执行 I/O 或阻塞操作时会被挂起，释放操作系统线程去执行其他虚拟线程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-性能">
  3. <strong>性能</strong>
  <a class="anchor" href="#3-%e6%80%a7%e8%83%bd">#</a>
</h3>
<ul>
<li><strong>传统线程</strong>：
<ul>
<li>线程数量有限，无法高效处理大量并发任务。</li>
<li>线程切换需要操作系统介入，开销较大。</li>
</ul>
</li>
<li><strong>虚拟线程</strong>：
<ul>
<li>可以轻松创建大量线程，适合高并发场景。</li>
<li>线程切换由 JVM 管理，开销极小。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-适用场景-1">
  4. <strong>适用场景</strong>
  <a class="anchor" href="#4-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af-1">#</a>
</h3>
<ul>
<li><strong>传统线程</strong>：
<ul>
<li>适合 CPU 密集型任务，如计算密集型操作。</li>
<li>需要直接控制操作系统线程的场景。</li>
</ul>
</li>
<li><strong>虚拟线程</strong>：
<ul>
<li>适合 I/O 密集型任务，如网络请求、文件读写等。</li>
<li>需要处理大量并发任务的场景，如微服务、Web 服务器等。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-编程模型">
  5. <strong>编程模型</strong>
  <a class="anchor" href="#5-%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b">#</a>
</h3>
<ul>
<li><strong>传统线程</strong>：
<ul>
<li>需要手动管理线程池，避免创建过多线程。</li>
<li>代码复杂度较高，尤其是在处理异步任务时。</li>
</ul>
</li>
<li><strong>虚拟线程</strong>：
<ul>
<li>无需手动管理线程池，可以按需创建虚拟线程。</li>
<li>代码更简洁，支持同步编程模型，同时具备异步性能。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-资源占用">
  6. <strong>资源占用</strong>
  <a class="anchor" href="#6-%e8%b5%84%e6%ba%90%e5%8d%a0%e7%94%a8">#</a>
</h3>
<ul>
<li><strong>传统线程</strong>：
<ul>
<li>每个线程占用固定的栈空间（默认 1MB），内存消耗较大。</li>
<li>线程数量受操作系统限制（通常数千个）。</li>
</ul>
</li>
<li><strong>虚拟线程</strong>：
<ul>
<li>栈空间动态分配，内存占用更小。</li>
<li>可以轻松创建数百万个虚拟线程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-兼容性">
  7. <strong>兼容性</strong>
  <a class="anchor" href="#7-%e5%85%bc%e5%ae%b9%e6%80%a7">#</a>
</h3>
<ul>
<li><strong>传统线程</strong>：
<ul>
<li>所有 Java 版本都支持。</li>
</ul>
</li>
<li><strong>虚拟线程</strong>：
<ul>
<li>从 Java 19 开始引入，默认是预览功能，需在运行时添加 <code>--enable-preview</code> 参数。</li>
<li>在 Java 21 中成为正式功能。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8-示例对比">
  8. <strong>示例对比</strong>
  <a class="anchor" href="#8-%e7%a4%ba%e4%be%8b%e5%af%b9%e6%af%94">#</a>
</h3>
<ul>
<li><strong>传统线程</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ExecutorService executor <span style="color:#f92672">=</span> Executors.<span style="color:#a6e22e">newFixedThreadPool</span>(10);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 1000; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    executor.<span style="color:#a6e22e">submit</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;传统线程执行任务&#34;</span>);
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>executor.<span style="color:#a6e22e">shutdown</span>();
</span></span></code></pre></div></li>
<li><strong>虚拟线程</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> (ExecutorService executor <span style="color:#f92672">=</span> Executors.<span style="color:#a6e22e">newVirtualThreadPerTaskExecutor</span>()) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 1000; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        executor.<span style="color:#a6e22e">submit</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;虚拟线程执行任务&#34;</span>);
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="总结-5">
  总结
  <a class="anchor" href="#%e6%80%bb%e7%bb%93-5">#</a>
</h3>
<table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>传统线程</strong></th>
          <th><strong>虚拟线程</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>实现方式</td>
          <td>1:1 映射到操作系统线程</td>
          <td>M:N 映射到操作系统线程</td>
      </tr>
      <tr>
          <td>内存占用</td>
          <td>高（默认 1MB 栈空间）</td>
          <td>低（动态分配栈空间）</td>
      </tr>
      <tr>
          <td>创建成本</td>
          <td>高</td>
          <td>极低</td>
      </tr>
      <tr>
          <td>线程切换</td>
          <td>操作系统介入，开销大</td>
          <td>JVM 管理，开销小</td>
      </tr>
      <tr>
          <td>适用场景</td>
          <td>CPU 密集型任务</td>
          <td>I/O 密集型任务</td>
      </tr>
      <tr>
          <td>线程数量</td>
          <td>受操作系统限制（通常数千个）</td>
          <td>可轻松创建数百万个</td>
      </tr>
      <tr>
          <td>编程复杂度</td>
          <td>高（需手动管理线程池）</td>
          <td>低（按需创建，无需池化）</td>
      </tr>
  </tbody>
</table>
<p>虚拟线程是 Java 在并发编程领域的一次重大改进，特别适合现代高并发、I/O 密集型的应用场景。</p>
<h2 id="可以生成一个java使用虚拟线程的例子吗">
  可以生成一个java使用虚拟线程的例子吗
  <a class="anchor" href="#%e5%8f%af%e4%bb%a5%e7%94%9f%e6%88%90%e4%b8%80%e4%b8%aajava%e4%bd%bf%e7%94%a8%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%be%8b%e5%ad%90%e5%90%97">#</a>
</h2>
<p>以下是一个使用 Java 虚拟线程的示例代码，展示了如何创建和运行虚拟线程：</p>
<h3 id="示例代码-1">
  示例代码
  <a class="anchor" href="#%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81-1">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ExecutorService;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Executors;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VirtualThreadExample</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 方法 1: 直接创建并运行虚拟线程</span>
</span></span><span style="display:flex;"><span>        Thread.<span style="color:#a6e22e">startVirtualThread</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;虚拟线程 1 开始运行...&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                Thread.<span style="color:#a6e22e">sleep</span>(1000); <span style="color:#75715e">// 模拟耗时操作</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;虚拟线程 1 结束运行。&#34;</span>);
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 方法 2: 创建虚拟线程但不自动运行，手动调用 start()</span>
</span></span><span style="display:flex;"><span>        Thread virtualThread <span style="color:#f92672">=</span> Thread.<span style="color:#a6e22e">ofVirtual</span>().<span style="color:#a6e22e">unstarted</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;虚拟线程 2 开始运行...&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                Thread.<span style="color:#a6e22e">sleep</span>(1000); <span style="color:#75715e">// 模拟耗时操作</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;虚拟线程 2 结束运行。&#34;</span>);
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        virtualThread.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 方法 3: 使用 ExecutorService 调度虚拟线程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> (ExecutorService executor <span style="color:#f92672">=</span> Executors.<span style="color:#a6e22e">newVirtualThreadPerTaskExecutor</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 3; i <span style="color:#f92672">&lt;=</span> 5; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> threadId <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                executor.<span style="color:#a6e22e">submit</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>                    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;虚拟线程 &#34;</span> <span style="color:#f92672">+</span> threadId <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; 开始运行...&#34;</span>);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                        Thread.<span style="color:#a6e22e">sleep</span>(1000); <span style="color:#75715e">// 模拟耗时操作</span>
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                        e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;虚拟线程 &#34;</span> <span style="color:#f92672">+</span> threadId <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; 结束运行。&#34;</span>);
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="代码说明">
  代码说明
  <a class="anchor" href="#%e4%bb%a3%e7%a0%81%e8%af%b4%e6%98%8e">#</a>
</h3>
<ol>
<li><strong>方法 1</strong>: 使用 <code>Thread.startVirtualThread()</code> 直接创建并运行虚拟线程。这种方式适合简单的任务。</li>
<li><strong>方法 2</strong>: 使用 <code>Thread.ofVirtual().unstarted()</code> 创建虚拟线程，但不自动运行，需要手动调用 <code>start()</code> 启动。</li>
<li><strong>方法 3</strong>: 使用 <code>Executors.newVirtualThreadPerTaskExecutor()</code> 创建一个虚拟线程池，适合需要管理多个虚拟线程的场景。</li>
</ol>
<h3 id="运行说明">
  运行说明
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e8%af%b4%e6%98%8e">#</a>
</h3>
<ul>
<li>虚拟线程在 Java 19 中引入，但默认是预览功能，需在运行代码时添加 <code>--enable-preview</code> 参数。</li>
<li>虚拟线程适用于 I/O 密集型任务，如网络请求、文件读写等，能够在等待 I/O 时自动挂起并切换到其他虚拟线程，提升资源利用率<a href="@ref">1</a>。</li>
</ul>
<h3 id="运行命令">
  运行命令
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e5%91%bd%e4%bb%a4">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>java --source <span style="color:#ae81ff">19</span> --enable-preview VirtualThreadExample.java
</span></span></code></pre></div><h3 id="注意事项">
  注意事项
  <a class="anchor" href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">#</a>
</h3>
<ul>
<li>虚拟线程不应池化，因为其创建和销毁成本极低，适合按需创建<a href="@ref">1</a>。</li>
<li>虚拟线程的 I/O 操作会自动挂起并切换，而普通线程的 I/O 操作仍会阻塞<a href="@ref">1</a>。</li>
</ul>
<p>以上示例展示了虚拟线程的基本用法，适用于 Java 19 及以上版本。</p>
<h2 id="学习资料">
  学习资料
  <a class="anchor" href="#%e5%ad%a6%e4%b9%a0%e8%b5%84%e6%96%99">#</a>
</h2>
<ul>
<li><a href="https://www.cyc2018.xyz">CS-Notes面试笔记</a></li>
<li><a href="https://cloud.macrozheng.com/foreword/mall_swarm_video.html">mall-swarm视频教程</a></li>
</ul>
<h2 id="basic">
  basic
  <a class="anchor" href="#basic">#</a>
</h2>
<h3 id="java-array-转-list">
  java array 转 list
  <a class="anchor" href="#java-array-%e8%bd%ac-list">#</a>
</h3>
<p>在Java中，你可以使用<code>Arrays.asList()</code>方法将数组转换为列表。这是一个简单的方法来创建一个固定大小的<code>List</code>。如果你需要一个能够改变大小的<code>List</code>，你需要使用<code>new ArrayList&lt;&gt;(Arrays.asList(array))</code>来创建一个新的<code>ArrayList</code>实例。</p>
<p>以下是两种情况的代码示例：</p>
<h4 id="创建一个固定大小的列表">
  创建一个固定大小的列表
  <a class="anchor" href="#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%9b%ba%e5%ae%9a%e5%a4%a7%e5%b0%8f%e7%9a%84%e5%88%97%e8%a1%a8">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Arrays;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.List;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ArrayToListExample</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        String<span style="color:#f92672">[]</span> array <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#e6db74">&#34;c&#34;</span>};
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> Arrays.<span style="color:#a6e22e">asList</span>(array);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(list); <span style="color:#75715e">// 输出: [a, b, c]</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="创建一个可变大小的列表">
  创建一个可变大小的列表
  <a class="anchor" href="#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%8f%af%e5%8f%98%e5%a4%a7%e5%b0%8f%e7%9a%84%e5%88%97%e8%a1%a8">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.ArrayList;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Arrays;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.List;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ArrayToArrayListExample</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        String<span style="color:#f92672">[]</span> array <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#e6db74">&#34;c&#34;</span>};
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> arrayList <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>(Arrays.<span style="color:#a6e22e">asList</span>(array));
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 现在可以添加或删除元素了</span>
</span></span><span style="display:flex;"><span>        arrayList.<span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#34;d&#34;</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(arrayList); <span style="color:#75715e">// 输出: [a, b, c, d]</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>请注意，当你使用<code>Arrays.asList()</code>时，它返回的是一个受数组支持的固定大小的列表。这意味着你不能添加或移除元素（除非你将其转换为像<code>ArrayList</code>这样的可调整大小的列表），但是你可以修改已经存在的元素。如果你尝试对固定大小的列表执行添加或移除操作，将会抛出<code>UnsupportedOperationException</code>异常。</p>
<h3 id="java-怎么用二进制打印int">
  java， 怎么用二进制打印int
  <a class="anchor" href="#java-%e6%80%8e%e4%b9%88%e7%94%a8%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%89%93%e5%8d%b0int">#</a>
</h3>
<p>在Java中，可以使用<code>Integer.toBinaryString()</code>方法来将一个<code>int</code>类型的数值转换为二进制字符串表示。此方法返回的是一个不带前导零的字符串，也就是说它不会打印出完整的32位（对于<code>int</code>类型），如果需要显示所有位，包括前导零，则需要额外处理。</p>
<p>以下是一些例子：</p>
<h4 id="使用-integertobinarystring">
  使用 <code>Integer.toBinaryString()</code>
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8-integertobinarystring">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BinaryPrintExample</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> number <span style="color:#f92672">=</span> 42;
</span></span><span style="display:flex;"><span>        String binaryString <span style="color:#f92672">=</span> Integer.<span style="color:#a6e22e">toBinaryString</span>(number);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;The binary representation of &#34;</span> <span style="color:#f92672">+</span> number <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is: &#34;</span> <span style="color:#f92672">+</span> binaryString);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="打印包含前导零的完整32位">
  打印包含前导零的完整32位
  <a class="anchor" href="#%e6%89%93%e5%8d%b0%e5%8c%85%e5%90%ab%e5%89%8d%e5%af%bc%e9%9b%b6%e7%9a%84%e5%ae%8c%e6%95%b432%e4%bd%8d">#</a>
</h4>
<p>如果你想要打印出完整的32位二进制数，包括前导的0，你可以使用<code>String.format()</code>或者<code>BitSet</code>，但最简单的方法是用<code>String.format()</code>配合循环补足前导零：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FullBinaryPrintExample</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> number <span style="color:#f92672">=</span> 42;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Convert to binary string and ensure it&#39;s 32 bits long with leading zeros</span>
</span></span><span style="display:flex;"><span>        String binaryString <span style="color:#f92672">=</span> String.<span style="color:#a6e22e">format</span>(<span style="color:#e6db74">&#34;%32s&#34;</span>, Integer.<span style="color:#a6e22e">toBinaryString</span>(number)).<span style="color:#a6e22e">replace</span>(<span style="color:#e6db74">&#39; &#39;</span>, <span style="color:#e6db74">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;The full 32-bit binary representation of &#34;</span> <span style="color:#f92672">+</span> number <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is: &#34;</span> <span style="color:#f92672">+</span> binaryString);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码中，<code>%32s</code>指定了格式化后的字符串总长度为32，不足的部分用空格填充，然后我们用<code>replace(' ', '0')</code>把所有的空格替换成'0&rsquo;。</p>
<h4 id="使用位运算手动构建二进制字符串">
  使用位运算手动构建二进制字符串
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8%e4%bd%8d%e8%bf%90%e7%ae%97%e6%89%8b%e5%8a%a8%e6%9e%84%e5%bb%ba%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%ad%97%e7%ac%a6%e4%b8%b2">#</a>
</h4>
<p>如果你想自己实现这个功能，你也可以使用位运算来构建二进制字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ManualBinaryPrintExample</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> number <span style="color:#f92672">=</span> 42;
</span></span><span style="display:flex;"><span>        StringBuilder binaryString <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringBuilder();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 31; i <span style="color:#f92672">&gt;=</span> 0; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> number <span style="color:#f92672">&gt;&gt;</span> i;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ((k <span style="color:#f92672">&amp;</span> 1) <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                binaryString.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;1&#34;</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                binaryString.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;0&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;The manually constructed 32-bit binary representation of &#34;</span> <span style="color:#f92672">+</span> number <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is: &#34;</span> <span style="color:#f92672">+</span> binaryString.<span style="color:#a6e22e">toString</span>());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这段代码通过逐位检查整数的每一位是否为1，并相应地添加&quot;1&quot;或&quot;0&quot;到<code>StringBuilder</code>对象中，最终构建出完整的32位二进制字符串。</p>
<h2 id="concurrent">
  concurrent
  <a class="anchor" href="#concurrent">#</a>
</h2>
<h2 id="每一个java的版本的主要更新">
  每一个java的版本的主要更新
  <a class="anchor" href="#%e6%af%8f%e4%b8%80%e4%b8%aajava%e7%9a%84%e7%89%88%e6%9c%ac%e7%9a%84%e4%b8%bb%e8%a6%81%e6%9b%b4%e6%96%b0">#</a>
</h2>
<p>以下是Java主要版本的主要更新内容：</p>
<h3 id="java-10-1996">
  Java 1.0 (1996)
  <a class="anchor" href="#java-10-1996">#</a>
</h3>
<ul>
<li><strong>初始版本</strong>：包含核心API和基础功能，如AWT、线程、IO等。</li>
</ul>
<h3 id="java-11-1997">
  Java 1.1 (1997)
  <a class="anchor" href="#java-11-1997">#</a>
</h3>
<ul>
<li><strong>JDBC</strong>：支持数据库连接。</li>
<li><strong>RMI</strong>：支持远程方法调用。</li>
<li><strong>内部类</strong>：引入内部类。</li>
<li><strong>JavaBeans</strong>：引入组件模型。</li>
</ul>
<h3 id="java-12-1998">
  Java 1.2 (1998)
  <a class="anchor" href="#java-12-1998">#</a>
</h3>
<ul>
<li><strong>集合框架</strong>：引入集合框架（如List、Set、Map）。</li>
<li><strong>Swing</strong>：引入新的GUI库。</li>
<li><strong>JIT编译器</strong>：引入即时编译器提升性能。</li>
</ul>
<h3 id="java-13-2000">
  Java 1.3 (2000)
  <a class="anchor" href="#java-13-2000">#</a>
</h3>
<ul>
<li><strong>HotSpot JVM</strong>：引入HotSpot虚拟机。</li>
<li><strong>JNDI</strong>：支持命名和目录服务。</li>
</ul>
<h3 id="java-14-2002">
  Java 1.4 (2002)
  <a class="anchor" href="#java-14-2002">#</a>
</h3>
<ul>
<li><strong>正则表达式</strong>：引入正则表达式支持。</li>
<li><strong>NIO</strong>：引入非阻塞IO。</li>
<li><strong>日志API</strong>：引入日志功能。</li>
</ul>
<h3 id="java-5-2004">
  Java 5 (2004)
  <a class="anchor" href="#java-5-2004">#</a>
</h3>
<ul>
<li><strong>泛型</strong>：引入泛型支持。</li>
<li><strong>注解</strong>：引入注解功能。</li>
<li><strong>自动装箱/拆箱</strong>：支持基本类型与包装类的自动转换。</li>
<li><strong>枚举</strong>：引入枚举类型。</li>
<li><strong>并发工具</strong>：引入<code>java.util.concurrent</code>包。</li>
</ul>
<h3 id="java-6-2006">
  Java 6 (2006)
  <a class="anchor" href="#java-6-2006">#</a>
</h3>
<ul>
<li><strong>脚本引擎</strong>：支持脚本语言（如JavaScript）。</li>
<li><strong>JDBC 4.0</strong>：增强数据库连接功能。</li>
<li><strong>JAX-WS</strong>：支持Web服务。</li>
</ul>
<h3 id="java-7-2011">
  Java 7 (2011)
  <a class="anchor" href="#java-7-2011">#</a>
</h3>
<ul>
<li><strong>try-with-resources</strong>：自动资源管理。</li>
<li><strong>NIO.2</strong>：增强文件IO操作。</li>
<li><strong>钻石操作符</strong>：简化泛型实例化。</li>
<li><strong>多异常捕获</strong>：支持一次捕获多个异常。</li>
</ul>
<h3 id="java-8-2014">
  Java 8 (2014)
  <a class="anchor" href="#java-8-2014">#</a>
</h3>
<ul>
<li><strong>Lambda表达式</strong>：引入函数式编程。</li>
<li><strong>Stream API</strong>：支持流式数据处理。</li>
<li><strong>默认方法</strong>：接口支持默认方法。</li>
<li><strong>新的日期时间API</strong>：引入<code>java.time</code>包。</li>
</ul>
<h3 id="java-9-2017">
  Java 9 (2017)
  <a class="anchor" href="#java-9-2017">#</a>
</h3>
<ul>
<li><strong>模块系统</strong>：引入模块化系统（Jigsaw）。</li>
<li><strong>JShell</strong>：引入交互式编程工具。</li>
<li><strong>集合工厂方法</strong>：简化集合创建。</li>
</ul>
<h3 id="java-10-2018">
  Java 10 (2018)
  <a class="anchor" href="#java-10-2018">#</a>
</h3>
<ul>
<li><strong>局部变量类型推断</strong>：引入<code>var</code>关键字。</li>
<li><strong>G1垃圾回收器</strong>：并行全堆回收。</li>
</ul>
<h3 id="java-11-2018">
  Java 11 (2018)
  <a class="anchor" href="#java-11-2018">#</a>
</h3>
<ul>
<li><strong>HTTP Client API</strong>：标准化HTTP客户端。</li>
<li><strong>局部变量语法扩展</strong>：支持Lambda表达式中的<code>var</code>。</li>
<li><strong>移除模块</strong>：移除Java EE和CORBA模块。</li>
</ul>
<h3 id="java-12-2019">
  Java 12 (2019)
  <a class="anchor" href="#java-12-2019">#</a>
</h3>
<ul>
<li><strong>Switch表达式</strong>：增强<code>switch</code>语句。</li>
<li><strong>JVM常量API</strong>：引入常量API。</li>
</ul>
<h3 id="java-13-2019">
  Java 13 (2019)
  <a class="anchor" href="#java-13-2019">#</a>
</h3>
<ul>
<li><strong>文本块</strong>：支持多行字符串。</li>
<li><strong>动态CDS归档</strong>：优化类数据共享。</li>
</ul>
<h3 id="java-14-2020">
  Java 14 (2020)
  <a class="anchor" href="#java-14-2020">#</a>
</h3>
<ul>
<li><strong>Records</strong>：引入记录类。</li>
<li><strong>Pattern Matching for instanceof</strong>：增强<code>instanceof</code>操作符。</li>
</ul>
<h3 id="java-15-2020">
  Java 15 (2020)
  <a class="anchor" href="#java-15-2020">#</a>
</h3>
<ul>
<li><strong>Sealed Classes</strong>：引入密封类。</li>
<li><strong>文本块</strong>：正式支持多行字符串。</li>
</ul>
<h3 id="java-16-2021">
  Java 16 (2021)
  <a class="anchor" href="#java-16-2021">#</a>
</h3>
<ul>
<li><strong>Records</strong>：正式支持记录类。</li>
<li><strong>Pattern Matching for instanceof</strong>：正式支持模式匹配。</li>
</ul>
<h3 id="java-17-2021">
  Java 17 (2021)
  <a class="anchor" href="#java-17-2021">#</a>
</h3>
<ul>
<li><strong>Sealed Classes</strong>：正式支持密封类。</li>
<li><strong>移除RMI激活系统</strong>：移除过时功能。</li>
</ul>
<h3 id="java-18-2022">
  Java 18 (2022)
  <a class="anchor" href="#java-18-2022">#</a>
</h3>
<ul>
<li><strong>简单Web服务器</strong>：引入简单HTTP服务器。</li>
<li><strong>UTF-8默认字符集</strong>：默认使用UTF-8编码。</li>
</ul>
<h3 id="java-19-2022">
  Java 19 (2022)
  <a class="anchor" href="#java-19-2022">#</a>
</h3>
<ul>
<li><strong>虚拟线程</strong>：引入虚拟线程（预览）。</li>
<li><strong>结构化并发</strong>：简化多线程编程（孵化器）。</li>
</ul>
<h3 id="java-20-2023">
  Java 20 (2023)
  <a class="anchor" href="#java-20-2023">#</a>
</h3>
<ul>
<li><strong>Scoped Values</strong>：引入作用域值（预览）。</li>
<li><strong>Record Patterns</strong>：引入记录模式（预览）。</li>
</ul>
<h3 id="java-21-2023">
  Java 21 (2023)
  <a class="anchor" href="#java-21-2023">#</a>
</h3>
<ul>
<li><strong>虚拟线程</strong>：正式支持虚拟线程。</li>
<li><strong>字符串模板</strong>：引入字符串模板（预览）。</li>
</ul>
<h3 id="总结-6">
  总结
  <a class="anchor" href="#%e6%80%bb%e7%bb%93-6">#</a>
</h3>
<p>Java每个版本都带来了新特性和改进，从基础功能到高级特性，不断提升开发效率和性能。</p>
<h2 id="面试java的时候可能会问到有没有了解最新的技术这个我该怎么准备提前了解哪些知识">
  面试java的时候可能会问到有没有了解最新的技术，这个我该怎么准备，提前了解哪些知识
  <a class="anchor" href="#%e9%9d%a2%e8%af%95java%e7%9a%84%e6%97%b6%e5%80%99%e5%8f%af%e8%83%bd%e4%bc%9a%e9%97%ae%e5%88%b0%e6%9c%89%e6%b2%a1%e6%9c%89%e4%ba%86%e8%a7%a3%e6%9c%80%e6%96%b0%e7%9a%84%e6%8a%80%e6%9c%af%e8%bf%99%e4%b8%aa%e6%88%91%e8%af%a5%e6%80%8e%e4%b9%88%e5%87%86%e5%a4%87%e6%8f%90%e5%89%8d%e4%ba%86%e8%a7%a3%e5%93%aa%e4%ba%9b%e7%9f%a5%e8%af%86">#</a>
</h2>
<p>在Java面试中，面试官可能会询问你对最新技术的了解，尤其是Java的最新版本和相关生态技术的发展。为了应对这类问题，你可以从以下几个方面进行准备：</p>
<hr>
<h3 id="1-java最新版本特性">
  1. <strong>Java最新版本特性</strong>
  <a class="anchor" href="#1-java%e6%9c%80%e6%96%b0%e7%89%88%e6%9c%ac%e7%89%b9%e6%80%a7">#</a>
</h3>
<p>Java的每个版本都会引入新特性，了解这些特性不仅能展现你的技术敏锐度，还能体现你对语言发展的关注。以下是Java 17及之后版本的重要特性：</p>
<ul>
<li><strong>Java 17 (LTS)</strong>：
<ul>
<li><strong>密封类（Sealed Classes）</strong>：限制类的继承，增强代码的安全性。</li>
<li><strong>模式匹配（Pattern Matching）</strong>：简化<code>instanceof</code>的使用，减少冗余代码。</li>
<li><strong>文本块（Text Blocks）</strong>：简化多行字符串的处理。</li>
</ul>
</li>
<li><strong>Java 21</strong>：
<ul>
<li><strong>虚拟线程（Virtual Threads）</strong>：轻量级线程，显著提升并发性能。</li>
<li><strong>结构化并发（Structured Concurrency）</strong>：简化多线程编程，提升代码可维护性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-微服务与云原生技术">
  2. <strong>微服务与云原生技术</strong>
  <a class="anchor" href="#2-%e5%be%ae%e6%9c%8d%e5%8a%a1%e4%b8%8e%e4%ba%91%e5%8e%9f%e7%94%9f%e6%8a%80%e6%9c%af">#</a>
</h3>
<p>微服务和云原生是当前Java开发的热门方向，面试官可能会问到相关技术栈：</p>
<ul>
<li><strong>Spring Cloud</strong>：了解服务发现（Eureka）、配置中心（Spring Cloud Config）、负载均衡（Ribbon）等。</li>
<li><strong>Docker与Kubernetes</strong>：掌握容器化部署和编排工具的使用场景。</li>
<li><strong>服务网格（Service Mesh）</strong>：了解Istio或Linkerd在微服务中的作用。</li>
</ul>
<hr>
<h3 id="3-数据库与缓存技术">
  3. <strong>数据库与缓存技术</strong>
  <a class="anchor" href="#3-%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%8e%e7%bc%93%e5%ad%98%e6%8a%80%e6%9c%af">#</a>
</h3>
<p>数据库和缓存是Java开发中的核心组件，面试官可能会问到最新趋势：</p>
<ul>
<li><strong>NoSQL数据库</strong>：了解MongoDB、Cassandra等非关系型数据库的使用场景。</li>
<li><strong>Redis</strong>：掌握Redis在缓存、分布式锁、消息队列中的应用。</li>
<li><strong>NewSQL</strong>：了解TiDB、CockroachDB等分布式数据库的特点。</li>
</ul>
<hr>
<h3 id="4-性能优化与jvm调优">
  4. <strong>性能优化与JVM调优</strong>
  <a class="anchor" href="#4-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e4%b8%8ejvm%e8%b0%83%e4%bc%98">#</a>
</h3>
<p>JVM调优是Java开发中的高级技能，面试官可能会问到相关实践：</p>
<ul>
<li><strong>垃圾回收器</strong>：了解G1、ZGC、Shenandoah等新型垃圾回收器的特点。</li>
<li><strong>性能监控工具</strong>：掌握JProfiler、VisualVM等工具的使用。</li>
<li><strong>内存模型</strong>：理解JVM内存分区（堆、栈、方法区）及优化策略。</li>
</ul>
<hr>
<h3 id="5-前沿技术与趋势">
  5. <strong>前沿技术与趋势</strong>
  <a class="anchor" href="#5-%e5%89%8d%e6%b2%bf%e6%8a%80%e6%9c%af%e4%b8%8e%e8%b6%8b%e5%8a%bf">#</a>
</h3>
<ul>
<li><strong>响应式编程</strong>：了解Spring WebFlux和Project Reactor的使用场景。</li>
<li><strong>AI与大数据</strong>：了解Java在机器学习（如DL4J）和大数据处理（如Apache Flink）中的应用。</li>
<li><strong>低代码/无代码平台</strong>：了解Java在低代码开发中的角色。</li>
</ul>
<hr>
<h3 id="6-实践与项目结合">
  6. <strong>实践与项目结合</strong>
  <a class="anchor" href="#6-%e5%ae%9e%e8%b7%b5%e4%b8%8e%e9%a1%b9%e7%9b%ae%e7%bb%93%e5%90%88">#</a>
</h3>
<ul>
<li><strong>项目中的应用</strong>：如果你在实际项目中使用过上述技术，可以结合项目经验进行说明。例如，如何在项目中利用虚拟线程提升并发性能，或如何使用Redis优化缓存策略。</li>
<li><strong>学习资源</strong>：关注技术博客、官方文档、GitHub开源项目，保持对最新技术的敏感度。</li>
</ul>
<hr>
<h3 id="7-面试中的表达技巧">
  7. <strong>面试中的表达技巧</strong>
  <a class="anchor" href="#7-%e9%9d%a2%e8%af%95%e4%b8%ad%e7%9a%84%e8%a1%a8%e8%be%be%e6%8a%80%e5%b7%a7">#</a>
</h3>
<ul>
<li><strong>结构化回答</strong>：使用STAR法则（情境、任务、行动、结果）描述你对新技术的理解和应用。</li>
<li><strong>展现学习能力</strong>：如果对某些技术不熟悉，可以表达出学习的意愿和计划。</li>
</ul>
<hr>
<p>通过以上准备，你可以在面试中展现出对最新技术的深刻理解和实际应用能力，从而提升竞争力。如果需要更详细的学习资源或具体技术点的深入解析，可以参考相关文档或技术社区。</p>
<h1 id="hashmap">
  HashMap
  <a class="anchor" href="#hashmap">#</a>
</h1>
<h2 id="为什么hashmap要使用红黑树而不使用其他的树结构">
  为什么HashMap要使用红黑树而不使用其他的树结构？
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88hashmap%e8%a6%81%e4%bd%bf%e7%94%a8%e7%ba%a2%e9%bb%91%e6%a0%91%e8%80%8c%e4%b8%8d%e4%bd%bf%e7%94%a8%e5%85%b6%e4%bb%96%e7%9a%84%e6%a0%91%e7%bb%93%e6%9e%84">#</a>
</h2>
<pre tabindex="0"><code class="language-ys_think" data-lang="ys_think">
&lt;icon&gt;https://wy-static.wenxiaobai.com/bot-capability/prod/%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83.png&lt;/icon&gt;

&lt;start&gt;思考中...&lt;/start&gt;

嗯，用户问为什么HashMap用红黑树而不是其他树结构。我得仔细看看搜索结果里的内容。首先，记得之前学过的，红黑树是自平衡二叉搜索树，而HashMap在链表过长时转成红黑树是为了提高查询效率。那为什么要选红黑树而不是比如AVL树或者其他树呢？

搜索结果里，网页1提到红黑树的平均查找长度是log(n)，链表是n/2，当长度超过8的时候，转换成树更有必要。同时，网页6和网页8也讨论了红黑树和AVL树的区别。网页6说红黑树在插入和删除时效率更高，因为旋转次数少。而AVL树虽然查询更快，但维护平衡的成本高，每次调整可能需要更多旋转。

网页8提到红黑树的平衡性不如AVL严格，但这样换来的是更高效的插入和删除操作。对于HashMap这种需要频繁插入和删除的场景，红黑树的性能更好。另外，红黑树在调整时最多三次旋转就能恢复平衡，而AVL可能需要O(log n)次，这在多线程或高并发情况下更有优势。

还有网页4和网页7也提到，红黑树在解决哈希冲突时，能提供O(log n)的时间复杂度，而链表是O(n)。当链表长度增加到一定阈值时，转换为树结构能有效提升性能。而选择红黑树而不是其他树结构，比如B树或者二叉搜索树，可能是因为红黑树在内存中操作更高效，不需要像B树那样处理大量子节点，适合内存中的数据结构。

另外，网页9和网页10提到HashMap在JDK8之后使用红黑树的条件是链表长度超过8且数组容量达到64。这说明红黑树的使用是有严格条件的，而红黑树的结构特性刚好满足这种需要部分平衡的场景，既保证了查询效率，又减少了维护平衡的开销。

所以总结下来，HashMap选择红黑树主要是因为它在插入、删除和查询之间找到了一个平衡点，适合频繁修改的场景。而其他树结构如AVL树可能在查询上更快，但维护成本高；二叉堆或B树可能结构不适合HashMap的需求。红黑树的这些特性使得它在HashMap中表现更优。

&lt;end&gt;已深度思考（用时14秒）&lt;/end&gt;
</code></pre><p>在 Java 的 HashMap 中，当哈希冲突导致链表长度超过阈值（默认为 8）时，链表会转换为红黑树以优化性能。选择红黑树而非其他树结构（如 AVL 树、普通二叉搜索树等）是经过多方面权衡后的结果，主要原因如下：</p>
<hr>
<h3 id="一红黑树的特性优势">
  一、<strong>红黑树的特性优势</strong>
  <a class="anchor" href="#%e4%b8%80%e7%ba%a2%e9%bb%91%e6%a0%91%e7%9a%84%e7%89%b9%e6%80%a7%e4%bc%98%e5%8a%bf">#</a>
</h3>
<p>红黑树是一种<strong>自平衡二叉搜索树</strong>，其核心优势在于<strong>平衡性与操作效率的折中</strong>。以下是其关键特性：</p>
<ol>
<li>
<p><strong>近似平衡</strong><br>
红黑树通过约束条件（如红色节点不能连续、从根到叶子的黑节点数相同）保证最长路径不超过最短路径的两倍<a href="@ref">1</a><a href="@ref">5</a><a href="@ref">9</a>。这种“非严格平衡”使得维护成本低于 AVL 树，同时仍能保证对数级时间复杂度（O(log n)）的查找效率。</p>
</li>
<li>
<p><strong>高效的增删操作</strong></p>
<ul>
<li><strong>插入/删除性能</strong>：红黑树在调整平衡时最多需要<strong>3次旋转</strong>即可完成，而 AVL 树可能需要多次旋转甚至 O(log n) 次调整<a href="@ref">6</a><a href="@ref">8</a>。例如，删除节点时，AVL 需维护从删除节点到根的路径平衡，而红黑树只需局部调整<a href="@ref">8</a>。</li>
<li><strong>时间复杂度</strong>：红黑树的插入、删除和查找均为 O(log n)，且实际性能稳定，适合频繁修改的场景<a href="@ref">7</a><a href="@ref">12</a>。</li>
</ul>
</li>
<li>
<p><strong>内存占用优化</strong><br>
红黑树仅需存储颜色标记（1 bit），而 AVL 树需存储平衡因子（通常为整型），内存开销更小<a href="@ref">8</a>。</p>
</li>
</ol>
<hr>
<h3 id="二与其他树结构的对比">
  二、<strong>与其他树结构的对比</strong>
  <a class="anchor" href="#%e4%ba%8c%e4%b8%8e%e5%85%b6%e4%bb%96%e6%a0%91%e7%bb%93%e6%9e%84%e7%9a%84%e5%af%b9%e6%af%94">#</a>
</h3>
<h4 id="1-与-avl-树的对比">
  1. <strong>与 AVL 树的对比</strong>
  <a class="anchor" href="#1-%e4%b8%8e-avl-%e6%a0%91%e7%9a%84%e5%af%b9%e6%af%94">#</a>
</h4>
<ul>
<li><strong>平衡性</strong>：AVL 树追求严格平衡（左右子树高度差≤1），查询效率略高于红黑树，但插入/删除时维护平衡的代价更高<a href="@ref">6</a><a href="@ref">8</a>。</li>
<li><strong>适用场景</strong>：AVL 树适合<strong>读多写少</strong>的场景（如数据库索引），而 HashMap 需要频繁插入和删除节点，红黑树的综合性能更优<a href="@ref">8</a><a href="@ref">12</a>。</li>
</ul>
<h4 id="2-与普通二叉搜索树的对比">
  2. <strong>与普通二叉搜索树的对比</strong>
  <a class="anchor" href="#2-%e4%b8%8e%e6%99%ae%e9%80%9a%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e5%af%b9%e6%af%94">#</a>
</h4>
<ul>
<li><strong>退化问题</strong>：普通二叉搜索树在极端情况下（如数据有序插入）会退化为链表，时间复杂度退化为 O(n)，而红黑树通过自平衡机制避免此问题<a href="@ref">5</a><a href="@ref">9</a>。</li>
</ul>
<h4 id="3-与-b-树b-树的对比">
  3. <strong>与 B 树/B+ 树的对比</strong>
  <a class="anchor" href="#3-%e4%b8%8e-b-%e6%a0%91b-%e6%a0%91%e7%9a%84%e5%af%b9%e6%af%94">#</a>
</h4>
<ul>
<li><strong>内存与磁盘优化</strong>：B 树适用于磁盘存储（减少 I/O 次数），而红黑树作为内存数据结构，更适合 HashMap 的哈希桶管理<a href="@ref">8</a>。</li>
</ul>
<hr>
<h3 id="三hashmap-的特定需求">
  三、<strong>HashMap 的特定需求</strong>
  <a class="anchor" href="#%e4%b8%89hashmap-%e7%9a%84%e7%89%b9%e5%ae%9a%e9%9c%80%e6%b1%82">#</a>
</h3>
<ol>
<li>
<p><strong>哈希冲突的局部性</strong><br>
HashMap 仅在单个哈希桶内使用红黑树，冲突节点数量通常较小（默认阈值 8），红黑树的局部调整特性更契合这种场景<a href="@ref">3</a><a href="@ref">7</a><a href="@ref">10</a>。</p>
</li>
<li>
<p><strong>性能与成本的权衡</strong></p>
<ul>
<li><strong>树化阈值选择</strong>：链表长度超过 8 才转换为红黑树，因为此时链表的平均查找长度为 4，而红黑树为 3，性能提升显著<a href="@ref">1</a><a href="@ref">3</a>。</li>
<li><strong>树退化阈值</strong>：当节点数降至 6 时还原为链表，避免频繁树化与退化（中间差值 7 作为缓冲）<a href="@ref">1</a><a href="@ref">10</a>。</li>
</ul>
</li>
<li>
<p><strong>工程实践验证</strong><br>
红黑树的实现复杂度适中，且经过大量工程验证（如 Linux 内核、Java 集合框架），其稳定性和效率已被广泛认可<a href="@ref">6</a><a href="@ref">8</a>。</p>
</li>
</ol>
<hr>
<h3 id="四总结">
  四、<strong>总结</strong>
  <a class="anchor" href="#%e5%9b%9b%e6%80%bb%e7%bb%93">#</a>
</h3>
<p>HashMap 选择红黑树的核心原因在于：</p>
<ol>
<li><strong>平衡效率与维护成本</strong>：在近似平衡的基础上，以更低的代价实现高效的增删操作。</li>
<li><strong>适应哈希冲突场景</strong>：适合局部、小规模的数据结构管理需求。</li>
<li><strong>工程实践优势</strong>：经过长期验证，性能稳定且实现成熟。</li>
</ol>
<p>相比之下，其他树结构或过于追求平衡（如 AVL 树），或缺乏自适应性（如普通二叉搜索树），无法在 HashMap 的特定场景中达到最优性能<a href="@ref">1</a><a href="@ref">6</a><a href="@ref">8</a>。</p>
<h1 id="socket">
  socket
  <a class="anchor" href="#socket">#</a>
</h1>
<h2 id="我有这样一个开发场景服务端需要和多个客户端进行tcp连接服务端会发送指令给客户端客户端会返回指令执行结果客户端会定时返回心跳报文上报状态客户端会不定时上报事件报文我该怎么实现上述功能">
  我有这样一个开发场景，服务端需要和多个客户端进行tcp连接，服务端会发送指令给客户端，客户端会返回指令执行结果；客户端会定时返回心跳报文上报状态；客户端会不定时上报事件报文。我该怎么实现上述功能？
  <a class="anchor" href="#%e6%88%91%e6%9c%89%e8%bf%99%e6%a0%b7%e4%b8%80%e4%b8%aa%e5%bc%80%e5%8f%91%e5%9c%ba%e6%99%af%e6%9c%8d%e5%8a%a1%e7%ab%af%e9%9c%80%e8%a6%81%e5%92%8c%e5%a4%9a%e4%b8%aa%e5%ae%a2%e6%88%b7%e7%ab%af%e8%bf%9b%e8%a1%8ctcp%e8%bf%9e%e6%8e%a5%e6%9c%8d%e5%8a%a1%e7%ab%af%e4%bc%9a%e5%8f%91%e9%80%81%e6%8c%87%e4%bb%a4%e7%bb%99%e5%ae%a2%e6%88%b7%e7%ab%af%e5%ae%a2%e6%88%b7%e7%ab%af%e4%bc%9a%e8%bf%94%e5%9b%9e%e6%8c%87%e4%bb%a4%e6%89%a7%e8%a1%8c%e7%bb%93%e6%9e%9c%e5%ae%a2%e6%88%b7%e7%ab%af%e4%bc%9a%e5%ae%9a%e6%97%b6%e8%bf%94%e5%9b%9e%e5%bf%83%e8%b7%b3%e6%8a%a5%e6%96%87%e4%b8%8a%e6%8a%a5%e7%8a%b6%e6%80%81%e5%ae%a2%e6%88%b7%e7%ab%af%e4%bc%9a%e4%b8%8d%e5%ae%9a%e6%97%b6%e4%b8%8a%e6%8a%a5%e4%ba%8b%e4%bb%b6%e6%8a%a5%e6%96%87%e6%88%91%e8%af%a5%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e4%b8%8a%e8%bf%b0%e5%8a%9f%e8%83%bd">#</a>
</h2>
<p>要实现上述功能，可以按照以下步骤进行设计和开发：</p>
<h3 id="1-服务端设计">
  1. 服务端设计
  <a class="anchor" href="#1-%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%ae%be%e8%ae%a1">#</a>
</h3>
<h4 id="11-建立tcp连接">
  1.1 建立TCP连接
  <a class="anchor" href="#11-%e5%bb%ba%e7%ab%8btcp%e8%bf%9e%e6%8e%a5">#</a>
</h4>
<ul>
<li>使用一个主线程监听指定端口，接受客户端的连接请求。</li>
<li>为每个客户端连接创建一个独立的线程或使用I/O多路复用（如<code>select</code>、<code>poll</code>、<code>epoll</code>）处理多个连接。</li>
</ul>
<h4 id="12-指令发送">
  1.2 指令发送
  <a class="anchor" href="#12-%e6%8c%87%e4%bb%a4%e5%8f%91%e9%80%81">#</a>
</h4>
<ul>
<li>服务端根据需要向特定客户端发送指令，指令可以封装成特定的协议格式（如JSON、XML或自定义二进制格式）。</li>
<li>通过客户端的TCP连接发送指令，并等待客户端返回执行结果。</li>
</ul>
<h4 id="13-处理客户端返回">
  1.3 处理客户端返回
  <a class="anchor" href="#13-%e5%a4%84%e7%90%86%e5%ae%a2%e6%88%b7%e7%ab%af%e8%bf%94%e5%9b%9e">#</a>
</h4>
<ul>
<li>接收客户端返回的指令执行结果，解析并处理。</li>
<li>如果在一定时间内未收到响应，可以进行超时重发或标记客户端为不可用。</li>
</ul>
<h4 id="14-心跳处理">
  1.4 心跳处理
  <a class="anchor" href="#14-%e5%bf%83%e8%b7%b3%e5%a4%84%e7%90%86">#</a>
</h4>
<ul>
<li>接收客户端定时发送的心跳报文，更新客户端的状态和最后活跃时间。</li>
<li>如果长时间未收到心跳，可以认为客户端断开连接，进行清理。</li>
</ul>
<h4 id="15-事件处理">
  1.5 事件处理
  <a class="anchor" href="#15-%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86">#</a>
</h4>
<ul>
<li>接收客户端不定时发送的事件报文，解析并处理。</li>
<li>事件报文可能包含重要信息，需要及时处理。</li>
</ul>
<h3 id="2-客户端设计">
  2. 客户端设计
  <a class="anchor" href="#2-%e5%ae%a2%e6%88%b7%e7%ab%af%e8%ae%be%e8%ae%a1">#</a>
</h3>
<h4 id="21-连接服务端">
  2.1 连接服务端
  <a class="anchor" href="#21-%e8%bf%9e%e6%8e%a5%e6%9c%8d%e5%8a%a1%e7%ab%af">#</a>
</h4>
<ul>
<li>客户端启动时，主动连接服务端的指定IP和端口。</li>
<li>连接成功后，进入主循环等待服务端指令。</li>
</ul>
<h4 id="22-指令执行">
  2.2 指令执行
  <a class="anchor" href="#22-%e6%8c%87%e4%bb%a4%e6%89%a7%e8%a1%8c">#</a>
</h4>
<ul>
<li>接收服务端发送的指令，解析并执行。</li>
<li>执行完成后，将结果封装成协议格式，通过TCP连接返回给服务端。</li>
</ul>
<h4 id="23-心跳发送">
  2.3 心跳发送
  <a class="anchor" href="#23-%e5%bf%83%e8%b7%b3%e5%8f%91%e9%80%81">#</a>
</h4>
<ul>
<li>定时（如每30秒）向服务端发送心跳报文，报文可以简单包含客户端ID和当前状态。</li>
<li>心跳报文用于告知服务端客户端仍然存活。</li>
</ul>
<h4 id="24-事件上报">
  2.4 事件上报
  <a class="anchor" href="#24-%e4%ba%8b%e4%bb%b6%e4%b8%8a%e6%8a%a5">#</a>
</h4>
<ul>
<li>当客户端检测到某些事件发生时，主动将事件信息封装成协议格式，通过TCP连接发送给服务端。</li>
</ul>
<h3 id="3-协议设计">
  3. 协议设计
  <a class="anchor" href="#3-%e5%8d%8f%e8%ae%ae%e8%ae%be%e8%ae%a1">#</a>
</h3>
<p>为了确保服务端和客户端之间的通信有序，需要设计一个简单的通信协议。例如：</p>
<ul>
<li>
<p><strong>指令格式</strong>：</p>
<ul>
<li>指令类型（1字节）</li>
<li>指令长度（2字节）</li>
<li>指令数据（可变长度）</li>
</ul>
</li>
<li>
<p><strong>返回结果格式</strong>：</p>
<ul>
<li>返回码（1字节）</li>
<li>返回长度（2字节）</li>
<li>返回数据（可变长度）</li>
</ul>
</li>
<li>
<p><strong>心跳报文格式</strong>：</p>
<ul>
<li>心跳标识（1字节）</li>
<li>客户端ID（4字节）</li>
</ul>
</li>
<li>
<p><strong>事件报文格式</strong>：</p>
<ul>
<li>事件类型（1字节）</li>
<li>事件长度（2字节）</li>
<li>事件数据（可变长度）</li>
</ul>
</li>
</ul>
<h3 id="4-实现示例">
  4. 实现示例
  <a class="anchor" href="#4-%e5%ae%9e%e7%8e%b0%e7%a4%ba%e4%be%8b">#</a>
</h3>
<h4 id="服务端示例python伪代码">
  服务端示例（Python伪代码）
  <a class="anchor" href="#%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%a4%ba%e4%be%8bpython%e4%bc%aa%e4%bb%a3%e7%a0%81">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> threading
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">handle_client</span>(conn, addr):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> conn<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> data:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 解析和处理数据</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 发送响应</span>
</span></span><span style="display:flex;"><span>        conn<span style="color:#f92672">.</span>send(response)
</span></span><span style="display:flex;"><span>    conn<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>server <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_INET, socket<span style="color:#f92672">.</span>SOCK_STREAM)
</span></span><span style="display:flex;"><span>server<span style="color:#f92672">.</span>bind((<span style="color:#e6db74">&#39;0.0.0.0&#39;</span>, <span style="color:#ae81ff">12345</span>))
</span></span><span style="display:flex;"><span>server<span style="color:#f92672">.</span>listen(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    conn, addr <span style="color:#f92672">=</span> server<span style="color:#f92672">.</span>accept()
</span></span><span style="display:flex;"><span>    threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>handle_client, args<span style="color:#f92672">=</span>(conn, addr))<span style="color:#f92672">.</span>start()
</span></span></code></pre></div><h4 id="客户端示例python伪代码">
  客户端示例（Python伪代码）
  <a class="anchor" href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e7%a4%ba%e4%be%8bpython%e4%bc%aa%e4%bb%a3%e7%a0%81">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>client <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_INET, socket<span style="color:#f92672">.</span>SOCK_STREAM)
</span></span><span style="display:flex;"><span>client<span style="color:#f92672">.</span>connect((<span style="color:#e6db74">&#39;server_ip&#39;</span>, <span style="color:#ae81ff">12345</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">send_heartbeat</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">30</span>)
</span></span><span style="display:flex;"><span>        client<span style="color:#f92672">.</span>send(heartbeat_message)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">monitor_events</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        event <span style="color:#f92672">=</span> detect_event()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> event:
</span></span><span style="display:flex;"><span>            client<span style="color:#f92672">.</span>send(event_message)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 启动心跳和事件监控线程</span>
</span></span><span style="display:flex;"><span>threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>send_heartbeat)<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>monitor_events)<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> client<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> data:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 解析和处理指令</span>
</span></span><span style="display:flex;"><span>        client<span style="color:#f92672">.</span>send(response)
</span></span></code></pre></div><h3 id="5-注意事项">
  5. 注意事项
  <a class="anchor" href="#5-%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">#</a>
</h3>
<ul>
<li><strong>并发处理</strong>：服务端需要处理多个客户端连接，确保并发处理能力。</li>
<li><strong>异常处理</strong>：网络连接可能不稳定，需要处理各种异常情况（如连接断开、超时等）。</li>
<li><strong>安全性</strong>：考虑使用SSL/TLS加密通信，防止数据被窃听或篡改。</li>
<li><strong>性能优化</strong>：根据实际需求，选择合适的I/O模型（如异步I/O）和协议格式，优化性能。</li>
</ul>
<p>通过以上设计和实现，可以满足服务端与多个客户端之间的TCP通信需求。</p>
<h2 id="如果我使用io多路复用来实现给我一个java版本代码示例">
  如果我使用IO多路复用来实现，给我一个java版本代码示例
  <a class="anchor" href="#%e5%a6%82%e6%9e%9c%e6%88%91%e4%bd%bf%e7%94%a8io%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8%e6%9d%a5%e5%ae%9e%e7%8e%b0%e7%bb%99%e6%88%91%e4%b8%80%e4%b8%aajava%e7%89%88%e6%9c%ac%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b">#</a>
</h2>
<p>使用I/O多路复用（如Java NIO）可以更高效地处理多个客户端连接。以下是一个基于Java NIO的示例代码，展示了如何实现服务端与多个客户端的TCP通信，包括指令发送、心跳处理和事件上报。</p>
<h3 id="服务端代码示例">
  服务端代码示例
  <a class="anchor" href="#%e6%9c%8d%e5%8a%a1%e7%ab%af%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.IOException;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.net.InetSocketAddress;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.ByteBuffer;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.channels.*;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Iterator;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Set;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NIOServer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> PORT <span style="color:#f92672">=</span> 12345;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> BUFFER_SIZE <span style="color:#f92672">=</span> 1024;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建Selector</span>
</span></span><span style="display:flex;"><span>        Selector selector <span style="color:#f92672">=</span> Selector.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建ServerSocketChannel并绑定端口</span>
</span></span><span style="display:flex;"><span>        ServerSocketChannel serverSocketChannel <span style="color:#f92672">=</span> ServerSocketChannel.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        serverSocketChannel.<span style="color:#a6e22e">bind</span>(<span style="color:#66d9ef">new</span> InetSocketAddress(PORT));
</span></span><span style="display:flex;"><span>        serverSocketChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>        serverSocketChannel.<span style="color:#a6e22e">register</span>(selector, SelectionKey.<span style="color:#a6e22e">OP_ACCEPT</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Server started on port &#34;</span> <span style="color:#f92672">+</span> PORT);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 阻塞等待就绪的Channel</span>
</span></span><span style="display:flex;"><span>            selector.<span style="color:#a6e22e">select</span>();
</span></span><span style="display:flex;"><span>            Set<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> selectedKeys <span style="color:#f92672">=</span> selector.<span style="color:#a6e22e">selectedKeys</span>();
</span></span><span style="display:flex;"><span>            Iterator<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> selectedKeys.<span style="color:#a6e22e">iterator</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (iterator.<span style="color:#a6e22e">hasNext</span>()) {
</span></span><span style="display:flex;"><span>                SelectionKey key <span style="color:#f92672">=</span> iterator.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>                iterator.<span style="color:#a6e22e">remove</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isAcceptable</span>()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 接受客户端连接</span>
</span></span><span style="display:flex;"><span>                    ServerSocketChannel serverChannel <span style="color:#f92672">=</span> (ServerSocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                    SocketChannel clientChannel <span style="color:#f92672">=</span> serverChannel.<span style="color:#a6e22e">accept</span>();
</span></span><span style="display:flex;"><span>                    clientChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>                    clientChannel.<span style="color:#a6e22e">register</span>(selector, SelectionKey.<span style="color:#a6e22e">OP_READ</span>);
</span></span><span style="display:flex;"><span>                    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Client connected: &#34;</span> <span style="color:#f92672">+</span> clientChannel.<span style="color:#a6e22e">getRemoteAddress</span>());
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isReadable</span>()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 读取客户端数据</span>
</span></span><span style="display:flex;"><span>                    SocketChannel clientChannel <span style="color:#f92672">=</span> (SocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                    ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">allocate</span>(BUFFER_SIZE);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> bytesRead <span style="color:#f92672">=</span> clientChannel.<span style="color:#a6e22e">read</span>(buffer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 客户端断开连接</span>
</span></span><span style="display:flex;"><span>                        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Client disconnected: &#34;</span> <span style="color:#f92672">+</span> clientChannel.<span style="color:#a6e22e">getRemoteAddress</span>());
</span></span><span style="display:flex;"><span>                        clientChannel.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 处理接收到的数据</span>
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">flip</span>();
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>buffer.<span style="color:#a6e22e">remaining</span>()<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">get</span>(data);
</span></span><span style="display:flex;"><span>                        String message <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String(data);
</span></span><span style="display:flex;"><span>                        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Received from client: &#34;</span> <span style="color:#f92672">+</span> message);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 根据消息类型处理</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (message.<span style="color:#a6e22e">startsWith</span>(<span style="color:#e6db74">&#34;HEARTBEAT&#34;</span>)) {
</span></span><span style="display:flex;"><span>                            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Heartbeat received from client: &#34;</span> <span style="color:#f92672">+</span> clientChannel.<span style="color:#a6e22e">getRemoteAddress</span>());
</span></span><span style="display:flex;"><span>                        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (message.<span style="color:#a6e22e">startsWith</span>(<span style="color:#e6db74">&#34;EVENT&#34;</span>)) {
</span></span><span style="display:flex;"><span>                            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Event received from client: &#34;</span> <span style="color:#f92672">+</span> clientChannel.<span style="color:#a6e22e">getRemoteAddress</span>());
</span></span><span style="display:flex;"><span>                        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e">// 发送指令响应</span>
</span></span><span style="display:flex;"><span>                            String response <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ACK: &#34;</span> <span style="color:#f92672">+</span> message;
</span></span><span style="display:flex;"><span>                            ByteBuffer responseBuffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">wrap</span>(response.<span style="color:#a6e22e">getBytes</span>());
</span></span><span style="display:flex;"><span>                            clientChannel.<span style="color:#a6e22e">write</span>(responseBuffer);
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="客户端代码示例">
  客户端代码示例
  <a class="anchor" href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.IOException;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.net.InetSocketAddress;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.ByteBuffer;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.channels.SocketChannel;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Scanner;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Executors;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ScheduledExecutorService;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.TimeUnit;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NIOClient</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String SERVER_IP <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;localhost&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> SERVER_PORT <span style="color:#f92672">=</span> 12345;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> BUFFER_SIZE <span style="color:#f92672">=</span> 1024;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 连接服务器</span>
</span></span><span style="display:flex;"><span>        SocketChannel socketChannel <span style="color:#f92672">=</span> SocketChannel.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        socketChannel.<span style="color:#a6e22e">connect</span>(<span style="color:#66d9ef">new</span> InetSocketAddress(SERVER_IP, SERVER_PORT));
</span></span><span style="display:flex;"><span>        socketChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connected to server at &#34;</span> <span style="color:#f92672">+</span> SERVER_IP <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> SERVER_PORT);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 定时发送心跳</span>
</span></span><span style="display:flex;"><span>        ScheduledExecutorService scheduler <span style="color:#f92672">=</span> Executors.<span style="color:#a6e22e">newScheduledThreadPool</span>(1);
</span></span><span style="display:flex;"><span>        scheduler.<span style="color:#a6e22e">scheduleAtFixedRate</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                String heartbeat <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;HEARTBEAT&#34;</span>;
</span></span><span style="display:flex;"><span>                ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">wrap</span>(heartbeat.<span style="color:#a6e22e">getBytes</span>());
</span></span><span style="display:flex;"><span>                socketChannel.<span style="color:#a6e22e">write</span>(buffer);
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Sent heartbeat to server&#34;</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>                e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }, 0, 30, TimeUnit.<span style="color:#a6e22e">SECONDS</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 监听服务器指令</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">allocate</span>(BUFFER_SIZE);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> bytesRead <span style="color:#f92672">=</span> socketChannel.<span style="color:#a6e22e">read</span>(buffer);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">flip</span>();
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>buffer.<span style="color:#a6e22e">remaining</span>()<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">get</span>(data);
</span></span><span style="display:flex;"><span>                        String message <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String(data);
</span></span><span style="display:flex;"><span>                        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Received from server: &#34;</span> <span style="color:#f92672">+</span> message);
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">clear</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }).<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 模拟事件上报</span>
</span></span><span style="display:flex;"><span>        Scanner scanner <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Enter an event to send (or &#39;exit&#39; to quit):&#34;</span>);
</span></span><span style="display:flex;"><span>            String input <span style="color:#f92672">=</span> scanner.<span style="color:#a6e22e">nextLine</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#34;exit&#34;</span>.<span style="color:#a6e22e">equalsIgnoreCase</span>(input)) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            String event <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;EVENT: &#34;</span> <span style="color:#f92672">+</span> input;
</span></span><span style="display:flex;"><span>            ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">wrap</span>(event.<span style="color:#a6e22e">getBytes</span>());
</span></span><span style="display:flex;"><span>            socketChannel.<span style="color:#a6e22e">write</span>(buffer);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Sent event to server: &#34;</span> <span style="color:#f92672">+</span> event);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关闭连接</span>
</span></span><span style="display:flex;"><span>        socketChannel.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>        scheduler.<span style="color:#a6e22e">shutdown</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Disconnected from server&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="代码说明-1">
  代码说明
  <a class="anchor" href="#%e4%bb%a3%e7%a0%81%e8%af%b4%e6%98%8e-1">#</a>
</h3>
<ol>
<li>
<p><strong>服务端</strong>：</p>
<ul>
<li>使用<code>Selector</code>监听多个客户端连接。</li>
<li>处理客户端连接、读取数据、发送响应。</li>
<li>根据接收到的消息类型（心跳、事件、指令）进行相应处理。</li>
</ul>
</li>
<li>
<p><strong>客户端</strong>：</p>
<ul>
<li>连接服务端并定时发送心跳报文。</li>
<li>监听服务端指令并打印响应。</li>
<li>支持用户输入模拟事件上报。</li>
</ul>
</li>
<li>
<p><strong>协议</strong>：</p>
<ul>
<li>使用简单的字符串协议，例如：
<ul>
<li>心跳报文：<code>HEARTBEAT</code></li>
<li>事件报文：<code>EVENT: &lt;event_data&gt;</code></li>
<li>指令响应：<code>ACK: &lt;message&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>并发</strong>：</p>
<ul>
<li>使用<code>ScheduledExecutorService</code>定时发送心跳。</li>
<li>使用单独的线程监听服务端指令。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="运行方式">
  运行方式
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e6%96%b9%e5%bc%8f">#</a>
</h3>
<ol>
<li>启动服务端：<code>java NIOServer</code></li>
<li>启动一个或多个客户端：<code>java NIOClient</code></li>
<li>在客户端输入事件内容，观察服务端和客户端的日志输出。</li>
</ol>
<hr>
<h3 id="扩展建议">
  扩展建议
  <a class="anchor" href="#%e6%89%a9%e5%b1%95%e5%bb%ba%e8%ae%ae">#</a>
</h3>
<ul>
<li><strong>协议优化</strong>：可以使用更复杂的协议（如JSON或自定义二进制协议）来封装数据。</li>
<li><strong>异常处理</strong>：增加对网络异常、超时等的处理逻辑。</li>
<li><strong>性能优化</strong>：根据实际需求调整缓冲区大小、线程池配置等。</li>
</ul>
<h2 id="我有一个服务端需要连接多个服务端进行tcp连接给我一个java的代码示例">
  我有一个服务端，需要连接多个服务端进行tcp连接，给我一个java的代码示例
  <a class="anchor" href="#%e6%88%91%e6%9c%89%e4%b8%80%e4%b8%aa%e6%9c%8d%e5%8a%a1%e7%ab%af%e9%9c%80%e8%a6%81%e8%bf%9e%e6%8e%a5%e5%a4%9a%e4%b8%aa%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%bf%9b%e8%a1%8ctcp%e8%bf%9e%e6%8e%a5%e7%bb%99%e6%88%91%e4%b8%80%e4%b8%aajava%e7%9a%84%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b">#</a>
</h2>
<p>以下是基于Java NIO的实现示例，展示了一个服务端如何连接多个服务端并进行TCP通信。该示例使用了<code>Selector</code>实现I/O多路复用，能够高效处理多个连接。</p>
<h3 id="代码示例">
  代码示例
  <a class="anchor" href="#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.IOException;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.net.InetSocketAddress;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.ByteBuffer;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.channels.*;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Iterator;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Set;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MultiServerConnector</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> BUFFER_SIZE <span style="color:#f92672">=</span> 1024;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建Selector</span>
</span></span><span style="display:flex;"><span>        Selector selector <span style="color:#f92672">=</span> Selector.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 连接多个服务端</span>
</span></span><span style="display:flex;"><span>        connectToServers(selector, <span style="color:#66d9ef">new</span> String<span style="color:#f92672">[]</span>{<span style="color:#e6db74">&#34;127.0.0.1:8081&#34;</span>, <span style="color:#e6db74">&#34;127.0.0.1:8082&#34;</span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connected to multiple servers.&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 阻塞等待就绪的Channel</span>
</span></span><span style="display:flex;"><span>            selector.<span style="color:#a6e22e">select</span>();
</span></span><span style="display:flex;"><span>            Set<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> selectedKeys <span style="color:#f92672">=</span> selector.<span style="color:#a6e22e">selectedKeys</span>();
</span></span><span style="display:flex;"><span>            Iterator<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> selectedKeys.<span style="color:#a6e22e">iterator</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (iterator.<span style="color:#a6e22e">hasNext</span>()) {
</span></span><span style="display:flex;"><span>                SelectionKey key <span style="color:#f92672">=</span> iterator.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>                iterator.<span style="color:#a6e22e">remove</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isConnectable</span>()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 处理连接完成事件</span>
</span></span><span style="display:flex;"><span>                    SocketChannel clientChannel <span style="color:#f92672">=</span> (SocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (clientChannel.<span style="color:#a6e22e">isConnectionPending</span>()) {
</span></span><span style="display:flex;"><span>                        clientChannel.<span style="color:#a6e22e">finishConnect</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    clientChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>                    clientChannel.<span style="color:#a6e22e">register</span>(selector, SelectionKey.<span style="color:#a6e22e">OP_READ</span>);
</span></span><span style="display:flex;"><span>                    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connected to server: &#34;</span> <span style="color:#f92672">+</span> clientChannel.<span style="color:#a6e22e">getRemoteAddress</span>());
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isReadable</span>()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 处理读取事件</span>
</span></span><span style="display:flex;"><span>                    SocketChannel clientChannel <span style="color:#f92672">=</span> (SocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                    ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">allocate</span>(BUFFER_SIZE);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> bytesRead <span style="color:#f92672">=</span> clientChannel.<span style="color:#a6e22e">read</span>(buffer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 服务端断开连接</span>
</span></span><span style="display:flex;"><span>                        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Server disconnected: &#34;</span> <span style="color:#f92672">+</span> clientChannel.<span style="color:#a6e22e">getRemoteAddress</span>());
</span></span><span style="display:flex;"><span>                        clientChannel.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 处理接收到的数据</span>
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">flip</span>();
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>buffer.<span style="color:#a6e22e">remaining</span>()<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">get</span>(data);
</span></span><span style="display:flex;"><span>                        String message <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String(data);
</span></span><span style="display:flex;"><span>                        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Received from server: &#34;</span> <span style="color:#f92672">+</span> message);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 连接多个服务端</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">connectToServers</span>(Selector selector, String<span style="color:#f92672">[]</span> serverAddresses) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (String address : serverAddresses) {
</span></span><span style="display:flex;"><span>            String<span style="color:#f92672">[]</span> parts <span style="color:#f92672">=</span> address.<span style="color:#a6e22e">split</span>(<span style="color:#e6db74">&#34;:&#34;</span>);
</span></span><span style="display:flex;"><span>            String host <span style="color:#f92672">=</span> parts<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> port <span style="color:#f92672">=</span> Integer.<span style="color:#a6e22e">parseInt</span>(parts<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 创建SocketChannel并连接服务端</span>
</span></span><span style="display:flex;"><span>            SocketChannel clientChannel <span style="color:#f92672">=</span> SocketChannel.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>            clientChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>            clientChannel.<span style="color:#a6e22e">connect</span>(<span style="color:#66d9ef">new</span> InetSocketAddress(host, port));
</span></span><span style="display:flex;"><span>            clientChannel.<span style="color:#a6e22e">register</span>(selector, SelectionKey.<span style="color:#a6e22e">OP_CONNECT</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="代码说明-2">
  代码说明
  <a class="anchor" href="#%e4%bb%a3%e7%a0%81%e8%af%b4%e6%98%8e-2">#</a>
</h3>
<ol>
<li>
<p><strong><code>Selector</code></strong>：</p>
<ul>
<li>使用<code>Selector</code>监听多个服务端的连接和读取事件，实现I/O多路复用<a href="@ref">1</a><a href="@ref">2</a>。</li>
</ul>
</li>
<li>
<p><strong>连接多个服务端</strong>：</p>
<ul>
<li>在<code>connectToServers</code>方法中，遍历服务端地址列表，创建<code>SocketChannel</code>并连接服务端。</li>
<li>将<code>SocketChannel</code>注册到<code>Selector</code>，监听<code>OP_CONNECT</code>事件。</li>
</ul>
</li>
<li>
<p><strong>处理连接完成事件</strong>：</p>
<ul>
<li>当<code>SocketChannel</code>连接成功时，触发<code>OP_CONNECT</code>事件，调用<code>finishConnect</code>完成连接，并注册<code>OP_READ</code>事件以监听数据读取。</li>
</ul>
</li>
<li>
<p><strong>处理读取事件</strong>：</p>
<ul>
<li>当服务端发送数据时，触发<code>OP_READ</code>事件，读取数据并处理。</li>
</ul>
</li>
<li>
<p><strong>异常处理</strong>：</p>
<ul>
<li>如果服务端断开连接，关闭<code>SocketChannel</code>并清理资源。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="运行方式-1">
  运行方式
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e6%96%b9%e5%bc%8f-1">#</a>
</h3>
<ol>
<li>启动多个服务端，分别监听<code>8081</code>和<code>8082</code>端口。</li>
<li>运行<code>MultiServerConnector</code>，它将连接这些服务端并处理数据。</li>
</ol>
<hr>
<h3 id="参考">
  参考
  <a class="anchor" href="#%e5%8f%82%e8%80%83">#</a>
</h3>
<ul>
<li>使用<code>Selector</code>实现I/O多路复用<a href="@ref">1</a><a href="@ref">2</a>。</li>
<li>连接多个服务端的最佳实践<a href="@ref">3</a>。</li>
</ul>
<hr>
<h3 id="扩展建议-1">
  扩展建议
  <a class="anchor" href="#%e6%89%a9%e5%b1%95%e5%bb%ba%e8%ae%ae-1">#</a>
</h3>
<ul>
<li><strong>心跳机制</strong>：可以定时向服务端发送心跳报文，检测连接状态<a href="@ref">1</a>。</li>
<li><strong>协议设计</strong>：使用更复杂的协议（如JSON或自定义二进制协议）封装数据<a href="@ref">2</a>。</li>
<li><strong>异常重连</strong>：在连接断开时实现自动重连机制<a href="@ref">3</a>。</li>
</ul>
<h2 id="我在tcp连接的过程中可能会新增连接修改连接信息ip或端口号或者删除连接这个该怎么实现">
  我在tcp连接的过程中，可能会新增连接，修改连接信息（ip或端口号）或者删除连接，这个该怎么实现
  <a class="anchor" href="#%e6%88%91%e5%9c%a8tcp%e8%bf%9e%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b%e4%b8%ad%e5%8f%af%e8%83%bd%e4%bc%9a%e6%96%b0%e5%a2%9e%e8%bf%9e%e6%8e%a5%e4%bf%ae%e6%94%b9%e8%bf%9e%e6%8e%a5%e4%bf%a1%e6%81%afip%e6%88%96%e7%ab%af%e5%8f%a3%e5%8f%b7%e6%88%96%e8%80%85%e5%88%a0%e9%99%a4%e8%bf%9e%e6%8e%a5%e8%bf%99%e4%b8%aa%e8%af%a5%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0">#</a>
</h2>
<p>为了支持在TCP连接过程中动态新增连接、修改连接信息（如IP或端口号）或删除连接，可以使用以下设计思路：</p>
<hr>
<h3 id="设计思路">
  设计思路
  <a class="anchor" href="#%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af">#</a>
</h3>
<ol>
<li>
<p><strong>连接管理</strong>：</p>
<ul>
<li>使用一个<code>Map</code>来管理所有连接，键为连接的唯一标识（如<code>ip:port</code>），值为<code>SocketChannel</code>。</li>
<li>提供方法来新增、修改和删除连接。</li>
</ul>
</li>
<li>
<p><strong>动态更新连接</strong>：</p>
<ul>
<li>新增连接：创建新的<code>SocketChannel</code>并注册到<code>Selector</code>。</li>
<li>修改连接信息：先关闭旧的<code>SocketChannel</code>，然后使用新的IP和端口创建新的连接。</li>
<li>删除连接：关闭<code>SocketChannel</code>并从<code>Map</code>中移除。</li>
</ul>
</li>
<li>
<p><strong>线程安全</strong>：</p>
<ul>
<li>使用<code>ConcurrentHashMap</code>管理连接，确保多线程操作的安全性。</li>
<li>在修改连接信息时，使用同步机制（如<code>synchronized</code>）避免竞争条件。</li>
</ul>
</li>
<li>
<p><strong>事件处理</strong>：</p>
<ul>
<li>使用<code>Selector</code>监听所有连接的读写事件。</li>
<li>在事件循环中处理连接的新增、修改和删除操作。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="代码实现">
  代码实现
  <a class="anchor" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">#</a>
</h3>
<p>以下是完整的Java实现示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.IOException;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.net.InetSocketAddress;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.ByteBuffer;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.channels.*;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Iterator;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Map;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Set;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ConcurrentHashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DynamicTCPConnector</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> BUFFER_SIZE <span style="color:#f92672">=</span> 1024;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Selector selector;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Map<span style="color:#f92672">&lt;</span>String, SocketChannel<span style="color:#f92672">&gt;</span> connections;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DynamicTCPConnector</span>() <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">selector</span> <span style="color:#f92672">=</span> Selector.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">connections</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ConcurrentHashMap<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start</span>() <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Dynamic TCP Connector started.&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>            selector.<span style="color:#a6e22e">select</span>();
</span></span><span style="display:flex;"><span>            Set<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> selectedKeys <span style="color:#f92672">=</span> selector.<span style="color:#a6e22e">selectedKeys</span>();
</span></span><span style="display:flex;"><span>            Iterator<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> selectedKeys.<span style="color:#a6e22e">iterator</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (iterator.<span style="color:#a6e22e">hasNext</span>()) {
</span></span><span style="display:flex;"><span>                SelectionKey key <span style="color:#f92672">=</span> iterator.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>                iterator.<span style="color:#a6e22e">remove</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isConnectable</span>()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 处理连接完成事件</span>
</span></span><span style="display:flex;"><span>                    SocketChannel clientChannel <span style="color:#f92672">=</span> (SocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (clientChannel.<span style="color:#a6e22e">isConnectionPending</span>()) {
</span></span><span style="display:flex;"><span>                        clientChannel.<span style="color:#a6e22e">finishConnect</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    clientChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>                    clientChannel.<span style="color:#a6e22e">register</span>(selector, SelectionKey.<span style="color:#a6e22e">OP_READ</span>);
</span></span><span style="display:flex;"><span>                    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connected to server: &#34;</span> <span style="color:#f92672">+</span> clientChannel.<span style="color:#a6e22e">getRemoteAddress</span>());
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isReadable</span>()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 处理读取事件</span>
</span></span><span style="display:flex;"><span>                    SocketChannel clientChannel <span style="color:#f92672">=</span> (SocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                    ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">allocate</span>(BUFFER_SIZE);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> bytesRead <span style="color:#f92672">=</span> clientChannel.<span style="color:#a6e22e">read</span>(buffer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 服务端断开连接</span>
</span></span><span style="display:flex;"><span>                        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Server disconnected: &#34;</span> <span style="color:#f92672">+</span> clientChannel.<span style="color:#a6e22e">getRemoteAddress</span>());
</span></span><span style="display:flex;"><span>                        clientChannel.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>                        removeConnection(clientChannel);
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 处理接收到的数据</span>
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">flip</span>();
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>buffer.<span style="color:#a6e22e">remaining</span>()<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">get</span>(data);
</span></span><span style="display:flex;"><span>                        String message <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String(data);
</span></span><span style="display:flex;"><span>                        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Received from server: &#34;</span> <span style="color:#f92672">+</span> message);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新增连接</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addConnection</span>(String ip, <span style="color:#66d9ef">int</span> port) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        String key <span style="color:#f92672">=</span> ip <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> port;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (connections.<span style="color:#a6e22e">containsKey</span>(key)) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connection already exists: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        SocketChannel clientChannel <span style="color:#f92672">=</span> SocketChannel.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        clientChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>        clientChannel.<span style="color:#a6e22e">connect</span>(<span style="color:#66d9ef">new</span> InetSocketAddress(ip, port));
</span></span><span style="display:flex;"><span>        clientChannel.<span style="color:#a6e22e">register</span>(selector, SelectionKey.<span style="color:#a6e22e">OP_CONNECT</span>);
</span></span><span style="display:flex;"><span>        connections.<span style="color:#a6e22e">put</span>(key, clientChannel);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Added new connection: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改连接信息</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">updateConnection</span>(String oldIp, <span style="color:#66d9ef">int</span> oldPort, String newIp, <span style="color:#66d9ef">int</span> newPort) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        String oldKey <span style="color:#f92672">=</span> oldIp <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> oldPort;
</span></span><span style="display:flex;"><span>        String newKey <span style="color:#f92672">=</span> newIp <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> newPort;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>connections.<span style="color:#a6e22e">containsKey</span>(oldKey)) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connection not found: &#34;</span> <span style="color:#f92672">+</span> oldKey);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关闭旧连接</span>
</span></span><span style="display:flex;"><span>        SocketChannel oldChannel <span style="color:#f92672">=</span> connections.<span style="color:#a6e22e">get</span>(oldKey);
</span></span><span style="display:flex;"><span>        oldChannel.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>        connections.<span style="color:#a6e22e">remove</span>(oldKey);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建新连接</span>
</span></span><span style="display:flex;"><span>        addConnection(newIp, newPort);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Updated connection from &#34;</span> <span style="color:#f92672">+</span> oldKey <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; to &#34;</span> <span style="color:#f92672">+</span> newKey);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 删除连接</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">removeConnection</span>(SocketChannel channel) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        String key <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (Map.<span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>String, SocketChannel<span style="color:#f92672">&gt;</span> entry : connections.<span style="color:#a6e22e">entrySet</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (entry.<span style="color:#a6e22e">getValue</span>().<span style="color:#a6e22e">equals</span>(channel)) {
</span></span><span style="display:flex;"><span>                key <span style="color:#f92672">=</span> entry.<span style="color:#a6e22e">getKey</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            connections.<span style="color:#a6e22e">remove</span>(key);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Removed connection: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        DynamicTCPConnector connector <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DynamicTCPConnector();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 启动事件循环</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                connector.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>                e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }).<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 示例：动态管理连接</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 新增连接</span>
</span></span><span style="display:flex;"><span>            connector.<span style="color:#a6e22e">addConnection</span>(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8081);
</span></span><span style="display:flex;"><span>            connector.<span style="color:#a6e22e">addConnection</span>(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8082);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 修改连接</span>
</span></span><span style="display:flex;"><span>            Thread.<span style="color:#a6e22e">sleep</span>(5000);
</span></span><span style="display:flex;"><span>            connector.<span style="color:#a6e22e">updateConnection</span>(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8081, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8083);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 删除连接</span>
</span></span><span style="display:flex;"><span>            Thread.<span style="color:#a6e22e">sleep</span>(5000);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (SocketChannel channel : connector.<span style="color:#a6e22e">connections</span>.<span style="color:#a6e22e">values</span>()) {
</span></span><span style="display:flex;"><span>                connector.<span style="color:#a6e22e">removeConnection</span>(channel);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="代码说明-3">
  代码说明
  <a class="anchor" href="#%e4%bb%a3%e7%a0%81%e8%af%b4%e6%98%8e-3">#</a>
</h3>
<ol>
<li>
<p><strong><code>DynamicTCPConnector</code>类</strong>：</p>
<ul>
<li>使用<code>Selector</code>监听所有连接的读写事件。</li>
<li>使用<code>ConcurrentHashMap</code>管理所有连接。</li>
</ul>
</li>
<li>
<p><strong>动态管理连接</strong>：</p>
<ul>
<li><code>addConnection</code>：新增连接。</li>
<li><code>updateConnection</code>：修改连接信息（先关闭旧连接，再创建新连接）。</li>
<li><code>removeConnection</code>：删除连接。</li>
</ul>
</li>
<li>
<p><strong>事件处理</strong>：</p>
<ul>
<li>处理连接完成事件（<code>OP_CONNECT</code>）。</li>
<li>处理读取事件（<code>OP_READ</code>）。</li>
</ul>
</li>
<li>
<p><strong>线程安全</strong>：</p>
<ul>
<li>使用<code>ConcurrentHashMap</code>确保多线程操作的安全性。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="运行方式-2">
  运行方式
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e6%96%b9%e5%bc%8f-2">#</a>
</h3>
<ol>
<li>启动多个服务端，分别监听<code>8081</code>、<code>8082</code>和<code>8083</code>端口。</li>
<li>运行<code>DynamicTCPConnector</code>，它将动态管理连接并与服务端通信。</li>
</ol>
<hr>
<h3 id="扩展建议-2">
  扩展建议
  <a class="anchor" href="#%e6%89%a9%e5%b1%95%e5%bb%ba%e8%ae%ae-2">#</a>
</h3>
<ul>
<li><strong>心跳机制</strong>：可以定时向服务端发送心跳报文，检测连接状态。</li>
<li><strong>异常重连</strong>：在连接断开时实现自动重连机制。</li>
<li><strong>日志记录</strong>：记录连接的新增、修改和删除操作，便于排查问题。</li>
</ul>
<h2 id="使用-socketchannel-的-close-方法是否会导致tcp连接还在传输数据的时候意外断开的情况">
  使用 socketChannel 的 close 方法，是否会导致tcp连接还在传输数据的时候意外断开的情况
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8-socketchannel-%e7%9a%84-close-%e6%96%b9%e6%b3%95%e6%98%af%e5%90%a6%e4%bc%9a%e5%af%bc%e8%87%b4tcp%e8%bf%9e%e6%8e%a5%e8%bf%98%e5%9c%a8%e4%bc%a0%e8%be%93%e6%95%b0%e6%8d%ae%e7%9a%84%e6%97%b6%e5%80%99%e6%84%8f%e5%a4%96%e6%96%ad%e5%bc%80%e7%9a%84%e6%83%85%e5%86%b5">#</a>
</h2>
<p>使用 <code>SocketChannel</code> 的 <code>close</code> 方法时，<strong>不会</strong>导致 TCP 连接在传输数据时意外断开。<code>close</code> 方法会按照 TCP 协议的正常流程关闭连接，确保数据传输的完整性。以下是详细说明：</p>
<hr>
<h3 id="1-socketchannelclose">
  1. <strong><code>SocketChannel.close</code> 的行为</strong>
  <a class="anchor" href="#1-socketchannelclose">#</a>
</h3>
<p>当调用 <code>SocketChannel.close</code> 方法时，底层 TCP 协议会执行以下操作：</p>
<ul>
<li>如果连接处于数据传输状态，<code>close</code> 会触发 TCP 的<strong>四次挥手</strong>过程，确保双方都能正常关闭连接。</li>
<li><code>close</code> 方法会发送 <code>FIN</code> 报文给对方，表示本方不再发送数据，但仍可以接收对方的数据，直到对方也发送 <code>FIN</code> 报文<a href="@ref">1</a><a href="@ref">5</a>。</li>
</ul>
<hr>
<h3 id="2-数据传输中的关闭">
  2. <strong>数据传输中的关闭</strong>
  <a class="anchor" href="#2-%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93%e4%b8%ad%e7%9a%84%e5%85%b3%e9%97%ad">#</a>
</h3>
<p>如果在数据传输过程中调用 <code>close</code> 方法，TCP 协议会确保以下行为：</p>
<ul>
<li>已经发送的数据会继续传输，直到对方确认接收。</li>
<li>对方可以继续发送数据，直到本方也发送 <code>FIN</code> 报文。</li>
<li>只有在双方都完成数据传输并确认后，连接才会完全关闭<a href="@ref">2</a><a href="@ref">5</a>。</li>
</ul>
<p>因此，<code>close</code> 方法不会导致数据意外丢失或连接意外断开。</p>
<hr>
<h3 id="3-异常情况">
  3. <strong>异常情况</strong>
  <a class="anchor" href="#3-%e5%bc%82%e5%b8%b8%e6%83%85%e5%86%b5">#</a>
</h3>
<p>在以下异常情况下，<code>close</code> 方法可能会导致连接异常断开：</p>
<ul>
<li><strong>网络故障</strong>：如果网络在关闭过程中发生故障，可能导致 <code>FIN</code> 报文无法送达对方，从而触发超时重传机制<a href="@ref">2</a>。</li>
<li><strong>进程崩溃</strong>：如果调用 <code>close</code> 的进程突然崩溃，操作系统会强制关闭连接，可能导致数据未完全传输<a href="@ref">2</a>。</li>
</ul>
<hr>
<h3 id="4-最佳实践">
  4. <strong>最佳实践</strong>
  <a class="anchor" href="#4-%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5">#</a>
</h3>
<p>为了避免意外情况，建议在调用 <code>close</code> 方法前：</p>
<ul>
<li>确保所有数据都已发送并确认（例如，调用 <code>SocketChannel.finishConnect</code> 或检查 <code>SocketChannel.write</code> 的返回值）<a href="@ref">1</a><a href="@ref">4</a>。</li>
<li>使用 <code>SocketChannel.shutdownOutput</code> 先关闭输出流，确保对方知道本方不再发送数据，然后再调用 <code>close</code><a href="@ref">5</a>。</li>
</ul>
<hr>
<h3 id="总结-7">
  总结
  <a class="anchor" href="#%e6%80%bb%e7%bb%93-7">#</a>
</h3>
<p><code>SocketChannel.close</code> 方法会按照 TCP 协议的正常流程关闭连接，<strong>不会</strong>导致数据传输时意外断开。但在网络故障或进程崩溃等异常情况下，可能会导致连接异常关闭。因此，建议在关闭连接前确保数据传输完成，并遵循 TCP 关闭的最佳实践<a href="@ref">1</a><a href="@ref">2</a><a href="@ref">5</a>。</p>
<h2 id="我还需要实现对特定连接发送命令报文">
  我还需要实现对特定连接发送命令报文
  <a class="anchor" href="#%e6%88%91%e8%bf%98%e9%9c%80%e8%a6%81%e5%ae%9e%e7%8e%b0%e5%af%b9%e7%89%b9%e5%ae%9a%e8%bf%9e%e6%8e%a5%e5%8f%91%e9%80%81%e5%91%bd%e4%bb%a4%e6%8a%a5%e6%96%87">#</a>
</h2>
<p>为了实现向特定连接发送命令报文，可以在现有的 <code>DynamicTCPConnector</code> 基础上增加以下功能：</p>
<ol>
<li><strong>查找特定连接</strong>：根据连接的标识（如 <code>ip:port</code>）查找对应的 <code>SocketChannel</code>。</li>
<li><strong>发送命令报文</strong>：通过 <code>SocketChannel.write</code> 方法向特定连接发送数据。</li>
<li><strong>线程安全</strong>：确保在发送数据时，连接不会被意外关闭或修改。</li>
</ol>
<p>以下是完整的实现示例：</p>
<hr>
<h3 id="代码实现-1">
  代码实现
  <a class="anchor" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.IOException;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.net.InetSocketAddress;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.ByteBuffer;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.channels.*;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Iterator;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Map;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Set;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ConcurrentHashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DynamicTCPConnector</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> BUFFER_SIZE <span style="color:#f92672">=</span> 1024;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Selector selector;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Map<span style="color:#f92672">&lt;</span>String, SocketChannel<span style="color:#f92672">&gt;</span> connections;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DynamicTCPConnector</span>() <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">selector</span> <span style="color:#f92672">=</span> Selector.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">connections</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ConcurrentHashMap<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start</span>() <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Dynamic TCP Connector started.&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>            selector.<span style="color:#a6e22e">select</span>();
</span></span><span style="display:flex;"><span>            Set<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> selectedKeys <span style="color:#f92672">=</span> selector.<span style="color:#a6e22e">selectedKeys</span>();
</span></span><span style="display:flex;"><span>            Iterator<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> selectedKeys.<span style="color:#a6e22e">iterator</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (iterator.<span style="color:#a6e22e">hasNext</span>()) {
</span></span><span style="display:flex;"><span>                SelectionKey key <span style="color:#f92672">=</span> iterator.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>                iterator.<span style="color:#a6e22e">remove</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isConnectable</span>()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 处理连接完成事件</span>
</span></span><span style="display:flex;"><span>                    SocketChannel clientChannel <span style="color:#f92672">=</span> (SocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (clientChannel.<span style="color:#a6e22e">isConnectionPending</span>()) {
</span></span><span style="display:flex;"><span>                        clientChannel.<span style="color:#a6e22e">finishConnect</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    clientChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>                    clientChannel.<span style="color:#a6e22e">register</span>(selector, SelectionKey.<span style="color:#a6e22e">OP_READ</span>);
</span></span><span style="display:flex;"><span>                    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connected to server: &#34;</span> <span style="color:#f92672">+</span> clientChannel.<span style="color:#a6e22e">getRemoteAddress</span>());
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isReadable</span>()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 处理读取事件</span>
</span></span><span style="display:flex;"><span>                    SocketChannel clientChannel <span style="color:#f92672">=</span> (SocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                    ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">allocate</span>(BUFFER_SIZE);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> bytesRead <span style="color:#f92672">=</span> clientChannel.<span style="color:#a6e22e">read</span>(buffer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 服务端断开连接</span>
</span></span><span style="display:flex;"><span>                        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Server disconnected: &#34;</span> <span style="color:#f92672">+</span> clientChannel.<span style="color:#a6e22e">getRemoteAddress</span>());
</span></span><span style="display:flex;"><span>                        clientChannel.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>                        removeConnection(clientChannel);
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 处理接收到的数据</span>
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">flip</span>();
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>buffer.<span style="color:#a6e22e">remaining</span>()<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">get</span>(data);
</span></span><span style="display:flex;"><span>                        String message <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String(data);
</span></span><span style="display:flex;"><span>                        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Received from server: &#34;</span> <span style="color:#f92672">+</span> message);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新增连接</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addConnection</span>(String ip, <span style="color:#66d9ef">int</span> port) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        String key <span style="color:#f92672">=</span> ip <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> port;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (connections.<span style="color:#a6e22e">containsKey</span>(key)) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connection already exists: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        SocketChannel clientChannel <span style="color:#f92672">=</span> SocketChannel.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        clientChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>        clientChannel.<span style="color:#a6e22e">connect</span>(<span style="color:#66d9ef">new</span> InetSocketAddress(ip, port));
</span></span><span style="display:flex;"><span>        clientChannel.<span style="color:#a6e22e">register</span>(selector, SelectionKey.<span style="color:#a6e22e">OP_CONNECT</span>);
</span></span><span style="display:flex;"><span>        connections.<span style="color:#a6e22e">put</span>(key, clientChannel);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Added new connection: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改连接信息</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">updateConnection</span>(String oldIp, <span style="color:#66d9ef">int</span> oldPort, String newIp, <span style="color:#66d9ef">int</span> newPort) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        String oldKey <span style="color:#f92672">=</span> oldIp <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> oldPort;
</span></span><span style="display:flex;"><span>        String newKey <span style="color:#f92672">=</span> newIp <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> newPort;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>connections.<span style="color:#a6e22e">containsKey</span>(oldKey)) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connection not found: &#34;</span> <span style="color:#f92672">+</span> oldKey);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关闭旧连接</span>
</span></span><span style="display:flex;"><span>        SocketChannel oldChannel <span style="color:#f92672">=</span> connections.<span style="color:#a6e22e">get</span>(oldKey);
</span></span><span style="display:flex;"><span>        oldChannel.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>        connections.<span style="color:#a6e22e">remove</span>(oldKey);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建新连接</span>
</span></span><span style="display:flex;"><span>        addConnection(newIp, newPort);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Updated connection from &#34;</span> <span style="color:#f92672">+</span> oldKey <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; to &#34;</span> <span style="color:#f92672">+</span> newKey);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 删除连接</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">removeConnection</span>(SocketChannel channel) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        String key <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (Map.<span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>String, SocketChannel<span style="color:#f92672">&gt;</span> entry : connections.<span style="color:#a6e22e">entrySet</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (entry.<span style="color:#a6e22e">getValue</span>().<span style="color:#a6e22e">equals</span>(channel)) {
</span></span><span style="display:flex;"><span>                key <span style="color:#f92672">=</span> entry.<span style="color:#a6e22e">getKey</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            connections.<span style="color:#a6e22e">remove</span>(key);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Removed connection: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 向特定连接发送命令报文</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sendCommand</span>(String ip, <span style="color:#66d9ef">int</span> port, String command) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        String key <span style="color:#f92672">=</span> ip <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> port;
</span></span><span style="display:flex;"><span>        SocketChannel clientChannel <span style="color:#f92672">=</span> connections.<span style="color:#a6e22e">get</span>(key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (clientChannel <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connection not found: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>clientChannel.<span style="color:#a6e22e">isConnected</span>()) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connection is not active: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 发送命令报文</span>
</span></span><span style="display:flex;"><span>        ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">wrap</span>(command.<span style="color:#a6e22e">getBytes</span>());
</span></span><span style="display:flex;"><span>        clientChannel.<span style="color:#a6e22e">write</span>(buffer);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Sent command to &#34;</span> <span style="color:#f92672">+</span> key <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">+</span> command);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        DynamicTCPConnector connector <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DynamicTCPConnector();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 启动事件循环</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                connector.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>                e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }).<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 示例：动态管理连接</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 新增连接</span>
</span></span><span style="display:flex;"><span>            connector.<span style="color:#a6e22e">addConnection</span>(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8081);
</span></span><span style="display:flex;"><span>            connector.<span style="color:#a6e22e">addConnection</span>(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8082);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 向特定连接发送命令</span>
</span></span><span style="display:flex;"><span>            Thread.<span style="color:#a6e22e">sleep</span>(2000);
</span></span><span style="display:flex;"><span>            connector.<span style="color:#a6e22e">sendCommand</span>(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8081, <span style="color:#e6db74">&#34;COMMAND: START&#34;</span>);
</span></span><span style="display:flex;"><span>            connector.<span style="color:#a6e22e">sendCommand</span>(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8082, <span style="color:#e6db74">&#34;COMMAND: STOP&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 修改连接</span>
</span></span><span style="display:flex;"><span>            Thread.<span style="color:#a6e22e">sleep</span>(5000);
</span></span><span style="display:flex;"><span>            connector.<span style="color:#a6e22e">updateConnection</span>(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8081, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8083);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 删除连接</span>
</span></span><span style="display:flex;"><span>            Thread.<span style="color:#a6e22e">sleep</span>(5000);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (SocketChannel channel : connector.<span style="color:#a6e22e">connections</span>.<span style="color:#a6e22e">values</span>()) {
</span></span><span style="display:flex;"><span>                connector.<span style="color:#a6e22e">removeConnection</span>(channel);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="代码说明-4">
  代码说明
  <a class="anchor" href="#%e4%bb%a3%e7%a0%81%e8%af%b4%e6%98%8e-4">#</a>
</h3>
<ol>
<li>
<p><strong><code>sendCommand</code> 方法</strong>：</p>
<ul>
<li>根据 <code>ip</code> 和 <code>port</code> 查找对应的 <code>SocketChannel</code>。</li>
<li>检查连接是否处于活动状态。</li>
<li>使用 <code>SocketChannel.write</code> 发送命令报文。</li>
</ul>
</li>
<li>
<p><strong>线程安全</strong>：</p>
<ul>
<li>使用 <code>ConcurrentHashMap</code> 管理连接，确保多线程操作的安全性。</li>
<li>在发送数据时，连接不会被意外关闭或修改。</li>
</ul>
</li>
<li>
<p><strong>动态管理连接</strong>：</p>
<ul>
<li>支持新增、修改和删除连接。</li>
<li>使用 <code>Selector</code> 监听所有连接的读写事件。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="运行方式-3">
  运行方式
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e6%96%b9%e5%bc%8f-3">#</a>
</h3>
<ol>
<li>启动多个服务端，分别监听 <code>8081</code>、<code>8082</code> 和 <code>8083</code> 端口。</li>
<li>运行 <code>DynamicTCPConnector</code>，它将动态管理连接并向特定连接发送命令报文。</li>
</ol>
<hr>
<h3 id="扩展建议-3">
  扩展建议
  <a class="anchor" href="#%e6%89%a9%e5%b1%95%e5%bb%ba%e8%ae%ae-3">#</a>
</h3>
<ul>
<li><strong>超时重试</strong>：在发送命令时，如果连接不可用，可以加入重试机制。</li>
<li><strong>日志记录</strong>：记录命令发送的结果，便于排查问题。</li>
<li><strong>协议设计</strong>：使用更复杂的协议（如 JSON 或自定义二进制协议）封装命令报文。</li>
</ul>
<h2 id="发送完命令之后我需要等待收到一个回复的报文命令执行才算完成">
  发送完命令之后我需要等待收到一个回复的报文，命令执行才算完成
  <a class="anchor" href="#%e5%8f%91%e9%80%81%e5%ae%8c%e5%91%bd%e4%bb%a4%e4%b9%8b%e5%90%8e%e6%88%91%e9%9c%80%e8%a6%81%e7%ad%89%e5%be%85%e6%94%b6%e5%88%b0%e4%b8%80%e4%b8%aa%e5%9b%9e%e5%a4%8d%e7%9a%84%e6%8a%a5%e6%96%87%e5%91%bd%e4%bb%a4%e6%89%a7%e8%a1%8c%e6%89%8d%e7%ae%97%e5%ae%8c%e6%88%90">#</a>
</h2>
<p>为了在发送命令后等待接收回复报文，可以扩展 <code>sendCommand</code> 方法，使其支持同步等待回复。以下是实现思路和代码示例：</p>
<hr>
<h3 id="设计思路-1">
  设计思路
  <a class="anchor" href="#%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af-1">#</a>
</h3>
<ol>
<li>
<p><strong>发送命令</strong>：</p>
<ul>
<li>向特定连接发送命令报文。</li>
<li>使用 <code>SocketChannel.write</code> 发送数据。</li>
</ul>
</li>
<li>
<p><strong>等待回复</strong>：</p>
<ul>
<li>在发送命令后，阻塞等待接收回复报文。</li>
<li>使用 <code>Selector</code> 监听 <code>OP_READ</code> 事件，等待对方发送数据。</li>
</ul>
</li>
<li>
<p><strong>超时机制</strong>：</p>
<ul>
<li>如果在一定时间内未收到回复，抛出超时异常。</li>
</ul>
</li>
<li>
<p><strong>线程安全</strong>：</p>
<ul>
<li>确保在等待回复时，连接不会被意外关闭或修改。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="代码实现-2">
  代码实现
  <a class="anchor" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.IOException;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.net.InetSocketAddress;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.ByteBuffer;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.channels.*;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Iterator;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Map;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Set;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ConcurrentHashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DynamicTCPConnector</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> BUFFER_SIZE <span style="color:#f92672">=</span> 1024;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> REPLY_TIMEOUT <span style="color:#f92672">=</span> 5000; <span style="color:#75715e">// 等待回复的超时时间（毫秒）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Selector selector;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Map<span style="color:#f92672">&lt;</span>String, SocketChannel<span style="color:#f92672">&gt;</span> connections;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DynamicTCPConnector</span>() <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">selector</span> <span style="color:#f92672">=</span> Selector.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">connections</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ConcurrentHashMap<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start</span>() <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Dynamic TCP Connector started.&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>            selector.<span style="color:#a6e22e">select</span>();
</span></span><span style="display:flex;"><span>            Set<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> selectedKeys <span style="color:#f92672">=</span> selector.<span style="color:#a6e22e">selectedKeys</span>();
</span></span><span style="display:flex;"><span>            Iterator<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> selectedKeys.<span style="color:#a6e22e">iterator</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (iterator.<span style="color:#a6e22e">hasNext</span>()) {
</span></span><span style="display:flex;"><span>                SelectionKey key <span style="color:#f92672">=</span> iterator.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>                iterator.<span style="color:#a6e22e">remove</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isConnectable</span>()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 处理连接完成事件</span>
</span></span><span style="display:flex;"><span>                    SocketChannel clientChannel <span style="color:#f92672">=</span> (SocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (clientChannel.<span style="color:#a6e22e">isConnectionPending</span>()) {
</span></span><span style="display:flex;"><span>                        clientChannel.<span style="color:#a6e22e">finishConnect</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    clientChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>                    clientChannel.<span style="color:#a6e22e">register</span>(selector, SelectionKey.<span style="color:#a6e22e">OP_READ</span>);
</span></span><span style="display:flex;"><span>                    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connected to server: &#34;</span> <span style="color:#f92672">+</span> clientChannel.<span style="color:#a6e22e">getRemoteAddress</span>());
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isReadable</span>()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 处理读取事件</span>
</span></span><span style="display:flex;"><span>                    SocketChannel clientChannel <span style="color:#f92672">=</span> (SocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                    ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">allocate</span>(BUFFER_SIZE);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> bytesRead <span style="color:#f92672">=</span> clientChannel.<span style="color:#a6e22e">read</span>(buffer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 服务端断开连接</span>
</span></span><span style="display:flex;"><span>                        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Server disconnected: &#34;</span> <span style="color:#f92672">+</span> clientChannel.<span style="color:#a6e22e">getRemoteAddress</span>());
</span></span><span style="display:flex;"><span>                        clientChannel.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>                        removeConnection(clientChannel);
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 处理接收到的数据</span>
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">flip</span>();
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>buffer.<span style="color:#a6e22e">remaining</span>()<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                        buffer.<span style="color:#a6e22e">get</span>(data);
</span></span><span style="display:flex;"><span>                        String message <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String(data);
</span></span><span style="display:flex;"><span>                        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Received from server: &#34;</span> <span style="color:#f92672">+</span> message);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 唤醒等待回复的线程</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">synchronized</span> (clientChannel) {
</span></span><span style="display:flex;"><span>                            clientChannel.<span style="color:#a6e22e">notifyAll</span>();
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新增连接</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addConnection</span>(String ip, <span style="color:#66d9ef">int</span> port) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        String key <span style="color:#f92672">=</span> ip <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> port;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (connections.<span style="color:#a6e22e">containsKey</span>(key)) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connection already exists: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        SocketChannel clientChannel <span style="color:#f92672">=</span> SocketChannel.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        clientChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>        clientChannel.<span style="color:#a6e22e">connect</span>(<span style="color:#66d9ef">new</span> InetSocketAddress(ip, port));
</span></span><span style="display:flex;"><span>        clientChannel.<span style="color:#a6e22e">register</span>(selector, SelectionKey.<span style="color:#a6e22e">OP_CONNECT</span>);
</span></span><span style="display:flex;"><span>        connections.<span style="color:#a6e22e">put</span>(key, clientChannel);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Added new connection: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改连接信息</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">updateConnection</span>(String oldIp, <span style="color:#66d9ef">int</span> oldPort, String newIp, <span style="color:#66d9ef">int</span> newPort) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        String oldKey <span style="color:#f92672">=</span> oldIp <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> oldPort;
</span></span><span style="display:flex;"><span>        String newKey <span style="color:#f92672">=</span> newIp <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> newPort;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>connections.<span style="color:#a6e22e">containsKey</span>(oldKey)) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Connection not found: &#34;</span> <span style="color:#f92672">+</span> oldKey);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关闭旧连接</span>
</span></span><span style="display:flex;"><span>        SocketChannel oldChannel <span style="color:#f92672">=</span> connections.<span style="color:#a6e22e">get</span>(oldKey);
</span></span><span style="display:flex;"><span>        oldChannel.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>        connections.<span style="color:#a6e22e">remove</span>(oldKey);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建新连接</span>
</span></span><span style="display:flex;"><span>        addConnection(newIp, newPort);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Updated connection from &#34;</span> <span style="color:#f92672">+</span> oldKey <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; to &#34;</span> <span style="color:#f92672">+</span> newKey);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 删除连接</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">removeConnection</span>(SocketChannel channel) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        String key <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (Map.<span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>String, SocketChannel<span style="color:#f92672">&gt;</span> entry : connections.<span style="color:#a6e22e">entrySet</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (entry.<span style="color:#a6e22e">getValue</span>().<span style="color:#a6e22e">equals</span>(channel)) {
</span></span><span style="display:flex;"><span>                key <span style="color:#f92672">=</span> entry.<span style="color:#a6e22e">getKey</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            connections.<span style="color:#a6e22e">remove</span>(key);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Removed connection: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 向特定连接发送命令报文并等待回复</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">sendCommand</span>(String ip, <span style="color:#66d9ef">int</span> port, String command) <span style="color:#66d9ef">throws</span> IOException, InterruptedException {
</span></span><span style="display:flex;"><span>        String key <span style="color:#f92672">=</span> ip <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> port;
</span></span><span style="display:flex;"><span>        SocketChannel clientChannel <span style="color:#f92672">=</span> connections.<span style="color:#a6e22e">get</span>(key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (clientChannel <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IOException(<span style="color:#e6db74">&#34;Connection not found: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>clientChannel.<span style="color:#a6e22e">isConnected</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IOException(<span style="color:#e6db74">&#34;Connection is not active: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 发送命令报文</span>
</span></span><span style="display:flex;"><span>        ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">wrap</span>(command.<span style="color:#a6e22e">getBytes</span>());
</span></span><span style="display:flex;"><span>        clientChannel.<span style="color:#a6e22e">write</span>(buffer);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Sent command to &#34;</span> <span style="color:#f92672">+</span> key <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">+</span> command);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 等待回复</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (clientChannel) {
</span></span><span style="display:flex;"><span>            clientChannel.<span style="color:#a6e22e">wait</span>(REPLY_TIMEOUT);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 读取回复</span>
</span></span><span style="display:flex;"><span>        buffer.<span style="color:#a6e22e">clear</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> bytesRead <span style="color:#f92672">=</span> clientChannel.<span style="color:#a6e22e">read</span>(buffer);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IOException(<span style="color:#e6db74">&#34;Connection closed by server: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>            buffer.<span style="color:#a6e22e">flip</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>buffer.<span style="color:#a6e22e">remaining</span>()<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            buffer.<span style="color:#a6e22e">get</span>(data);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> String(data);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IOException(<span style="color:#e6db74">&#34;No reply received from server: &#34;</span> <span style="color:#f92672">+</span> key);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        DynamicTCPConnector connector <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DynamicTCPConnector();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 启动事件循环</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                connector.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>                e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }).<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 示例：动态管理连接</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 新增连接</span>
</span></span><span style="display:flex;"><span>            connector.<span style="color:#a6e22e">addConnection</span>(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8081);
</span></span><span style="display:flex;"><span>            connector.<span style="color:#a6e22e">addConnection</span>(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8082);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 向特定连接发送命令并等待回复</span>
</span></span><span style="display:flex;"><span>            String reply <span style="color:#f92672">=</span> connector.<span style="color:#a6e22e">sendCommand</span>(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8081, <span style="color:#e6db74">&#34;COMMAND: START&#34;</span>);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Received reply: &#34;</span> <span style="color:#f92672">+</span> reply);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 修改连接</span>
</span></span><span style="display:flex;"><span>            Thread.<span style="color:#a6e22e">sleep</span>(5000);
</span></span><span style="display:flex;"><span>            connector.<span style="color:#a6e22e">updateConnection</span>(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8081, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, 8083);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 删除连接</span>
</span></span><span style="display:flex;"><span>            Thread.<span style="color:#a6e22e">sleep</span>(5000);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (SocketChannel channel : connector.<span style="color:#a6e22e">connections</span>.<span style="color:#a6e22e">values</span>()) {
</span></span><span style="display:flex;"><span>                connector.<span style="color:#a6e22e">removeConnection</span>(channel);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="代码说明-5">
  代码说明
  <a class="anchor" href="#%e4%bb%a3%e7%a0%81%e8%af%b4%e6%98%8e-5">#</a>
</h3>
<ol>
<li>
<p><strong><code>sendCommand</code> 方法</strong>：</p>
<ul>
<li>发送命令报文后，使用 <code>wait</code> 方法阻塞等待回复。</li>
<li>在收到回复后，使用 <code>notifyAll</code> 唤醒等待的线程。</li>
<li>如果超时未收到回复，抛出异常。</li>
</ul>
</li>
<li>
<p><strong>线程安全</strong>：</p>
<ul>
<li>使用 <code>synchronized</code> 确保在等待回复时，连接不会被意外关闭或修改。</li>
</ul>
</li>
<li>
<p><strong>超时机制</strong>：</p>
<ul>
<li>如果超过 <code>REPLY_TIMEOUT</code> 时间未收到回复，抛出超时异常。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="运行方式-4">
  运行方式
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e6%96%b9%e5%bc%8f-4">#</a>
</h3>
<ol>
<li>启动多个服务端，分别监听 <code>8081</code>、<code>8082</code> 和 <code>8083</code> 端口。</li>
<li>运行 <code>DynamicTCPConnector</code>，它将动态管理连接、发送命令并等待回复。</li>
</ol>
<hr>
<h3 id="扩展建议-4">
  扩展建议
  <a class="anchor" href="#%e6%89%a9%e5%b1%95%e5%bb%ba%e8%ae%ae-4">#</a>
</h3>
<ul>
<li><strong>更复杂的协议</strong>：可以使用 JSON 或自定义二进制协议封装命令和回复。</li>
<li><strong>重试机制</strong>：在超时或连接失败时，加入重试逻辑。</li>
<li><strong>日志记录</strong>：记录命令发送和回复的详细信息，便于排查问题。</li>
</ul>
<h2 id="如果连接的tcp数量很多使用一个selector接收有点慢该怎么优化">
  如果连接的tcp数量很多，使用一个selector接收有点慢，该怎么优化
  <a class="anchor" href="#%e5%a6%82%e6%9e%9c%e8%bf%9e%e6%8e%a5%e7%9a%84tcp%e6%95%b0%e9%87%8f%e5%be%88%e5%a4%9a%e4%bd%bf%e7%94%a8%e4%b8%80%e4%b8%aaselector%e6%8e%a5%e6%94%b6%e6%9c%89%e7%82%b9%e6%85%a2%e8%af%a5%e6%80%8e%e4%b9%88%e4%bc%98%e5%8c%96">#</a>
</h2>
<p>当使用一个 <code>Selector</code> 处理大量 TCP 连接时，可能会遇到性能瓶颈。以下是优化建议和具体实现思路：</p>
<hr>
<h3 id="1-优化思路">
  1. <strong>优化思路</strong>
  <a class="anchor" href="#1-%e4%bc%98%e5%8c%96%e6%80%9d%e8%b7%af">#</a>
</h3>
<h4 id="11-使用多个-selector">
  1.1 <strong>使用多个 Selector</strong>
  <a class="anchor" href="#11-%e4%bd%bf%e7%94%a8%e5%a4%9a%e4%b8%aa-selector">#</a>
</h4>
<ul>
<li>将连接分散到多个 <code>Selector</code> 中，每个 <code>Selector</code> 负责处理一部分连接。</li>
<li>可以通过线程池管理多个 <code>Selector</code>，每个线程运行一个 <code>Selector</code> 的事件循环<a href="@ref">3</a>。</li>
</ul>
<h4 id="12-分离连接处理和数据处理">
  1.2 <strong>分离连接处理和数据处理</strong>
  <a class="anchor" href="#12-%e5%88%86%e7%a6%bb%e8%bf%9e%e6%8e%a5%e5%a4%84%e7%90%86%e5%92%8c%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86">#</a>
</h4>
<ul>
<li>使用一个 <code>Selector</code> 专门处理新连接（<code>ACCEPT</code> 事件），另一个或多个 <code>Selector</code> 处理已连接通道的读写事件（<code>READ</code> 和 <code>WRITE</code> 事件）。</li>
<li>这种方式可以避免单个 <code>Selector</code> 处理过多事件导致的性能下降<a href="@ref">3</a>。</li>
</ul>
<h4 id="13-调整缓冲区大小">
  1.3 <strong>调整缓冲区大小</strong>
  <a class="anchor" href="#13-%e8%b0%83%e6%95%b4%e7%bc%93%e5%86%b2%e5%8c%ba%e5%a4%a7%e5%b0%8f">#</a>
</h4>
<ul>
<li>根据网络带宽和时延调整 TCP 缓冲区大小（<code>tcp_wmem</code> 和 <code>tcp_rmem</code>），确保缓冲区大小与带宽时延积（BDP）匹配，以充分利用网络性能<a href="@ref">1</a>。</li>
</ul>
<h4 id="14-使用非阻塞-io">
  1.4 <strong>使用非阻塞 I/O</strong>
  <a class="anchor" href="#14-%e4%bd%bf%e7%94%a8%e9%9d%9e%e9%98%bb%e5%a1%9e-io">#</a>
</h4>
<ul>
<li>确保所有 <code>Channel</code> 都设置为非阻塞模式（<code>configureBlocking(false)</code>），避免阻塞操作影响 <code>Selector</code> 的效率<a href="@ref">3</a>。</li>
</ul>
<h4 id="15-减少事件处理的耗时">
  1.5 <strong>减少事件处理的耗时</strong>
  <a class="anchor" href="#15-%e5%87%8f%e5%b0%91%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e7%9a%84%e8%80%97%e6%97%b6">#</a>
</h4>
<ul>
<li>避免在事件处理逻辑中执行耗时操作（如数据库查询、复杂计算等），可以将这些操作委托给线程池处理。</li>
</ul>
<hr>
<h3 id="2-实现示例">
  2. <strong>实现示例</strong>
  <a class="anchor" href="#2-%e5%ae%9e%e7%8e%b0%e7%a4%ba%e4%be%8b">#</a>
</h3>
<p>以下是一个使用多个 <code>Selector</code> 优化大量 TCP 连接的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.IOException;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.net.InetSocketAddress;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.ByteBuffer;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.channels.*;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Iterator;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Set;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ExecutorService;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Executors;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MultiSelectorServer</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> PORT <span style="color:#f92672">=</span> 8080;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> SELECTOR_THREADS <span style="color:#f92672">=</span> 4; <span style="color:#75715e">// 使用 4 个 Selector</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> ExecutorService selectorPool <span style="color:#f92672">=</span> Executors.<span style="color:#a6e22e">newFixedThreadPool</span>(SELECTOR_THREADS);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建主 Selector，专门处理 ACCEPT 事件</span>
</span></span><span style="display:flex;"><span>        Selector acceptSelector <span style="color:#f92672">=</span> Selector.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        ServerSocketChannel serverChannel <span style="color:#f92672">=</span> ServerSocketChannel.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        serverChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>        serverChannel.<span style="color:#a6e22e">bind</span>(<span style="color:#66d9ef">new</span> InetSocketAddress(PORT));
</span></span><span style="display:flex;"><span>        serverChannel.<span style="color:#a6e22e">register</span>(acceptSelector, SelectionKey.<span style="color:#a6e22e">OP_ACCEPT</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 启动多个 Selector 线程处理读写事件</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> SELECTOR_THREADS; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            selectorPool.<span style="color:#a6e22e">submit</span>(<span style="color:#66d9ef">new</span> EventLoop());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 主线程运行 ACCEPT 事件循环</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>            acceptSelector.<span style="color:#a6e22e">select</span>();
</span></span><span style="display:flex;"><span>            Set<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> keys <span style="color:#f92672">=</span> acceptSelector.<span style="color:#a6e22e">selectedKeys</span>();
</span></span><span style="display:flex;"><span>            Iterator<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> keys.<span style="color:#a6e22e">iterator</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (iterator.<span style="color:#a6e22e">hasNext</span>()) {
</span></span><span style="display:flex;"><span>                SelectionKey key <span style="color:#f92672">=</span> iterator.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>                iterator.<span style="color:#a6e22e">remove</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isAcceptable</span>()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 接受新连接并分配给一个 EventLoop</span>
</span></span><span style="display:flex;"><span>                    ServerSocketChannel server <span style="color:#f92672">=</span> (ServerSocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                    SocketChannel clientChannel <span style="color:#f92672">=</span> server.<span style="color:#a6e22e">accept</span>();
</span></span><span style="display:flex;"><span>                    clientChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 将新连接分配给一个 EventLoop</span>
</span></span><span style="display:flex;"><span>                    EventLoop.<span style="color:#a6e22e">assignChannel</span>(clientChannel);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// EventLoop 类，处理读写事件</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EventLoop</span> <span style="color:#66d9ef">implements</span> Runnable {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Selector selector;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">EventLoop</span>() <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">selector</span> <span style="color:#f92672">=</span> Selector.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">assignChannel</span>(SocketChannel channel) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 将新连接注册到某个 EventLoop 的 Selector</span>
</span></span><span style="display:flex;"><span>            EventLoop eventLoop <span style="color:#f92672">=</span> (EventLoop) selectorPool.<span style="color:#a6e22e">submit</span>(<span style="color:#66d9ef">new</span> EventLoop()).<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>            channel.<span style="color:#a6e22e">register</span>(eventLoop.<span style="color:#a6e22e">selector</span>, SelectionKey.<span style="color:#a6e22e">OP_READ</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    selector.<span style="color:#a6e22e">select</span>();
</span></span><span style="display:flex;"><span>                    Set<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> keys <span style="color:#f92672">=</span> selector.<span style="color:#a6e22e">selectedKeys</span>();
</span></span><span style="display:flex;"><span>                    Iterator<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> keys.<span style="color:#a6e22e">iterator</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">while</span> (iterator.<span style="color:#a6e22e">hasNext</span>()) {
</span></span><span style="display:flex;"><span>                        SelectionKey key <span style="color:#f92672">=</span> iterator.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>                        iterator.<span style="color:#a6e22e">remove</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isReadable</span>()) {
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e">// 处理读事件</span>
</span></span><span style="display:flex;"><span>                            SocketChannel channel <span style="color:#f92672">=</span> (SocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                            ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">allocate</span>(1024);
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">int</span> bytesRead <span style="color:#f92672">=</span> channel.<span style="color:#a6e22e">read</span>(buffer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1) {
</span></span><span style="display:flex;"><span>                                channel.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>                            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                                buffer.<span style="color:#a6e22e">flip</span>();
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>buffer.<span style="color:#a6e22e">remaining</span>()<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                                buffer.<span style="color:#a6e22e">get</span>(data);
</span></span><span style="display:flex;"><span>                                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Received: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">new</span> String(data));
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="3-优化建议">
  3. <strong>优化建议</strong>
  <a class="anchor" href="#3-%e4%bc%98%e5%8c%96%e5%bb%ba%e8%ae%ae">#</a>
</h3>
<ol>
<li>
<p><strong>动态调整 Selector 数量</strong>：</p>
<ul>
<li>根据连接的负载情况动态调整 <code>Selector</code> 的数量，避免资源浪费<a href="@ref">3</a>。</li>
</ul>
</li>
<li>
<p><strong>使用更高效的 I/O 模型</strong>：</p>
<ul>
<li>如果 <code>Selector</code> 仍然无法满足性能需求，可以考虑使用更高效的 I/O 模型，如 Linux 的 <code>epoll</code> 或 Windows 的 <code>IOCP</code>。</li>
</ul>
</li>
<li>
<p><strong>监控和调优</strong>：</p>
<ul>
<li>使用工具（如 <code>netstat</code>、<code>ss</code>）监控连接状态，调整系统参数（如 <code>tcp_max_syn_backlog</code>、<code>somaxconn</code>）以优化 TCP 连接处理能力<a href="@ref">1</a>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-参考外部资料">
  4. <strong>参考外部资料</strong>
  <a class="anchor" href="#4-%e5%8f%82%e8%80%83%e5%a4%96%e9%83%a8%e8%b5%84%e6%96%99">#</a>
</h3>
<ul>
<li><a href="@ref">1</a>：优化 TCP 缓冲区大小和滑动窗口。</li>
<li><a href="@ref">3</a>：使用多个 <code>Selector</code> 和线程池处理大量连接。</li>
</ul>
<p>通过以上优化措施，可以有效提升 <code>Selector</code> 处理大量 TCP 连接的性能。</p>
<h2 id="如果我需要维护100个tcp连接使用一个selector够吗">
  如果我需要维护100个tcp连接，使用一个selector够吗
  <a class="anchor" href="#%e5%a6%82%e6%9e%9c%e6%88%91%e9%9c%80%e8%a6%81%e7%bb%b4%e6%8a%a4100%e4%b8%aatcp%e8%bf%9e%e6%8e%a5%e4%bd%bf%e7%94%a8%e4%b8%80%e4%b8%aaselector%e5%a4%9f%e5%90%97">#</a>
</h2>
<p>维护100个TCP连接时，使用单个<code>Selector</code>是可行的，但可能会遇到性能瓶颈，尤其是在连接数量进一步增加或网络负载较高的情况下。以下是详细分析和优化建议：</p>
<hr>
<h3 id="1-单个">
  1. <strong>单个 <code>Selector</code> 的局限性</strong>
  <a class="anchor" href="#1-%e5%8d%95%e4%b8%aa">#</a>
</h3>
<ul>
<li><strong>事件处理延迟</strong>：单个<code>Selector</code>需要轮询所有注册的<code>Channel</code>，随着连接数量增加，事件处理的延迟可能会增加。</li>
<li><strong>单线程瓶颈</strong>：如果所有连接的事件处理都由一个线程完成，CPU 和 I/O 资源可能无法充分利用，尤其是在多核系统上。</li>
<li><strong>扩展性差</strong>：当连接数量进一步增加（如1000个以上），单个<code>Selector</code>的性能可能无法满足需求。</li>
</ul>
<hr>
<h3 id="2-优化方案">
  2. <strong>优化方案</strong>
  <a class="anchor" href="#2-%e4%bc%98%e5%8c%96%e6%96%b9%e6%a1%88">#</a>
</h3>
<h4 id="21-使用多个">
  2.1 <strong>使用多个 <code>Selector</code></strong>
  <a class="anchor" href="#21-%e4%bd%bf%e7%94%a8%e5%a4%9a%e4%b8%aa">#</a>
</h4>
<ul>
<li>将连接分散到多个<code>Selector</code>中，每个<code>Selector</code>负责处理一部分连接。可以通过线程池管理多个<code>Selector</code>，每个线程运行一个<code>Selector</code>的事件循环。</li>
<li>示例：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Selector<span style="color:#f92672">[]</span> selectors <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Selector<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>; <span style="color:#75715e">// 使用 4 个 Selector</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> selectors.<span style="color:#a6e22e">length</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    selectors<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Selector.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>将连接均匀分配到不同的<code>Selector</code>中，例如通过哈希算法将连接分配到特定的<code>Selector</code>。</li>
</ul>
<h4 id="22-分离连接处理和数据处理">
  2.2 <strong>分离连接处理和数据处理</strong>
  <a class="anchor" href="#22-%e5%88%86%e7%a6%bb%e8%bf%9e%e6%8e%a5%e5%a4%84%e7%90%86%e5%92%8c%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86">#</a>
</h4>
<ul>
<li>使用一个<code>Selector</code>专门处理新连接（<code>ACCEPT</code>事件），另一个或多个<code>Selector</code>处理已连接通道的读写事件（<code>READ</code>和<code>WRITE</code>事件）。</li>
<li>示例：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Selector acceptSelector <span style="color:#f92672">=</span> Selector.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>ServerSocketChannel serverChannel <span style="color:#f92672">=</span> ServerSocketChannel.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>serverChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>serverChannel.<span style="color:#a6e22e">bind</span>(<span style="color:#66d9ef">new</span> InetSocketAddress(PORT));
</span></span><span style="display:flex;"><span>serverChannel.<span style="color:#a6e22e">register</span>(acceptSelector, SelectionKey.<span style="color:#a6e22e">OP_ACCEPT</span>);
</span></span></code></pre></div></li>
</ul>
<h4 id="23-调整缓冲区大小">
  2.3 <strong>调整缓冲区大小</strong>
  <a class="anchor" href="#23-%e8%b0%83%e6%95%b4%e7%bc%93%e5%86%b2%e5%8c%ba%e5%a4%a7%e5%b0%8f">#</a>
</h4>
<ul>
<li>根据网络带宽和时延调整 TCP 缓冲区大小（<code>tcp_wmem</code> 和 <code>tcp_rmem</code>），确保缓冲区大小与带宽时延积（BDP）匹配，以充分利用网络性能。</li>
</ul>
<h4 id="24-使用非阻塞-io">
  2.4 <strong>使用非阻塞 I/O</strong>
  <a class="anchor" href="#24-%e4%bd%bf%e7%94%a8%e9%9d%9e%e9%98%bb%e5%a1%9e-io">#</a>
</h4>
<ul>
<li>确保所有<code>Channel</code>都设置为非阻塞模式（<code>configureBlocking(false)</code>），避免阻塞操作影响<code>Selector</code>的效率。</li>
</ul>
<h4 id="25-减少事件处理的耗时">
  2.5 <strong>减少事件处理的耗时</strong>
  <a class="anchor" href="#25-%e5%87%8f%e5%b0%91%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e7%9a%84%e8%80%97%e6%97%b6">#</a>
</h4>
<ul>
<li>避免在事件处理逻辑中执行耗时操作（如数据库查询、复杂计算等），可以将这些操作委托给线程池处理。</li>
</ul>
<hr>
<h3 id="3-参考外部资料">
  3. <strong>参考外部资料</strong>
  <a class="anchor" href="#3-%e5%8f%82%e8%80%83%e5%a4%96%e9%83%a8%e8%b5%84%e6%96%99">#</a>
</h3>
<ul>
<li><strong>单个 <code>Selector</code> 的性能瓶颈</strong>：单个<code>Selector</code>在处理大量连接时，可能会因为轮询和单线程限制导致性能下降<a href="@ref">2</a>。</li>
<li><strong>使用多个 <code>Selector</code> 的优化</strong>：通过将连接分散到多个<code>Selector</code>中，可以充分利用多核 CPU 和 I/O 资源<a href="@ref">3</a>。</li>
<li><strong>分离连接处理和数据处理</strong>：将新连接和已连接通道的事件处理分离，可以提高系统的扩展性和性能<a href="@ref">4</a>。</li>
</ul>
<hr>
<h3 id="4-示例代码-1">
  4. <strong>示例代码</strong>
  <a class="anchor" href="#4-%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81-1">#</a>
</h3>
<p>以下是使用多个<code>Selector</code>的示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.nio.channels.*;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ExecutorService;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Executors;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MultiSelectorServer</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> PORT <span style="color:#f92672">=</span> 8080;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> SELECTOR_THREADS <span style="color:#f92672">=</span> 4; <span style="color:#75715e">// 使用 4 个 Selector</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> ExecutorService selectorPool <span style="color:#f92672">=</span> Executors.<span style="color:#a6e22e">newFixedThreadPool</span>(SELECTOR_THREADS);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建主 Selector，专门处理 ACCEPT 事件</span>
</span></span><span style="display:flex;"><span>        Selector acceptSelector <span style="color:#f92672">=</span> Selector.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        ServerSocketChannel serverChannel <span style="color:#f92672">=</span> ServerSocketChannel.<span style="color:#a6e22e">open</span>();
</span></span><span style="display:flex;"><span>        serverChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>        serverChannel.<span style="color:#a6e22e">bind</span>(<span style="color:#66d9ef">new</span> InetSocketAddress(PORT));
</span></span><span style="display:flex;"><span>        serverChannel.<span style="color:#a6e22e">register</span>(acceptSelector, SelectionKey.<span style="color:#a6e22e">OP_ACCEPT</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 启动多个 Selector 线程处理读写事件</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> SELECTOR_THREADS; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            selectorPool.<span style="color:#a6e22e">submit</span>(<span style="color:#66d9ef">new</span> EventLoop());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 主线程运行 ACCEPT 事件循环</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>            acceptSelector.<span style="color:#a6e22e">select</span>();
</span></span><span style="display:flex;"><span>            Set<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> keys <span style="color:#f92672">=</span> acceptSelector.<span style="color:#a6e22e">selectedKeys</span>();
</span></span><span style="display:flex;"><span>            Iterator<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> keys.<span style="color:#a6e22e">iterator</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (iterator.<span style="color:#a6e22e">hasNext</span>()) {
</span></span><span style="display:flex;"><span>                SelectionKey key <span style="color:#f92672">=</span> iterator.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>                iterator.<span style="color:#a6e22e">remove</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">isAcceptable</span>()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 接受新连接并分配给一个 EventLoop</span>
</span></span><span style="display:flex;"><span>                    ServerSocketChannel server <span style="color:#f92672">=</span> (ServerSocketChannel) key.<span style="color:#a6e22e">channel</span>();
</span></span><span style="display:flex;"><span>                    SocketChannel clientChannel <span style="color:#f92672">=</span> server.<span style="color:#a6e22e">accept</span>();
</span></span><span style="display:flex;"><span>                    clientChannel.<span style="color:#a6e22e">configureBlocking</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 将新连接分配给一个 EventLoop</span>
</span></span><span style="display:flex;"><span>                    EventLoop.<span style="color:#a6e22e">assignChannel</span>(clientChannel);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="5-总结-1">
  5. <strong>总结</strong>
  <a class="anchor" href="#5-%e6%80%bb%e7%bb%93-1">#</a>
</h3>
<p>对于维护100个TCP连接，单个<code>Selector</code>可以满足需求，但在高负载或连接数量进一步增加时，建议使用多个<code>Selector</code>、分离连接处理和数据处理等优化措施，以提高系统性能和扩展性。</p>
<h2 id="在java中一个tcp连接使用一个socket连接多个tcp这样占用很多内存吗">
  在java中，一个tcp连接使用一个socket，连接多个tcp，这样占用很多内存吗
  <a class="anchor" href="#%e5%9c%a8java%e4%b8%ad%e4%b8%80%e4%b8%aatcp%e8%bf%9e%e6%8e%a5%e4%bd%bf%e7%94%a8%e4%b8%80%e4%b8%aasocket%e8%bf%9e%e6%8e%a5%e5%a4%9a%e4%b8%aatcp%e8%bf%99%e6%a0%b7%e5%8d%a0%e7%94%a8%e5%be%88%e5%a4%9a%e5%86%85%e5%ad%98%e5%90%97">#</a>
</h2>
<p>在Java中，每个TCP连接确实会使用一个Socket，而每个Socket都会占用一定的内存。具体的内存消耗取决于多个因素，包括操作系统内核的实现、缓冲区的大小以及其他相关的数据结构。</p>
<p>根据搜索结果，每个TCP连接（即一个Socket）在内核中会涉及多个数据结构，例如 <code>struct tcp_sock</code>、<code>struct file</code>、<code>struct dentry</code> 等。这些结构的内存占用总和大约在3KB左右。此外，如果使用了 <code>epoll</code> 等事件处理机制，每个连接还会额外占用一些内存（例如 <code>epitem</code> 对象，大小为128字节）<a href="@ref">3</a>。</p>
<p>对于接收和发送缓冲区，如果没有数据传输，它们不会占用内存。只有当有数据在缓冲区中等待处理时，才会占用内存。默认情况下，接收和发送缓冲区的最小大小各为4KB，因此每个连接在数据传输时可能会额外占用8KB的内存<a href="@ref">3</a>。</p>
<p>总的来说，一个TCP连接在不传输数据时，占用的内存大约为3KB左右；在传输数据时，可能会增加到10KB以上。因此，连接多个TCP连接确实会占用较多的内存，尤其是在高并发的情况下。例如，10万个TCP连接在不传输数据时，大约会占用300MB的内存；在传输数据时，可能会占用超过1GB的内存<a href="@ref">3</a>。</p>
<p>如果需要支持大量并发连接，可以通过调整内核参数（如 <code>tcp_rmem</code>、<code>tcp_wmem</code> 和 <code>tcp_mem</code>）来优化内存使用<a href="@ref">3</a>。此外，在Java中，可以通过优化代码和合理设置缓冲区大小来减少内存占用<a href="@ref">1</a>。</p>
<p>综上所述，连接多个TCP连接确实会占用较多内存，特别是在高并发场景下。通过优化系统和代码，可以有效地管理和减少内存消耗。</p>
<h2 id="在java中创建线程的内存开销">
  在java中创建线程的内存开销
  <a class="anchor" href="#%e5%9c%a8java%e4%b8%ad%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%86%85%e5%ad%98%e5%bc%80%e9%94%80">#</a>
</h2>
<p>在Java中，创建线程确实会带来一定的内存开销。以下是关于Java线程内存开销的详细说明：</p>
<h3 id="1-线程栈的内存开销">
  1. <strong>线程栈的内存开销</strong>
  <a class="anchor" href="#1-%e7%ba%bf%e7%a8%8b%e6%a0%88%e7%9a%84%e5%86%85%e5%ad%98%e5%bc%80%e9%94%80">#</a>
</h3>
<p>Java线程的线程栈区别于堆，它不受Java程序直接控制，而是由操作系统管理。默认情况下，每个线程的线程栈大小为1MB。这意味着如果创建了1024个线程，仅线程栈就会占用1GB的内存。这种内存消耗在高并发场景下可能会迅速耗尽系统资源，导致程序崩溃<a href="@ref">1</a><a href="@ref">4</a>。</p>
<p>然而，实际内存占用可能比默认值低，因为操作系统会以延迟分配的方式分配内存页面（例如在第一次使用时分配），因此每个线程栈实际占用的内存可能在80KB到200KB之间<a href="@ref">2</a>。</p>
<h3 id="2-其他内存开销">
  2. <strong>其他内存开销</strong>
  <a class="anchor" href="#2-%e5%85%b6%e4%bb%96%e5%86%85%e5%ad%98%e5%bc%80%e9%94%80">#</a>
</h3>
<p>除了线程栈，线程的创建和运行还会带来其他内存开销，包括：</p>
<ul>
<li><strong>线程控制块（TCB）</strong>：操作系统为每个线程维护的数据结构，用于管理线程的状态和上下文。</li>
<li><strong>本地内存</strong>：JVM本身也会为线程分配一些本地内存，用于管理线程的元数据和资源<a href="@ref">2</a>。</li>
</ul>
<h3 id="3-线程创建和销毁的开销">
  3. <strong>线程创建和销毁的开销</strong>
  <a class="anchor" href="#3-%e7%ba%bf%e7%a8%8b%e5%88%9b%e5%bb%ba%e5%92%8c%e9%94%80%e6%af%81%e7%9a%84%e5%bc%80%e9%94%80">#</a>
</h3>
<p>频繁创建和销毁线程会带来额外的性能开销，包括：</p>
<ul>
<li><strong>系统调用</strong>：创建线程需要操作系统介入，分配资源和初始化数据结构。</li>
<li><strong>上下文切换</strong>：线程切换时，CPU缓存会被清空，内存页面可能需要换入换出，这些操作都会影响性能<a href="@ref">1</a><a href="@ref">6</a>。</li>
</ul>
<h3 id="4-线程池的优化">
  4. <strong>线程池的优化</strong>
  <a class="anchor" href="#4-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e4%bc%98%e5%8c%96">#</a>
</h3>
<p>为了减少线程创建和销毁的开销，Java中通常使用线程池（如<code>ThreadPoolExecutor</code>）来管理线程。线程池通过复用线程资源，显著降低了内存和性能开销。线程池的主要优点包括：</p>
<ul>
<li><strong>资源复用</strong>：线程池中的线程可以重复使用，避免了频繁创建和销毁线程的开销。</li>
<li><strong>内存控制</strong>：线程池可以限制最大线程数，防止内存被过多占用<a href="@ref">1</a><a href="@ref">3</a>。</li>
</ul>
<h3 id="5-如何减少线程内存开销">
  5. <strong>如何减少线程内存开销</strong>
  <a class="anchor" href="#5-%e5%a6%82%e4%bd%95%e5%87%8f%e5%b0%91%e7%ba%bf%e7%a8%8b%e5%86%85%e5%ad%98%e5%bc%80%e9%94%80">#</a>
</h3>
<ul>
<li><strong>调整线程栈大小</strong>：通过JVM参数<code>-Xss</code>可以设置线程栈的大小，例如<code>-Xss256k</code>将线程栈大小设置为256KB。</li>
<li><strong>使用线程池</strong>：通过线程池管理线程，避免频繁创建和销毁线程。</li>
<li><strong>优化任务设计</strong>：将任务拆分为更小的可并行单元，充分利用线程池的并发能力<a href="@ref">2</a><a href="@ref">3</a>。</li>
</ul>
<h3 id="总结-8">
  总结
  <a class="anchor" href="#%e6%80%bb%e7%bb%93-8">#</a>
</h3>
<p>在Java中，每个线程默认会占用1MB的线程栈内存（实际可能为80KB到200KB），加上其他内存开销，创建大量线程可能会导致内存耗尽。通过使用线程池和优化线程栈大小，可以有效减少内存开销，提升系统性能<a href="@ref">1</a><a href="@ref">2</a><a href="@ref">3</a>。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/penruins/penruins.github.io/commit/ea621b7ba863150f080435f29b9d49677d958d05" title='最后修改者 penruins | 三月 2, 2025' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="" />
      <span>三月 2, 2025</span>
    </a>
  </div>




</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#stringbuffer-是怎么保证线程安全的">StringBuffer 是怎么保证线程安全的？</a>
      <ul>
        <li><a href="#1-同步方法">1. <strong>同步方法</strong></a></li>
        <li><a href="#2-锁机制">2. <strong>锁机制</strong></a></li>
        <li><a href="#3-性能影响">3. <strong>性能影响</strong></a></li>
        <li><a href="#4-适用场景">4. <strong>适用场景</strong></a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#stringbuffer-和-stringbuilder-字符串在底层是以什么数据结构保存的">StringBuffer 和 StringBuilder 字符串在底层是以什么数据结构保存的</a>
      <ul>
        <li><a href="#1-底层数据结构">1. <strong>底层数据结构</strong></a></li>
        <li><a href="#2-初始容量">2. <strong>初始容量</strong></a></li>
        <li><a href="#3-扩容机制">3. <strong>扩容机制</strong></a></li>
        <li><a href="#4-示例代码">4. <strong>示例代码</strong></a></li>
        <li><a href="#5-总结">5. <strong>总结</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#响应式编程和虚拟线程都能提高程序的并发量它们的差异是什么">响应式编程和虚拟线程都能提高程序的并发量，它们的差异是什么</a>
      <ul>
        <li><a href="#1-实现原理">1. <strong>实现原理</strong></a></li>
        <li><a href="#2-编程模型">2. <strong>编程模型</strong></a></li>
        <li><a href="#3-适用场景">3. <strong>适用场景</strong></a></li>
        <li><a href="#4-开发体验">4. <strong>开发体验</strong></a></li>
        <li><a href="#5-性能优化">5. <strong>性能优化</strong></a></li>
        <li><a href="#总结-1">总结</a></li>
      </ul>
    </li>
    <li><a href="#虚拟线程在jvm中的内存模型是怎样的">虚拟线程在jvm中的内存模型是怎样的</a>
      <ul>
        <li><a href="#1-虚拟线程的内存结构">1. <strong>虚拟线程的内存结构</strong></a></li>
        <li><a href="#2-虚拟线程与jvm内存模型的关系">2. <strong>虚拟线程与JVM内存模型的关系</strong></a></li>
        <li><a href="#3-虚拟线程的调度与内存使用">3. <strong>虚拟线程的调度与内存使用</strong></a></li>
        <li><a href="#4-虚拟线程与垃圾回收">4. <strong>虚拟线程与垃圾回收</strong></a></li>
        <li><a href="#5-虚拟线程的适用场景">5. <strong>虚拟线程的适用场景</strong></a></li>
        <li><a href="#总结-2">总结</a></li>
      </ul>
    </li>
    <li><a href="#虚拟线程会增加jvm的性能消耗吗">虚拟线程会增加jvm的性能消耗吗</a>
      <ul>
        <li><a href="#1-虚拟线程的资源消耗">1. <strong>虚拟线程的资源消耗</strong></a></li>
        <li><a href="#2-性能优势">2. <strong>性能优势</strong></a></li>
        <li><a href="#3-cpu密集型任务的限制">3. <strong>CPU密集型任务的限制</strong></a></li>
        <li><a href="#4-jvm的性能消耗">4. <strong>JVM的性能消耗</strong></a></li>
        <li><a href="#5-适用场景">5. <strong>适用场景</strong></a></li>
        <li><a href="#总结-3">总结</a></li>
      </ul>
    </li>
    <li><a href="#在-springboot-项目中虚拟线程可以怎么使用">在 springboot 项目中虚拟线程可以怎么使用</a>
      <ul>
        <li><a href="#1-启用虚拟线程处理-http-请求">1. <strong>启用虚拟线程处理 HTTP 请求</strong></a>
          <ul>
            <li><a href="#配置代码">配置代码：</a></li>
            <li><a href="#说明">说明：</a></li>
          </ul>
        </li>
        <li><a href="#2-使用虚拟线程执行异步任务">2. <strong>使用虚拟线程执行异步任务</strong></a>
          <ul>
            <li><a href="#配置代码-1">配置代码：</a></li>
            <li><a href="#使用示例">使用示例：</a></li>
            <li><a href="#说明-1">说明：</a></li>
          </ul>
        </li>
        <li><a href="#3-使用虚拟线程执行定时任务">3. <strong>使用虚拟线程执行定时任务</strong></a>
          <ul>
            <li><a href="#配置代码-2">配置代码：</a></li>
            <li><a href="#使用示例-1">使用示例：</a></li>
            <li><a href="#说明-2">说明：</a></li>
          </ul>
        </li>
        <li><a href="#4-使用虚拟线程执行自定义任务">4. <strong>使用虚拟线程执行自定义任务</strong></a>
          <ul>
            <li><a href="#示例代码">示例代码：</a></li>
            <li><a href="#说明-3">说明：</a></li>
          </ul>
        </li>
        <li><a href="#5-虚拟线程的最佳实践">5. <strong>虚拟线程的最佳实践</strong></a></li>
        <li><a href="#6-环境要求">6. <strong>环境要求</strong></a></li>
      </ul>
    </li>
    <li><a href="#虚拟线程的mn模型具体是如何工作的">虚拟线程的M:N模型具体是如何工作的？</a>
      <ul>
        <li><a href="#1-基本概念">1. <strong>基本概念</strong></a></li>
        <li><a href="#2-mn-模型的核心思想">2. <strong>M:N 模型的核心思想</strong></a></li>
        <li><a href="#3-具体工作流程">3. <strong>具体工作流程</strong></a></li>
        <li><a href="#4-mn-模型的优势">4. <strong>M:N 模型的优势</strong></a></li>
        <li><a href="#5-mn-模型的实现细节">5. <strong>M:N 模型的实现细节</strong></a></li>
        <li><a href="#6-示例">6. <strong>示例</strong></a></li>
        <li><a href="#7-与传统线程模型的对比">7. <strong>与传统线程模型的对比</strong></a></li>
        <li><a href="#总结-4">总结</a></li>
      </ul>
    </li>
    <li><a href="#java虚拟线程和传统线程有什么区别">Java虚拟线程和传统线程有什么区别</a>
      <ul>
        <li><a href="#1-实现方式">1. <strong>实现方式</strong></a></li>
        <li><a href="#2-线程模型">2. <strong>线程模型</strong></a></li>
        <li><a href="#3-性能">3. <strong>性能</strong></a></li>
        <li><a href="#4-适用场景-1">4. <strong>适用场景</strong></a></li>
        <li><a href="#5-编程模型">5. <strong>编程模型</strong></a></li>
        <li><a href="#6-资源占用">6. <strong>资源占用</strong></a></li>
        <li><a href="#7-兼容性">7. <strong>兼容性</strong></a></li>
        <li><a href="#8-示例对比">8. <strong>示例对比</strong></a></li>
        <li><a href="#总结-5">总结</a></li>
      </ul>
    </li>
    <li><a href="#可以生成一个java使用虚拟线程的例子吗">可以生成一个java使用虚拟线程的例子吗</a>
      <ul>
        <li><a href="#示例代码-1">示例代码</a></li>
        <li><a href="#代码说明">代码说明</a></li>
        <li><a href="#运行说明">运行说明</a></li>
        <li><a href="#运行命令">运行命令</a></li>
        <li><a href="#注意事项">注意事项</a></li>
      </ul>
    </li>
    <li><a href="#学习资料">学习资料</a></li>
    <li><a href="#basic">basic</a>
      <ul>
        <li><a href="#java-array-转-list">java array 转 list</a>
          <ul>
            <li><a href="#创建一个固定大小的列表">创建一个固定大小的列表</a></li>
            <li><a href="#创建一个可变大小的列表">创建一个可变大小的列表</a></li>
          </ul>
        </li>
        <li><a href="#java-怎么用二进制打印int">java， 怎么用二进制打印int</a>
          <ul>
            <li><a href="#使用-integertobinarystring">使用 <code>Integer.toBinaryString()</code></a></li>
            <li><a href="#打印包含前导零的完整32位">打印包含前导零的完整32位</a></li>
            <li><a href="#使用位运算手动构建二进制字符串">使用位运算手动构建二进制字符串</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#concurrent">concurrent</a></li>
    <li><a href="#每一个java的版本的主要更新">每一个java的版本的主要更新</a>
      <ul>
        <li><a href="#java-10-1996">Java 1.0 (1996)</a></li>
        <li><a href="#java-11-1997">Java 1.1 (1997)</a></li>
        <li><a href="#java-12-1998">Java 1.2 (1998)</a></li>
        <li><a href="#java-13-2000">Java 1.3 (2000)</a></li>
        <li><a href="#java-14-2002">Java 1.4 (2002)</a></li>
        <li><a href="#java-5-2004">Java 5 (2004)</a></li>
        <li><a href="#java-6-2006">Java 6 (2006)</a></li>
        <li><a href="#java-7-2011">Java 7 (2011)</a></li>
        <li><a href="#java-8-2014">Java 8 (2014)</a></li>
        <li><a href="#java-9-2017">Java 9 (2017)</a></li>
        <li><a href="#java-10-2018">Java 10 (2018)</a></li>
        <li><a href="#java-11-2018">Java 11 (2018)</a></li>
        <li><a href="#java-12-2019">Java 12 (2019)</a></li>
        <li><a href="#java-13-2019">Java 13 (2019)</a></li>
        <li><a href="#java-14-2020">Java 14 (2020)</a></li>
        <li><a href="#java-15-2020">Java 15 (2020)</a></li>
        <li><a href="#java-16-2021">Java 16 (2021)</a></li>
        <li><a href="#java-17-2021">Java 17 (2021)</a></li>
        <li><a href="#java-18-2022">Java 18 (2022)</a></li>
        <li><a href="#java-19-2022">Java 19 (2022)</a></li>
        <li><a href="#java-20-2023">Java 20 (2023)</a></li>
        <li><a href="#java-21-2023">Java 21 (2023)</a></li>
        <li><a href="#总结-6">总结</a></li>
      </ul>
    </li>
    <li><a href="#面试java的时候可能会问到有没有了解最新的技术这个我该怎么准备提前了解哪些知识">面试java的时候可能会问到有没有了解最新的技术，这个我该怎么准备，提前了解哪些知识</a>
      <ul>
        <li><a href="#1-java最新版本特性">1. <strong>Java最新版本特性</strong></a></li>
        <li><a href="#2-微服务与云原生技术">2. <strong>微服务与云原生技术</strong></a></li>
        <li><a href="#3-数据库与缓存技术">3. <strong>数据库与缓存技术</strong></a></li>
        <li><a href="#4-性能优化与jvm调优">4. <strong>性能优化与JVM调优</strong></a></li>
        <li><a href="#5-前沿技术与趋势">5. <strong>前沿技术与趋势</strong></a></li>
        <li><a href="#6-实践与项目结合">6. <strong>实践与项目结合</strong></a></li>
        <li><a href="#7-面试中的表达技巧">7. <strong>面试中的表达技巧</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#为什么hashmap要使用红黑树而不使用其他的树结构">为什么HashMap要使用红黑树而不使用其他的树结构？</a>
      <ul>
        <li><a href="#一红黑树的特性优势">一、<strong>红黑树的特性优势</strong></a></li>
        <li><a href="#二与其他树结构的对比">二、<strong>与其他树结构的对比</strong></a>
          <ul>
            <li><a href="#1-与-avl-树的对比">1. <strong>与 AVL 树的对比</strong></a></li>
            <li><a href="#2-与普通二叉搜索树的对比">2. <strong>与普通二叉搜索树的对比</strong></a></li>
            <li><a href="#3-与-b-树b-树的对比">3. <strong>与 B 树/B+ 树的对比</strong></a></li>
          </ul>
        </li>
        <li><a href="#三hashmap-的特定需求">三、<strong>HashMap 的特定需求</strong></a></li>
        <li><a href="#四总结">四、<strong>总结</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#我有这样一个开发场景服务端需要和多个客户端进行tcp连接服务端会发送指令给客户端客户端会返回指令执行结果客户端会定时返回心跳报文上报状态客户端会不定时上报事件报文我该怎么实现上述功能">我有这样一个开发场景，服务端需要和多个客户端进行tcp连接，服务端会发送指令给客户端，客户端会返回指令执行结果；客户端会定时返回心跳报文上报状态；客户端会不定时上报事件报文。我该怎么实现上述功能？</a>
      <ul>
        <li><a href="#1-服务端设计">1. 服务端设计</a>
          <ul>
            <li><a href="#11-建立tcp连接">1.1 建立TCP连接</a></li>
            <li><a href="#12-指令发送">1.2 指令发送</a></li>
            <li><a href="#13-处理客户端返回">1.3 处理客户端返回</a></li>
            <li><a href="#14-心跳处理">1.4 心跳处理</a></li>
            <li><a href="#15-事件处理">1.5 事件处理</a></li>
          </ul>
        </li>
        <li><a href="#2-客户端设计">2. 客户端设计</a>
          <ul>
            <li><a href="#21-连接服务端">2.1 连接服务端</a></li>
            <li><a href="#22-指令执行">2.2 指令执行</a></li>
            <li><a href="#23-心跳发送">2.3 心跳发送</a></li>
            <li><a href="#24-事件上报">2.4 事件上报</a></li>
          </ul>
        </li>
        <li><a href="#3-协议设计">3. 协议设计</a></li>
        <li><a href="#4-实现示例">4. 实现示例</a>
          <ul>
            <li><a href="#服务端示例python伪代码">服务端示例（Python伪代码）</a></li>
            <li><a href="#客户端示例python伪代码">客户端示例（Python伪代码）</a></li>
          </ul>
        </li>
        <li><a href="#5-注意事项">5. 注意事项</a></li>
      </ul>
    </li>
    <li><a href="#如果我使用io多路复用来实现给我一个java版本代码示例">如果我使用IO多路复用来实现，给我一个java版本代码示例</a>
      <ul>
        <li><a href="#服务端代码示例">服务端代码示例</a></li>
        <li><a href="#客户端代码示例">客户端代码示例</a></li>
        <li><a href="#代码说明-1">代码说明</a></li>
        <li><a href="#运行方式">运行方式</a></li>
        <li><a href="#扩展建议">扩展建议</a></li>
      </ul>
    </li>
    <li><a href="#我有一个服务端需要连接多个服务端进行tcp连接给我一个java的代码示例">我有一个服务端，需要连接多个服务端进行tcp连接，给我一个java的代码示例</a>
      <ul>
        <li><a href="#代码示例">代码示例</a></li>
        <li><a href="#代码说明-2">代码说明</a></li>
        <li><a href="#运行方式-1">运行方式</a></li>
        <li><a href="#参考">参考</a></li>
        <li><a href="#扩展建议-1">扩展建议</a></li>
      </ul>
    </li>
    <li><a href="#我在tcp连接的过程中可能会新增连接修改连接信息ip或端口号或者删除连接这个该怎么实现">我在tcp连接的过程中，可能会新增连接，修改连接信息（ip或端口号）或者删除连接，这个该怎么实现</a>
      <ul>
        <li><a href="#设计思路">设计思路</a></li>
        <li><a href="#代码实现">代码实现</a></li>
        <li><a href="#代码说明-3">代码说明</a></li>
        <li><a href="#运行方式-2">运行方式</a></li>
        <li><a href="#扩展建议-2">扩展建议</a></li>
      </ul>
    </li>
    <li><a href="#使用-socketchannel-的-close-方法是否会导致tcp连接还在传输数据的时候意外断开的情况">使用 socketChannel 的 close 方法，是否会导致tcp连接还在传输数据的时候意外断开的情况</a>
      <ul>
        <li><a href="#1-socketchannelclose">1. <strong><code>SocketChannel.close</code> 的行为</strong></a></li>
        <li><a href="#2-数据传输中的关闭">2. <strong>数据传输中的关闭</strong></a></li>
        <li><a href="#3-异常情况">3. <strong>异常情况</strong></a></li>
        <li><a href="#4-最佳实践">4. <strong>最佳实践</strong></a></li>
        <li><a href="#总结-7">总结</a></li>
      </ul>
    </li>
    <li><a href="#我还需要实现对特定连接发送命令报文">我还需要实现对特定连接发送命令报文</a>
      <ul>
        <li><a href="#代码实现-1">代码实现</a></li>
        <li><a href="#代码说明-4">代码说明</a></li>
        <li><a href="#运行方式-3">运行方式</a></li>
        <li><a href="#扩展建议-3">扩展建议</a></li>
      </ul>
    </li>
    <li><a href="#发送完命令之后我需要等待收到一个回复的报文命令执行才算完成">发送完命令之后我需要等待收到一个回复的报文，命令执行才算完成</a>
      <ul>
        <li><a href="#设计思路-1">设计思路</a></li>
        <li><a href="#代码实现-2">代码实现</a></li>
        <li><a href="#代码说明-5">代码说明</a></li>
        <li><a href="#运行方式-4">运行方式</a></li>
        <li><a href="#扩展建议-4">扩展建议</a></li>
      </ul>
    </li>
    <li><a href="#如果连接的tcp数量很多使用一个selector接收有点慢该怎么优化">如果连接的tcp数量很多，使用一个selector接收有点慢，该怎么优化</a>
      <ul>
        <li><a href="#1-优化思路">1. <strong>优化思路</strong></a>
          <ul>
            <li><a href="#11-使用多个-selector">1.1 <strong>使用多个 Selector</strong></a></li>
            <li><a href="#12-分离连接处理和数据处理">1.2 <strong>分离连接处理和数据处理</strong></a></li>
            <li><a href="#13-调整缓冲区大小">1.3 <strong>调整缓冲区大小</strong></a></li>
            <li><a href="#14-使用非阻塞-io">1.4 <strong>使用非阻塞 I/O</strong></a></li>
            <li><a href="#15-减少事件处理的耗时">1.5 <strong>减少事件处理的耗时</strong></a></li>
          </ul>
        </li>
        <li><a href="#2-实现示例">2. <strong>实现示例</strong></a></li>
        <li><a href="#3-优化建议">3. <strong>优化建议</strong></a></li>
        <li><a href="#4-参考外部资料">4. <strong>参考外部资料</strong></a></li>
      </ul>
    </li>
    <li><a href="#如果我需要维护100个tcp连接使用一个selector够吗">如果我需要维护100个tcp连接，使用一个selector够吗</a>
      <ul>
        <li><a href="#1-单个">1. <strong>单个 <code>Selector</code> 的局限性</strong></a></li>
        <li><a href="#2-优化方案">2. <strong>优化方案</strong></a>
          <ul>
            <li><a href="#21-使用多个">2.1 <strong>使用多个 <code>Selector</code></strong></a></li>
            <li><a href="#22-分离连接处理和数据处理">2.2 <strong>分离连接处理和数据处理</strong></a></li>
            <li><a href="#23-调整缓冲区大小">2.3 <strong>调整缓冲区大小</strong></a></li>
            <li><a href="#24-使用非阻塞-io">2.4 <strong>使用非阻塞 I/O</strong></a></li>
            <li><a href="#25-减少事件处理的耗时">2.5 <strong>减少事件处理的耗时</strong></a></li>
          </ul>
        </li>
        <li><a href="#3-参考外部资料">3. <strong>参考外部资料</strong></a></li>
        <li><a href="#4-示例代码-1">4. <strong>示例代码</strong></a></li>
        <li><a href="#5-总结-1">5. <strong>总结</strong></a></li>
      </ul>
    </li>
    <li><a href="#在java中一个tcp连接使用一个socket连接多个tcp这样占用很多内存吗">在java中，一个tcp连接使用一个socket，连接多个tcp，这样占用很多内存吗</a></li>
    <li><a href="#在java中创建线程的内存开销">在java中创建线程的内存开销</a>
      <ul>
        <li><a href="#1-线程栈的内存开销">1. <strong>线程栈的内存开销</strong></a></li>
        <li><a href="#2-其他内存开销">2. <strong>其他内存开销</strong></a></li>
        <li><a href="#3-线程创建和销毁的开销">3. <strong>线程创建和销毁的开销</strong></a></li>
        <li><a href="#4-线程池的优化">4. <strong>线程池的优化</strong></a></li>
        <li><a href="#5-如何减少线程内存开销">5. <strong>如何减少线程内存开销</strong></a></li>
        <li><a href="#总结-8">总结</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












