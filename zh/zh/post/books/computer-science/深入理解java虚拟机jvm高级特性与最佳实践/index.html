<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  第1章　走近Java
  #

1.1　概述 / 2
1.2　Java技术体系 / 3
1.3　Java发展史 / 5
1.4　展望Java技术的未来 / 9
1.4.1　模块化 / 9
1.4.2　混合语言 / 9
1.4.3　多核并行 / 11
1.4.4　进一步丰富语法 / 12
1.4.5　64位虚拟机 / 13
1.5　实战：自己编译JDK / 13
1.5.1　获取JDK源码 / 13
1.5.2　系统需求 / 14
1.5.3　构建编译环境 / 15
1.5.4　准备依赖项 / 17
1.5.5　进行编译 / 18
1.6　本章小结 / 21

  第2章　Java内存区域与内存溢出异常
  #

Java与C&#43;&#43;之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="/zh/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">
  <meta property="og:site_name" content="Penruins">
  <meta property="og:title" content="深入理解Java虚拟机：JVM高级特性与最佳实践">
  <meta property="og:description" content="第1章　走近Java # 1.1　概述 / 2 1.2　Java技术体系 / 3 1.3　Java发展史 / 5 1.4　展望Java技术的未来 / 9 1.4.1　模块化 / 9 1.4.2　混合语言 / 9 1.4.3　多核并行 / 11 1.4.4　进一步丰富语法 / 12 1.4.5　64位虚拟机 / 13 1.5　实战：自己编译JDK / 13 1.5.1　获取JDK源码 / 13 1.5.2　系统需求 / 14 1.5.3　构建编译环境 / 15 1.5.4　准备依赖项 / 17 1.5.5　进行编译 / 18 1.6　本章小结 / 21
第2章　Java内存区域与内存溢出异常 # Java与C&#43;&#43;之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="zh">
<title>深入理解Java虚拟机：JVM高级特性与最佳实践 | Penruins</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="/zh/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">
<link rel="stylesheet" href="/book.min.26e661cf8028ea69ebe162050990c3a07de74e5bfe9389e880f2d6a7e5fa587c.css" >
  <script defer src="/fuse.min.js"></script>
  <script defer src="/zh.search.min.d6783a87034dec05abaff917f340568fbbaa22131f36e7ffcbc0ffb8276dd509.js" ></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/zh/"><span>Penruins</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>



  



  
    
  
    
  



<ul class="book-languages">
  <li>
    <input type="checkbox" id="languages" class="toggle" />
    <label for="languages" class="flex justify-between">
      <a role="button" class="flex align-center">
        <img src="/svg/translate.svg" class="book-icon" alt="Languages" />
        中文
      </a>
    </label>

    <ul>
      
      <li>
        <a href="/cn/">
          
        </a>
      </li>
      
      <li>
        <a href="/en/">
          English
        </a>
      </li>
      
    </ul>
  </li>
</ul>














  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Life</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/movies-log/" class="">观影记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/bilibili/" class="">bilibili</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/books/" class="">books</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/cycling/" class="">cycling</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/hiking/" class="">hiking</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/life-recommend/" class="">life recommand</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/learning-others-log/" class="">other learning</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/podcast/" class="">podcast</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/politics/" class="">politics</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/goal/" class="">goal</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/accumulation/" class="">accumulation</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/coffee/" class="">coffee</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Computer Science</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-855531983528655844a29f37632e7e30" class="toggle"  />
    <label for="section-855531983528655844a29f37632e7e30" class="flex justify-between">
      <a role="button" class="">Java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/java/" class="">java</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/mybatis/" class="">Mybatis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/jvm/" class="">jvm</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-recommend/" class="">推荐</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-learning-log/" class="">学习记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/database/" class="">database</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/echarts/" class="">echarts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/github/" class="">github</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/ios/" class="">ios</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/job/" class="">job</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/mac/" class="">mac</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/raspberrypi/" class="">raspberry pi</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/security/" class="">security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/vue/" class="">vue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/algorithm/" class="">Algorithm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/linux/" class="">linux</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Others</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/about-me/" class="">about me</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/english-learning/" class="">English Learning</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Books</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-70696d57febbe00561bcceac2d174d7c" class="toggle"  />
    <label for="section-70696d57febbe00561bcceac2d174d7c" class="flex justify-between">
      <a role="button" class="">Computer Science</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" class="">Java并发编程实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%AE%9E%E6%88%98/" class="">Java实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="">Python神经网络编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="">Redis设计与实现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/" class="">Spring Cloud微服务：入门、实战与进阶</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E5%89%91%E6%8C%87offer/" class="">剑指Offer</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="">深入理解Java虚拟机：JVM高级特性与最佳实践</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/" class="">深入浅出HTTPS：从原理到实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E6%94%B6%E5%89%B2-offer%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F/" class="">收割Offer：互联网大厂面经</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" class="">一本书讲透 ElasticSearch：原理、进阶与工程实践</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E7%AC%AC%E4%B8%89%E7%89%88/" class="">宏观经济学 第三版</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E7%BE%8E%E5%9B%BD%E5%9B%B0%E5%B1%80/" class="">美国困局</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E8%8B%B1%E4%BC%9F%E8%BE%BE-%E9%BB%84%E4%BB%81%E5%8B%8B%E4%B9%8B%E8%8A%AF/" class="">英伟达-黄仁勋之芯</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E7%94%A8%E5%9C%B0%E5%9B%BE%E7%9C%8B%E6%87%82%E4%B8%96%E7%95%8C%E6%A0%BC%E5%B1%80/" class="">用地图看懂世界格局</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>深入理解Java虚拟机：JVM高级特性与最佳实践</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第1章走近java">第1章　走近Java</a></li>
    <li><a href="#第2章java内存区域与内存溢出异常">第2章　Java内存区域与内存溢出异常</a>
      <ul>
        <li><a href="#21概述">2.1　概述</a></li>
        <li><a href="#22运行时数据区域">2.2　运行时数据区域</a>
          <ul>
            <li><a href="#221程序计数器">2.2.1　程序计数器</a></li>
            <li><a href="#222java虚拟机栈">2.2.2　Java虚拟机栈</a></li>
            <li><a href="#223本地方法栈">2.2.3　本地方法栈</a></li>
            <li><a href="#224java堆">2.2.4　Java堆</a></li>
            <li><a href="#225方法区">2.2.5　方法区</a></li>
            <li><a href="#226运行时常量池">2.2.6　运行时常量池</a></li>
            <li><a href="#227直接内存">2.2.7　直接内存</a></li>
          </ul>
        </li>
        <li><a href="#23hotspot虚拟机对象探秘">2.3　HotSpot虚拟机对象探秘</a>
          <ul>
            <li><a href="#231-对象的创建">2.3.1 对象的创建</a></li>
            <li><a href="#232-对象的内存布局">2.3.2 对象的内存布局</a></li>
            <li><a href="#233-对象的访问定位">2.3.3 对象的访问定位</a></li>
          </ul>
        </li>
        <li><a href="#24实战outofmemoryerror异常">2.4　实战：OutOfMemoryError异常</a>
          <ul>
            <li><a href="#241java堆溢出">2.4.1　Java堆溢出</a></li>
            <li><a href="#242虚拟机栈和本地方法栈溢出">2.4.2　虚拟机栈和本地方法栈溢出</a></li>
            <li><a href="#243方法区和运行时常量池溢出">2.4.3　方法区和运行时常量池溢出</a></li>
            <li><a href="#244本机直接内存溢出">2.4.4　本机直接内存溢出</a></li>
          </ul>
        </li>
        <li><a href="#25本章小结">2.5　本章小结</a></li>
      </ul>
    </li>
    <li><a href="#第3章垃圾收集器与内存分配策略">第3章　垃圾收集器与内存分配策略</a>
      <ul>
        <li><a href="#31概述">3.1　概述</a></li>
        <li><a href="#32对象已死">3.2　对象已死？</a>
          <ul>
            <li><a href="#321引用计数算法">3.2.1　引用计数算法</a></li>
            <li><a href="#322可达性分析算法">3.2.2　可达性分析算法</a></li>
            <li><a href="#323再谈引用">3.2.3　再谈引用</a></li>
            <li><a href="#324生存还是死亡">3.2.4　生存还是死亡？</a></li>
            <li><a href="#325回收方法区">3.2.5　回收方法区</a></li>
          </ul>
        </li>
        <li><a href="#33垃圾收集算法">3.3　垃圾收集算法</a>
          <ul>
            <li><a href="#331分代收集理论">3.3.1　分代收集理论</a></li>
            <li><a href="#332标记-清除算法">3.3.2　标记-清除算法</a></li>
            <li><a href="#333标记-复制算法">3.3.3　标记-复制算法</a></li>
            <li><a href="#334标记-整理算法">3.3.4　标记-整理算法</a></li>
          </ul>
        </li>
        <li><a href="#34hotspot的算法细节实现">3.4　HotSpot的算法细节实现</a>
          <ul>
            <li><a href="#341根节点枚举">3.4.1　根节点枚举</a></li>
            <li><a href="#342安全点">3.4.2　安全点</a></li>
            <li><a href="#343安全区域">3.4.3　安全区域</a></li>
            <li><a href="#344记忆集与卡表">3.4.4　记忆集与卡表</a></li>
            <li><a href="#345写屏障">3.4.5　写屏障</a></li>
            <li><a href="#346并发的可达性分析">3.4.6　并发的可达性分析</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第4章虚拟机性能监控故障处理工具">第4章　虚拟机性能监控、故障处理工具</a></li>
    <li><a href="#第5章调优案例分析与实战">第5章　调优案例分析与实战</a></li>
    <li><a href="#第6章类文件结构">第6章　类文件结构</a></li>
    <li><a href="#第7章虚拟机类加载机制">第7章　虚拟机类加载机制</a></li>
    <li><a href="#第8章虚拟机字节码执行引擎">第8章　虚拟机字节码执行引擎</a></li>
    <li><a href="#第9章类加载及执行子系统的案例与实战">第9章　类加载及执行子系统的案例与实战</a></li>
    <li><a href="#第10章前端编译与优化">第10章　前端编译与优化</a></li>
    <li><a href="#第11章后端编译与优化">第11章　后端编译与优化</a></li>
    <li><a href="#第12章java内存模型与线程">第12章　Java内存模型与线程</a></li>
    <li><a href="#第13章线程安全与锁优化">第13章　线程安全与锁优化</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h2 id="第1章走近java">
  第1章　走近Java
  <a class="anchor" href="#%e7%ac%ac1%e7%ab%a0%e8%b5%b0%e8%bf%91java">#</a>
</h2>
<p>1.1　概述 / 2
1.2　Java技术体系 / 3
1.3　Java发展史 / 5
1.4　展望Java技术的未来 / 9
1.4.1　模块化 / 9
1.4.2　混合语言 / 9
1.4.3　多核并行 / 11
1.4.4　进一步丰富语法 / 12
1.4.5　64位虚拟机 / 13
1.5　实战：自己编译JDK / 13
1.5.1　获取JDK源码 / 13
1.5.2　系统需求 / 14
1.5.3　构建编译环境 / 15
1.5.4　准备依赖项 / 17
1.5.5　进行编译 / 18
1.6　本章小结 / 21</p>
<h2 id="第2章java内存区域与内存溢出异常">
  第2章　Java内存区域与内存溢出异常
  <a class="anchor" href="#%e7%ac%ac2%e7%ab%a0java%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%e4%b8%8e%e5%86%85%e5%ad%98%e6%ba%a2%e5%87%ba%e5%bc%82%e5%b8%b8">#</a>
</h2>
<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</p>
<h3 id="21概述">
  2.1　概述
  <a class="anchor" href="#21%e6%a6%82%e8%bf%b0">#</a>
</h3>
<h3 id="22运行时数据区域">
  2.2　运行时数据区域
  <a class="anchor" href="#22%e8%bf%90%e8%a1%8c%e6%97%b6%e6%95%b0%e6%8d%ae%e5%8c%ba%e5%9f%9f">#</a>
</h3>
<h4 id="221程序计数器">
  2.2.1　程序计数器
  <a class="anchor" href="#221%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8">#</a>
</h4>
<ul>
<li>程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</li>
<li>Java虚拟机的概念模型里￼，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</li>
<li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</li>
</ul>
<h4 id="222java虚拟机栈">
  2.2.2　Java虚拟机栈
  <a class="anchor" href="#222java%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88">#</a>
</h4>
<ul>
<li>与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stack)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧￼(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>经常有人把Java内存区域笼统地划分为堆内存(Heap)和栈内存(Stack)，这种划分方式直接继承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区域是“堆”和“栈”两块。其中，“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或者更多的情况下只是指虚拟机栈中局部变量表部分。
<ul>
<li>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</li>
</ul>
</li>
<li>这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</li>
<li>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展￼，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</li>
</ul>
<h4 id="223本地方法栈">
  2.2.3　本地方法栈
  <a class="anchor" href="#223%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88">#</a>
</h4>
<ul>
<li>本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。</li>
<li>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</li>
</ul>
<h4 id="224java堆">
  2.2.4　Java堆
  <a class="anchor" href="#224java%e5%a0%86">#</a>
</h4>
<ul>
<li>对于Java应用程序来说，Java堆(Java Heap)是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。</li>
<li>在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配￼”，而这里笔者写的“几乎”是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换￼优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。</li>
<li>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。</li>
<li>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer，TLAB)，以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</li>
<li>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</li>
<li>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</li>
</ul>
<h4 id="225方法区">
  2.2.5　方法区
  <a class="anchor" href="#225%e6%96%b9%e6%b3%95%e5%8c%ba">#</a>
</h4>
<ul>
<li>方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”(Non-Heap)，目的是与Java堆区分开来。</li>
<li>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载</li>
<li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</li>
</ul>
<h4 id="226运行时常量池">
  2.2.6　运行时常量池
  <a class="anchor" href="#226%e8%bf%90%e8%a1%8c%e6%97%b6%e5%b8%b8%e9%87%8f%e6%b1%a0">#</a>
</h4>
<ul>
<li>运行时常量池(Runtime Constant Pool)是方法区的一部分</li>
<li>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</li>
<li>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</li>
</ul>
<h4 id="227直接内存">
  2.2.7　直接内存
  <a class="anchor" href="#227%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98">#</a>
</h4>
<ul>
<li>在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</li>
</ul>
<h3 id="23hotspot虚拟机对象探秘">
  2.3　HotSpot虚拟机对象探秘
  <a class="anchor" href="#23hotspot%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%af%b9%e8%b1%a1%e6%8e%a2%e7%a7%98">#</a>
</h3>
<h4 id="231-对象的创建">
  2.3.1 对象的创建
  <a class="anchor" href="#231-%e5%af%b9%e8%b1%a1%e7%9a%84%e5%88%9b%e5%bb%ba">#</a>
</h4>
<ul>
<li>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程</li>
<li>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定将在2.3.2节中介绍），为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。</li>
<li>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”(Bump The Pointer)。</li>
<li>但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”(Free List)。</li>
<li>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理(Compact)的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除(Sweep)算法的收集器时，理论上￼就只能采用较为复杂的空闲列表来分配内存。</li>
<li>对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。
<ul>
<li>一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性</li>
<li>另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</li>
</ul>
</li>
<li>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</li>
<li>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header)之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>
<li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的<!-- raw HTML omitted -->()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。new指令之后会接着执行<!-- raw HTML omitted -->()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</li>
</ul>
<h4 id="232-对象的内存布局">
  2.3.2 对象的内存布局
  <a class="anchor" href="#232-%e5%af%b9%e8%b1%a1%e7%9a%84%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80">#</a>
</h4>
<ul>
<li>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：
<ul>
<li>对象头(Header)
<ul>
<li>第一类是用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。</li>
<li>对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</li>
<li>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</li>
</ul>
</li>
<li>实例数据(Instance Data)
<ul>
<li>HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers，OOPs)，从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</li>
</ul>
</li>
<li>对齐填充(Padding)
<ul>
<li>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="233-对象的访问定位">
  2.3.3 对象的访问定位
  <a class="anchor" href="#233-%e5%af%b9%e8%b1%a1%e7%9a%84%e8%ae%bf%e9%97%ae%e5%ae%9a%e4%bd%8d">#</a>
</h4>
<ul>
<li>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息</li>
<li>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销</li>
<li>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</li>
<li>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机HotSpot而言，它主要使用第二种方式进行对象访问</li>
</ul>
<h3 id="24实战outofmemoryerror异常">
  2.4　实战：OutOfMemoryError异常
  <a class="anchor" href="#24%e5%ae%9e%e6%88%98outofmemoryerror%e5%bc%82%e5%b8%b8">#</a>
</h3>
<h4 id="241java堆溢出">
  2.4.1　Java堆溢出
  <a class="anchor" href="#241java%e5%a0%86%e6%ba%a2%e5%87%ba">#</a>
</h4>
<ul>
<li>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。</li>
</ul>
<h4 id="242虚拟机栈和本地方法栈溢出">
  2.4.2　虚拟机栈和本地方法栈溢出
  <a class="anchor" href="#242%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88%e5%92%8c%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88%e6%ba%a2%e5%87%ba">#</a>
</h4>
<h4 id="243方法区和运行时常量池溢出">
  2.4.3　方法区和运行时常量池溢出
  <a class="anchor" href="#243%e6%96%b9%e6%b3%95%e5%8c%ba%e5%92%8c%e8%bf%90%e8%a1%8c%e6%97%b6%e5%b8%b8%e9%87%8f%e6%b1%a0%e6%ba%a2%e5%87%ba">#</a>
</h4>
<h4 id="244本机直接内存溢出">
  2.4.4　本机直接内存溢出
  <a class="anchor" href="#244%e6%9c%ac%e6%9c%ba%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98%e6%ba%a2%e5%87%ba">#</a>
</h4>
<h3 id="25本章小结">
  2.5　本章小结
  <a class="anchor" href="#25%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93">#</a>
</h3>
<h2 id="第3章垃圾收集器与内存分配策略">
  第3章　垃圾收集器与内存分配策略
  <a class="anchor" href="#%e7%ac%ac3%e7%ab%a0%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e4%b8%8e%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5">#</a>
</h2>
<h3 id="31概述">
  3.1　概述
  <a class="anchor" href="#31%e6%a6%82%e8%bf%b0">#</a>
</h3>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
<li>每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。</li>
<li>而Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理</li>
</ul>
<h3 id="32对象已死">
  3.2　对象已死？
  <a class="anchor" href="#32%e5%af%b9%e8%b1%a1%e5%b7%b2%e6%ad%bb">#</a>
</h3>
<h4 id="321引用计数算法">
  3.2.1　引用计数算法
  <a class="anchor" href="#321%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e7%ae%97%e6%b3%95">#</a>
</h4>
<h4 id="322可达性分析算法">
  3.2.2　可达性分析算法
  <a class="anchor" href="#322%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95">#</a>
</h4>
<ul>
<li>如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</li>
<li>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
</li>
</ul>
<h4 id="323再谈引用">
  3.2.3　再谈引用
  <a class="anchor" href="#323%e5%86%8d%e8%b0%88%e5%bc%95%e7%94%a8">#</a>
</h4>
<ul>
<li>强引用(Strongly Re-ference)
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
</ul>
</li>
<li>软引用(Soft Reference)
<ul>
<li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
</ul>
</li>
<li>弱引用(Weak Reference)
<ul>
<li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>
</ul>
</li>
<li>虚引用(Phantom Reference)
<ul>
<li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>
</li>
</ul>
<h4 id="324生存还是死亡">
  3.2.4　生存还是死亡？
  <a class="anchor" href="#324%e7%94%9f%e5%ad%98%e8%bf%98%e6%98%af%e6%ad%bb%e4%ba%a1">#</a>
</h4>
<h4 id="325回收方法区">
  3.2.5　回收方法区
  <a class="anchor" href="#325%e5%9b%9e%e6%94%b6%e6%96%b9%e6%b3%95%e5%8c%ba">#</a>
</h4>
<ul>
<li>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。</li>
<li>要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li>
</ul>
<h3 id="33垃圾收集算法">
  3.3　垃圾收集算法
  <a class="anchor" href="#33%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95">#</a>
</h3>
<h4 id="331分代收集理论">
  3.3.1　分代收集理论
  <a class="anchor" href="#331%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86%e7%90%86%e8%ae%ba">#</a>
</h4>
<ul>
<li>分代假说
<ul>
<li>1)弱分代假说(Weak Generational Hypothesis)：绝大多数对象都是朝生夕灭的。</li>
<li>2)强分代假说(Strong Generational Hypothesis)：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
<li>3)跨代引用假说(Intergenerational Reference Hypothesis)：跨代引用相对于同代引用来说仅占极少数。
<ul>
<li>如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。</li>
</ul>
</li>
</ul>
</li>
<li>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</li>
<li>如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间</li>
<li>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分</li>
<li>把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为新生代(Young Generation)和老年代(Old Generation)两个区域
<ul>
<li>在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</li>
</ul>
</li>
<li>分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会存在跨代引用。
<ul>
<li>假如要现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样</li>
<li>新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</li>
</ul>
</li>
<li>部分收集(Partial GC)：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
<ul>
<li>新生代收集(Minor GC/Young GC)：指目标只是新生代的垃圾收集。</li>
<li>老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</li>
<li>混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
<li>整堆收集(Full GC)：收集整个Java堆和方法区的垃圾收集。</li>
</ul>
</li>
</ul>
<h4 id="332标记-清除算法">
  3.3.2　标记-清除算法
  <a class="anchor" href="#332%e6%a0%87%e8%ae%b0-%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95">#</a>
</h4>
<h4 id="333标记-复制算法">
  3.3.3　标记-复制算法
  <a class="anchor" href="#333%e6%a0%87%e8%ae%b0-%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95">#</a>
</h4>
<ul>
<li>分配担保</li>
</ul>
<h4 id="334标记-整理算法">
  3.3.4　标记-整理算法
  <a class="anchor" href="#334%e6%a0%87%e8%ae%b0-%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95">#</a>
</h4>
<ul>
<li>即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。</li>
</ul>
<h3 id="34hotspot的算法细节实现">
  3.4　HotSpot的算法细节实现
  <a class="anchor" href="#34hotspot%e7%9a%84%e7%ae%97%e6%b3%95%e7%bb%86%e8%8a%82%e5%ae%9e%e7%8e%b0">#</a>
</h3>
<h4 id="341根节点枚举">
  3.4.1　根节点枚举
  <a class="anchor" href="#341%e6%a0%b9%e8%8a%82%e7%82%b9%e6%9e%9a%e4%b8%be">#</a>
</h4>
<ul>
<li>迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。</li>
<li>现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行——这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。</li>
</ul>
<h4 id="342安全点">
  3.4.2　安全点
  <a class="anchor" href="#342%e5%ae%89%e5%85%a8%e7%82%b9">#</a>
</h4>
<ul>
<li>有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。</li>
</ul>
<h4 id="343安全区域">
  3.4.3　安全区域
  <a class="anchor" href="#343%e5%ae%89%e5%85%a8%e5%8c%ba%e5%9f%9f">#</a>
</h4>
<h4 id="344记忆集与卡表">
  3.4.4　记忆集与卡表
  <a class="anchor" href="#344%e8%ae%b0%e5%bf%86%e9%9b%86%e4%b8%8e%e5%8d%a1%e8%a1%a8">#</a>
</h4>
<ul>
<li>讲解分代收集理论的时候，提到了为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集(Remembered Set)的数据结构，用以避免把整个老年代加进GC Roots扫描范围。</li>
<li>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</li>
</ul>
<h4 id="345写屏障">
  3.4.5　写屏障
  <a class="anchor" href="#345%e5%86%99%e5%b1%8f%e9%9a%9c">#</a>
</h4>
<h4 id="346并发的可达性分析">
  3.4.6　并发的可达性分析
  <a class="anchor" href="#346%e5%b9%b6%e5%8f%91%e7%9a%84%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90">#</a>
</h4>
<p>3.5　经典垃圾收集器
3.5.1　Serial收集器
3.5.2　ParNew收集器 92
3.5.3　Parallel Scavenge收集器 93
3.5.4　Serial Old收集器 94
3.5.5　Parallel Old收集器 95
3.5.6　CMS收集器 96
3.5.7　Garbage First收集器 98
3.6　低延迟垃圾收集器 104
3.6.1　Shenandoah收集器 105
3.6.2　ZGC收集器 112
3.7　选择合适的垃圾收集器 121
3.7.1　Epsilon收集器 121
3.7.2　收集器的权衡 121
3.7.3　虚拟机及垃圾收集器日志 122
3.7.4　垃圾收集器参数总结 127
3.8　实战：内存分配与回收策略 129
3.8.1　对象优先在Eden分配 130
3.8.2　大对象直接进入老年代 131
3.8.3　长期存活的对象将进入老年代 132
3.8.4　动态对象年龄判定 134
3.8.5　空间分配担保 135
3.9　本章小结 137</p>
<h2 id="第4章虚拟机性能监控故障处理工具">
  第4章　虚拟机性能监控、故障处理工具
  <a class="anchor" href="#%e7%ac%ac4%e7%ab%a0%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%80%a7%e8%83%bd%e7%9b%91%e6%8e%a7%e6%95%85%e9%9a%9c%e5%a4%84%e7%90%86%e5%b7%a5%e5%85%b7">#</a>
</h2>
<p>4.1　概述 138
4.2　基础故障处理工具 138
4.2.1　jps：虚拟机进程状况工具 141
4.2.2　jstat：虚拟机统计信息监视工具 142
4.2.3　jinfo：Java配置信息工具 143
4.2.4　jmap：Java内存映像工具 144
4.2.5　jhat：虚拟机堆转储快照分析工具 145
4.2.6　jstack：Java堆栈跟踪工具 146
4.2.7　基础工具总结 148
4.3　可视化故障处理工具 151
4.3.1　JHSDB：基于服务性代理的调试工具 152
4.3.2　JConsole：Java监视与管理控制台 157
4.3.3　VisualVM：多合-故障处理工具 164
4.3.4　Java Mission Control：可持续在线的监控工具 171
4.4　HotSpot虚拟机插件及工具 175
4.5　本章小结 180</p>
<h2 id="第5章调优案例分析与实战">
  第5章　调优案例分析与实战
  <a class="anchor" href="#%e7%ac%ac5%e7%ab%a0%e8%b0%83%e4%bc%98%e6%a1%88%e4%be%8b%e5%88%86%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98">#</a>
</h2>
<p>5.1　概述 181
5.2　案例分析 181
5.2.1　大内存硬件上的程序部署策略 182
5.2.2　集群间同步导致的内存溢出 184
5.2.3　堆外内存导致的溢出错误 185
5.2.4　外部命令导致系统缓慢 187
5.2.5　服务器虚拟机进程崩溃 187
5.2.6　不恰当数据结构导致内存占用过大 188
5.2.7　由Windows虚拟内存导致的长时间停顿 189
5.2.8　由安全点导致长时间停顿 190
5.3　实战：Eclipse运行速度调优 192
5.3.1　调优前的程序运行状态 193
5.3.2　升级JDK版本的性能变化及兼容问题 196
5.3.3　编译时间和类加载时间的优化 200
5.3.4　调整内存设置控制垃圾收集频率 203
5.3.5　选择收集器降低延迟 206
5.4　本章小结 209
第三部分　虚拟机执行子系统</p>
<h2 id="第6章类文件结构">
  第6章　类文件结构
  <a class="anchor" href="#%e7%ac%ac6%e7%ab%a0%e7%b1%bb%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84">#</a>
</h2>
<p>6.1　概述 212
6.2　无关性的基石 212
6.3　Class类文件的结构 214
6.3.1　魔数与Class文件的版本 215
6.3.2　常量池 218
6.3.3　访问标志 224
6.3.4　类索引、父类索引与接口索引集合 225
6.3.5　字段表集合 226
6.3.6　方法表集合 229
6.3.7　属性表集合 230
6.4　字节码指令简介 251
6.4.1　字节码与数据类型 251
6.4.2　加载和存储指令 253
6.4.3　运算指令 254
6.4.4　类型转换指令 255
6.4.5　对象创建与访问指令 256
6.4.6　操作数栈管理指令 256
6.4.7　控制转移指令 257
6.4.8　方法调用和返回指令 257
6.4.9　异常处理指令 258
6.4.10　同步指令 258
6.5　公有设计，私有实现 259
6.6　Class文件结构的发展 260
6.7　本章小结 261</p>
<h2 id="第7章虚拟机类加载机制">
  第7章　虚拟机类加载机制
  <a class="anchor" href="#%e7%ac%ac7%e7%ab%a0%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%b1%bb%e5%8a%a0%e8%bd%bd%e6%9c%ba%e5%88%b6">#</a>
</h2>
<p>7.1　概述 262
7.2　类加载的时机 263
7.3　类加载的过程 267
7.3.1　加载 267
7.3.2　验证 268
7.3.3　准备 271
7.3.4　解析 272
7.3.5　初始化 277
7.4　类加载器 279
7.4.1　类与类加载器 280
7.4.2　双亲委派模型 281
7.4.3　破坏双亲委派模型 285
7.5　Java模块化系统 287
7.5.1　模块的兼容性 288
7.5.2　模块化下的类加载器 290
7.6　本章小结 292</p>
<h2 id="第8章虚拟机字节码执行引擎">
  第8章　虚拟机字节码执行引擎
  <a class="anchor" href="#%e7%ac%ac8%e7%ab%a0%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%ad%97%e8%8a%82%e7%a0%81%e6%89%a7%e8%a1%8c%e5%bc%95%e6%93%8e">#</a>
</h2>
<p>8.1　概述 293
8.2　运行时栈帧结构 294
8.2.1　局部变量表 294
8.2.2　操作数栈 299
8.2.3　动态连接 300
8.2.4　方法返回地址 300
8.2.5　附加信息 301
8.3　方法调用 301
8.3.1　解析 301
8.3.2　分派 303
8.4　动态类型语言支持 315
8.4.1　动态类型语言 316
8.4.2　Java与动态类型 317
8.4.3　java.lang.invoke包 318
8.4.4　invokedynamic指令 321
8.4.5　实战：掌控方法分派规则 324
8.5　基于栈的字节码解释执行引擎 326
8.5.1　解释执行 327
8.5.2　基于栈的指令集与基于寄存器的指令集 328
8.5.3　基于栈的解释器执行过程 329
8.6　本章小结 334</p>
<h2 id="第9章类加载及执行子系统的案例与实战">
  第9章　类加载及执行子系统的案例与实战
  <a class="anchor" href="#%e7%ac%ac9%e7%ab%a0%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%8f%8a%e6%89%a7%e8%a1%8c%e5%ad%90%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%a1%88%e4%be%8b%e4%b8%8e%e5%ae%9e%e6%88%98">#</a>
</h2>
<p>9.1　概述 335
9.2　案例分析 335
9.2.1　Tomcat：正统的类加载器架构 335
9.2.2　OSGi：灵活的类加载器架构 338
9.2.3　字节码生成技术与动态代理的实现 341
9.2.4　Backport工具：Java的时光机器 345
9.3　实战：自己动手实现远程执行功能 348
9.3.1　目标 348
9.3.2　思路 349
9.3.3　实现 350
9.3.4　验证 355
9.4　本章小结 356</p>
<h2 id="第10章前端编译与优化">
  第10章　前端编译与优化
  <a class="anchor" href="#%e7%ac%ac10%e7%ab%a0%e5%89%8d%e7%ab%af%e7%bc%96%e8%af%91%e4%b8%8e%e4%bc%98%e5%8c%96">#</a>
</h2>
<p>10.1　概述 358
10.2　Javac编译器 359
10.2.1　Javac的源码与调试 359
10.2.2　解析与填充符号表 362
10.2.3　注解处理器 363
10.2.4　语义分析与字节码生成 364
10.3　Java语法糖的味道 367
10.3.1　泛型 367
10.3.2　自动装箱、拆箱与遍历循环 375
10.3.3　条件编译 377
10.4　实战：插入式注解处理器 378
10.4.1　实战目标 379
10.4.2　代码实现 379
10.4.3　运行与测试 385
10.4.4　其他应用案例 386
10.5　本章小结 386</p>
<h2 id="第11章后端编译与优化">
  第11章　后端编译与优化
  <a class="anchor" href="#%e7%ac%ac11%e7%ab%a0%e5%90%8e%e7%ab%af%e7%bc%96%e8%af%91%e4%b8%8e%e4%bc%98%e5%8c%96">#</a>
</h2>
<p>11.1　概述 388
11.2　即时编译器 389
11.2.1　解释器与编译器 389
11.2.2　编译对象与触发条件 392
11.2.3　编译过程 397
11.2.4　实战：查看及分析即时编译结果 398
11.3　提前编译器 404
11.3.1　提前编译的优劣得失 405
11.3.2　实战：Jaotc的提前编译 408
11.4　编译器优化技术 411
11.4.1　优化技术概览 411
11.4.2　方法内联 415
11.4.3　逃逸分析 417
11.4.4　公共子表达式消除 420
11.4.5　数组边界检查消除 421
11.5　实战：深入理解Graal编译器 423
11.5.1　历史背景 423
11.5.2　构建编译调试环境 424
11.5.3　JVMCI编译器接口 426
11.5.4　代码中间表示 429
11.5.5　代码优化与生成 432
11.6　本章小结 436</p>
<h2 id="第12章java内存模型与线程">
  第12章　Java内存模型与线程
  <a class="anchor" href="#%e7%ac%ac12%e7%ab%a0java%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b">#</a>
</h2>
<p>12.1　概述 438
12.2　硬件的效率与一致性 439
12.3　Java内存模型 440
12.3.1　主内存与工作内存 441
12.3.2　内存间交互操作 442
12.3.3　对于volatile型变量的特殊规则 444
12.3.4　针对long和double型变量的特殊规则 450
12.3.5　原子性、可见性与有序性 450
12.3.6　先行发生原则 452
12.4　Java与线程 455
12.4.1　线程的实现 455
12.4.2　Java线程调度 458
12.4.3　状态转换 460
12.5　Java与协程 461
12.5.1　内核线程的局限 461
12.5.2　协程的复苏 462
12.5.3　Java的解决方案 464
12.6　本章小结 465</p>
<h2 id="第13章线程安全与锁优化">
  第13章　线程安全与锁优化
  <a class="anchor" href="#%e7%ac%ac13%e7%ab%a0%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e4%b8%8e%e9%94%81%e4%bc%98%e5%8c%96">#</a>
</h2>
<p>13.1　概述 466
13.2　线程安全 466
13.2.1　Java语言中的线程安全 467
13.2.2　线程安全的实现方法 471
13.3　锁优化 479
13.3.1　自旋锁与自适应自旋 479
13.3.2　锁消除 480
13.3.3　锁粗化 481
13.3.4　轻量级锁 481
13.3.5　偏向锁 483
13.4　本章小结 485
附录A　在Windows系统下编译OpenJDK 6 486
附录B　展望Java技术的未来（2013年版） 493
附录C　虚拟机字节码指令表 499
附录D　对象查询语言（OQL）简介 506
附录E　JDK历史版本轨迹 512</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第1章走近java">第1章　走近Java</a></li>
    <li><a href="#第2章java内存区域与内存溢出异常">第2章　Java内存区域与内存溢出异常</a>
      <ul>
        <li><a href="#21概述">2.1　概述</a></li>
        <li><a href="#22运行时数据区域">2.2　运行时数据区域</a>
          <ul>
            <li><a href="#221程序计数器">2.2.1　程序计数器</a></li>
            <li><a href="#222java虚拟机栈">2.2.2　Java虚拟机栈</a></li>
            <li><a href="#223本地方法栈">2.2.3　本地方法栈</a></li>
            <li><a href="#224java堆">2.2.4　Java堆</a></li>
            <li><a href="#225方法区">2.2.5　方法区</a></li>
            <li><a href="#226运行时常量池">2.2.6　运行时常量池</a></li>
            <li><a href="#227直接内存">2.2.7　直接内存</a></li>
          </ul>
        </li>
        <li><a href="#23hotspot虚拟机对象探秘">2.3　HotSpot虚拟机对象探秘</a>
          <ul>
            <li><a href="#231-对象的创建">2.3.1 对象的创建</a></li>
            <li><a href="#232-对象的内存布局">2.3.2 对象的内存布局</a></li>
            <li><a href="#233-对象的访问定位">2.3.3 对象的访问定位</a></li>
          </ul>
        </li>
        <li><a href="#24实战outofmemoryerror异常">2.4　实战：OutOfMemoryError异常</a>
          <ul>
            <li><a href="#241java堆溢出">2.4.1　Java堆溢出</a></li>
            <li><a href="#242虚拟机栈和本地方法栈溢出">2.4.2　虚拟机栈和本地方法栈溢出</a></li>
            <li><a href="#243方法区和运行时常量池溢出">2.4.3　方法区和运行时常量池溢出</a></li>
            <li><a href="#244本机直接内存溢出">2.4.4　本机直接内存溢出</a></li>
          </ul>
        </li>
        <li><a href="#25本章小结">2.5　本章小结</a></li>
      </ul>
    </li>
    <li><a href="#第3章垃圾收集器与内存分配策略">第3章　垃圾收集器与内存分配策略</a>
      <ul>
        <li><a href="#31概述">3.1　概述</a></li>
        <li><a href="#32对象已死">3.2　对象已死？</a>
          <ul>
            <li><a href="#321引用计数算法">3.2.1　引用计数算法</a></li>
            <li><a href="#322可达性分析算法">3.2.2　可达性分析算法</a></li>
            <li><a href="#323再谈引用">3.2.3　再谈引用</a></li>
            <li><a href="#324生存还是死亡">3.2.4　生存还是死亡？</a></li>
            <li><a href="#325回收方法区">3.2.5　回收方法区</a></li>
          </ul>
        </li>
        <li><a href="#33垃圾收集算法">3.3　垃圾收集算法</a>
          <ul>
            <li><a href="#331分代收集理论">3.3.1　分代收集理论</a></li>
            <li><a href="#332标记-清除算法">3.3.2　标记-清除算法</a></li>
            <li><a href="#333标记-复制算法">3.3.3　标记-复制算法</a></li>
            <li><a href="#334标记-整理算法">3.3.4　标记-整理算法</a></li>
          </ul>
        </li>
        <li><a href="#34hotspot的算法细节实现">3.4　HotSpot的算法细节实现</a>
          <ul>
            <li><a href="#341根节点枚举">3.4.1　根节点枚举</a></li>
            <li><a href="#342安全点">3.4.2　安全点</a></li>
            <li><a href="#343安全区域">3.4.3　安全区域</a></li>
            <li><a href="#344记忆集与卡表">3.4.4　记忆集与卡表</a></li>
            <li><a href="#345写屏障">3.4.5　写屏障</a></li>
            <li><a href="#346并发的可达性分析">3.4.6　并发的可达性分析</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第4章虚拟机性能监控故障处理工具">第4章　虚拟机性能监控、故障处理工具</a></li>
    <li><a href="#第5章调优案例分析与实战">第5章　调优案例分析与实战</a></li>
    <li><a href="#第6章类文件结构">第6章　类文件结构</a></li>
    <li><a href="#第7章虚拟机类加载机制">第7章　虚拟机类加载机制</a></li>
    <li><a href="#第8章虚拟机字节码执行引擎">第8章　虚拟机字节码执行引擎</a></li>
    <li><a href="#第9章类加载及执行子系统的案例与实战">第9章　类加载及执行子系统的案例与实战</a></li>
    <li><a href="#第10章前端编译与优化">第10章　前端编译与优化</a></li>
    <li><a href="#第11章后端编译与优化">第11章　后端编译与优化</a></li>
    <li><a href="#第12章java内存模型与线程">第12章　Java内存模型与线程</a></li>
    <li><a href="#第13章线程安全与锁优化">第13章　线程安全与锁优化</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












