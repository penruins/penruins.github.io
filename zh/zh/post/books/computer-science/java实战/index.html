<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  Java实战
  #


Java实战（第2版）


  第一部分 基础知识
  #


  第1章　Java 8、9、10以及11的变化　　2
  #


  1.1 为什么要关心Java的变化 2
  #


  1.2 Java怎么还在变 4
  #


1.2.1 Java在编程语言生态系统中的位置 5
1.2.2 流处理 6
1.2.3 用行为参数化把代码传递给方法 7
1.2.4 并行与共享的可变数据 8
1.2.5 Java需要演变 9


  1.3 Java中的函数 9
  #


1.3.1 方法和Lambda作为一等值 10
1.3.2 传递代码：一个例子 11
1.3.3 从传递方法到Lambda 13


  1.4 流 14
  #


  1.5 默认方法及Java模块 17
  #


  1.6 来自函数式编程的其他好思想 19
  #


  1.7 小结 20
  #


  第2章　通过行为参数化传递代码　　22
  #


  2.1 应对不断变化的需求 23
  #


2.1.1 初试牛刀：筛选绿苹果 23
2.1.2 再展身手：把颜色作为参数 23
2.1.3 第三次尝试：对你能想到的每个属性做筛选 24


  2.2 行为参数化 25
  #


  2.3 对付啰唆 30
  #


2.3.1 匿名类 30
2.3.2 第五次尝试：使用匿名类 31
2.3.3 第六次尝试：使用Lambda表达式 32
2.3.4 第七次尝试：将List类型抽象化 33


  2.4 真实的例子 33
  #


2.4.1 用Comparator来排序 33
2.4.2 用Runnable执行代码块 34
2.4.3 通过Callable返回结果 35
2.4.4 GUI事件处理 35


  2.5 小结 36
  #


  第3章　Lambda表达式　　37
  #


  3.1 Lambda管中窥豹 37
  #


  3.2 在哪里以及如何使用Lambda 40
  #


3.2.1 函数式接口 40
3.2.2 函数描述符 42


  3.3 把Lambda付诸实践：环绕执行模式 44
  #


3.3.1 第1 步：记得行为参数化 44
3.3.2 第2 步：使用函数式接口来传递行为 45
3.3.3 第3 步：执行一个行为 45
3.3.4 第4 步：传递Lambda 46


  3.4 使用函数式接口 47
  #


3.4.1 Predicate 47
3.4.2 Consumer 47
3.4.3 Function 48


  3.5 类型检查、类型推断以及限制 52
  #


3.5.1 类型检查 52
3.5.2 同样的Lambda，不同的函数式接口 53
3.5.3 类型推断 55
3.5.4 使用局部变量 56


  3.6 方法引用 57
  #


3.6.1 管中窥豹 57
3.6.2 构造函数引用 60


  3.7 Lambda和方法引用实战 62
  #


3.7.1 第1 步：传递代码 62
3.7.2 第2 步：使用匿名类 62
3.7.3 第3 步：使用Lambda表达式 62
3.7.4 第4 步：使用方法引用 63


  3.8 复合Lambda表达式的有用方法 63
  #


3.8.1 比较器复合 64
3.8.2 谓词复合 64
3.8.3 函数复合 65


  3.9 数学中的类似思想 66
  #


3.9.1 积分 66
3.9.2 与Java 8的Lambda联系起来 68


  3.10 小结 68
  #


  第二部分 使用流进行函数式数据处理
  #


  第4章　引入流　　72
  #


  4.1 流是什么 72
  #


  4.2 流简介 76
  #


  4.3 流与集合 78
  #


4.3.1 只能遍历一次 79
4.3.2 外部迭代与内部迭代 80


  4.4 流操作 82
  #


4.4.1 中间操作 83
4.4.2 终端操作 84
4.4.3 使用流 84


  4.5 路线图 85
  #


  4.6 小结 85
  #


  第5章　使用流　　86
  #


  5.1 筛选 87
  #


5.1.1 用谓词筛选 87
5.1.2 筛选各异的元素 87


  5.2 流的切片 88
  #


5.2.1 使用谓词对流进行切片 88
5.2.2 截短流 90
5.2.3 跳过元素 90


  5.3 映射 91
  #


5.3.1 对流中每一个元素应用函数 91
5.3.2 流的扁平化 92


  5.4 查找和匹配 95
  #


5.4.1 检查谓词是否至少匹配一个元素 95
5.4.2 检查谓词是否匹配所有元素 96
5.4.3 查找元素 96
5.4.4 查找第一个元素 97


  5.5 归约 98
  #


5.5.1 元素求和 98
5.5.2 最大值和最小值 100


  5.6 付诸实践 103
  #


5.6.1 领域：交易员和交易 103
5.6.2 解答 104


  5.7 数值流 106
  #


5.7.1 原始类型流特化 107
5.7.2 数值范围 108
5.7.3 数值流应用：勾股数 108


  5.8 构建流 111
  #


5.8.1 由值创建流 111
5.8.2 由可空对象创建流 111
5.8.3 由数组创建流 112
5.8.4 由文件生成流 112
5.8.5 由函数生成流：创建无限流 113


  5.9 概述 116
  #


  5.10 小结 116
  #


  第6章　用流收集数据　　118
  #


  6.1 收集器简介 119
  #


6.1.1 收集器用作高级归约 119
6.1.2 预定义收集器 120


  6.2 归约和汇总 121
  #


6.2.1 查找流中的最大值和最小值 121
6.2.2 汇总 122
6.2.3 连接字符串 123
6.2.4 广义的归约汇总 124


  6.3 分组 127
  #


6.3.1 操作分组的元素 128
6.3.2 多级分组 130
6.3.3 按子组收集数据 131


  6.4 分区 134
  #


6.4.1 分区的优势 135
6.4.2 将数字按质数和非质数分区 136


  6.5 收集器接口 138
  #


6.5.1 理解Collector接口声明的方法 139
6.5.2 全部融合到一起 143


  6.6 开发你自己的收集器以获得更好的性能 144
  #


6.6.1 仅用质数做除数 145
6.6.2 比较收集器的性能 148


  6.7 小结 150
  #


  第7章　并行数据处理与性能　　151
  #


  7.1 并行流 152
  #


7.1.1 将顺序流转换为并行流 52
7.1.2 测量流性能 154
7.1.3 正确使用并行流 158
7.1.4 高效使用并行流 159


  7.2 分支/合并框架 161
  #


7.2.1 使用RecursiveTask 161
7.2.2 使用分支/合并框架的最佳做法 164
7.2.3 工作窃取 165


  7.3 Spliterator 166
  #


7.3.1 拆分过程 167
7.3.2 实现你自己的Spliterator 168


  7.4 小结 173
  #


  第三部分 使用流和Lambda进行高效编程
  #


  第8章　Collection API的增强功能　　176
  #


  8.1 集合工厂 176
  #


8.1.1 List工厂 177
8.1.2 Set工厂 178
8.1.3 Map工厂 179


  8.2 使用List和Set 180
  #


8.2.1 removeIf方法 180
8.2.2 replaceAll方法 181


  8.3 使用Map 181
  #


8.3.1 forEach方法 182
8.3.2 排序 182
8.3.3 getOrDefault方法 183
8.3.4 计算模式 183
8.3.5 删除模式 184
8.3.6 替换模式 185
8.3.7 merge方法 185


  8.4 改进的ConcurrentHashMap 187
  #


8.4.1 归约和搜索 187
8.4.2 计数 188
8.4.3 Set视图 188


  8.5 小结 188
  #


  第9章　重构、测试和调试　　189
  #


  9.1 为改善可读性和灵活性重构代码 189
  #


9.1.1 改善代码的可读性 190
9.1.2 从匿名类到Lambda表达式的转换 190
9.1.3 从Lambda表达式到方法引用的转换 191
9.1.4 从命令式的数据处理切换到Stream 193
9.1.5 增加代码的灵活性 193


  9.2 使用Lambda重构面向对象的设计模式 195
  #


9.2.1 策略模式 196
9.2.2 模板方法 197
9.2.3 观察者模式 198
9.2.4 责任链模式 201
9.2.5 工厂模式 202


  9.3 测试Lambda表达式 204
  #


9.3.1 测试可见Lambda函数的行为 204
9.3.2 测试使用Lambda的方法的行为 205
9.3.3 将复杂的Lambda表达式分为不同的方法 205
9.3.4 高阶函数的测试 206


  9.4 调试 206
  #


9.4.1 查看栈跟踪 206
9.4.2 使用日志调试 208


  9.5 小结 209
  #


  第10章　基于Lambda的领域特定语言　　210
  #


  10.1 领域特定语言 212
  #


10.1.1 DSL的优点和弊端 212
10.1.2 JVM中已提供的DSL解决方案 214


  10.2 现代Java API中的小型DSL 217
  #


10.2.1 把Stream API当成DSL去操作集合 219
10.2.2 将Collectors作为DSL汇总数据 220


  10.3 使用Java创建DSL的模式与技巧 221
  #


10.3.1 方法链接 224
10.3.2 使用嵌套函数 226
10.3.3 使用Lambda表达式的函数序列 228
10.3.4 把它们都放到一起 230
10.3.5 在DSL中使用方法引用 232


  10.4 Java 8 DSL的实际应用 234
  #


10.4.1 jOOQ 235
10.4.2 Cucumber 236
10.4.3 Spring Integration 238


  10.5 小结 239
  #


  第四部分 无所不在的Java
  #


  第11章　用Optional取代null　　242
  #


  11.1 如何为缺失的值建模 243
  #


11.1.1 采用防御式检查减少NullPointerException 243
11.1.2 null带来的种种问题 245
11.1.3 其他语言中null的替代品 245


  11.2 Optional类入门 246
  #


  11.3 应用Optional的几种模式 248
  #


11.3.1 创建Optional对象 248
11.3.2 使用map从Optional对象中提取和转换值 248
11.3.3 使用flatMap链接Optional对象 249
11.3.4 操纵由Optional对象构成的Stream 253
11.3.5 默认行为及解引用Optional对象 254
11.3.6 两个Optional对象的组合 255
11.3.7 使用filter剔除特定的值 257


  11.4 使用Optional的实战示例 258
  #


11.4.1 用Optional 封装可能为null的值 259
11.4.2 异常与Optional的对比 259
11.4.3 基础类型的Optional对象，以及为什么应该避免使用它们 260
11.4.4 把所有内容整合起来 260


  11.5 小结 262
  #


  第12章　新的日期和时间API　　263
  #


  12.1 LocalDate、LocalTime、LocalDateTime、Instant、Duration以及Period 264
  #


12.1.1 使用LocalDate和LocalTime 264
12.1.2 合并日期和时间 265
12.1.3 机器的日期和时间格式 266
12.1.4 定义Duration或Period 267


  12.2 操纵、解析和格式化日期 268
  #


12.2.1 使用TemporalAdjuster 270
12.2.2 打印输出及解析日期–时间对象 272


  12.3 处理不同的时区和历法 274
  #


12.3.1 使用时区 274
12.3.2 利用和UTC/格林尼治时间的固定偏差计算时区 275
12.3.3 使用别的日历系统 276


  12.4 小结 277
  #


  第13章　默认方法　　278
  #


  13.1 不断演进的API 280
  #


13.1.1 初始版本的API 281
13.1.2 第二版API 281


  13.2 概述默认方法 283
  #


  13.3 默认方法的使用模式 285
  #


13.3.1 可选方法 285
13.3.2 行为的多继承 286


  13.4 解决冲突的规则 289
  #


13.4.1 解决问题的三条规则 289
13.4.2 选择提供了最具体实现的默认方法的接口 290
13.4.3 冲突及如何显式地消除歧义 291
13.4.4 菱形继承问题 293


  13.5 小结 294
  #


  第14章　Java模块系统　　295
  #


  14.1 模块化的驱动力：软件的推理 295
  #


14.1.1 关注点分离 295
14.1.2 信息隐藏 296
14.1.3 Java软件 296


  14.2 为什么要设计Java模块系统 297
  #


14.2.1 模块化的局限性 297
14.2.2 单体型的JDK 298
14.2.3 与OSGi的比较 299


  14.3 Java模块：全局视图 300
  #


  14.4 使用Java模块系统开发应用 301
  #


14.4.1 从头开始搭建一个应用 302
14.4.2 细粒度和粗粒度的模块化 303
14.4.3 Java模块系统基础 303


  14.5 使用多个模块 304
  #


14.5.1 exports子句 304
14.5.2 requires子句 305
14.5.3 命名 306


  14.6 编译及打包 306
  #


  14.7 自动模块 310
  #


  14.8 模块声明及子句 311
  #


14.8.1 requires 311
14.8.2 exports 311
14.8.3 requires的传递 311
14.8.4 exports to 312
14.8.5 open和opens 312
14.8.6 uses和provides 313


  14.9 通过一个更复杂的例子了解更多 313
  #


  14.10 小结 314
  #


  第五部分 提升Java的并发性
  #


  第15章　CompletableFuture及反应式编程背后的概念　　316
  #


  15.1 为支持并发而不断演进的Java 318
  #


15.1.1 线程以及更高层的抽象 319
15.1.2 执行器和线程池 320
15.1.3 其他的线程抽象：非嵌套方法调用 322
15.1.4 你希望线程为你带来什么 324


  15.2 同步及异步API 324
  #


15.2.1 Future风格的API 326
15.2.2 反应式风格的API 327
15.2.3 有害的睡眠及其他阻塞式操作 328
15.2.4 实战验证 329
15.2.5 如何使用异步API进行异常处理 330


  15.3 “线框–管道”模型 331
  #


  15.4 为并发而生的CompletableFuture和结合器 332
  #


  15.5 “发布–订阅”以及反应式编程 335
  #


15.5.1 示例：对两个流求和 337
15.5.2 背压 341
15.5.3 一种简单的真实背压 341


  15.6 反应式系统和反应式编程 342
  #


  15.7 路线图 342
  #


  15.8 小结 343
  #


  第16章　CompletableFuture：组合式异步编程　　344
  #


  16.1 Future接口 344
  #


16.1.1 Future接口的局限性 346
16.1.2 使用CompletableFuture构建异步应用 346


  16.2 实现异步API 347
  #


16.2.1 将同步方法转换为异步方法 348
16.2.2 错误处理 350


  16.3 让你的代码免受阻塞之苦 352
  #


16.3.1 使用并行流对请求进行并行操作 353
16.3.2 使用CompletableFuture发起异步请求 353
16.3.3 寻找更好的方案 355
16.3.4 使用定制的执行器 356


  16.4 对多个异步任务进行流水线操作 358
  #


16.4.1 实现折扣服务 358
16.4.2 使用Discount服务 359
16.4.3 构造同步和异步操作 360
16.4.4 将两个CompletableFuture对象整合起来，无论它们是否存在依赖 363
16.4.5 对Future和Completable-Future 的回顾 364
16.4.6 高效地使用超时机制 365


  16.5 响应CompletableFuture的completion事件 366
  #


16.5.1 对最佳价格查询器应用的优化 367
16.5.2 付诸实践 368


  16.6 路线图 369
  #


  16.7 小结 369
  #


  第17章　反应式编程　　370
  #


  17.1 反应式宣言 371
  #


17.1.1 应用层的反应式编程 371
17.1.2 反应式系统 373


  17.2 反应式流以及Flow API 373
  #


17.2.1 Flow类 374
17.2.2 创建你的第一个反应式应用 377
17.2.3 使用Processor转换数据 381
17.2.4 为什么Java并未提供Flow API的实现 383


  17.3 使用反应式库RxJava 384
  #


17.3.1 创建和使用Observable 385
17.3.2 转换及整合多个Observable 392


  第六部分 函数式编程以及Java未来的演进
  #


  第18章　函数式的思考　　396
  #


  18.1 实现和维护系统 396
  #


18.1.1 共享的可变数据 397
18.1.2 声明式编程 398
18.1.3 为什么要采用函数式编程 399


  18.2 什么是函数式编程 399
  #


18.2.1 函数式Java编程 400
18.2.2 引用透明性 402
18.2.3 面向对象的编程和函数式编程的对比 402
18.2.4 函数式编程实战 403


  18.3 递归和迭代 405
  #


  18.4 小结 408
  #


  第19章　函数式编程的技巧　　409
  #


  19.1 无处不在的函数 409
  #


19.1.1 高阶函数 410
19.1.2 柯里化 411


  19.2 持久化数据结构 412
  #


19.2.1 破坏式更新和函数式更新的比较 413
19.2.2 另一个使用Tree的例子 415
19.2.3 采用函数式的方法 416


  19.3 Stream的延迟计算 418
  #


19.3.1 自定义的Stream 418
19.3.2 创建你自己的延迟列表 420


  19.4 模式匹配 425
  #


19.4.1 访问者模式 425
19.4.2 用模式匹配力挽狂澜 426


  19.5 杂项 429
  #


19.5.1 缓存或记忆表 429
19.5.2 “返回同样的对象”意味着什么 430
19.5.3 结合器 431


  19.6 小结 432
  #


  第20章　面向对象和函数式编程的混合：Java和Scala的比较　　433
  #


  20.1 Scala简介 434
  #


20.1.1 你好，啤酒 434
20.1.2 基础数据结构：List、Set、Map、Tuple、Stream以及Option 436


  20.2 函数 440
  #


20.2.1 Scala中的一等函数 441
20.2.2 匿名函数和闭包 442
20.2.3 柯里化 443


  20.3 类和trait 444
  #


20.3.1 更加简洁的Scala类 445
20.3.2 Scala的trait与Java 8的接口对比 446


  20.4 小结 447
  #


  第21章　结论以及Java的未来　　448
  #


  21.1 回顾Java 8的语言特性 448
  #


21.1.1 行为参数化（Lambda以及方法引用） 449
21.1.2 流 449
21.1.3 CompletableFuture 450
21.1.4 Optional 450
21.1.5 Flow API 451
21.1.6 默认方法 451


  21.2 Java 9的模块系统 451
  #


  21.3 Java 10的局部变量类型推断 453
  #


  21.4 Java的未来 454
  #


21.4.1 声明处型变 454
21.4.2 模式匹配 454
21.4.3 更加丰富的泛型形式 455
21.4.4 对不变性的更深层支持 457
21.4.5 值类型 458


  21.5 让Java发展得更快 461
  #


  21.6 写在最后的话 462
  #


附录A 其他语言特性的更新 463
附录B 其他类库的更新 467
附录C 如何以并发方式在同一个流上执行多种操作 475
附录D Lambda表达式和JVM字节码 483
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="/zh/zh/post/books/computer-science/java%E5%AE%9E%E6%88%98/">
  <meta property="og:site_name" content="Penruins">
  <meta property="og:title" content="Java实战">
  <meta property="og:description" content="Java实战 # Java实战（第2版） 第一部分 基础知识 # 第1章　Java 8、9、10以及11的变化　2 # 1.1 为什么要关心Java的变化 2 # 1.2 Java怎么还在变 4 # 1.2.1 Java在编程语言生态系统中的位置 5 1.2.2 流处理 6 1.2.3 用行为参数化把代码传递给方法 7 1.2.4 并行与共享的可变数据 8 1.2.5 Java需要演变 9 1.3 Java中的函数 9 # 1.3.1 方法和Lambda作为一等值 10 1.3.2 传递代码：一个例子 11 1.3.3 从传递方法到Lambda 13 1.4 流 14 # 1.5 默认方法及Java模块 17 # 1.6 来自函数式编程的其他好思想 19 # 1.7 小结 20 # 第2章　通过行为参数化传递代码　22 # 2.1 应对不断变化的需求 23 # 2.1.1 初试牛刀：筛选绿苹果 23 2.1.2 再展身手：把颜色作为参数 23 2.1.3 第三次尝试：对你能想到的每个属性做筛选 24 2.2 行为参数化 25 # 2.3 对付啰唆 30 # 2.3.1 匿名类 30 2.3.2 第五次尝试：使用匿名类 31 2.3.3 第六次尝试：使用Lambda表达式 32 2.3.4 第七次尝试：将List类型抽象化 33 2.4 真实的例子 33 # 2.4.1 用Comparator来排序 33 2.4.2 用Runnable执行代码块 34 2.4.3 通过Callable返回结果 35 2.4.4 GUI事件处理 35 2.5 小结 36 # 第3章　Lambda表达式　37 # 3.1 Lambda管中窥豹 37 # 3.2 在哪里以及如何使用Lambda 40 # 3.2.1 函数式接口 40 3.2.2 函数描述符 42 3.3 把Lambda付诸实践：环绕执行模式 44 # 3.3.1 第1 步：记得行为参数化 44 3.3.2 第2 步：使用函数式接口来传递行为 45 3.3.3 第3 步：执行一个行为 45 3.3.4 第4 步：传递Lambda 46 3.4 使用函数式接口 47 # 3.4.1 Predicate 47 3.4.2 Consumer 47 3.4.3 Function 48 3.5 类型检查、类型推断以及限制 52 # 3.5.1 类型检查 52 3.5.2 同样的Lambda，不同的函数式接口 53 3.5.3 类型推断 55 3.5.4 使用局部变量 56 3.6 方法引用 57 # 3.6.1 管中窥豹 57 3.6.2 构造函数引用 60 3.7 Lambda和方法引用实战 62 # 3.7.1 第1 步：传递代码 62 3.7.2 第2 步：使用匿名类 62 3.7.3 第3 步：使用Lambda表达式 62 3.7.4 第4 步：使用方法引用 63 3.8 复合Lambda表达式的有用方法 63 # 3.8.1 比较器复合 64 3.8.2 谓词复合 64 3.8.3 函数复合 65 3.9 数学中的类似思想 66 # 3.9.1 积分 66 3.9.2 与Java 8的Lambda联系起来 68 3.10 小结 68 # 第二部分 使用流进行函数式数据处理 # 第4章　引入流　72 # 4.1 流是什么 72 # 4.2 流简介 76 # 4.3 流与集合 78 # 4.3.1 只能遍历一次 79 4.3.2 外部迭代与内部迭代 80 4.4 流操作 82 # 4.4.1 中间操作 83 4.4.2 终端操作 84 4.4.3 使用流 84 4.5 路线图 85 # 4.6 小结 85 # 第5章　使用流　86 # 5.1 筛选 87 # 5.1.1 用谓词筛选 87 5.1.2 筛选各异的元素 87 5.2 流的切片 88 # 5.2.1 使用谓词对流进行切片 88 5.2.2 截短流 90 5.2.3 跳过元素 90 5.3 映射 91 # 5.3.1 对流中每一个元素应用函数 91 5.3.2 流的扁平化 92 5.4 查找和匹配 95 # 5.4.1 检查谓词是否至少匹配一个元素 95 5.4.2 检查谓词是否匹配所有元素 96 5.4.3 查找元素 96 5.4.4 查找第一个元素 97 5.5 归约 98 # 5.5.1 元素求和 98 5.5.2 最大值和最小值 100 5.6 付诸实践 103 # 5.6.1 领域：交易员和交易 103 5.6.2 解答 104 5.7 数值流 106 # 5.7.1 原始类型流特化 107 5.7.2 数值范围 108 5.7.3 数值流应用：勾股数 108 5.8 构建流 111 # 5.8.1 由值创建流 111 5.8.2 由可空对象创建流 111 5.8.3 由数组创建流 112 5.8.4 由文件生成流 112 5.8.5 由函数生成流：创建无限流 113 5.9 概述 116 # 5.10 小结 116 # 第6章　用流收集数据　118 # 6.1 收集器简介 119 # 6.1.1 收集器用作高级归约 119 6.1.2 预定义收集器 120 6.2 归约和汇总 121 # 6.2.1 查找流中的最大值和最小值 121 6.2.2 汇总 122 6.2.3 连接字符串 123 6.2.4 广义的归约汇总 124 6.3 分组 127 # 6.3.1 操作分组的元素 128 6.3.2 多级分组 130 6.3.3 按子组收集数据 131 6.4 分区 134 # 6.4.1 分区的优势 135 6.4.2 将数字按质数和非质数分区 136 6.5 收集器接口 138 # 6.5.1 理解Collector接口声明的方法 139 6.5.2 全部融合到一起 143 6.6 开发你自己的收集器以获得更好的性能 144 # 6.6.1 仅用质数做除数 145 6.6.2 比较收集器的性能 148 6.7 小结 150 # 第7章　并行数据处理与性能　151 # 7.1 并行流 152 # 7.1.1 将顺序流转换为并行流 52 7.1.2 测量流性能 154 7.1.3 正确使用并行流 158 7.1.4 高效使用并行流 159 7.2 分支/合并框架 161 # 7.2.1 使用RecursiveTask 161 7.2.2 使用分支/合并框架的最佳做法 164 7.2.3 工作窃取 165 7.3 Spliterator 166 # 7.3.1 拆分过程 167 7.3.2 实现你自己的Spliterator 168 7.4 小结 173 # 第三部分 使用流和Lambda进行高效编程 # 第8章　Collection API的增强功能　176 # 8.1 集合工厂 176 # 8.1.1 List工厂 177 8.1.2 Set工厂 178 8.1.3 Map工厂 179 8.2 使用List和Set 180 # 8.2.1 removeIf方法 180 8.2.2 replaceAll方法 181 8.3 使用Map 181 # 8.3.1 forEach方法 182 8.3.2 排序 182 8.3.3 getOrDefault方法 183 8.3.4 计算模式 183 8.3.5 删除模式 184 8.3.6 替换模式 185 8.3.7 merge方法 185 8.4 改进的ConcurrentHashMap 187 # 8.4.1 归约和搜索 187 8.4.2 计数 188 8.4.3 Set视图 188 8.5 小结 188 # 第9章　重构、测试和调试　189 # 9.1 为改善可读性和灵活性重构代码 189 # 9.1.1 改善代码的可读性 190 9.1.2 从匿名类到Lambda表达式的转换 190 9.1.3 从Lambda表达式到方法引用的转换 191 9.1.4 从命令式的数据处理切换到Stream 193 9.1.5 增加代码的灵活性 193 9.2 使用Lambda重构面向对象的设计模式 195 # 9.2.1 策略模式 196 9.2.2 模板方法 197 9.2.3 观察者模式 198 9.2.4 责任链模式 201 9.2.5 工厂模式 202 9.3 测试Lambda表达式 204 # 9.3.1 测试可见Lambda函数的行为 204 9.3.2 测试使用Lambda的方法的行为 205 9.3.3 将复杂的Lambda表达式分为不同的方法 205 9.3.4 高阶函数的测试 206 9.4 调试 206 # 9.4.1 查看栈跟踪 206 9.4.2 使用日志调试 208 9.5 小结 209 # 第10章　基于Lambda的领域特定语言　210 # 10.1 领域特定语言 212 # 10.1.1 DSL的优点和弊端 212 10.1.2 JVM中已提供的DSL解决方案 214 10.2 现代Java API中的小型DSL 217 # 10.2.1 把Stream API当成DSL去操作集合 219 10.2.2 将Collectors作为DSL汇总数据 220 10.3 使用Java创建DSL的模式与技巧 221 # 10.3.1 方法链接 224 10.3.2 使用嵌套函数 226 10.3.3 使用Lambda表达式的函数序列 228 10.3.4 把它们都放到一起 230 10.3.5 在DSL中使用方法引用 232 10.4 Java 8 DSL的实际应用 234 # 10.4.1 jOOQ 235 10.4.2 Cucumber 236 10.4.3 Spring Integration 238 10.5 小结 239 # 第四部分 无所不在的Java # 第11章　用Optional取代null　242 # 11.1 如何为缺失的值建模 243 # 11.1.1 采用防御式检查减少NullPointerException 243 11.1.2 null带来的种种问题 245 11.1.3 其他语言中null的替代品 245 11.2 Optional类入门 246 # 11.3 应用Optional的几种模式 248 # 11.3.1 创建Optional对象 248 11.3.2 使用map从Optional对象中提取和转换值 248 11.3.3 使用flatMap链接Optional对象 249 11.3.4 操纵由Optional对象构成的Stream 253 11.3.5 默认行为及解引用Optional对象 254 11.3.6 两个Optional对象的组合 255 11.3.7 使用filter剔除特定的值 257 11.4 使用Optional的实战示例 258 # 11.4.1 用Optional 封装可能为null的值 259 11.4.2 异常与Optional的对比 259 11.4.3 基础类型的Optional对象，以及为什么应该避免使用它们 260 11.4.4 把所有内容整合起来 260 11.5 小结 262 # 第12章　新的日期和时间API　263 # 12.1 LocalDate、LocalTime、LocalDateTime、Instant、Duration以及Period 264 # 12.1.1 使用LocalDate和LocalTime 264 12.1.2 合并日期和时间 265 12.1.3 机器的日期和时间格式 266 12.1.4 定义Duration或Period 267 12.2 操纵、解析和格式化日期 268 # 12.2.1 使用TemporalAdjuster 270 12.2.2 打印输出及解析日期–时间对象 272 12.3 处理不同的时区和历法 274 # 12.3.1 使用时区 274 12.3.2 利用和UTC/格林尼治时间的固定偏差计算时区 275 12.3.3 使用别的日历系统 276 12.4 小结 277 # 第13章　默认方法　278 # 13.1 不断演进的API 280 # 13.1.1 初始版本的API 281 13.1.2 第二版API 281 13.2 概述默认方法 283 # 13.3 默认方法的使用模式 285 # 13.3.1 可选方法 285 13.3.2 行为的多继承 286 13.4 解决冲突的规则 289 # 13.4.1 解决问题的三条规则 289 13.4.2 选择提供了最具体实现的默认方法的接口 290 13.4.3 冲突及如何显式地消除歧义 291 13.4.4 菱形继承问题 293 13.5 小结 294 # 第14章　Java模块系统　295 # 14.1 模块化的驱动力：软件的推理 295 # 14.1.1 关注点分离 295 14.1.2 信息隐藏 296 14.1.3 Java软件 296 14.2 为什么要设计Java模块系统 297 # 14.2.1 模块化的局限性 297 14.2.2 单体型的JDK 298 14.2.3 与OSGi的比较 299 14.3 Java模块：全局视图 300 # 14.4 使用Java模块系统开发应用 301 # 14.4.1 从头开始搭建一个应用 302 14.4.2 细粒度和粗粒度的模块化 303 14.4.3 Java模块系统基础 303 14.5 使用多个模块 304 # 14.5.1 exports子句 304 14.5.2 requires子句 305 14.5.3 命名 306 14.6 编译及打包 306 # 14.7 自动模块 310 # 14.8 模块声明及子句 311 # 14.8.1 requires 311 14.8.2 exports 311 14.8.3 requires的传递 311 14.8.4 exports to 312 14.8.5 open和opens 312 14.8.6 uses和provides 313 14.9 通过一个更复杂的例子了解更多 313 # 14.10 小结 314 # 第五部分 提升Java的并发性 # 第15章　CompletableFuture及反应式编程背后的概念　316 # 15.1 为支持并发而不断演进的Java 318 # 15.1.1 线程以及更高层的抽象 319 15.1.2 执行器和线程池 320 15.1.3 其他的线程抽象：非嵌套方法调用 322 15.1.4 你希望线程为你带来什么 324 15.2 同步及异步API 324 # 15.2.1 Future风格的API 326 15.2.2 反应式风格的API 327 15.2.3 有害的睡眠及其他阻塞式操作 328 15.2.4 实战验证 329 15.2.5 如何使用异步API进行异常处理 330 15.3 “线框–管道”模型 331 # 15.4 为并发而生的CompletableFuture和结合器 332 # 15.5 “发布–订阅”以及反应式编程 335 # 15.5.1 示例：对两个流求和 337 15.5.2 背压 341 15.5.3 一种简单的真实背压 341 15.6 反应式系统和反应式编程 342 # 15.7 路线图 342 # 15.8 小结 343 # 第16章　CompletableFuture：组合式异步编程　344 # 16.1 Future接口 344 # 16.1.1 Future接口的局限性 346 16.1.2 使用CompletableFuture构建异步应用 346 16.2 实现异步API 347 # 16.2.1 将同步方法转换为异步方法 348 16.2.2 错误处理 350 16.3 让你的代码免受阻塞之苦 352 # 16.3.1 使用并行流对请求进行并行操作 353 16.3.2 使用CompletableFuture发起异步请求 353 16.3.3 寻找更好的方案 355 16.3.4 使用定制的执行器 356 16.4 对多个异步任务进行流水线操作 358 # 16.4.1 实现折扣服务 358 16.4.2 使用Discount服务 359 16.4.3 构造同步和异步操作 360 16.4.4 将两个CompletableFuture对象整合起来，无论它们是否存在依赖 363 16.4.5 对Future和Completable-Future 的回顾 364 16.4.6 高效地使用超时机制 365 16.5 响应CompletableFuture的completion事件 366 # 16.5.1 对最佳价格查询器应用的优化 367 16.5.2 付诸实践 368 16.6 路线图 369 # 16.7 小结 369 # 第17章　反应式编程　370 # 17.1 反应式宣言 371 # 17.1.1 应用层的反应式编程 371 17.1.2 反应式系统 373 17.2 反应式流以及Flow API 373 # 17.2.1 Flow类 374 17.2.2 创建你的第一个反应式应用 377 17.2.3 使用Processor转换数据 381 17.2.4 为什么Java并未提供Flow API的实现 383 17.3 使用反应式库RxJava 384 # 17.3.1 创建和使用Observable 385 17.3.2 转换及整合多个Observable 392 第六部分 函数式编程以及Java未来的演进 # 第18章　函数式的思考　396 # 18.1 实现和维护系统 396 # 18.1.1 共享的可变数据 397 18.1.2 声明式编程 398 18.1.3 为什么要采用函数式编程 399 18.2 什么是函数式编程 399 # 18.2.1 函数式Java编程 400 18.2.2 引用透明性 402 18.2.3 面向对象的编程和函数式编程的对比 402 18.2.4 函数式编程实战 403 18.3 递归和迭代 405 # 18.4 小结 408 # 第19章　函数式编程的技巧　409 # 19.1 无处不在的函数 409 # 19.1.1 高阶函数 410 19.1.2 柯里化 411 19.2 持久化数据结构 412 # 19.2.1 破坏式更新和函数式更新的比较 413 19.2.2 另一个使用Tree的例子 415 19.2.3 采用函数式的方法 416 19.3 Stream的延迟计算 418 # 19.3.1 自定义的Stream 418 19.3.2 创建你自己的延迟列表 420 19.4 模式匹配 425 # 19.4.1 访问者模式 425 19.4.2 用模式匹配力挽狂澜 426 19.5 杂项 429 # 19.5.1 缓存或记忆表 429 19.5.2 “返回同样的对象”意味着什么 430 19.5.3 结合器 431 19.6 小结 432 # 第20章　面向对象和函数式编程的混合：Java和Scala的比较　433 # 20.1 Scala简介 434 # 20.1.1 你好，啤酒 434 20.1.2 基础数据结构：List、Set、Map、Tuple、Stream以及Option 436 20.2 函数 440 # 20.2.1 Scala中的一等函数 441 20.2.2 匿名函数和闭包 442 20.2.3 柯里化 443 20.3 类和trait 444 # 20.3.1 更加简洁的Scala类 445 20.3.2 Scala的trait与Java 8的接口对比 446 20.4 小结 447 # 第21章　结论以及Java的未来　448 # 21.1 回顾Java 8的语言特性 448 # 21.1.1 行为参数化（Lambda以及方法引用） 449 21.1.2 流 449 21.1.3 CompletableFuture 450 21.1.4 Optional 450 21.1.5 Flow API 451 21.1.6 默认方法 451 21.2 Java 9的模块系统 451 # 21.3 Java 10的局部变量类型推断 453 # 21.4 Java的未来 454 # 21.4.1 声明处型变 454 21.4.2 模式匹配 454 21.4.3 更加丰富的泛型形式 455 21.4.4 对不变性的更深层支持 457 21.4.5 值类型 458 21.5 让Java发展得更快 461 # 21.6 写在最后的话 462 # 附录A 其他语言特性的更新 463 附录B 其他类库的更新 467 附录C 如何以并发方式在同一个流上执行多种操作 475 附录D Lambda表达式和JVM字节码 483">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="zh">
<title>Java实战 | Penruins</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="/zh/zh/post/books/computer-science/java%E5%AE%9E%E6%88%98/">
<link rel="stylesheet" href="/book.min.26e661cf8028ea69ebe162050990c3a07de74e5bfe9389e880f2d6a7e5fa587c.css" >
  <script defer src="/fuse.min.js"></script>
  <script defer src="/zh.search.min.8be524883746aa403f193b698f0fe6545b17f51d36c17a79b8dce2eab338aa18.js" ></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/zh/"><span>Penruins</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>



  



  
    
  
    
  



<ul class="book-languages">
  <li>
    <input type="checkbox" id="languages" class="toggle" />
    <label for="languages" class="flex justify-between">
      <a role="button" class="flex align-center">
        <img src="/svg/translate.svg" class="book-icon" alt="Languages" />
        中文
      </a>
    </label>

    <ul>
      
      <li>
        <a href="/cn/">
          
        </a>
      </li>
      
      <li>
        <a href="/en/">
          English
        </a>
      </li>
      
    </ul>
  </li>
</ul>














  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Life</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/movies-log/" class="">观影记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/bilibili/" class="">bilibili</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/books/" class="">books</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/cycling/" class="">cycling</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/hiking/" class="">hiking</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/life-recommend/" class="">life recommand</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/learning-others-log/" class="">other learning</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/podcast/" class="">podcast</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/politics/" class="">politics</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/goal/" class="">goal</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/accumulation/" class="">accumulation</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/coffee/" class="">coffee</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Computer Science</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-855531983528655844a29f37632e7e30" class="toggle"  />
    <label for="section-855531983528655844a29f37632e7e30" class="flex justify-between">
      <a role="button" class="">Java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/java/" class="">java</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/mybatis/" class="">Mybatis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/jvm/" class="">jvm</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-recommend/" class="">推荐</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-learning-log/" class="">学习记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/database/" class="">database</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/echarts/" class="">echarts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/github/" class="">github</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/ios/" class="">ios</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/job/" class="">job</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/mac/" class="">mac</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/raspberrypi/" class="">raspberry pi</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/security/" class="">security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/vue/" class="">vue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/algorithm/" class="">Algorithm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/linux/" class="">linux</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Others</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/about-me/" class="">about me</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/english-learning/" class="">English Learning</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Books</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-70696d57febbe00561bcceac2d174d7c" class="toggle"  />
    <label for="section-70696d57febbe00561bcceac2d174d7c" class="flex justify-between">
      <a role="button" class="">Computer Science</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" class="">Java并发编程实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%AE%9E%E6%88%98/" class="">Java实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="">Python神经网络编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="">Redis设计与实现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/" class="">Spring Cloud微服务：入门、实战与进阶</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E5%89%91%E6%8C%87offer/" class="">剑指Offer</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/" class="">深入浅出HTTPS：从原理到实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E6%94%B6%E5%89%B2-offer%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F/" class="">收割Offer：互联网大厂面经</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" class="">一本书讲透 ElasticSearch：原理、进阶与工程实践</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E7%AC%AC%E4%B8%89%E7%89%88/" class="">宏观经济学 第三版</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E7%BE%8E%E5%9B%BD%E5%9B%B0%E5%B1%80/" class="">美国困局</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E8%8B%B1%E4%BC%9F%E8%BE%BE-%E9%BB%84%E4%BB%81%E5%8B%8B%E4%B9%8B%E8%8A%AF/" class="">英伟达-黄仁勋之芯</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E7%94%A8%E5%9C%B0%E5%9B%BE%E7%9C%8B%E6%87%82%E4%B8%96%E7%95%8C%E6%A0%BC%E5%B1%80/" class="">用地图看懂世界格局</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Java实战</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第一部分-基础知识">第一部分 基础知识</a>
      <ul>
        <li><a href="#第1章java-8910以及11的变化2">第1章　Java 8、9、10以及11的变化　　2</a>
          <ul>
            <li><a href="#11-为什么要关心java的变化-2">1.1 为什么要关心Java的变化 2</a></li>
            <li><a href="#12-java怎么还在变-4">1.2 Java怎么还在变 4</a></li>
            <li><a href="#13-java中的函数-9">1.3 Java中的函数 9</a></li>
            <li><a href="#14-流-14">1.4 流 14</a></li>
            <li><a href="#15-默认方法及java模块-17">1.5 默认方法及Java模块 17</a></li>
            <li><a href="#16-来自函数式编程的其他好思想-19">1.6 来自函数式编程的其他好思想 19</a></li>
            <li><a href="#17-小结-20">1.7 小结 20</a></li>
          </ul>
        </li>
        <li><a href="#第2章通过行为参数化传递代码22">第2章　通过行为参数化传递代码　　22</a>
          <ul>
            <li><a href="#21-应对不断变化的需求-23">2.1 应对不断变化的需求 23</a></li>
            <li><a href="#22-行为参数化-25">2.2 行为参数化 25</a></li>
            <li><a href="#23-对付啰唆-30">2.3 对付啰唆 30</a></li>
            <li><a href="#24-真实的例子-33">2.4 真实的例子 33</a></li>
            <li><a href="#25-小结-36">2.5 小结 36</a></li>
          </ul>
        </li>
        <li><a href="#第3章lambda表达式37">第3章　Lambda表达式　　37</a>
          <ul>
            <li><a href="#31-lambda管中窥豹-37">3.1 Lambda管中窥豹 37</a></li>
            <li><a href="#32-在哪里以及如何使用lambda-40">3.2 在哪里以及如何使用Lambda 40</a></li>
            <li><a href="#33-把lambda付诸实践环绕执行模式-44">3.3 把Lambda付诸实践：环绕执行模式 44</a></li>
            <li><a href="#34-使用函数式接口-47">3.4 使用函数式接口 47</a></li>
            <li><a href="#35-类型检查类型推断以及限制-52">3.5 类型检查、类型推断以及限制 52</a></li>
            <li><a href="#36-方法引用-57">3.6 方法引用 57</a></li>
            <li><a href="#37-lambda和方法引用实战-62">3.7 Lambda和方法引用实战 62</a></li>
            <li><a href="#38-复合lambda表达式的有用方法-63">3.8 复合Lambda表达式的有用方法 63</a></li>
            <li><a href="#39-数学中的类似思想-66">3.9 数学中的类似思想 66</a></li>
            <li><a href="#310-小结-68">3.10 小结 68</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第二部分-使用流进行函数式数据处理">第二部分 使用流进行函数式数据处理</a>
      <ul>
        <li><a href="#第4章引入流72">第4章　引入流　　72</a>
          <ul>
            <li><a href="#41-流是什么-72">4.1 流是什么 72</a></li>
            <li><a href="#42-流简介-76">4.2 流简介 76</a></li>
            <li><a href="#43-流与集合-78">4.3 流与集合 78</a></li>
            <li><a href="#44-流操作-82">4.4 流操作 82</a></li>
            <li><a href="#45-路线图-85">4.5 路线图 85</a></li>
            <li><a href="#46-小结-85">4.6 小结 85</a></li>
          </ul>
        </li>
        <li><a href="#第5章使用流86">第5章　使用流　　86</a>
          <ul>
            <li><a href="#51-筛选-87">5.1 筛选 87</a></li>
            <li><a href="#52-流的切片-88">5.2 流的切片 88</a></li>
            <li><a href="#53-映射-91">5.3 映射 91</a></li>
            <li><a href="#54-查找和匹配-95">5.4 查找和匹配 95</a></li>
            <li><a href="#55-归约-98">5.5 归约 98</a></li>
            <li><a href="#56-付诸实践-103">5.6 付诸实践 103</a></li>
            <li><a href="#57-数值流-106">5.7 数值流 106</a></li>
            <li><a href="#58-构建流-111">5.8 构建流 111</a></li>
            <li><a href="#59-概述-116">5.9 概述 116</a></li>
            <li><a href="#510-小结-116">5.10 小结 116</a></li>
          </ul>
        </li>
        <li><a href="#第6章用流收集数据118">第6章　用流收集数据　　118</a>
          <ul>
            <li><a href="#61-收集器简介-119">6.1 收集器简介 119</a></li>
            <li><a href="#62-归约和汇总-121">6.2 归约和汇总 121</a></li>
            <li><a href="#63-分组-127">6.3 分组 127</a></li>
            <li><a href="#64-分区-134">6.4 分区 134</a></li>
            <li><a href="#65-收集器接口-138">6.5 收集器接口 138</a></li>
            <li><a href="#66-开发你自己的收集器以获得更好的性能-144">6.6 开发你自己的收集器以获得更好的性能 144</a></li>
            <li><a href="#67-小结-150">6.7 小结 150</a></li>
          </ul>
        </li>
        <li><a href="#第7章并行数据处理与性能151">第7章　并行数据处理与性能　　151</a>
          <ul>
            <li><a href="#71-并行流-152">7.1 并行流 152</a></li>
            <li><a href="#72-分支合并框架-161">7.2 分支/合并框架 161</a></li>
            <li><a href="#73-spliterator-166">7.3 Spliterator 166</a></li>
            <li><a href="#74-小结-173">7.4 小结 173</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第三部分-使用流和lambda进行高效编程">第三部分 使用流和Lambda进行高效编程</a>
      <ul>
        <li><a href="#第8章collection-api的增强功能176">第8章　Collection API的增强功能　　176</a>
          <ul>
            <li><a href="#81-集合工厂-176">8.1 集合工厂 176</a></li>
            <li><a href="#82-使用list和set-180">8.2 使用List和Set 180</a></li>
            <li><a href="#83-使用map-181">8.3 使用Map 181</a></li>
            <li><a href="#84-改进的concurrenthashmap-187">8.4 改进的ConcurrentHashMap 187</a></li>
            <li><a href="#85-小结-188">8.5 小结 188</a></li>
          </ul>
        </li>
        <li><a href="#第9章重构测试和调试189">第9章　重构、测试和调试　　189</a>
          <ul>
            <li><a href="#91-为改善可读性和灵活性重构代码-189">9.1 为改善可读性和灵活性重构代码 189</a></li>
            <li><a href="#92-使用lambda重构面向对象的设计模式-195">9.2 使用Lambda重构面向对象的设计模式 195</a></li>
            <li><a href="#93-测试lambda表达式-204">9.3 测试Lambda表达式 204</a></li>
            <li><a href="#94-调试-206">9.4 调试 206</a></li>
            <li><a href="#95-小结-209">9.5 小结 209</a></li>
          </ul>
        </li>
        <li><a href="#第10章基于lambda的领域特定语言210">第10章　基于Lambda的领域特定语言　　210</a>
          <ul>
            <li><a href="#101-领域特定语言-212">10.1 领域特定语言 212</a></li>
            <li><a href="#102-现代java-api中的小型dsl-217">10.2 现代Java API中的小型DSL 217</a></li>
            <li><a href="#103-使用java创建dsl的模式与技巧-221">10.3 使用Java创建DSL的模式与技巧 221</a></li>
            <li><a href="#104-java-8-dsl的实际应用-234">10.4 Java 8 DSL的实际应用 234</a></li>
            <li><a href="#105-小结-239">10.5 小结 239</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第四部分-无所不在的java">第四部分 无所不在的Java</a>
      <ul>
        <li><a href="#第11章用optional取代null242">第11章　用Optional取代null　　242</a>
          <ul>
            <li><a href="#111-如何为缺失的值建模-243">11.1 如何为缺失的值建模 243</a></li>
            <li><a href="#112-optional类入门-246">11.2 Optional类入门 246</a></li>
            <li><a href="#113-应用optional的几种模式-248">11.3 应用Optional的几种模式 248</a></li>
            <li><a href="#114-使用optional的实战示例-258">11.4 使用Optional的实战示例 258</a></li>
            <li><a href="#115-小结-262">11.5 小结 262</a></li>
          </ul>
        </li>
        <li><a href="#第12章新的日期和时间api263">第12章　新的日期和时间API　　263</a>
          <ul>
            <li><a href="#121-localdatelocaltimelocaldatetimeinstantduration以及period-264">12.1 LocalDate、LocalTime、LocalDateTime、Instant、Duration以及Period 264</a></li>
            <li><a href="#122-操纵解析和格式化日期-268">12.2 操纵、解析和格式化日期 268</a></li>
            <li><a href="#123-处理不同的时区和历法-274">12.3 处理不同的时区和历法 274</a></li>
            <li><a href="#124-小结-277">12.4 小结 277</a></li>
          </ul>
        </li>
        <li><a href="#第13章默认方法278">第13章　默认方法　　278</a>
          <ul>
            <li><a href="#131-不断演进的api-280">13.1 不断演进的API 280</a></li>
            <li><a href="#132-概述默认方法-283">13.2 概述默认方法 283</a></li>
            <li><a href="#133-默认方法的使用模式-285">13.3 默认方法的使用模式 285</a></li>
            <li><a href="#134-解决冲突的规则-289">13.4 解决冲突的规则 289</a></li>
            <li><a href="#135-小结-294">13.5 小结 294</a></li>
          </ul>
        </li>
        <li><a href="#第14章java模块系统295">第14章　Java模块系统　　295</a>
          <ul>
            <li><a href="#141-模块化的驱动力软件的推理-295">14.1 模块化的驱动力：软件的推理 295</a></li>
            <li><a href="#142-为什么要设计java模块系统-297">14.2 为什么要设计Java模块系统 297</a></li>
            <li><a href="#143-java模块全局视图-300">14.3 Java模块：全局视图 300</a></li>
            <li><a href="#144-使用java模块系统开发应用-301">14.4 使用Java模块系统开发应用 301</a></li>
            <li><a href="#145-使用多个模块-304">14.5 使用多个模块 304</a></li>
            <li><a href="#146-编译及打包-306">14.6 编译及打包 306</a></li>
            <li><a href="#147-自动模块-310">14.7 自动模块 310</a></li>
            <li><a href="#148-模块声明及子句-311">14.8 模块声明及子句 311</a></li>
            <li><a href="#149-通过一个更复杂的例子了解更多-313">14.9 通过一个更复杂的例子了解更多 313</a></li>
            <li><a href="#1410-小结-314">14.10 小结 314</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第五部分-提升java的并发性">第五部分 提升Java的并发性</a>
      <ul>
        <li><a href="#第15章completablefuture及反应式编程背后的概念316">第15章　CompletableFuture及反应式编程背后的概念　　316</a>
          <ul>
            <li><a href="#151-为支持并发而不断演进的java-318">15.1 为支持并发而不断演进的Java 318</a></li>
            <li><a href="#152-同步及异步api-324">15.2 同步及异步API 324</a></li>
            <li><a href="#153-线框管道模型-331">15.3 “线框–管道”模型 331</a></li>
            <li><a href="#154-为并发而生的completablefuture和结合器-332">15.4 为并发而生的CompletableFuture和结合器 332</a></li>
            <li><a href="#155-发布订阅以及反应式编程-335">15.5 “发布–订阅”以及反应式编程 335</a></li>
            <li><a href="#156-反应式系统和反应式编程-342">15.6 反应式系统和反应式编程 342</a></li>
            <li><a href="#157-路线图-342">15.7 路线图 342</a></li>
            <li><a href="#158-小结-343">15.8 小结 343</a></li>
          </ul>
        </li>
        <li><a href="#第16章completablefuture组合式异步编程344">第16章　CompletableFuture：组合式异步编程　　344</a>
          <ul>
            <li><a href="#161-future接口-344">16.1 Future接口 344</a></li>
            <li><a href="#162-实现异步api-347">16.2 实现异步API 347</a></li>
            <li><a href="#163-让你的代码免受阻塞之苦-352">16.3 让你的代码免受阻塞之苦 352</a></li>
            <li><a href="#164-对多个异步任务进行流水线操作-358">16.4 对多个异步任务进行流水线操作 358</a></li>
            <li><a href="#165-响应completablefuture的completion事件-366">16.5 响应CompletableFuture的completion事件 366</a></li>
            <li><a href="#166-路线图-369">16.6 路线图 369</a></li>
            <li><a href="#167-小结-369">16.7 小结 369</a></li>
          </ul>
        </li>
        <li><a href="#第17章反应式编程370">第17章　反应式编程　　370</a>
          <ul>
            <li><a href="#171-反应式宣言-371">17.1 反应式宣言 371</a></li>
            <li><a href="#172-反应式流以及flow-api-373">17.2 反应式流以及Flow API 373</a></li>
            <li><a href="#173-使用反应式库rxjava-384">17.3 使用反应式库RxJava 384</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第六部分-函数式编程以及java未来的演进">第六部分 函数式编程以及Java未来的演进</a>
      <ul>
        <li><a href="#第18章函数式的思考396">第18章　函数式的思考　　396</a>
          <ul>
            <li><a href="#181-实现和维护系统-396">18.1 实现和维护系统 396</a></li>
            <li><a href="#182-什么是函数式编程-399">18.2 什么是函数式编程 399</a></li>
            <li><a href="#183-递归和迭代-405">18.3 递归和迭代 405</a></li>
            <li><a href="#184-小结-408">18.4 小结 408</a></li>
          </ul>
        </li>
        <li><a href="#第19章函数式编程的技巧409">第19章　函数式编程的技巧　　409</a>
          <ul>
            <li><a href="#191-无处不在的函数-409">19.1 无处不在的函数 409</a></li>
            <li><a href="#192-持久化数据结构-412">19.2 持久化数据结构 412</a></li>
            <li><a href="#193-stream的延迟计算-418">19.3 Stream的延迟计算 418</a></li>
            <li><a href="#194-模式匹配-425">19.4 模式匹配 425</a></li>
            <li><a href="#195-杂项-429">19.5 杂项 429</a></li>
            <li><a href="#196-小结-432">19.6 小结 432</a></li>
          </ul>
        </li>
        <li><a href="#第20章面向对象和函数式编程的混合java和scala的比较433">第20章　面向对象和函数式编程的混合：Java和Scala的比较　　433</a>
          <ul>
            <li><a href="#201-scala简介-434">20.1 Scala简介 434</a></li>
            <li><a href="#202-函数-440">20.2 函数 440</a></li>
            <li><a href="#203-类和trait-444">20.3 类和trait 444</a></li>
            <li><a href="#204-小结-447">20.4 小结 447</a></li>
          </ul>
        </li>
        <li><a href="#第21章结论以及java的未来448">第21章　结论以及Java的未来　　448</a>
          <ul>
            <li><a href="#211-回顾java-8的语言特性-448">21.1 回顾Java 8的语言特性 448</a></li>
            <li><a href="#212-java-9的模块系统-451">21.2 Java 9的模块系统 451</a></li>
            <li><a href="#213-java-10的局部变量类型推断-453">21.3 Java 10的局部变量类型推断 453</a></li>
            <li><a href="#214-java的未来-454">21.4 Java的未来 454</a></li>
            <li><a href="#215-让java发展得更快-461">21.5 让Java发展得更快 461</a></li>
            <li><a href="#216-写在最后的话-462">21.6 写在最后的话 462</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="java实战">
  Java实战
  <a class="anchor" href="#java%e5%ae%9e%e6%88%98">#</a>
</h1>
<ul>
<li><a href="https://book.douban.com/subject/34895968/">Java实战（第2版）</a></li>
</ul>
<h2 id="第一部分-基础知识">
  第一部分 基础知识
  <a class="anchor" href="#%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86-%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86">#</a>
</h2>
<h3 id="第1章java-8910以及11的变化2">
  第1章　Java 8、9、10以及11的变化　　2
  <a class="anchor" href="#%e7%ac%ac1%e7%ab%a0java-8910%e4%bb%a5%e5%8f%8a11%e7%9a%84%e5%8f%98%e5%8c%962">#</a>
</h3>
<h4 id="11-为什么要关心java的变化-2">
  1.1 为什么要关心Java的变化 2
  <a class="anchor" href="#11-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%85%b3%e5%bf%83java%e7%9a%84%e5%8f%98%e5%8c%96-2">#</a>
</h4>
<h4 id="12-java怎么还在变-4">
  1.2 Java怎么还在变 4
  <a class="anchor" href="#12-java%e6%80%8e%e4%b9%88%e8%bf%98%e5%9c%a8%e5%8f%98-4">#</a>
</h4>
<ul>
<li>1.2.1 Java在编程语言生态系统中的位置 5</li>
<li>1.2.2 流处理 6</li>
<li>1.2.3 用行为参数化把代码传递给方法 7</li>
<li>1.2.4 并行与共享的可变数据 8</li>
<li>1.2.5 Java需要演变 9</li>
</ul>
<h4 id="13-java中的函数-9">
  1.3 Java中的函数 9
  <a class="anchor" href="#13-java%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0-9">#</a>
</h4>
<ul>
<li>1.3.1 方法和Lambda作为一等值 10</li>
<li>1.3.2 传递代码：一个例子 11</li>
<li>1.3.3 从传递方法到Lambda 13</li>
</ul>
<h4 id="14-流-14">
  1.4 流 14
  <a class="anchor" href="#14-%e6%b5%81-14">#</a>
</h4>
<h4 id="15-默认方法及java模块-17">
  1.5 默认方法及Java模块 17
  <a class="anchor" href="#15-%e9%bb%98%e8%ae%a4%e6%96%b9%e6%b3%95%e5%8f%8ajava%e6%a8%a1%e5%9d%97-17">#</a>
</h4>
<h4 id="16-来自函数式编程的其他好思想-19">
  1.6 来自函数式编程的其他好思想 19
  <a class="anchor" href="#16-%e6%9d%a5%e8%87%aa%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e7%9a%84%e5%85%b6%e4%bb%96%e5%a5%bd%e6%80%9d%e6%83%b3-19">#</a>
</h4>
<h4 id="17-小结-20">
  1.7 小结 20
  <a class="anchor" href="#17-%e5%b0%8f%e7%bb%93-20">#</a>
</h4>
<h3 id="第2章通过行为参数化传递代码22">
  第2章　通过行为参数化传递代码　　22
  <a class="anchor" href="#%e7%ac%ac2%e7%ab%a0%e9%80%9a%e8%bf%87%e8%a1%8c%e4%b8%ba%e5%8f%82%e6%95%b0%e5%8c%96%e4%bc%a0%e9%80%92%e4%bb%a3%e7%a0%8122">#</a>
</h3>
<h4 id="21-应对不断变化的需求-23">
  2.1 应对不断变化的需求 23
  <a class="anchor" href="#21-%e5%ba%94%e5%af%b9%e4%b8%8d%e6%96%ad%e5%8f%98%e5%8c%96%e7%9a%84%e9%9c%80%e6%b1%82-23">#</a>
</h4>
<ul>
<li>2.1.1 初试牛刀：筛选绿苹果 23</li>
<li>2.1.2 再展身手：把颜色作为参数 23</li>
<li>2.1.3 第三次尝试：对你能想到的每个属性做筛选 24</li>
</ul>
<h4 id="22-行为参数化-25">
  2.2 行为参数化 25
  <a class="anchor" href="#22-%e8%a1%8c%e4%b8%ba%e5%8f%82%e6%95%b0%e5%8c%96-25">#</a>
</h4>
<h4 id="23-对付啰唆-30">
  2.3 对付啰唆 30
  <a class="anchor" href="#23-%e5%af%b9%e4%bb%98%e5%95%b0%e5%94%86-30">#</a>
</h4>
<ul>
<li>2.3.1 匿名类 30</li>
<li>2.3.2 第五次尝试：使用匿名类 31</li>
<li>2.3.3 第六次尝试：使用Lambda表达式 32</li>
<li>2.3.4 第七次尝试：将List类型抽象化 33</li>
</ul>
<h4 id="24-真实的例子-33">
  2.4 真实的例子 33
  <a class="anchor" href="#24-%e7%9c%9f%e5%ae%9e%e7%9a%84%e4%be%8b%e5%ad%90-33">#</a>
</h4>
<ul>
<li>2.4.1 用Comparator来排序 33</li>
<li>2.4.2 用Runnable执行代码块 34</li>
<li>2.4.3 通过Callable返回结果 35</li>
<li>2.4.4 GUI事件处理 35</li>
</ul>
<h4 id="25-小结-36">
  2.5 小结 36
  <a class="anchor" href="#25-%e5%b0%8f%e7%bb%93-36">#</a>
</h4>
<h3 id="第3章lambda表达式37">
  第3章　Lambda表达式　　37
  <a class="anchor" href="#%e7%ac%ac3%e7%ab%a0lambda%e8%a1%a8%e8%be%be%e5%bc%8f37">#</a>
</h3>
<h4 id="31-lambda管中窥豹-37">
  3.1 Lambda管中窥豹 37
  <a class="anchor" href="#31-lambda%e7%ae%a1%e4%b8%ad%e7%aa%a5%e8%b1%b9-37">#</a>
</h4>
<h4 id="32-在哪里以及如何使用lambda-40">
  3.2 在哪里以及如何使用Lambda 40
  <a class="anchor" href="#32-%e5%9c%a8%e5%93%aa%e9%87%8c%e4%bb%a5%e5%8f%8a%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8lambda-40">#</a>
</h4>
<ul>
<li>3.2.1 函数式接口 40</li>
<li>3.2.2 函数描述符 42</li>
</ul>
<h4 id="33-把lambda付诸实践环绕执行模式-44">
  3.3 把Lambda付诸实践：环绕执行模式 44
  <a class="anchor" href="#33-%e6%8a%8alambda%e4%bb%98%e8%af%b8%e5%ae%9e%e8%b7%b5%e7%8e%af%e7%bb%95%e6%89%a7%e8%a1%8c%e6%a8%a1%e5%bc%8f-44">#</a>
</h4>
<ul>
<li>3.3.1 第1 步：记得行为参数化 44</li>
<li>3.3.2 第2 步：使用函数式接口来传递行为 45</li>
<li>3.3.3 第3 步：执行一个行为 45</li>
<li>3.3.4 第4 步：传递Lambda 46</li>
</ul>
<h4 id="34-使用函数式接口-47">
  3.4 使用函数式接口 47
  <a class="anchor" href="#34-%e4%bd%bf%e7%94%a8%e5%87%bd%e6%95%b0%e5%bc%8f%e6%8e%a5%e5%8f%a3-47">#</a>
</h4>
<ul>
<li>3.4.1 Predicate 47</li>
<li>3.4.2 Consumer 47</li>
<li>3.4.3 Function 48</li>
</ul>
<h4 id="35-类型检查类型推断以及限制-52">
  3.5 类型检查、类型推断以及限制 52
  <a class="anchor" href="#35-%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%9f%a5%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%ad%e4%bb%a5%e5%8f%8a%e9%99%90%e5%88%b6-52">#</a>
</h4>
<ul>
<li>3.5.1 类型检查 52</li>
<li>3.5.2 同样的Lambda，不同的函数式接口 53</li>
<li>3.5.3 类型推断 55</li>
<li>3.5.4 使用局部变量 56</li>
</ul>
<h4 id="36-方法引用-57">
  3.6 方法引用 57
  <a class="anchor" href="#36-%e6%96%b9%e6%b3%95%e5%bc%95%e7%94%a8-57">#</a>
</h4>
<ul>
<li>3.6.1 管中窥豹 57</li>
<li>3.6.2 构造函数引用 60</li>
</ul>
<h4 id="37-lambda和方法引用实战-62">
  3.7 Lambda和方法引用实战 62
  <a class="anchor" href="#37-lambda%e5%92%8c%e6%96%b9%e6%b3%95%e5%bc%95%e7%94%a8%e5%ae%9e%e6%88%98-62">#</a>
</h4>
<ul>
<li>3.7.1 第1 步：传递代码 62</li>
<li>3.7.2 第2 步：使用匿名类 62</li>
<li>3.7.3 第3 步：使用Lambda表达式 62</li>
<li>3.7.4 第4 步：使用方法引用 63</li>
</ul>
<h4 id="38-复合lambda表达式的有用方法-63">
  3.8 复合Lambda表达式的有用方法 63
  <a class="anchor" href="#38-%e5%a4%8d%e5%90%88lambda%e8%a1%a8%e8%be%be%e5%bc%8f%e7%9a%84%e6%9c%89%e7%94%a8%e6%96%b9%e6%b3%95-63">#</a>
</h4>
<ul>
<li>3.8.1 比较器复合 64</li>
<li>3.8.2 谓词复合 64</li>
<li>3.8.3 函数复合 65</li>
</ul>
<h4 id="39-数学中的类似思想-66">
  3.9 数学中的类似思想 66
  <a class="anchor" href="#39-%e6%95%b0%e5%ad%a6%e4%b8%ad%e7%9a%84%e7%b1%bb%e4%bc%bc%e6%80%9d%e6%83%b3-66">#</a>
</h4>
<ul>
<li>3.9.1 积分 66</li>
<li>3.9.2 与Java 8的Lambda联系起来 68</li>
</ul>
<h4 id="310-小结-68">
  3.10 小结 68
  <a class="anchor" href="#310-%e5%b0%8f%e7%bb%93-68">#</a>
</h4>
<h2 id="第二部分-使用流进行函数式数据处理">
  第二部分 使用流进行函数式数据处理
  <a class="anchor" href="#%e7%ac%ac%e4%ba%8c%e9%83%a8%e5%88%86-%e4%bd%bf%e7%94%a8%e6%b5%81%e8%bf%9b%e8%a1%8c%e5%87%bd%e6%95%b0%e5%bc%8f%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86">#</a>
</h2>
<h3 id="第4章引入流72">
  第4章　引入流　　72
  <a class="anchor" href="#%e7%ac%ac4%e7%ab%a0%e5%bc%95%e5%85%a5%e6%b5%8172">#</a>
</h3>
<h4 id="41-流是什么-72">
  4.1 流是什么 72
  <a class="anchor" href="#41-%e6%b5%81%e6%98%af%e4%bb%80%e4%b9%88-72">#</a>
</h4>
<h4 id="42-流简介-76">
  4.2 流简介 76
  <a class="anchor" href="#42-%e6%b5%81%e7%ae%80%e4%bb%8b-76">#</a>
</h4>
<h4 id="43-流与集合-78">
  4.3 流与集合 78
  <a class="anchor" href="#43-%e6%b5%81%e4%b8%8e%e9%9b%86%e5%90%88-78">#</a>
</h4>
<ul>
<li>4.3.1 只能遍历一次 79</li>
<li>4.3.2 外部迭代与内部迭代 80</li>
</ul>
<h4 id="44-流操作-82">
  4.4 流操作 82
  <a class="anchor" href="#44-%e6%b5%81%e6%93%8d%e4%bd%9c-82">#</a>
</h4>
<ul>
<li>4.4.1 中间操作 83</li>
<li>4.4.2 终端操作 84</li>
<li>4.4.3 使用流 84</li>
</ul>
<h4 id="45-路线图-85">
  4.5 路线图 85
  <a class="anchor" href="#45-%e8%b7%af%e7%ba%bf%e5%9b%be-85">#</a>
</h4>
<h4 id="46-小结-85">
  4.6 小结 85
  <a class="anchor" href="#46-%e5%b0%8f%e7%bb%93-85">#</a>
</h4>
<h3 id="第5章使用流86">
  第5章　使用流　　86
  <a class="anchor" href="#%e7%ac%ac5%e7%ab%a0%e4%bd%bf%e7%94%a8%e6%b5%8186">#</a>
</h3>
<h4 id="51-筛选-87">
  5.1 筛选 87
  <a class="anchor" href="#51-%e7%ad%9b%e9%80%89-87">#</a>
</h4>
<ul>
<li>5.1.1 用谓词筛选 87</li>
<li>5.1.2 筛选各异的元素 87</li>
</ul>
<h4 id="52-流的切片-88">
  5.2 流的切片 88
  <a class="anchor" href="#52-%e6%b5%81%e7%9a%84%e5%88%87%e7%89%87-88">#</a>
</h4>
<ul>
<li>5.2.1 使用谓词对流进行切片 88</li>
<li>5.2.2 截短流 90</li>
<li>5.2.3 跳过元素 90</li>
</ul>
<h4 id="53-映射-91">
  5.3 映射 91
  <a class="anchor" href="#53-%e6%98%a0%e5%b0%84-91">#</a>
</h4>
<ul>
<li>5.3.1 对流中每一个元素应用函数 91</li>
<li>5.3.2 流的扁平化 92</li>
</ul>
<h4 id="54-查找和匹配-95">
  5.4 查找和匹配 95
  <a class="anchor" href="#54-%e6%9f%a5%e6%89%be%e5%92%8c%e5%8c%b9%e9%85%8d-95">#</a>
</h4>
<ul>
<li>5.4.1 检查谓词是否至少匹配一个元素 95</li>
<li>5.4.2 检查谓词是否匹配所有元素 96</li>
<li>5.4.3 查找元素 96</li>
<li>5.4.4 查找第一个元素 97</li>
</ul>
<h4 id="55-归约-98">
  5.5 归约 98
  <a class="anchor" href="#55-%e5%bd%92%e7%ba%a6-98">#</a>
</h4>
<ul>
<li>5.5.1 元素求和 98</li>
<li>5.5.2 最大值和最小值 100</li>
</ul>
<h4 id="56-付诸实践-103">
  5.6 付诸实践 103
  <a class="anchor" href="#56-%e4%bb%98%e8%af%b8%e5%ae%9e%e8%b7%b5-103">#</a>
</h4>
<ul>
<li>5.6.1 领域：交易员和交易 103</li>
<li>5.6.2 解答 104</li>
</ul>
<h4 id="57-数值流-106">
  5.7 数值流 106
  <a class="anchor" href="#57-%e6%95%b0%e5%80%bc%e6%b5%81-106">#</a>
</h4>
<ul>
<li>5.7.1 原始类型流特化 107</li>
<li>5.7.2 数值范围 108</li>
<li>5.7.3 数值流应用：勾股数 108</li>
</ul>
<h4 id="58-构建流-111">
  5.8 构建流 111
  <a class="anchor" href="#58-%e6%9e%84%e5%bb%ba%e6%b5%81-111">#</a>
</h4>
<ul>
<li>5.8.1 由值创建流 111</li>
<li>5.8.2 由可空对象创建流 111</li>
<li>5.8.3 由数组创建流 112</li>
<li>5.8.4 由文件生成流 112</li>
<li>5.8.5 由函数生成流：创建无限流 113</li>
</ul>
<h4 id="59-概述-116">
  5.9 概述 116
  <a class="anchor" href="#59-%e6%a6%82%e8%bf%b0-116">#</a>
</h4>
<h4 id="510-小结-116">
  5.10 小结 116
  <a class="anchor" href="#510-%e5%b0%8f%e7%bb%93-116">#</a>
</h4>
<h3 id="第6章用流收集数据118">
  第6章　用流收集数据　　118
  <a class="anchor" href="#%e7%ac%ac6%e7%ab%a0%e7%94%a8%e6%b5%81%e6%94%b6%e9%9b%86%e6%95%b0%e6%8d%ae118">#</a>
</h3>
<h4 id="61-收集器简介-119">
  6.1 收集器简介 119
  <a class="anchor" href="#61-%e6%94%b6%e9%9b%86%e5%99%a8%e7%ae%80%e4%bb%8b-119">#</a>
</h4>
<ul>
<li>6.1.1 收集器用作高级归约 119</li>
<li>6.1.2 预定义收集器 120</li>
</ul>
<h4 id="62-归约和汇总-121">
  6.2 归约和汇总 121
  <a class="anchor" href="#62-%e5%bd%92%e7%ba%a6%e5%92%8c%e6%b1%87%e6%80%bb-121">#</a>
</h4>
<ul>
<li>6.2.1 查找流中的最大值和最小值 121</li>
<li>6.2.2 汇总 122</li>
<li>6.2.3 连接字符串 123</li>
<li>6.2.4 广义的归约汇总 124</li>
</ul>
<h4 id="63-分组-127">
  6.3 分组 127
  <a class="anchor" href="#63-%e5%88%86%e7%bb%84-127">#</a>
</h4>
<ul>
<li>6.3.1 操作分组的元素 128</li>
<li>6.3.2 多级分组 130</li>
<li>6.3.3 按子组收集数据 131</li>
</ul>
<h4 id="64-分区-134">
  6.4 分区 134
  <a class="anchor" href="#64-%e5%88%86%e5%8c%ba-134">#</a>
</h4>
<ul>
<li>6.4.1 分区的优势 135</li>
<li>6.4.2 将数字按质数和非质数分区 136</li>
</ul>
<h4 id="65-收集器接口-138">
  6.5 收集器接口 138
  <a class="anchor" href="#65-%e6%94%b6%e9%9b%86%e5%99%a8%e6%8e%a5%e5%8f%a3-138">#</a>
</h4>
<ul>
<li>6.5.1 理解Collector接口声明的方法 139</li>
<li>6.5.2 全部融合到一起 143</li>
</ul>
<h4 id="66-开发你自己的收集器以获得更好的性能-144">
  6.6 开发你自己的收集器以获得更好的性能 144
  <a class="anchor" href="#66-%e5%bc%80%e5%8f%91%e4%bd%a0%e8%87%aa%e5%b7%b1%e7%9a%84%e6%94%b6%e9%9b%86%e5%99%a8%e4%bb%a5%e8%8e%b7%e5%be%97%e6%9b%b4%e5%a5%bd%e7%9a%84%e6%80%a7%e8%83%bd-144">#</a>
</h4>
<ul>
<li>6.6.1 仅用质数做除数 145</li>
<li>6.6.2 比较收集器的性能 148</li>
</ul>
<h4 id="67-小结-150">
  6.7 小结 150
  <a class="anchor" href="#67-%e5%b0%8f%e7%bb%93-150">#</a>
</h4>
<h3 id="第7章并行数据处理与性能151">
  第7章　并行数据处理与性能　　151
  <a class="anchor" href="#%e7%ac%ac7%e7%ab%a0%e5%b9%b6%e8%a1%8c%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86%e4%b8%8e%e6%80%a7%e8%83%bd151">#</a>
</h3>
<h4 id="71-并行流-152">
  7.1 并行流 152
  <a class="anchor" href="#71-%e5%b9%b6%e8%a1%8c%e6%b5%81-152">#</a>
</h4>
<ul>
<li>7.1.1 将顺序流转换为并行流 52</li>
<li>7.1.2 测量流性能 154</li>
<li>7.1.3 正确使用并行流 158</li>
<li>7.1.4 高效使用并行流 159</li>
</ul>
<h4 id="72-分支合并框架-161">
  7.2 分支/合并框架 161
  <a class="anchor" href="#72-%e5%88%86%e6%94%af%e5%90%88%e5%b9%b6%e6%a1%86%e6%9e%b6-161">#</a>
</h4>
<ul>
<li>7.2.1 使用RecursiveTask 161</li>
<li>7.2.2 使用分支/合并框架的最佳做法 164</li>
<li>7.2.3 工作窃取 165</li>
</ul>
<h4 id="73-spliterator-166">
  7.3 Spliterator 166
  <a class="anchor" href="#73-spliterator-166">#</a>
</h4>
<ul>
<li>7.3.1 拆分过程 167</li>
<li>7.3.2 实现你自己的Spliterator 168</li>
</ul>
<h4 id="74-小结-173">
  7.4 小结 173
  <a class="anchor" href="#74-%e5%b0%8f%e7%bb%93-173">#</a>
</h4>
<h2 id="第三部分-使用流和lambda进行高效编程">
  第三部分 使用流和Lambda进行高效编程
  <a class="anchor" href="#%e7%ac%ac%e4%b8%89%e9%83%a8%e5%88%86-%e4%bd%bf%e7%94%a8%e6%b5%81%e5%92%8clambda%e8%bf%9b%e8%a1%8c%e9%ab%98%e6%95%88%e7%bc%96%e7%a8%8b">#</a>
</h2>
<h3 id="第8章collection-api的增强功能176">
  第8章　Collection API的增强功能　　176
  <a class="anchor" href="#%e7%ac%ac8%e7%ab%a0collection-api%e7%9a%84%e5%a2%9e%e5%bc%ba%e5%8a%9f%e8%83%bd176">#</a>
</h3>
<h4 id="81-集合工厂-176">
  8.1 集合工厂 176
  <a class="anchor" href="#81-%e9%9b%86%e5%90%88%e5%b7%a5%e5%8e%82-176">#</a>
</h4>
<ul>
<li>8.1.1 List工厂 177</li>
<li>8.1.2 Set工厂 178</li>
<li>8.1.3 Map工厂 179</li>
</ul>
<h4 id="82-使用list和set-180">
  8.2 使用List和Set 180
  <a class="anchor" href="#82-%e4%bd%bf%e7%94%a8list%e5%92%8cset-180">#</a>
</h4>
<ul>
<li>8.2.1 removeIf方法 180</li>
<li>8.2.2 replaceAll方法 181</li>
</ul>
<h4 id="83-使用map-181">
  8.3 使用Map 181
  <a class="anchor" href="#83-%e4%bd%bf%e7%94%a8map-181">#</a>
</h4>
<ul>
<li>8.3.1 forEach方法 182</li>
<li>8.3.2 排序 182</li>
<li>8.3.3 getOrDefault方法 183</li>
<li>8.3.4 计算模式 183</li>
<li>8.3.5 删除模式 184</li>
<li>8.3.6 替换模式 185</li>
<li>8.3.7 merge方法 185</li>
</ul>
<h4 id="84-改进的concurrenthashmap-187">
  8.4 改进的ConcurrentHashMap 187
  <a class="anchor" href="#84-%e6%94%b9%e8%bf%9b%e7%9a%84concurrenthashmap-187">#</a>
</h4>
<ul>
<li>8.4.1 归约和搜索 187</li>
<li>8.4.2 计数 188</li>
<li>8.4.3 Set视图 188</li>
</ul>
<h4 id="85-小结-188">
  8.5 小结 188
  <a class="anchor" href="#85-%e5%b0%8f%e7%bb%93-188">#</a>
</h4>
<h3 id="第9章重构测试和调试189">
  第9章　重构、测试和调试　　189
  <a class="anchor" href="#%e7%ac%ac9%e7%ab%a0%e9%87%8d%e6%9e%84%e6%b5%8b%e8%af%95%e5%92%8c%e8%b0%83%e8%af%95189">#</a>
</h3>
<h4 id="91-为改善可读性和灵活性重构代码-189">
  9.1 为改善可读性和灵活性重构代码 189
  <a class="anchor" href="#91-%e4%b8%ba%e6%94%b9%e5%96%84%e5%8f%af%e8%af%bb%e6%80%a7%e5%92%8c%e7%81%b5%e6%b4%bb%e6%80%a7%e9%87%8d%e6%9e%84%e4%bb%a3%e7%a0%81-189">#</a>
</h4>
<ul>
<li>9.1.1 改善代码的可读性 190</li>
<li>9.1.2 从匿名类到Lambda表达式的转换 190</li>
<li>9.1.3 从Lambda表达式到方法引用的转换 191</li>
<li>9.1.4 从命令式的数据处理切换到Stream 193</li>
<li>9.1.5 增加代码的灵活性 193</li>
</ul>
<h4 id="92-使用lambda重构面向对象的设计模式-195">
  9.2 使用Lambda重构面向对象的设计模式 195
  <a class="anchor" href="#92-%e4%bd%bf%e7%94%a8lambda%e9%87%8d%e6%9e%84%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f-195">#</a>
</h4>
<ul>
<li>9.2.1 策略模式 196</li>
<li>9.2.2 模板方法 197</li>
<li>9.2.3 观察者模式 198</li>
<li>9.2.4 责任链模式 201</li>
<li>9.2.5 工厂模式 202</li>
</ul>
<h4 id="93-测试lambda表达式-204">
  9.3 测试Lambda表达式 204
  <a class="anchor" href="#93-%e6%b5%8b%e8%af%95lambda%e8%a1%a8%e8%be%be%e5%bc%8f-204">#</a>
</h4>
<ul>
<li>9.3.1 测试可见Lambda函数的行为 204</li>
<li>9.3.2 测试使用Lambda的方法的行为 205</li>
<li>9.3.3 将复杂的Lambda表达式分为不同的方法 205</li>
<li>9.3.4 高阶函数的测试 206</li>
</ul>
<h4 id="94-调试-206">
  9.4 调试 206
  <a class="anchor" href="#94-%e8%b0%83%e8%af%95-206">#</a>
</h4>
<ul>
<li>9.4.1 查看栈跟踪 206</li>
<li>9.4.2 使用日志调试 208</li>
</ul>
<h4 id="95-小结-209">
  9.5 小结 209
  <a class="anchor" href="#95-%e5%b0%8f%e7%bb%93-209">#</a>
</h4>
<h3 id="第10章基于lambda的领域特定语言210">
  第10章　基于Lambda的领域特定语言　　210
  <a class="anchor" href="#%e7%ac%ac10%e7%ab%a0%e5%9f%ba%e4%ba%8elambda%e7%9a%84%e9%a2%86%e5%9f%9f%e7%89%b9%e5%ae%9a%e8%af%ad%e8%a8%80210">#</a>
</h3>
<h4 id="101-领域特定语言-212">
  10.1 领域特定语言 212
  <a class="anchor" href="#101-%e9%a2%86%e5%9f%9f%e7%89%b9%e5%ae%9a%e8%af%ad%e8%a8%80-212">#</a>
</h4>
<ul>
<li>10.1.1 DSL的优点和弊端 212</li>
<li>10.1.2 JVM中已提供的DSL解决方案 214</li>
</ul>
<h4 id="102-现代java-api中的小型dsl-217">
  10.2 现代Java API中的小型DSL 217
  <a class="anchor" href="#102-%e7%8e%b0%e4%bb%a3java-api%e4%b8%ad%e7%9a%84%e5%b0%8f%e5%9e%8bdsl-217">#</a>
</h4>
<ul>
<li>10.2.1 把Stream API当成DSL去操作集合 219</li>
<li>10.2.2 将Collectors作为DSL汇总数据 220</li>
</ul>
<h4 id="103-使用java创建dsl的模式与技巧-221">
  10.3 使用Java创建DSL的模式与技巧 221
  <a class="anchor" href="#103-%e4%bd%bf%e7%94%a8java%e5%88%9b%e5%bb%badsl%e7%9a%84%e6%a8%a1%e5%bc%8f%e4%b8%8e%e6%8a%80%e5%b7%a7-221">#</a>
</h4>
<ul>
<li>10.3.1 方法链接 224</li>
<li>10.3.2 使用嵌套函数 226</li>
<li>10.3.3 使用Lambda表达式的函数序列 228</li>
<li>10.3.4 把它们都放到一起 230</li>
<li>10.3.5 在DSL中使用方法引用 232</li>
</ul>
<h4 id="104-java-8-dsl的实际应用-234">
  10.4 Java 8 DSL的实际应用 234
  <a class="anchor" href="#104-java-8-dsl%e7%9a%84%e5%ae%9e%e9%99%85%e5%ba%94%e7%94%a8-234">#</a>
</h4>
<ul>
<li>10.4.1 jOOQ 235</li>
<li>10.4.2 Cucumber 236</li>
<li>10.4.3 Spring Integration 238</li>
</ul>
<h4 id="105-小结-239">
  10.5 小结 239
  <a class="anchor" href="#105-%e5%b0%8f%e7%bb%93-239">#</a>
</h4>
<h2 id="第四部分-无所不在的java">
  第四部分 无所不在的Java
  <a class="anchor" href="#%e7%ac%ac%e5%9b%9b%e9%83%a8%e5%88%86-%e6%97%a0%e6%89%80%e4%b8%8d%e5%9c%a8%e7%9a%84java">#</a>
</h2>
<h3 id="第11章用optional取代null242">
  第11章　用Optional取代null　　242
  <a class="anchor" href="#%e7%ac%ac11%e7%ab%a0%e7%94%a8optional%e5%8f%96%e4%bb%a3null242">#</a>
</h3>
<h4 id="111-如何为缺失的值建模-243">
  11.1 如何为缺失的值建模 243
  <a class="anchor" href="#111-%e5%a6%82%e4%bd%95%e4%b8%ba%e7%bc%ba%e5%a4%b1%e7%9a%84%e5%80%bc%e5%bb%ba%e6%a8%a1-243">#</a>
</h4>
<ul>
<li>11.1.1 采用防御式检查减少NullPointerException 243</li>
<li>11.1.2 null带来的种种问题 245</li>
<li>11.1.3 其他语言中null的替代品 245</li>
</ul>
<h4 id="112-optional类入门-246">
  11.2 Optional类入门 246
  <a class="anchor" href="#112-optional%e7%b1%bb%e5%85%a5%e9%97%a8-246">#</a>
</h4>
<h4 id="113-应用optional的几种模式-248">
  11.3 应用Optional的几种模式 248
  <a class="anchor" href="#113-%e5%ba%94%e7%94%a8optional%e7%9a%84%e5%87%a0%e7%a7%8d%e6%a8%a1%e5%bc%8f-248">#</a>
</h4>
<ul>
<li>11.3.1 创建Optional对象 248</li>
<li>11.3.2 使用map从Optional对象中提取和转换值 248</li>
<li>11.3.3 使用flatMap链接Optional对象 249</li>
<li>11.3.4 操纵由Optional对象构成的Stream 253</li>
<li>11.3.5 默认行为及解引用Optional对象 254</li>
<li>11.3.6 两个Optional对象的组合 255</li>
<li>11.3.7 使用filter剔除特定的值 257</li>
</ul>
<h4 id="114-使用optional的实战示例-258">
  11.4 使用Optional的实战示例 258
  <a class="anchor" href="#114-%e4%bd%bf%e7%94%a8optional%e7%9a%84%e5%ae%9e%e6%88%98%e7%a4%ba%e4%be%8b-258">#</a>
</h4>
<ul>
<li>11.4.1 用Optional 封装可能为null的值 259</li>
<li>11.4.2 异常与Optional的对比 259</li>
<li>11.4.3 基础类型的Optional对象，以及为什么应该避免使用它们 260</li>
<li>11.4.4 把所有内容整合起来 260</li>
</ul>
<h4 id="115-小结-262">
  11.5 小结 262
  <a class="anchor" href="#115-%e5%b0%8f%e7%bb%93-262">#</a>
</h4>
<h3 id="第12章新的日期和时间api263">
  第12章　新的日期和时间API　　263
  <a class="anchor" href="#%e7%ac%ac12%e7%ab%a0%e6%96%b0%e7%9a%84%e6%97%a5%e6%9c%9f%e5%92%8c%e6%97%b6%e9%97%b4api263">#</a>
</h3>
<h4 id="121-localdatelocaltimelocaldatetimeinstantduration以及period-264">
  12.1 LocalDate、LocalTime、LocalDateTime、Instant、Duration以及Period 264
  <a class="anchor" href="#121-localdatelocaltimelocaldatetimeinstantduration%e4%bb%a5%e5%8f%8aperiod-264">#</a>
</h4>
<ul>
<li>12.1.1 使用LocalDate和LocalTime 264</li>
<li>12.1.2 合并日期和时间 265</li>
<li>12.1.3 机器的日期和时间格式 266</li>
<li>12.1.4 定义Duration或Period 267</li>
</ul>
<h4 id="122-操纵解析和格式化日期-268">
  12.2 操纵、解析和格式化日期 268
  <a class="anchor" href="#122-%e6%93%8d%e7%ba%b5%e8%a7%a3%e6%9e%90%e5%92%8c%e6%a0%bc%e5%bc%8f%e5%8c%96%e6%97%a5%e6%9c%9f-268">#</a>
</h4>
<ul>
<li>12.2.1 使用TemporalAdjuster 270</li>
<li>12.2.2 打印输出及解析日期–时间对象 272</li>
</ul>
<h4 id="123-处理不同的时区和历法-274">
  12.3 处理不同的时区和历法 274
  <a class="anchor" href="#123-%e5%a4%84%e7%90%86%e4%b8%8d%e5%90%8c%e7%9a%84%e6%97%b6%e5%8c%ba%e5%92%8c%e5%8e%86%e6%b3%95-274">#</a>
</h4>
<ul>
<li>12.3.1 使用时区 274</li>
<li>12.3.2 利用和UTC/格林尼治时间的固定偏差计算时区 275</li>
<li>12.3.3 使用别的日历系统 276</li>
</ul>
<h4 id="124-小结-277">
  12.4 小结 277
  <a class="anchor" href="#124-%e5%b0%8f%e7%bb%93-277">#</a>
</h4>
<h3 id="第13章默认方法278">
  第13章　默认方法　　278
  <a class="anchor" href="#%e7%ac%ac13%e7%ab%a0%e9%bb%98%e8%ae%a4%e6%96%b9%e6%b3%95278">#</a>
</h3>
<h4 id="131-不断演进的api-280">
  13.1 不断演进的API 280
  <a class="anchor" href="#131-%e4%b8%8d%e6%96%ad%e6%bc%94%e8%bf%9b%e7%9a%84api-280">#</a>
</h4>
<ul>
<li>13.1.1 初始版本的API 281</li>
<li>13.1.2 第二版API 281</li>
</ul>
<h4 id="132-概述默认方法-283">
  13.2 概述默认方法 283
  <a class="anchor" href="#132-%e6%a6%82%e8%bf%b0%e9%bb%98%e8%ae%a4%e6%96%b9%e6%b3%95-283">#</a>
</h4>
<h4 id="133-默认方法的使用模式-285">
  13.3 默认方法的使用模式 285
  <a class="anchor" href="#133-%e9%bb%98%e8%ae%a4%e6%96%b9%e6%b3%95%e7%9a%84%e4%bd%bf%e7%94%a8%e6%a8%a1%e5%bc%8f-285">#</a>
</h4>
<ul>
<li>13.3.1 可选方法 285</li>
<li>13.3.2 行为的多继承 286</li>
</ul>
<h4 id="134-解决冲突的规则-289">
  13.4 解决冲突的规则 289
  <a class="anchor" href="#134-%e8%a7%a3%e5%86%b3%e5%86%b2%e7%aa%81%e7%9a%84%e8%a7%84%e5%88%99-289">#</a>
</h4>
<ul>
<li>13.4.1 解决问题的三条规则 289</li>
<li>13.4.2 选择提供了最具体实现的默认方法的接口 290</li>
<li>13.4.3 冲突及如何显式地消除歧义 291</li>
<li>13.4.4 菱形继承问题 293</li>
</ul>
<h4 id="135-小结-294">
  13.5 小结 294
  <a class="anchor" href="#135-%e5%b0%8f%e7%bb%93-294">#</a>
</h4>
<h3 id="第14章java模块系统295">
  第14章　Java模块系统　　295
  <a class="anchor" href="#%e7%ac%ac14%e7%ab%a0java%e6%a8%a1%e5%9d%97%e7%b3%bb%e7%bb%9f295">#</a>
</h3>
<h4 id="141-模块化的驱动力软件的推理-295">
  14.1 模块化的驱动力：软件的推理 295
  <a class="anchor" href="#141-%e6%a8%a1%e5%9d%97%e5%8c%96%e7%9a%84%e9%a9%b1%e5%8a%a8%e5%8a%9b%e8%bd%af%e4%bb%b6%e7%9a%84%e6%8e%a8%e7%90%86-295">#</a>
</h4>
<ul>
<li>14.1.1 关注点分离 295</li>
<li>14.1.2 信息隐藏 296</li>
<li>14.1.3 Java软件 296</li>
</ul>
<h4 id="142-为什么要设计java模块系统-297">
  14.2 为什么要设计Java模块系统 297
  <a class="anchor" href="#142-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%ae%be%e8%ae%a1java%e6%a8%a1%e5%9d%97%e7%b3%bb%e7%bb%9f-297">#</a>
</h4>
<ul>
<li>14.2.1 模块化的局限性 297</li>
<li>14.2.2 单体型的JDK 298</li>
<li>14.2.3 与OSGi的比较 299</li>
</ul>
<h4 id="143-java模块全局视图-300">
  14.3 Java模块：全局视图 300
  <a class="anchor" href="#143-java%e6%a8%a1%e5%9d%97%e5%85%a8%e5%b1%80%e8%a7%86%e5%9b%be-300">#</a>
</h4>
<h4 id="144-使用java模块系统开发应用-301">
  14.4 使用Java模块系统开发应用 301
  <a class="anchor" href="#144-%e4%bd%bf%e7%94%a8java%e6%a8%a1%e5%9d%97%e7%b3%bb%e7%bb%9f%e5%bc%80%e5%8f%91%e5%ba%94%e7%94%a8-301">#</a>
</h4>
<ul>
<li>14.4.1 从头开始搭建一个应用 302</li>
<li>14.4.2 细粒度和粗粒度的模块化 303</li>
<li>14.4.3 Java模块系统基础 303</li>
</ul>
<h4 id="145-使用多个模块-304">
  14.5 使用多个模块 304
  <a class="anchor" href="#145-%e4%bd%bf%e7%94%a8%e5%a4%9a%e4%b8%aa%e6%a8%a1%e5%9d%97-304">#</a>
</h4>
<ul>
<li>14.5.1 exports子句 304</li>
<li>14.5.2 requires子句 305</li>
<li>14.5.3 命名 306</li>
</ul>
<h4 id="146-编译及打包-306">
  14.6 编译及打包 306
  <a class="anchor" href="#146-%e7%bc%96%e8%af%91%e5%8f%8a%e6%89%93%e5%8c%85-306">#</a>
</h4>
<h4 id="147-自动模块-310">
  14.7 自动模块 310
  <a class="anchor" href="#147-%e8%87%aa%e5%8a%a8%e6%a8%a1%e5%9d%97-310">#</a>
</h4>
<h4 id="148-模块声明及子句-311">
  14.8 模块声明及子句 311
  <a class="anchor" href="#148-%e6%a8%a1%e5%9d%97%e5%a3%b0%e6%98%8e%e5%8f%8a%e5%ad%90%e5%8f%a5-311">#</a>
</h4>
<ul>
<li>14.8.1 requires 311</li>
<li>14.8.2 exports 311</li>
<li>14.8.3 requires的传递 311</li>
<li>14.8.4 exports to 312</li>
<li>14.8.5 open和opens 312</li>
<li>14.8.6 uses和provides 313</li>
</ul>
<h4 id="149-通过一个更复杂的例子了解更多-313">
  14.9 通过一个更复杂的例子了解更多 313
  <a class="anchor" href="#149-%e9%80%9a%e8%bf%87%e4%b8%80%e4%b8%aa%e6%9b%b4%e5%a4%8d%e6%9d%82%e7%9a%84%e4%be%8b%e5%ad%90%e4%ba%86%e8%a7%a3%e6%9b%b4%e5%a4%9a-313">#</a>
</h4>
<h4 id="1410-小结-314">
  14.10 小结 314
  <a class="anchor" href="#1410-%e5%b0%8f%e7%bb%93-314">#</a>
</h4>
<h2 id="第五部分-提升java的并发性">
  第五部分 提升Java的并发性
  <a class="anchor" href="#%e7%ac%ac%e4%ba%94%e9%83%a8%e5%88%86-%e6%8f%90%e5%8d%87java%e7%9a%84%e5%b9%b6%e5%8f%91%e6%80%a7">#</a>
</h2>
<h3 id="第15章completablefuture及反应式编程背后的概念316">
  第15章　CompletableFuture及反应式编程背后的概念　　316
  <a class="anchor" href="#%e7%ac%ac15%e7%ab%a0completablefuture%e5%8f%8a%e5%8f%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e8%83%8c%e5%90%8e%e7%9a%84%e6%a6%82%e5%bf%b5316">#</a>
</h3>
<h4 id="151-为支持并发而不断演进的java-318">
  15.1 为支持并发而不断演进的Java 318
  <a class="anchor" href="#151-%e4%b8%ba%e6%94%af%e6%8c%81%e5%b9%b6%e5%8f%91%e8%80%8c%e4%b8%8d%e6%96%ad%e6%bc%94%e8%bf%9b%e7%9a%84java-318">#</a>
</h4>
<ul>
<li>15.1.1 线程以及更高层的抽象 319</li>
<li>15.1.2 执行器和线程池 320</li>
<li>15.1.3 其他的线程抽象：非嵌套方法调用 322</li>
<li>15.1.4 你希望线程为你带来什么 324</li>
</ul>
<h4 id="152-同步及异步api-324">
  15.2 同步及异步API 324
  <a class="anchor" href="#152-%e5%90%8c%e6%ad%a5%e5%8f%8a%e5%bc%82%e6%ad%a5api-324">#</a>
</h4>
<ul>
<li>15.2.1 Future风格的API 326</li>
<li>15.2.2 反应式风格的API 327</li>
<li>15.2.3 有害的睡眠及其他阻塞式操作 328</li>
<li>15.2.4 实战验证 329</li>
<li>15.2.5 如何使用异步API进行异常处理 330</li>
</ul>
<h4 id="153-线框管道模型-331">
  15.3 “线框–管道”模型 331
  <a class="anchor" href="#153-%e7%ba%bf%e6%a1%86%e7%ae%a1%e9%81%93%e6%a8%a1%e5%9e%8b-331">#</a>
</h4>
<h4 id="154-为并发而生的completablefuture和结合器-332">
  15.4 为并发而生的CompletableFuture和结合器 332
  <a class="anchor" href="#154-%e4%b8%ba%e5%b9%b6%e5%8f%91%e8%80%8c%e7%94%9f%e7%9a%84completablefuture%e5%92%8c%e7%bb%93%e5%90%88%e5%99%a8-332">#</a>
</h4>
<h4 id="155-发布订阅以及反应式编程-335">
  15.5 “发布–订阅”以及反应式编程 335
  <a class="anchor" href="#155-%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%e4%bb%a5%e5%8f%8a%e5%8f%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b-335">#</a>
</h4>
<ul>
<li>15.5.1 示例：对两个流求和 337</li>
<li>15.5.2 背压 341</li>
<li>15.5.3 一种简单的真实背压 341</li>
</ul>
<h4 id="156-反应式系统和反应式编程-342">
  15.6 反应式系统和反应式编程 342
  <a class="anchor" href="#156-%e5%8f%8d%e5%ba%94%e5%bc%8f%e7%b3%bb%e7%bb%9f%e5%92%8c%e5%8f%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b-342">#</a>
</h4>
<h4 id="157-路线图-342">
  15.7 路线图 342
  <a class="anchor" href="#157-%e8%b7%af%e7%ba%bf%e5%9b%be-342">#</a>
</h4>
<h4 id="158-小结-343">
  15.8 小结 343
  <a class="anchor" href="#158-%e5%b0%8f%e7%bb%93-343">#</a>
</h4>
<h3 id="第16章completablefuture组合式异步编程344">
  第16章　CompletableFuture：组合式异步编程　　344
  <a class="anchor" href="#%e7%ac%ac16%e7%ab%a0completablefuture%e7%bb%84%e5%90%88%e5%bc%8f%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b344">#</a>
</h3>
<h4 id="161-future接口-344">
  16.1 Future接口 344
  <a class="anchor" href="#161-future%e6%8e%a5%e5%8f%a3-344">#</a>
</h4>
<ul>
<li>16.1.1 Future接口的局限性 346</li>
<li>16.1.2 使用CompletableFuture构建异步应用 346</li>
</ul>
<h4 id="162-实现异步api-347">
  16.2 实现异步API 347
  <a class="anchor" href="#162-%e5%ae%9e%e7%8e%b0%e5%bc%82%e6%ad%a5api-347">#</a>
</h4>
<ul>
<li>16.2.1 将同步方法转换为异步方法 348</li>
<li>16.2.2 错误处理 350</li>
</ul>
<h4 id="163-让你的代码免受阻塞之苦-352">
  16.3 让你的代码免受阻塞之苦 352
  <a class="anchor" href="#163-%e8%ae%a9%e4%bd%a0%e7%9a%84%e4%bb%a3%e7%a0%81%e5%85%8d%e5%8f%97%e9%98%bb%e5%a1%9e%e4%b9%8b%e8%8b%a6-352">#</a>
</h4>
<ul>
<li>16.3.1 使用并行流对请求进行并行操作 353</li>
<li>16.3.2 使用CompletableFuture发起异步请求 353</li>
<li>16.3.3 寻找更好的方案 355</li>
<li>16.3.4 使用定制的执行器 356</li>
</ul>
<h4 id="164-对多个异步任务进行流水线操作-358">
  16.4 对多个异步任务进行流水线操作 358
  <a class="anchor" href="#164-%e5%af%b9%e5%a4%9a%e4%b8%aa%e5%bc%82%e6%ad%a5%e4%bb%bb%e5%8a%a1%e8%bf%9b%e8%a1%8c%e6%b5%81%e6%b0%b4%e7%ba%bf%e6%93%8d%e4%bd%9c-358">#</a>
</h4>
<ul>
<li>16.4.1 实现折扣服务 358</li>
<li>16.4.2 使用Discount服务 359</li>
<li>16.4.3 构造同步和异步操作 360</li>
<li>16.4.4 将两个CompletableFuture对象整合起来，无论它们是否存在依赖 363</li>
<li>16.4.5 对Future和Completable-Future 的回顾 364</li>
<li>16.4.6 高效地使用超时机制 365</li>
</ul>
<h4 id="165-响应completablefuture的completion事件-366">
  16.5 响应CompletableFuture的completion事件 366
  <a class="anchor" href="#165-%e5%93%8d%e5%ba%94completablefuture%e7%9a%84completion%e4%ba%8b%e4%bb%b6-366">#</a>
</h4>
<ul>
<li>16.5.1 对最佳价格查询器应用的优化 367</li>
<li>16.5.2 付诸实践 368</li>
</ul>
<h4 id="166-路线图-369">
  16.6 路线图 369
  <a class="anchor" href="#166-%e8%b7%af%e7%ba%bf%e5%9b%be-369">#</a>
</h4>
<h4 id="167-小结-369">
  16.7 小结 369
  <a class="anchor" href="#167-%e5%b0%8f%e7%bb%93-369">#</a>
</h4>
<h3 id="第17章反应式编程370">
  第17章　反应式编程　　370
  <a class="anchor" href="#%e7%ac%ac17%e7%ab%a0%e5%8f%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b370">#</a>
</h3>
<h4 id="171-反应式宣言-371">
  17.1 反应式宣言 371
  <a class="anchor" href="#171-%e5%8f%8d%e5%ba%94%e5%bc%8f%e5%ae%a3%e8%a8%80-371">#</a>
</h4>
<ul>
<li>17.1.1 应用层的反应式编程 371</li>
<li>17.1.2 反应式系统 373</li>
</ul>
<h4 id="172-反应式流以及flow-api-373">
  17.2 反应式流以及Flow API 373
  <a class="anchor" href="#172-%e5%8f%8d%e5%ba%94%e5%bc%8f%e6%b5%81%e4%bb%a5%e5%8f%8aflow-api-373">#</a>
</h4>
<ul>
<li>17.2.1 Flow类 374</li>
<li>17.2.2 创建你的第一个反应式应用 377</li>
<li>17.2.3 使用Processor转换数据 381</li>
<li>17.2.4 为什么Java并未提供Flow API的实现 383</li>
</ul>
<h4 id="173-使用反应式库rxjava-384">
  17.3 使用反应式库RxJava 384
  <a class="anchor" href="#173-%e4%bd%bf%e7%94%a8%e5%8f%8d%e5%ba%94%e5%bc%8f%e5%ba%93rxjava-384">#</a>
</h4>
<ul>
<li>17.3.1 创建和使用Observable 385</li>
<li>17.3.2 转换及整合多个Observable 392</li>
</ul>
<h2 id="第六部分-函数式编程以及java未来的演进">
  第六部分 函数式编程以及Java未来的演进
  <a class="anchor" href="#%e7%ac%ac%e5%85%ad%e9%83%a8%e5%88%86-%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e4%bb%a5%e5%8f%8ajava%e6%9c%aa%e6%9d%a5%e7%9a%84%e6%bc%94%e8%bf%9b">#</a>
</h2>
<h3 id="第18章函数式的思考396">
  第18章　函数式的思考　　396
  <a class="anchor" href="#%e7%ac%ac18%e7%ab%a0%e5%87%bd%e6%95%b0%e5%bc%8f%e7%9a%84%e6%80%9d%e8%80%83396">#</a>
</h3>
<h4 id="181-实现和维护系统-396">
  18.1 实现和维护系统 396
  <a class="anchor" href="#181-%e5%ae%9e%e7%8e%b0%e5%92%8c%e7%bb%b4%e6%8a%a4%e7%b3%bb%e7%bb%9f-396">#</a>
</h4>
<ul>
<li>18.1.1 共享的可变数据 397</li>
<li>18.1.2 声明式编程 398</li>
<li>18.1.3 为什么要采用函数式编程 399</li>
</ul>
<h4 id="182-什么是函数式编程-399">
  18.2 什么是函数式编程 399
  <a class="anchor" href="#182-%e4%bb%80%e4%b9%88%e6%98%af%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b-399">#</a>
</h4>
<ul>
<li>18.2.1 函数式Java编程 400</li>
<li>18.2.2 引用透明性 402</li>
<li>18.2.3 面向对象的编程和函数式编程的对比 402</li>
<li>18.2.4 函数式编程实战 403</li>
</ul>
<h4 id="183-递归和迭代-405">
  18.3 递归和迭代 405
  <a class="anchor" href="#183-%e9%80%92%e5%bd%92%e5%92%8c%e8%bf%ad%e4%bb%a3-405">#</a>
</h4>
<h4 id="184-小结-408">
  18.4 小结 408
  <a class="anchor" href="#184-%e5%b0%8f%e7%bb%93-408">#</a>
</h4>
<h3 id="第19章函数式编程的技巧409">
  第19章　函数式编程的技巧　　409
  <a class="anchor" href="#%e7%ac%ac19%e7%ab%a0%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e7%9a%84%e6%8a%80%e5%b7%a7409">#</a>
</h3>
<h4 id="191-无处不在的函数-409">
  19.1 无处不在的函数 409
  <a class="anchor" href="#191-%e6%97%a0%e5%a4%84%e4%b8%8d%e5%9c%a8%e7%9a%84%e5%87%bd%e6%95%b0-409">#</a>
</h4>
<ul>
<li>19.1.1 高阶函数 410</li>
<li>19.1.2 柯里化 411</li>
</ul>
<h4 id="192-持久化数据结构-412">
  19.2 持久化数据结构 412
  <a class="anchor" href="#192-%e6%8c%81%e4%b9%85%e5%8c%96%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-412">#</a>
</h4>
<ul>
<li>19.2.1 破坏式更新和函数式更新的比较 413</li>
<li>19.2.2 另一个使用Tree的例子 415</li>
<li>19.2.3 采用函数式的方法 416</li>
</ul>
<h4 id="193-stream的延迟计算-418">
  19.3 Stream的延迟计算 418
  <a class="anchor" href="#193-stream%e7%9a%84%e5%bb%b6%e8%bf%9f%e8%ae%a1%e7%ae%97-418">#</a>
</h4>
<ul>
<li>19.3.1 自定义的Stream 418</li>
<li>19.3.2 创建你自己的延迟列表 420</li>
</ul>
<h4 id="194-模式匹配-425">
  19.4 模式匹配 425
  <a class="anchor" href="#194-%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d-425">#</a>
</h4>
<ul>
<li>19.4.1 访问者模式 425</li>
<li>19.4.2 用模式匹配力挽狂澜 426</li>
</ul>
<h4 id="195-杂项-429">
  19.5 杂项 429
  <a class="anchor" href="#195-%e6%9d%82%e9%a1%b9-429">#</a>
</h4>
<ul>
<li>19.5.1 缓存或记忆表 429</li>
<li>19.5.2 “返回同样的对象”意味着什么 430</li>
<li>19.5.3 结合器 431</li>
</ul>
<h4 id="196-小结-432">
  19.6 小结 432
  <a class="anchor" href="#196-%e5%b0%8f%e7%bb%93-432">#</a>
</h4>
<h3 id="第20章面向对象和函数式编程的混合java和scala的比较433">
  第20章　面向对象和函数式编程的混合：Java和Scala的比较　　433
  <a class="anchor" href="#%e7%ac%ac20%e7%ab%a0%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e5%92%8c%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e7%9a%84%e6%b7%b7%e5%90%88java%e5%92%8cscala%e7%9a%84%e6%af%94%e8%be%83433">#</a>
</h3>
<h4 id="201-scala简介-434">
  20.1 Scala简介 434
  <a class="anchor" href="#201-scala%e7%ae%80%e4%bb%8b-434">#</a>
</h4>
<ul>
<li>20.1.1 你好，啤酒 434</li>
<li>20.1.2 基础数据结构：List、Set、Map、Tuple、Stream以及Option 436</li>
</ul>
<h4 id="202-函数-440">
  20.2 函数 440
  <a class="anchor" href="#202-%e5%87%bd%e6%95%b0-440">#</a>
</h4>
<ul>
<li>20.2.1 Scala中的一等函数 441</li>
<li>20.2.2 匿名函数和闭包 442</li>
<li>20.2.3 柯里化 443</li>
</ul>
<h4 id="203-类和trait-444">
  20.3 类和trait 444
  <a class="anchor" href="#203-%e7%b1%bb%e5%92%8ctrait-444">#</a>
</h4>
<ul>
<li>20.3.1 更加简洁的Scala类 445</li>
<li>20.3.2 Scala的trait与Java 8的接口对比 446</li>
</ul>
<h4 id="204-小结-447">
  20.4 小结 447
  <a class="anchor" href="#204-%e5%b0%8f%e7%bb%93-447">#</a>
</h4>
<h3 id="第21章结论以及java的未来448">
  第21章　结论以及Java的未来　　448
  <a class="anchor" href="#%e7%ac%ac21%e7%ab%a0%e7%bb%93%e8%ae%ba%e4%bb%a5%e5%8f%8ajava%e7%9a%84%e6%9c%aa%e6%9d%a5448">#</a>
</h3>
<h4 id="211-回顾java-8的语言特性-448">
  21.1 回顾Java 8的语言特性 448
  <a class="anchor" href="#211-%e5%9b%9e%e9%a1%bejava-8%e7%9a%84%e8%af%ad%e8%a8%80%e7%89%b9%e6%80%a7-448">#</a>
</h4>
<ul>
<li>21.1.1 行为参数化（Lambda以及方法引用） 449</li>
<li>21.1.2 流 449</li>
<li>21.1.3 CompletableFuture 450</li>
<li>21.1.4 Optional 450</li>
<li>21.1.5 Flow API 451</li>
<li>21.1.6 默认方法 451</li>
</ul>
<h4 id="212-java-9的模块系统-451">
  21.2 Java 9的模块系统 451
  <a class="anchor" href="#212-java-9%e7%9a%84%e6%a8%a1%e5%9d%97%e7%b3%bb%e7%bb%9f-451">#</a>
</h4>
<h4 id="213-java-10的局部变量类型推断-453">
  21.3 Java 10的局部变量类型推断 453
  <a class="anchor" href="#213-java-10%e7%9a%84%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%ad-453">#</a>
</h4>
<h4 id="214-java的未来-454">
  21.4 Java的未来 454
  <a class="anchor" href="#214-java%e7%9a%84%e6%9c%aa%e6%9d%a5-454">#</a>
</h4>
<ul>
<li>21.4.1 声明处型变 454</li>
<li>21.4.2 模式匹配 454</li>
<li>21.4.3 更加丰富的泛型形式 455</li>
<li>21.4.4 对不变性的更深层支持 457</li>
<li>21.4.5 值类型 458</li>
</ul>
<h4 id="215-让java发展得更快-461">
  21.5 让Java发展得更快 461
  <a class="anchor" href="#215-%e8%ae%a9java%e5%8f%91%e5%b1%95%e5%be%97%e6%9b%b4%e5%bf%ab-461">#</a>
</h4>
<h4 id="216-写在最后的话-462">
  21.6 写在最后的话 462
  <a class="anchor" href="#216-%e5%86%99%e5%9c%a8%e6%9c%80%e5%90%8e%e7%9a%84%e8%af%9d-462">#</a>
</h4>
<ul>
<li>附录A 其他语言特性的更新 463</li>
<li>附录B 其他类库的更新 467</li>
<li>附录C 如何以并发方式在同一个流上执行多种操作 475</li>
<li>附录D Lambda表达式和JVM字节码 483</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第一部分-基础知识">第一部分 基础知识</a>
      <ul>
        <li><a href="#第1章java-8910以及11的变化2">第1章　Java 8、9、10以及11的变化　　2</a>
          <ul>
            <li><a href="#11-为什么要关心java的变化-2">1.1 为什么要关心Java的变化 2</a></li>
            <li><a href="#12-java怎么还在变-4">1.2 Java怎么还在变 4</a></li>
            <li><a href="#13-java中的函数-9">1.3 Java中的函数 9</a></li>
            <li><a href="#14-流-14">1.4 流 14</a></li>
            <li><a href="#15-默认方法及java模块-17">1.5 默认方法及Java模块 17</a></li>
            <li><a href="#16-来自函数式编程的其他好思想-19">1.6 来自函数式编程的其他好思想 19</a></li>
            <li><a href="#17-小结-20">1.7 小结 20</a></li>
          </ul>
        </li>
        <li><a href="#第2章通过行为参数化传递代码22">第2章　通过行为参数化传递代码　　22</a>
          <ul>
            <li><a href="#21-应对不断变化的需求-23">2.1 应对不断变化的需求 23</a></li>
            <li><a href="#22-行为参数化-25">2.2 行为参数化 25</a></li>
            <li><a href="#23-对付啰唆-30">2.3 对付啰唆 30</a></li>
            <li><a href="#24-真实的例子-33">2.4 真实的例子 33</a></li>
            <li><a href="#25-小结-36">2.5 小结 36</a></li>
          </ul>
        </li>
        <li><a href="#第3章lambda表达式37">第3章　Lambda表达式　　37</a>
          <ul>
            <li><a href="#31-lambda管中窥豹-37">3.1 Lambda管中窥豹 37</a></li>
            <li><a href="#32-在哪里以及如何使用lambda-40">3.2 在哪里以及如何使用Lambda 40</a></li>
            <li><a href="#33-把lambda付诸实践环绕执行模式-44">3.3 把Lambda付诸实践：环绕执行模式 44</a></li>
            <li><a href="#34-使用函数式接口-47">3.4 使用函数式接口 47</a></li>
            <li><a href="#35-类型检查类型推断以及限制-52">3.5 类型检查、类型推断以及限制 52</a></li>
            <li><a href="#36-方法引用-57">3.6 方法引用 57</a></li>
            <li><a href="#37-lambda和方法引用实战-62">3.7 Lambda和方法引用实战 62</a></li>
            <li><a href="#38-复合lambda表达式的有用方法-63">3.8 复合Lambda表达式的有用方法 63</a></li>
            <li><a href="#39-数学中的类似思想-66">3.9 数学中的类似思想 66</a></li>
            <li><a href="#310-小结-68">3.10 小结 68</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第二部分-使用流进行函数式数据处理">第二部分 使用流进行函数式数据处理</a>
      <ul>
        <li><a href="#第4章引入流72">第4章　引入流　　72</a>
          <ul>
            <li><a href="#41-流是什么-72">4.1 流是什么 72</a></li>
            <li><a href="#42-流简介-76">4.2 流简介 76</a></li>
            <li><a href="#43-流与集合-78">4.3 流与集合 78</a></li>
            <li><a href="#44-流操作-82">4.4 流操作 82</a></li>
            <li><a href="#45-路线图-85">4.5 路线图 85</a></li>
            <li><a href="#46-小结-85">4.6 小结 85</a></li>
          </ul>
        </li>
        <li><a href="#第5章使用流86">第5章　使用流　　86</a>
          <ul>
            <li><a href="#51-筛选-87">5.1 筛选 87</a></li>
            <li><a href="#52-流的切片-88">5.2 流的切片 88</a></li>
            <li><a href="#53-映射-91">5.3 映射 91</a></li>
            <li><a href="#54-查找和匹配-95">5.4 查找和匹配 95</a></li>
            <li><a href="#55-归约-98">5.5 归约 98</a></li>
            <li><a href="#56-付诸实践-103">5.6 付诸实践 103</a></li>
            <li><a href="#57-数值流-106">5.7 数值流 106</a></li>
            <li><a href="#58-构建流-111">5.8 构建流 111</a></li>
            <li><a href="#59-概述-116">5.9 概述 116</a></li>
            <li><a href="#510-小结-116">5.10 小结 116</a></li>
          </ul>
        </li>
        <li><a href="#第6章用流收集数据118">第6章　用流收集数据　　118</a>
          <ul>
            <li><a href="#61-收集器简介-119">6.1 收集器简介 119</a></li>
            <li><a href="#62-归约和汇总-121">6.2 归约和汇总 121</a></li>
            <li><a href="#63-分组-127">6.3 分组 127</a></li>
            <li><a href="#64-分区-134">6.4 分区 134</a></li>
            <li><a href="#65-收集器接口-138">6.5 收集器接口 138</a></li>
            <li><a href="#66-开发你自己的收集器以获得更好的性能-144">6.6 开发你自己的收集器以获得更好的性能 144</a></li>
            <li><a href="#67-小结-150">6.7 小结 150</a></li>
          </ul>
        </li>
        <li><a href="#第7章并行数据处理与性能151">第7章　并行数据处理与性能　　151</a>
          <ul>
            <li><a href="#71-并行流-152">7.1 并行流 152</a></li>
            <li><a href="#72-分支合并框架-161">7.2 分支/合并框架 161</a></li>
            <li><a href="#73-spliterator-166">7.3 Spliterator 166</a></li>
            <li><a href="#74-小结-173">7.4 小结 173</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第三部分-使用流和lambda进行高效编程">第三部分 使用流和Lambda进行高效编程</a>
      <ul>
        <li><a href="#第8章collection-api的增强功能176">第8章　Collection API的增强功能　　176</a>
          <ul>
            <li><a href="#81-集合工厂-176">8.1 集合工厂 176</a></li>
            <li><a href="#82-使用list和set-180">8.2 使用List和Set 180</a></li>
            <li><a href="#83-使用map-181">8.3 使用Map 181</a></li>
            <li><a href="#84-改进的concurrenthashmap-187">8.4 改进的ConcurrentHashMap 187</a></li>
            <li><a href="#85-小结-188">8.5 小结 188</a></li>
          </ul>
        </li>
        <li><a href="#第9章重构测试和调试189">第9章　重构、测试和调试　　189</a>
          <ul>
            <li><a href="#91-为改善可读性和灵活性重构代码-189">9.1 为改善可读性和灵活性重构代码 189</a></li>
            <li><a href="#92-使用lambda重构面向对象的设计模式-195">9.2 使用Lambda重构面向对象的设计模式 195</a></li>
            <li><a href="#93-测试lambda表达式-204">9.3 测试Lambda表达式 204</a></li>
            <li><a href="#94-调试-206">9.4 调试 206</a></li>
            <li><a href="#95-小结-209">9.5 小结 209</a></li>
          </ul>
        </li>
        <li><a href="#第10章基于lambda的领域特定语言210">第10章　基于Lambda的领域特定语言　　210</a>
          <ul>
            <li><a href="#101-领域特定语言-212">10.1 领域特定语言 212</a></li>
            <li><a href="#102-现代java-api中的小型dsl-217">10.2 现代Java API中的小型DSL 217</a></li>
            <li><a href="#103-使用java创建dsl的模式与技巧-221">10.3 使用Java创建DSL的模式与技巧 221</a></li>
            <li><a href="#104-java-8-dsl的实际应用-234">10.4 Java 8 DSL的实际应用 234</a></li>
            <li><a href="#105-小结-239">10.5 小结 239</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第四部分-无所不在的java">第四部分 无所不在的Java</a>
      <ul>
        <li><a href="#第11章用optional取代null242">第11章　用Optional取代null　　242</a>
          <ul>
            <li><a href="#111-如何为缺失的值建模-243">11.1 如何为缺失的值建模 243</a></li>
            <li><a href="#112-optional类入门-246">11.2 Optional类入门 246</a></li>
            <li><a href="#113-应用optional的几种模式-248">11.3 应用Optional的几种模式 248</a></li>
            <li><a href="#114-使用optional的实战示例-258">11.4 使用Optional的实战示例 258</a></li>
            <li><a href="#115-小结-262">11.5 小结 262</a></li>
          </ul>
        </li>
        <li><a href="#第12章新的日期和时间api263">第12章　新的日期和时间API　　263</a>
          <ul>
            <li><a href="#121-localdatelocaltimelocaldatetimeinstantduration以及period-264">12.1 LocalDate、LocalTime、LocalDateTime、Instant、Duration以及Period 264</a></li>
            <li><a href="#122-操纵解析和格式化日期-268">12.2 操纵、解析和格式化日期 268</a></li>
            <li><a href="#123-处理不同的时区和历法-274">12.3 处理不同的时区和历法 274</a></li>
            <li><a href="#124-小结-277">12.4 小结 277</a></li>
          </ul>
        </li>
        <li><a href="#第13章默认方法278">第13章　默认方法　　278</a>
          <ul>
            <li><a href="#131-不断演进的api-280">13.1 不断演进的API 280</a></li>
            <li><a href="#132-概述默认方法-283">13.2 概述默认方法 283</a></li>
            <li><a href="#133-默认方法的使用模式-285">13.3 默认方法的使用模式 285</a></li>
            <li><a href="#134-解决冲突的规则-289">13.4 解决冲突的规则 289</a></li>
            <li><a href="#135-小结-294">13.5 小结 294</a></li>
          </ul>
        </li>
        <li><a href="#第14章java模块系统295">第14章　Java模块系统　　295</a>
          <ul>
            <li><a href="#141-模块化的驱动力软件的推理-295">14.1 模块化的驱动力：软件的推理 295</a></li>
            <li><a href="#142-为什么要设计java模块系统-297">14.2 为什么要设计Java模块系统 297</a></li>
            <li><a href="#143-java模块全局视图-300">14.3 Java模块：全局视图 300</a></li>
            <li><a href="#144-使用java模块系统开发应用-301">14.4 使用Java模块系统开发应用 301</a></li>
            <li><a href="#145-使用多个模块-304">14.5 使用多个模块 304</a></li>
            <li><a href="#146-编译及打包-306">14.6 编译及打包 306</a></li>
            <li><a href="#147-自动模块-310">14.7 自动模块 310</a></li>
            <li><a href="#148-模块声明及子句-311">14.8 模块声明及子句 311</a></li>
            <li><a href="#149-通过一个更复杂的例子了解更多-313">14.9 通过一个更复杂的例子了解更多 313</a></li>
            <li><a href="#1410-小结-314">14.10 小结 314</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第五部分-提升java的并发性">第五部分 提升Java的并发性</a>
      <ul>
        <li><a href="#第15章completablefuture及反应式编程背后的概念316">第15章　CompletableFuture及反应式编程背后的概念　　316</a>
          <ul>
            <li><a href="#151-为支持并发而不断演进的java-318">15.1 为支持并发而不断演进的Java 318</a></li>
            <li><a href="#152-同步及异步api-324">15.2 同步及异步API 324</a></li>
            <li><a href="#153-线框管道模型-331">15.3 “线框–管道”模型 331</a></li>
            <li><a href="#154-为并发而生的completablefuture和结合器-332">15.4 为并发而生的CompletableFuture和结合器 332</a></li>
            <li><a href="#155-发布订阅以及反应式编程-335">15.5 “发布–订阅”以及反应式编程 335</a></li>
            <li><a href="#156-反应式系统和反应式编程-342">15.6 反应式系统和反应式编程 342</a></li>
            <li><a href="#157-路线图-342">15.7 路线图 342</a></li>
            <li><a href="#158-小结-343">15.8 小结 343</a></li>
          </ul>
        </li>
        <li><a href="#第16章completablefuture组合式异步编程344">第16章　CompletableFuture：组合式异步编程　　344</a>
          <ul>
            <li><a href="#161-future接口-344">16.1 Future接口 344</a></li>
            <li><a href="#162-实现异步api-347">16.2 实现异步API 347</a></li>
            <li><a href="#163-让你的代码免受阻塞之苦-352">16.3 让你的代码免受阻塞之苦 352</a></li>
            <li><a href="#164-对多个异步任务进行流水线操作-358">16.4 对多个异步任务进行流水线操作 358</a></li>
            <li><a href="#165-响应completablefuture的completion事件-366">16.5 响应CompletableFuture的completion事件 366</a></li>
            <li><a href="#166-路线图-369">16.6 路线图 369</a></li>
            <li><a href="#167-小结-369">16.7 小结 369</a></li>
          </ul>
        </li>
        <li><a href="#第17章反应式编程370">第17章　反应式编程　　370</a>
          <ul>
            <li><a href="#171-反应式宣言-371">17.1 反应式宣言 371</a></li>
            <li><a href="#172-反应式流以及flow-api-373">17.2 反应式流以及Flow API 373</a></li>
            <li><a href="#173-使用反应式库rxjava-384">17.3 使用反应式库RxJava 384</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第六部分-函数式编程以及java未来的演进">第六部分 函数式编程以及Java未来的演进</a>
      <ul>
        <li><a href="#第18章函数式的思考396">第18章　函数式的思考　　396</a>
          <ul>
            <li><a href="#181-实现和维护系统-396">18.1 实现和维护系统 396</a></li>
            <li><a href="#182-什么是函数式编程-399">18.2 什么是函数式编程 399</a></li>
            <li><a href="#183-递归和迭代-405">18.3 递归和迭代 405</a></li>
            <li><a href="#184-小结-408">18.4 小结 408</a></li>
          </ul>
        </li>
        <li><a href="#第19章函数式编程的技巧409">第19章　函数式编程的技巧　　409</a>
          <ul>
            <li><a href="#191-无处不在的函数-409">19.1 无处不在的函数 409</a></li>
            <li><a href="#192-持久化数据结构-412">19.2 持久化数据结构 412</a></li>
            <li><a href="#193-stream的延迟计算-418">19.3 Stream的延迟计算 418</a></li>
            <li><a href="#194-模式匹配-425">19.4 模式匹配 425</a></li>
            <li><a href="#195-杂项-429">19.5 杂项 429</a></li>
            <li><a href="#196-小结-432">19.6 小结 432</a></li>
          </ul>
        </li>
        <li><a href="#第20章面向对象和函数式编程的混合java和scala的比较433">第20章　面向对象和函数式编程的混合：Java和Scala的比较　　433</a>
          <ul>
            <li><a href="#201-scala简介-434">20.1 Scala简介 434</a></li>
            <li><a href="#202-函数-440">20.2 函数 440</a></li>
            <li><a href="#203-类和trait-444">20.3 类和trait 444</a></li>
            <li><a href="#204-小结-447">20.4 小结 447</a></li>
          </ul>
        </li>
        <li><a href="#第21章结论以及java的未来448">第21章　结论以及Java的未来　　448</a>
          <ul>
            <li><a href="#211-回顾java-8的语言特性-448">21.1 回顾Java 8的语言特性 448</a></li>
            <li><a href="#212-java-9的模块系统-451">21.2 Java 9的模块系统 451</a></li>
            <li><a href="#213-java-10的局部变量类型推断-453">21.3 Java 10的局部变量类型推断 453</a></li>
            <li><a href="#214-java的未来-454">21.4 Java的未来 454</a></li>
            <li><a href="#215-让java发展得更快-461">21.5 让Java发展得更快 461</a></li>
            <li><a href="#216-写在最后的话-462">21.6 写在最后的话 462</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












