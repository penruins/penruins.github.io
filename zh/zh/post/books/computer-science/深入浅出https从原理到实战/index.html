<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
2015年百度搜索引擎完成其历史上最大的系统性升级——全面由HTTP升级到HTTPS
2016年苹果公告要求App Store中的所有应用在2017年1月1日之后都必须使用HTTPS加密连接
2017年1月9日微信上线小程序后，要求开发者的所有服务端请求必须为HTTPS
同时Google已调整搜索引擎算法，让采用HTTPS的网站在搜索结果中排名更靠前，并宣布从2018年7月开始所有的HTTP网站将标记为“不安全”


  第1章 HTTP介绍
  #


HTTP的特点

客户端/服务器模型

客户端和服务器是否正确传输依赖于TCP这个协议。


HTTP是无状态的

所谓的无状态就是每次请求完成后，不会在客户端和服务器上保存任何的信息，对于客户端和服务器来说，根本不知道上一次请求的信息是什么，甚至不知道本次连接的对端是不是上次连接的那一端，它的生命周期随着TCP/IP连接的关闭结束了
无状态的设计已经不能适应新的情况，为了保持状态，出现了Cookie和Session技术，但是Cookie技术设计得非常不严谨，引发了很多安全问题。
介绍下Cookie是如何进行会话保持的，客户端第一次请求完成后，服务器会发送Cookie信息到客户端的计算机上，客户端下次请求的时候会携带该Cookie信息，这样服务器就知道该用户就是上一次请求的用户了。


HTTP是跨平台的

通过上面的讲解，读者知道HTTP就是具备一定规则的纯文本信息，任何开发语言都可以实现HTTP或者基于HTTP进行开发，开发出来的软件也很容易移植，受系统环境的影响非常少。


HTTP用途很广泛




  1.3 网络模型
  #


HTTP是应用层协议，应用层协议是TCP/IP的一部分
OSI模型是一个通用的网络协议标准，但实际使用的标准却是TCP/IP标准，TCP/IP包含的不仅仅是TCP或者IP，它是一个协议族，网络应用开发都需要掌握TCP/IP。
TCP/IP有两个最大的特点，分别是分层和封包/拆包机制
每一层和它的上下层都有标准的接口规范，每一层无须关心上下层是如何工作的，它只关心上下层是否正确基于规范实现了接口
应用层

如果没有应用层，那么网络中传输的数据没有任何意义，因为人类无法理解数据的含义。而有了应用层，软件就能解释应用层数据的含义。在Web应用中，有了HTTP和HTML标准，浏览器才能呈现对用户有意义的内容。
应用层协议有很多，比如HTTP、FTP、邮件协议，开发者开发的软件一般都是应用层协议软件。


传输层
网络层

网络层主要是IP这个协议，客户端和服务器传输的时候，会经过很多节点，IP就是选择一条最优的路径。每个终端上都有一张路由表，路由表负责将数据传输到下一个节点，下一个节点再传输到下下个节点，最终到达目的地址。


链路层

应用层、传输层、网络层都是虚拟的，只有链路层才是实体设备，包括光纤、网卡等设备。基于这些设备，数据最终才能到达终端。


接下来简单描述封包/拆包机制，对于客户端请求来说，传输层接收到应用层消息后，在HTTP数据包前面增加TCP包头，然后发送给网络层；网络层在TCP数据包前面加上IP包头发送给链路层；链路层在IP数据包前面加上以太网包头；最终服务器接收到完整的数据包。
然后服务器进行拆包：首先在网络层去除链路层包头；在传输层去除IP包头；在应用层去除TCP包头；最终得到完整的HTTP应用层数据。


  1.4 协议安全分析
  #


协议不安全的根本原因

数据没有加密
无法验证身份
数据易篡改




  第2章 密码学
  #


  2.1 对于密码学的认知
  #


OpenSSL

OpenSSL命令行功能非常强大，有很多的子命令和参数，如果不理解密码学算法，根本无法理解子命令和参数的含义，这是难学习的根本原因，也说明学习OpenSSL之前必须先掌握密码学算法。
不同版本的OpenSSL命令行工具在使用的时候有一些差别，同样一条命令，读者会发现在特定版本下可能无法正确运行。
OpenSSL命令行的帮助手册和文档描写得不是很通俗，很难进行系统的学习。
完成同样一个操作，OpenSSL命令行有许多方法实现，这可能会干扰读者的学习。




  2.2 随机数
  #


而对于PRNG来说，内部状态的数值来自于模拟的数值，称为种子（seed）。随机数生成器每次生成随机数的时候，内部状态的值都会变化，这样才能产生不一样的随机数，如果每次熵和种子是一样的，生成的随机数也是相同的，所以熵和种子对于随机数生成器非常重要。


  2.3 Hash算法
  #


由于Hash算法有很多功能，所以Hash算法有多种称呼，比如摘要算法（Message Digest Algorithms）、单向散列函数（Cryptographic One-way Hash Functions）。输出值也有多种称呼，比如摘要值、散列、指纹。读者看到这些名词的时候，都可以理解为Hash算法
密码学Hash算法的主要特性

相同的消息总是能得到同样的摘要值，特定的Hash算法，不管消息长度是多少，最终的摘要值长度是相同的。
不管多长的消息，Hash运算非常快速，这是非常重要的特性。
通过摘要值很难逆向计算出原始消息，Hash算法具备单向性，摘要值是不可逆的，这也是非常重要的特性。为了逆向计算出原始消息，唯一的方法就是采用暴力攻击、字典攻击、彩虹表，对不同的消息组合进行迭代运算，运算的结果如果匹配该消息的摘要值，表示该Hash算法不应该用于密码学。
原始消息一旦修改，即使是很轻微的修改，最终的摘要值也会产生变化。
很难找出两个不同的消息，并且它们的摘要值是相同的。


Hash算法的用途

文件比较
身份校验


密码学Hash算法的分类

MD5

MD5是一种比较常用的Hash算法，摘要值长度固定是128比特，MD5算法目前被证明已经不安全了，MD5算法违反了强抗碰撞性原则，但是还没有破坏单一性原则。
理论上经过2^80次运算就能产生碰撞，但目前最快只要经过2^63次运算就能破坏强抗碰撞性。


SHA

SHA（Secure Hash Algorithms）算法是美国国家标准与技术研究院（NIST）指定的算法，SHA算法不是一个算法，而是一组算法，主要分为三类算法。
SHA-1
SHA-2
SHA-3






  2.4 对称加密算法
  #


建议使用AES算法，该算法是对称加密算法的标准算法

美国国家标准与技术研究院（National Institute of Standards and Technology, NIST）对众多的对称加密算法进行了考核，从安全性和效率进行了多方面评测，最终选取Rijndael算法作为对称加密算法的标准。以Rijndael算法为原型，创建了AES（Advanced Encryption Standard）算法，AES就是最终的对称加密算法标准。Rijndael算法和AES算法略微不同，但在理解的时候可以认为是相同的算法。


流密码算法
块密码算法

迭代模式

**ECB模式（Electronic Codebook）**是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。

ECB模式（Electronic Codebook）是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。


**CBC模式（Cipher Block Chaining）**是比较常见的一种迭代模式，解决了ECB模式的安全问题。

迭代运算数据块不能并行处理，只有处理完第n个数据块，才能继续处理第n&#43;1个数据块。


**CTR模式（counter）**在迭代的时候，相当于是一个流密码的运行模式。每次迭代运算的时候要生成一个密钥流（keystream），生成密钥流的方法可以是任意的，但是各个密钥流之间是有关系的，最简单的方式就是密钥流不断递增，所以才叫作计数器模式。






  2.5 消息验证码
  #


MAC值一般和原始消息一起传输，原始消息可以选择加密，也可以选择不加密，通信双方会以相同的方式生成MAC值，然后进行比较
CBC-MAC算法
HMAC算法 Hash-based Message Authentication Code
加密算法不能提供完整性，加密的同时必须引入MAC算法避免消息被篡改
使用者结合对称加密算法和MAC算法，提供机密性和完整性的模式也叫作Authenticated Encryption（AE）加密模式，主要有三种

Encrypt-and-MAC (E&amp;M)
MAC-then-Encrypt (MtE)

这种模式（图2-12）先对消息进行MAC计算，然后将消息和MAC值组合在一起再进行加密，最终的加密值再发送给接收方。在HTTPS中，一般使用这种模式进行处理，比如AES-128-CBC#PKCS7-HMAC-SHA256模式。


Encrypt-then-MAC (EtM)


不管是Encrypt-and-MAC模式还是MAC-then-Encrypt模式，使用不当的话都会存在安全问题，目前建议使用Encrypt-then-MAC模式。需要强调的是，这三种模式使用者必须分别处理，一旦处理不当，就可能会存在安全风险，那有没有一种方法在底层直接提供加密和MAC运算呢？无须使用者分别处理加密和MAC运算，这就是接下来讲解的AEAD模式。
AEAD加密模式

CCM模式
GCM模式
ChaCha20-Poly1305




  hash算法可以作为消息验证码吗？
  #

是的，哈希算法可以作为消息验证码（MAC）的一部分，但单独使用哈希算法并不能直接构成消息验证码。消息验证码（MAC）是一种用于验证消息完整性和真实性的技术，通常需要结合密钥来确保安全性。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="/zh/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/">
  <meta property="og:site_name" content="Penruins">
  <meta property="og:title" content="深入浅出HTTPS：从原理到实战">
  <meta property="og:description" content="2015年百度搜索引擎完成其历史上最大的系统性升级——全面由HTTP升级到HTTPS 2016年苹果公告要求App Store中的所有应用在2017年1月1日之后都必须使用HTTPS加密连接 2017年1月9日微信上线小程序后，要求开发者的所有服务端请求必须为HTTPS 同时Google已调整搜索引擎算法，让采用HTTPS的网站在搜索结果中排名更靠前，并宣布从2018年7月开始所有的HTTP网站将标记为“不安全” 第1章 HTTP介绍 # HTTP的特点 客户端/服务器模型 客户端和服务器是否正确传输依赖于TCP这个协议。 HTTP是无状态的 所谓的无状态就是每次请求完成后，不会在客户端和服务器上保存任何的信息，对于客户端和服务器来说，根本不知道上一次请求的信息是什么，甚至不知道本次连接的对端是不是上次连接的那一端，它的生命周期随着TCP/IP连接的关闭结束了 无状态的设计已经不能适应新的情况，为了保持状态，出现了Cookie和Session技术，但是Cookie技术设计得非常不严谨，引发了很多安全问题。 介绍下Cookie是如何进行会话保持的，客户端第一次请求完成后，服务器会发送Cookie信息到客户端的计算机上，客户端下次请求的时候会携带该Cookie信息，这样服务器就知道该用户就是上一次请求的用户了。 HTTP是跨平台的 通过上面的讲解，读者知道HTTP就是具备一定规则的纯文本信息，任何开发语言都可以实现HTTP或者基于HTTP进行开发，开发出来的软件也很容易移植，受系统环境的影响非常少。 HTTP用途很广泛 1.3 网络模型 # HTTP是应用层协议，应用层协议是TCP/IP的一部分 OSI模型是一个通用的网络协议标准，但实际使用的标准却是TCP/IP标准，TCP/IP包含的不仅仅是TCP或者IP，它是一个协议族，网络应用开发都需要掌握TCP/IP。 TCP/IP有两个最大的特点，分别是分层和封包/拆包机制 每一层和它的上下层都有标准的接口规范，每一层无须关心上下层是如何工作的，它只关心上下层是否正确基于规范实现了接口 应用层 如果没有应用层，那么网络中传输的数据没有任何意义，因为人类无法理解数据的含义。而有了应用层，软件就能解释应用层数据的含义。在Web应用中，有了HTTP和HTML标准，浏览器才能呈现对用户有意义的内容。 应用层协议有很多，比如HTTP、FTP、邮件协议，开发者开发的软件一般都是应用层协议软件。 传输层 网络层 网络层主要是IP这个协议，客户端和服务器传输的时候，会经过很多节点，IP就是选择一条最优的路径。每个终端上都有一张路由表，路由表负责将数据传输到下一个节点，下一个节点再传输到下下个节点，最终到达目的地址。 链路层 应用层、传输层、网络层都是虚拟的，只有链路层才是实体设备，包括光纤、网卡等设备。基于这些设备，数据最终才能到达终端。 接下来简单描述封包/拆包机制，对于客户端请求来说，传输层接收到应用层消息后，在HTTP数据包前面增加TCP包头，然后发送给网络层；网络层在TCP数据包前面加上IP包头发送给链路层；链路层在IP数据包前面加上以太网包头；最终服务器接收到完整的数据包。 然后服务器进行拆包：首先在网络层去除链路层包头；在传输层去除IP包头；在应用层去除TCP包头；最终得到完整的HTTP应用层数据。 1.4 协议安全分析 # 协议不安全的根本原因 数据没有加密 无法验证身份 数据易篡改 第2章 密码学 # 2.1 对于密码学的认知 # OpenSSL OpenSSL命令行功能非常强大，有很多的子命令和参数，如果不理解密码学算法，根本无法理解子命令和参数的含义，这是难学习的根本原因，也说明学习OpenSSL之前必须先掌握密码学算法。 不同版本的OpenSSL命令行工具在使用的时候有一些差别，同样一条命令，读者会发现在特定版本下可能无法正确运行。 OpenSSL命令行的帮助手册和文档描写得不是很通俗，很难进行系统的学习。 完成同样一个操作，OpenSSL命令行有许多方法实现，这可能会干扰读者的学习。 2.2 随机数 # 而对于PRNG来说，内部状态的数值来自于模拟的数值，称为种子（seed）。随机数生成器每次生成随机数的时候，内部状态的值都会变化，这样才能产生不一样的随机数，如果每次熵和种子是一样的，生成的随机数也是相同的，所以熵和种子对于随机数生成器非常重要。 2.3 Hash算法 # 由于Hash算法有很多功能，所以Hash算法有多种称呼，比如摘要算法（Message Digest Algorithms）、单向散列函数（Cryptographic One-way Hash Functions）。输出值也有多种称呼，比如摘要值、散列、指纹。读者看到这些名词的时候，都可以理解为Hash算法 密码学Hash算法的主要特性 相同的消息总是能得到同样的摘要值，特定的Hash算法，不管消息长度是多少，最终的摘要值长度是相同的。 不管多长的消息，Hash运算非常快速，这是非常重要的特性。 通过摘要值很难逆向计算出原始消息，Hash算法具备单向性，摘要值是不可逆的，这也是非常重要的特性。为了逆向计算出原始消息，唯一的方法就是采用暴力攻击、字典攻击、彩虹表，对不同的消息组合进行迭代运算，运算的结果如果匹配该消息的摘要值，表示该Hash算法不应该用于密码学。 原始消息一旦修改，即使是很轻微的修改，最终的摘要值也会产生变化。 很难找出两个不同的消息，并且它们的摘要值是相同的。 Hash算法的用途 文件比较 身份校验 密码学Hash算法的分类 MD5 MD5是一种比较常用的Hash算法，摘要值长度固定是128比特，MD5算法目前被证明已经不安全了，MD5算法违反了强抗碰撞性原则，但是还没有破坏单一性原则。 理论上经过2^80次运算就能产生碰撞，但目前最快只要经过2^63次运算就能破坏强抗碰撞性。 SHA SHA（Secure Hash Algorithms）算法是美国国家标准与技术研究院（NIST）指定的算法，SHA算法不是一个算法，而是一组算法，主要分为三类算法。 SHA-1 SHA-2 SHA-3 2.4 对称加密算法 # 建议使用AES算法，该算法是对称加密算法的标准算法 美国国家标准与技术研究院（National Institute of Standards and Technology, NIST）对众多的对称加密算法进行了考核，从安全性和效率进行了多方面评测，最终选取Rijndael算法作为对称加密算法的标准。以Rijndael算法为原型，创建了AES（Advanced Encryption Standard）算法，AES就是最终的对称加密算法标准。Rijndael算法和AES算法略微不同，但在理解的时候可以认为是相同的算法。 流密码算法 块密码算法 迭代模式 **ECB模式（Electronic Codebook）**是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。 ECB模式（Electronic Codebook）是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。 **CBC模式（Cipher Block Chaining）**是比较常见的一种迭代模式，解决了ECB模式的安全问题。 迭代运算数据块不能并行处理，只有处理完第n个数据块，才能继续处理第n&#43;1个数据块。 **CTR模式（counter）**在迭代的时候，相当于是一个流密码的运行模式。每次迭代运算的时候要生成一个密钥流（keystream），生成密钥流的方法可以是任意的，但是各个密钥流之间是有关系的，最简单的方式就是密钥流不断递增，所以才叫作计数器模式。 2.5 消息验证码 # MAC值一般和原始消息一起传输，原始消息可以选择加密，也可以选择不加密，通信双方会以相同的方式生成MAC值，然后进行比较 CBC-MAC算法 HMAC算法 Hash-based Message Authentication Code 加密算法不能提供完整性，加密的同时必须引入MAC算法避免消息被篡改 使用者结合对称加密算法和MAC算法，提供机密性和完整性的模式也叫作Authenticated Encryption（AE）加密模式，主要有三种 Encrypt-and-MAC (E&amp;M) MAC-then-Encrypt (MtE) 这种模式（图2-12）先对消息进行MAC计算，然后将消息和MAC值组合在一起再进行加密，最终的加密值再发送给接收方。在HTTPS中，一般使用这种模式进行处理，比如AES-128-CBC#PKCS7-HMAC-SHA256模式。 Encrypt-then-MAC (EtM) 不管是Encrypt-and-MAC模式还是MAC-then-Encrypt模式，使用不当的话都会存在安全问题，目前建议使用Encrypt-then-MAC模式。需要强调的是，这三种模式使用者必须分别处理，一旦处理不当，就可能会存在安全风险，那有没有一种方法在底层直接提供加密和MAC运算呢？无须使用者分别处理加密和MAC运算，这就是接下来讲解的AEAD模式。 AEAD加密模式 CCM模式 GCM模式 ChaCha20-Poly1305 hash算法可以作为消息验证码吗？ # 是的，哈希算法可以作为消息验证码（MAC）的一部分，但单独使用哈希算法并不能直接构成消息验证码。消息验证码（MAC）是一种用于验证消息完整性和真实性的技术，通常需要结合密钥来确保安全性。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="zh">
<title>深入浅出HTTPS：从原理到实战 | Penruins</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="/zh/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/">
<link rel="stylesheet" href="/book.min.26e661cf8028ea69ebe162050990c3a07de74e5bfe9389e880f2d6a7e5fa587c.css" >
  <script defer src="/fuse.min.js"></script>
  <script defer src="/zh.search.min.36b3f14524517fa6518b6c52cb829f8945ed108b7a5bc61960da1b583e8cfeb9.js" ></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/zh/"><span>Penruins</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>



  



  
    
  
    
  



<ul class="book-languages">
  <li>
    <input type="checkbox" id="languages" class="toggle" />
    <label for="languages" class="flex justify-between">
      <a role="button" class="flex align-center">
        <img src="/svg/translate.svg" class="book-icon" alt="Languages" />
        中文
      </a>
    </label>

    <ul>
      
      <li>
        <a href="/cn/">
          
        </a>
      </li>
      
      <li>
        <a href="/en/">
          English
        </a>
      </li>
      
    </ul>
  </li>
</ul>














  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Life</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/movies-log/" class="">观影记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/bilibili/" class="">bilibili</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/books/" class="">books</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/cycling/" class="">cycling</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/hiking/" class="">hiking</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/life-recommend/" class="">life recommand</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/learning-others-log/" class="">other learning</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/podcast/" class="">podcast</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/politics/" class="">politics</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/goal/" class="">goal</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/accumulation/" class="">accumulation</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/coffee/" class="">coffee</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Computer Science</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-855531983528655844a29f37632e7e30" class="toggle"  />
    <label for="section-855531983528655844a29f37632e7e30" class="flex justify-between">
      <a role="button" class="">Java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/java/" class="">java</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/mybatis/" class="">Mybatis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/jvm/" class="">jvm</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-recommend/" class="">推荐</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-learning-log/" class="">学习记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/database/" class="">database</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/echarts/" class="">echarts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/github/" class="">github</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/ios/" class="">ios</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/job/" class="">job</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/mac/" class="">mac</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/raspberrypi/" class="">raspberry pi</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/security/" class="">security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/vue/" class="">vue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/algorithm/" class="">Algorithm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/linux/" class="">linux</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Others</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/about-me/" class="">about me</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/english-learning/" class="">English Learning</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Books</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-70696d57febbe00561bcceac2d174d7c" class="toggle"  />
    <label for="section-70696d57febbe00561bcceac2d174d7c" class="flex justify-between">
      <a role="button" class="">Computer Science</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" class="">Java并发编程实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%AE%9E%E6%88%98/" class="">Java实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="">Python神经网络编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="">Redis设计与实现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/" class="">Spring Cloud微服务：入门、实战与进阶</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/" class="">深入浅出HTTPS：从原理到实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" class="">一本书讲透 ElasticSearch：原理、进阶与工程实践</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E7%AC%AC%E4%B8%89%E7%89%88/" class="">宏观经济学 第三版</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E7%BE%8E%E5%9B%BD%E5%9B%B0%E5%B1%80/" class="">美国困局</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E8%8B%B1%E4%BC%9F%E8%BE%BE-%E9%BB%84%E4%BB%81%E5%8B%8B%E4%B9%8B%E8%8A%AF/" class="">英伟达-黄仁勋之芯</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E7%94%A8%E5%9C%B0%E5%9B%BE%E7%9C%8B%E6%87%82%E4%B8%96%E7%95%8C%E6%A0%BC%E5%B1%80/" class="">用地图看懂世界格局</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>深入浅出HTTPS：从原理到实战</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第1章-http介绍">第1章 HTTP介绍</a>
      <ul>
        <li><a href="#13-网络模型">1.3 网络模型</a></li>
        <li><a href="#14-协议安全分析">1.4 协议安全分析</a></li>
      </ul>
    </li>
    <li><a href="#第2章-密码学">第2章 密码学</a>
      <ul>
        <li><a href="#21-对于密码学的认知">2.1 对于密码学的认知</a></li>
        <li><a href="#22-随机数">2.2 随机数</a></li>
        <li><a href="#23-hash算法">2.3 Hash算法</a></li>
        <li><a href="#24-对称加密算法">2.4 对称加密算法</a></li>
        <li><a href="#25-消息验证码">2.5 消息验证码</a>
          <ul>
            <li><a href="#hash算法可以作为消息验证码吗">hash算法可以作为消息验证码吗？</a></li>
          </ul>
        </li>
        <li><a href="#26-公开密钥算法">2.6 公开密钥算法</a></li>
        <li><a href="#27-密钥">2.7 密钥</a></li>
        <li><a href="#28-密钥协商算法">2.8 密钥协商算法</a></li>
        <li><a href="#29-椭圆曲线密码学">2.9 椭圆曲线密码学</a></li>
        <li><a href="#210-数字签名">2.10 数字签名</a></li>
      </ul>
    </li>
    <li><a href="#第3章-宏观理解tls">第3章 宏观理解TLS</a>
      <ul>
        <li><a href="#32-tlsssl协议背后的算法">3.2 TLS/SSL协议背后的算法</a></li>
        <li><a href="#34-实施https网站的必备条件">3.4 实施HTTPS网站的必备条件</a></li>
        <li><a href="#35-从用户的角度看https">3.5 从用户的角度看HTTPS</a></li>
      </ul>
    </li>
    <li><a href="#第4章-选择https的必要性和疑惑">第4章 选择HTTPS的必要性和疑惑</a></li>
    <li><a href="#第5章-快速搭建一个https网站">第5章 快速搭建一个HTTPS网站</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><ul>
<li>2015年百度搜索引擎完成其历史上最大的系统性升级——全面由HTTP升级到HTTPS</li>
<li>2016年苹果公告要求App Store中的所有应用在2017年1月1日之后都必须使用HTTPS加密连接</li>
<li>2017年1月9日微信上线小程序后，要求开发者的所有服务端请求必须为HTTPS</li>
<li>同时Google已调整搜索引擎算法，让采用HTTPS的网站在搜索结果中排名更靠前，并宣布从2018年7月开始所有的HTTP网站将标记为“不安全”</li>
</ul>
<h2 id="第1章-http介绍">
  第1章 HTTP介绍
  <a class="anchor" href="#%e7%ac%ac1%e7%ab%a0-http%e4%bb%8b%e7%bb%8d">#</a>
</h2>
<ul>
<li>HTTP的特点
<ul>
<li><strong>客户端/服务器模型</strong>
<ul>
<li>客户端和服务器是否正确传输依赖于TCP这个协议。</li>
</ul>
</li>
<li><strong>HTTP是无状态的</strong>
<ul>
<li>所谓的无状态就是每次请求完成后，不会在客户端和服务器上保存任何的信息，对于客户端和服务器来说，根本不知道上一次请求的信息是什么，甚至不知道本次连接的对端是不是上次连接的那一端，它的生命周期随着TCP/IP连接的关闭结束了</li>
<li>无状态的设计已经不能适应新的情况，为了保持状态，出现了Cookie和Session技术，但是Cookie技术设计得非常不严谨，引发了很多安全问题。</li>
<li>介绍下Cookie是如何进行会话保持的，客户端第一次请求完成后，服务器会发送Cookie信息到客户端的计算机上，客户端下次请求的时候会携带该Cookie信息，这样服务器就知道该用户就是上一次请求的用户了。</li>
</ul>
</li>
<li><strong>HTTP是跨平台的</strong>
<ul>
<li>通过上面的讲解，读者知道HTTP就是具备一定规则的纯文本信息，任何开发语言都可以实现HTTP或者基于HTTP进行开发，开发出来的软件也很容易移植，受系统环境的影响非常少。</li>
</ul>
</li>
<li><strong>HTTP用途很广泛</strong></li>
</ul>
</li>
</ul>
<h3 id="13-网络模型">
  1.3 网络模型
  <a class="anchor" href="#13-%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b">#</a>
</h3>
<ul>
<li>HTTP是应用层协议，应用层协议是TCP/IP的一部分</li>
<li>OSI模型是一个通用的网络协议标准，但实际使用的标准却是TCP/IP标准，TCP/IP包含的不仅仅是TCP或者IP，它是一个协议族，网络应用开发都需要掌握TCP/IP。</li>
<li>TCP/IP有两个最大的特点，分别是分层和封包/拆包机制</li>
<li>每一层和它的上下层都有标准的接口规范，每一层无须关心上下层是如何工作的，它只关心上下层是否正确基于规范实现了接口</li>
<li><strong>应用层</strong>
<ul>
<li>如果没有应用层，那么网络中传输的数据没有任何意义，因为人类无法理解数据的含义。而有了应用层，软件就能解释应用层数据的含义。在Web应用中，有了HTTP和HTML标准，浏览器才能呈现对用户有意义的内容。</li>
<li>应用层协议有很多，比如HTTP、FTP、邮件协议，开发者开发的软件一般都是应用层协议软件。</li>
</ul>
</li>
<li><strong>传输层</strong></li>
<li><strong>网络层</strong>
<ul>
<li>网络层主要是IP这个协议，客户端和服务器传输的时候，会经过很多节点，IP就是选择一条最优的路径。每个终端上都有一张路由表，路由表负责将数据传输到下一个节点，下一个节点再传输到下下个节点，最终到达目的地址。</li>
</ul>
</li>
<li><strong>链路层</strong>
<ul>
<li>应用层、传输层、网络层都是虚拟的，只有链路层才是实体设备，包括光纤、网卡等设备。基于这些设备，数据最终才能到达终端。</li>
</ul>
</li>
<li>接下来简单描述封包/拆包机制，对于客户端请求来说，传输层接收到应用层消息后，在HTTP数据包前面增加TCP包头，然后发送给网络层；网络层在TCP数据包前面加上IP包头发送给链路层；链路层在IP数据包前面加上以太网包头；最终服务器接收到完整的数据包。</li>
<li>然后服务器进行拆包：首先在网络层去除链路层包头；在传输层去除IP包头；在应用层去除TCP包头；最终得到完整的HTTP应用层数据。</li>
</ul>
<h3 id="14-协议安全分析">
  1.4 协议安全分析
  <a class="anchor" href="#14-%e5%8d%8f%e8%ae%ae%e5%ae%89%e5%85%a8%e5%88%86%e6%9e%90">#</a>
</h3>
<ul>
<li>协议不安全的根本原因
<ul>
<li><strong>数据没有加密</strong></li>
<li><strong>无法验证身份</strong></li>
<li><strong>数据易篡改</strong></li>
</ul>
</li>
</ul>
<h2 id="第2章-密码学">
  第2章 密码学
  <a class="anchor" href="#%e7%ac%ac2%e7%ab%a0-%e5%af%86%e7%a0%81%e5%ad%a6">#</a>
</h2>
<h3 id="21-对于密码学的认知">
  2.1 对于密码学的认知
  <a class="anchor" href="#21-%e5%af%b9%e4%ba%8e%e5%af%86%e7%a0%81%e5%ad%a6%e7%9a%84%e8%ae%a4%e7%9f%a5">#</a>
</h3>
<ul>
<li>OpenSSL
<ul>
<li>OpenSSL命令行功能非常强大，有很多的子命令和参数，如果不理解密码学算法，根本无法理解子命令和参数的含义，这是难学习的根本原因，也说明学习OpenSSL之前必须先掌握密码学算法。</li>
<li>不同版本的OpenSSL命令行工具在使用的时候有一些差别，同样一条命令，读者会发现在特定版本下可能无法正确运行。</li>
<li>OpenSSL命令行的帮助手册和文档描写得不是很通俗，很难进行系统的学习。</li>
<li>完成同样一个操作，OpenSSL命令行有许多方法实现，这可能会干扰读者的学习。</li>
</ul>
</li>
</ul>
<h3 id="22-随机数">
  2.2 随机数
  <a class="anchor" href="#22-%e9%9a%8f%e6%9c%ba%e6%95%b0">#</a>
</h3>
<ul>
<li>而对于PRNG来说，内部状态的数值来自于模拟的数值，称为种子（seed）。随机数生成器每次生成随机数的时候，内部状态的值都会变化，这样才能产生不一样的随机数，如果每次熵和种子是一样的，生成的随机数也是相同的，所以熵和种子对于随机数生成器非常重要。</li>
</ul>
<h3 id="23-hash算法">
  2.3 Hash算法
  <a class="anchor" href="#23-hash%e7%ae%97%e6%b3%95">#</a>
</h3>
<ul>
<li>由于Hash算法有很多功能，所以Hash算法有多种称呼，比如<strong>摘要算法（Message Digest Algorithms）</strong>、<strong>单向散列函数（Cryptographic One-way Hash Functions）</strong>。输出值也有多种称呼，比如<strong>摘要值</strong>、<strong>散列</strong>、<strong>指纹</strong>。读者看到这些名词的时候，都可以理解为Hash算法</li>
<li>密码学Hash算法的主要特性
<ul>
<li>相同的消息总是能得到同样的摘要值，特定的Hash算法，不管消息长度是多少，最终的摘要值<strong>长度是相同的</strong>。</li>
<li>不管多长的消息，<strong>Hash运算非常快速</strong>，这是非常重要的特性。</li>
<li>通过摘要值很难逆向计算出原始消息，Hash算法具备单向性，摘要值是<strong>不可逆</strong>的，这也是非常重要的特性。为了逆向计算出原始消息，唯一的方法就是采用暴力攻击、字典攻击、彩虹表，对不同的消息组合进行迭代运算，运算的结果如果匹配该消息的摘要值，表示该Hash算法不应该用于密码学。</li>
<li>原始消息一旦修改，即使是<strong>很轻微的修改，最终的摘要值也会产生变化</strong>。</li>
<li>很难找出两个不同的消息，并且它们的摘要值是相同的。</li>
</ul>
</li>
<li>Hash算法的用途
<ul>
<li>文件比较</li>
<li>身份校验</li>
</ul>
</li>
<li>密码学Hash算法的分类
<ul>
<li><strong>MD5</strong>
<ul>
<li>MD5是一种比较常用的Hash算法，摘要值长度固定是128比特，MD5算法目前被证明已经不安全了，MD5算法违反了强抗碰撞性原则，但是还没有破坏单一性原则。</li>
<li>理论上经过2^80次运算就能产生碰撞，但目前最快只要经过2^63次运算就能破坏强抗碰撞性。</li>
</ul>
</li>
<li><strong>SHA</strong>
<ul>
<li>SHA（Secure Hash Algorithms）算法是美国国家标准与技术研究院（NIST）指定的算法，SHA算法不是一个算法，而是一组算法，主要分为三类算法。</li>
<li>SHA-1</li>
<li>SHA-2</li>
<li>SHA-3</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="24-对称加密算法">
  2.4 对称加密算法
  <a class="anchor" href="#24-%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95">#</a>
</h3>
<ul>
<li>建议使用<strong>AES算法</strong>，该算法是对称加密算法的标准算法
<ul>
<li>美国国家标准与技术研究院（National Institute of Standards and Technology, NIST）对众多的对称加密算法进行了考核，从安全性和效率进行了多方面评测，最终选取Rijndael算法作为对称加密算法的标准。以Rijndael算法为原型，创建了AES（Advanced Encryption Standard）算法，AES就是最终的对称加密算法标准。Rijndael算法和AES算法略微不同，但在理解的时候可以认为是相同的算法。</li>
</ul>
</li>
<li><strong>流密码算法</strong></li>
<li><strong>块密码算法</strong>
<ul>
<li>迭代模式
<ul>
<li>**ECB模式（Electronic Codebook）**是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。
<ul>
<li>ECB模式（Electronic Codebook）是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。</li>
</ul>
</li>
<li>**CBC模式（Cipher Block Chaining）**是比较常见的一种迭代模式，解决了ECB模式的安全问题。
<ul>
<li>迭代运算数据块不能并行处理，只有处理完第n个数据块，才能继续处理第n+1个数据块。</li>
</ul>
</li>
<li>**CTR模式（counter）**在迭代的时候，相当于是一个流密码的运行模式。每次迭代运算的时候要生成一个密钥流（keystream），生成密钥流的方法可以是任意的，但是各个密钥流之间是有关系的，最简单的方式就是密钥流不断递增，所以才叫作计数器模式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="25-消息验证码">
  2.5 消息验证码
  <a class="anchor" href="#25-%e6%b6%88%e6%81%af%e9%aa%8c%e8%af%81%e7%a0%81">#</a>
</h3>
<ul>
<li>MAC值一般和原始消息一起传输，原始消息可以选择加密，也可以选择不加密，通信双方会以相同的方式生成MAC值，然后进行比较</li>
<li>CBC-MAC算法</li>
<li>HMAC算法 Hash-based Message Authentication Code</li>
<li>加密算法不能提供完整性，加密的同时必须引入MAC算法避免消息被篡改</li>
<li>使用者结合对称加密算法和MAC算法，提供机密性和完整性的模式也叫作Authenticated Encryption（AE）加密模式，主要有三种
<ul>
<li>Encrypt-and-MAC (E&amp;M)</li>
<li>MAC-then-Encrypt (MtE)
<ul>
<li>这种模式（图2-12）先对消息进行MAC计算，然后将消息和MAC值组合在一起再进行加密，最终的加密值再发送给接收方。在HTTPS中，一般使用这种模式进行处理，比如AES-128-CBC#PKCS7-HMAC-SHA256模式。</li>
</ul>
</li>
<li>Encrypt-then-MAC (EtM)</li>
</ul>
</li>
<li>不管是Encrypt-and-MAC模式还是MAC-then-Encrypt模式，使用不当的话都会存在安全问题，目前建议使用Encrypt-then-MAC模式。需要强调的是，这三种模式使用者必须分别处理，一旦处理不当，就可能会存在安全风险，那有没有一种方法在底层直接提供加密和MAC运算呢？无须使用者分别处理加密和MAC运算，这就是接下来讲解的AEAD模式。</li>
<li>AEAD加密模式
<ul>
<li>CCM模式</li>
<li>GCM模式</li>
<li>ChaCha20-Poly1305</li>
</ul>
</li>
</ul>
<h4 id="hash算法可以作为消息验证码吗">
  hash算法可以作为消息验证码吗？
  <a class="anchor" href="#hash%e7%ae%97%e6%b3%95%e5%8f%af%e4%bb%a5%e4%bd%9c%e4%b8%ba%e6%b6%88%e6%81%af%e9%aa%8c%e8%af%81%e7%a0%81%e5%90%97">#</a>
</h4>
<p>是的，哈希算法可以作为消息验证码（MAC）的一部分，但单独使用哈希算法并不能直接构成消息验证码。消息验证码（MAC）是一种用于验证消息<strong>完整性</strong>和<strong>真实性</strong>的技术，通常需要结合密钥来确保安全性。</p>
<p>哈希算法与MAC的区别</p>
<ul>
<li><strong>哈希算法</strong>：如SHA-256、MD5等，用于生成固定长度的哈希值，确保数据完整性，<strong>但不涉及密钥，无法防止篡改</strong>。</li>
<li><strong>消息验证码（MAC）</strong>：结合哈希算法和密钥，生成一个与消息和密钥相关的验证码，确保消息未被篡改且来自可信来源。</li>
</ul>
<p>使用哈希算法构建MAC</p>
<p>常见的方法是<strong>HMAC（Hash-based Message Authentication Code）</strong>，它通过以下步骤生成MAC：</p>
<ol>
<li>将密钥与一个固定值（如<code>ipad</code>）异或，生成<code>k_ipad</code>。</li>
<li>将<code>k_ipad</code>与消息拼接，计算哈希值。</li>
<li>将密钥与另一个固定值（如<code>opad</code>）异或，生成<code>k_opad</code>。</li>
<li>将<code>k_opad</code>与步骤2的哈希值拼接，再次计算哈希值，得到最终的MAC。</li>
</ol>
<p>示例</p>
<p>假设使用SHA-256和密钥<code>key</code>，消息为<code>message</code>，HMAC生成过程如下：</p>
<ol>
<li>生成<code>k_ipad</code>和<code>k_opad</code>。</li>
<li>计算<code>hash(k_ipad + message)</code>。</li>
<li>计算<code>hash(k_opad + hash(k_ipad + message))</code>，得到MAC。</li>
</ol>
<p>总结</p>
<p>哈希算法可以作为MAC的基础，但单独使用无法提供完整的安全性。HMAC等结合密钥的方法才能确保消息的完整性和真实性。</p>
<h3 id="26-公开密钥算法">
  2.6 公开密钥算法
  <a class="anchor" href="#26-%e5%85%ac%e5%bc%80%e5%af%86%e9%92%a5%e7%ae%97%e6%b3%95">#</a>
</h3>
<ul>
<li>相比对称加密算法来说，公开密钥算法尤其是RSA算法运算非常缓慢，一般情况下，需要加密的明文数据都非常大，如果使用公开密钥算法进行加密，运算性能会惨不忍睹。公开密钥算法在密码学中一般进行密钥协商或者数字签名，因为这两者运算的数据相对较小。</li>
<li>公开密钥算法最重要和最广泛使用的算法就是RSA算法，该算法是Ron Rivest、Adi Shamir、Leonard Adleman三个人创建的，以三个人名字的首字母命名。</li>
<li>和对称密钥算法一样，公开密钥算法也有使用标准，公开密钥算法的标准称为PKCS（Public Key Cryptography Standards），这个标准由很多的子标准组成，指导使用者正确地使用公开密钥算法。</li>
<li>RSA加密算法的应用场景
<ul>
<li>单步加密</li>
<li>双向加密</li>
</ul>
</li>
</ul>
<h3 id="27-密钥">
  2.7 密钥
  <a class="anchor" href="#27-%e5%af%86%e9%92%a5">#</a>
</h3>
<ul>
<li>口令（password或者passphrase）也可以认为是一种密钥，都需要保密，不能泄露。口令和密钥最大的区别在于口令更容易生成、更容易记忆，一般情况下口令记录在人脑中，口令可以认为是一种弱密钥，由固定的字母、数字、符号组成，长度也有一定的限制。</li>
<li>在密码学中很少直接用口令进行加密，容易受到暴力攻击和字典攻击，暴力攻击的原理在于口令都是由固定的字母、数字、符号组成的，攻击者可以生成所有可能的口令，然后使用口令迭代去解密，一旦成功解密，就表示口令被暴力破解了。</li>
<li>字典攻击本质上也是一种暴力攻击，只是能够加快破解效率（时间和空间），人类一般使用常见的字母、数字、符号组合成口令（比如很多人喜欢用字母password作为口令），攻击者可以将常见的口令保存在一张字典中，然后用字典中的口令迭代去解密密文。除了字典攻击，还有彩虹表攻击方式，破解的关键点就在于口令相对容易猜测和预测。</li>
<li>密钥存储和传输</li>
</ul>
<h3 id="28-密钥协商算法">
  2.8 密钥协商算法
  <a class="anchor" href="#28-%e5%af%86%e9%92%a5%e5%8d%8f%e5%95%86%e7%ae%97%e6%b3%95">#</a>
</h3>
<ul>
<li>RSA密钥协商算法</li>
<li>DH密钥协商算法
<ul>
<li>Diffie-Hellman算法，简称DH算法，是Whitfield Diffie和Martin Hellman在1976年公布的一个公开密钥算法，它的历史比RSA公开密钥算法更悠久。</li>
<li>使用RSA密钥协商算法传输会话密钥的时候，会话密钥完全由客户端控制，并没有服务器的参与，所以叫作密钥传输。</li>
<li>而DH算法确切地说，实现的是密钥交换或者密钥协商，DH算法在进行密钥协商的时候，通信双方的任何一方无法独自计算出一个会话密钥，通信双方各自保留一部分关键信息，再将另外一部分信息告诉对方，双方有了全部信息才能共同计算出相同的会话密钥。</li>
</ul>
</li>
</ul>
<h3 id="29-椭圆曲线密码学">
  2.9 椭圆曲线密码学
  <a class="anchor" href="#29-%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e5%af%86%e7%a0%81%e5%ad%a6">#</a>
</h3>
<ul>
<li>
<p>为了保证DH的密钥对不被破解，提升安全性的主要手段就是增加密钥对的长度，但是长度越长，性能越低。公开密钥算法是一个O(n)操作，n就是密钥对的长度，n越小，操作越快。为了解决性能问题，需要了解下椭圆曲线密码学（Elliptic Curve Cryptography），简称为ECC。</p>
</li>
<li>
<p>ECC是新一代的公开密钥算法，主要的优点就是安全性，极短的密钥能够提供很大的安全性。比如224比特的ECC密钥和2048比特的RSA密钥可以达到同样的安全水平，由于ECC密钥具有很短的长度，运算速度非常快。ECC基于非常复杂的算法，到目前位置，对于ECC进行逆操作还是很难的，数学上被证明是不可破解的，ECC算法的优势就是性能和安全性非常高。</p>
</li>
<li>
<p>在具体应用的时候，ECC可以结合其他公开密钥算法形成更快、更安全的公开密钥算法，比如结合DH密钥协商算法组成ECDH密钥协商算法，结合数字签名DSA算法组成ECDSA数字签名算法。</p>
</li>
</ul>
<h3 id="210-数字签名">
  2.10 数字签名
  <a class="anchor" href="#210-%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d">#</a>
</h3>
<ul>
<li>RSA数字签名算法
<ul>
<li>RSA算法的用途非常广泛，可以进行数字签名。和RSA加密算法相似，不同的是，RSA加密算法是公钥加密，私钥解密；RSA签名算法是私钥签名，公钥验证签名。</li>
</ul>
</li>
</ul>
<h2 id="第3章-宏观理解tls">
  第3章 宏观理解TLS
  <a class="anchor" href="#%e7%ac%ac3%e7%ab%a0-%e5%ae%8f%e8%a7%82%e7%90%86%e8%a7%a3tls">#</a>
</h2>
<ul>
<li>解决HTTP三大问题的通用解决方案就是TLS协议</li>
<li>读者可能听说过TLS（Transport Layer Security）协议，也可能听说过SSL（Secure Sockets Layer）协议，在理解的时候可以认为两者是一样的，TLS协议是SSL协议的升级版，本书使用TLS/SSL协议代表TLS协议或者SSL协议。</li>
<li>TLS/SSL协议位于应用层协议和TCP之间，构建在TCP之上，由TCP协议保证数据传输的可靠性，任何数据到达TCP之前，都经过TLS/SSL协议处理。</li>
<li>对于应用层协议来说，它无须过多改变，引入TLS/SSL协议即可保证数据机密性和完整性。任何应用层协议（HTTP、SMTP、FTP、其他自定义应用层协议）都可以结合TLS/SSL协议。</li>
<li>TLS/SSL协议一般构建在TCP之上，也可以构建在UDP之上，称为DTLS（Datagram Transport Layer Security）协议，DTLS协议在Web中使用得比较少。</li>
</ul>
<h3 id="32-tlsssl协议背后的算法">
  3.2 TLS/SSL协议背后的算法
  <a class="anchor" href="#32-tlsssl%e5%8d%8f%e8%ae%ae%e8%83%8c%e5%90%8e%e7%9a%84%e7%ae%97%e6%b3%95">#</a>
</h3>
<ul>
<li>为了对数据进行加密，可以采用对称加密算法或者公开密钥加密算法，有加密算法必定就有MAC算法，两者是一个整体。</li>
<li>使用何种密钥协商算法也是由客户端和服务器端共同决定的，或者说由密码套件决定，对于HTTPS来说，在连接阶段必须协商出一个双方认可的密码套件，密码套件是各个密码学算法组合。
<ul>
<li>在HTTPS中，一般采用RSA或者DH算法协商预备主密钥</li>
</ul>
</li>
</ul>
<h3 id="34-实施https网站的必备条件">
  3.4 实施HTTPS网站的必备条件
  <a class="anchor" href="#34-%e5%ae%9e%e6%96%bdhttps%e7%bd%91%e7%ab%99%e7%9a%84%e5%bf%85%e5%a4%87%e6%9d%a1%e4%bb%b6">#</a>
</h3>
<h3 id="35-从用户的角度看https">
  3.5 从用户的角度看HTTPS
  <a class="anchor" href="#35-%e4%bb%8e%e7%94%a8%e6%88%b7%e7%9a%84%e8%a7%92%e5%ba%a6%e7%9c%8bhttps">#</a>
</h3>
<h2 id="第4章-选择https的必要性和疑惑">
  第4章 选择HTTPS的必要性和疑惑
  <a class="anchor" href="#%e7%ac%ac4%e7%ab%a0-%e9%80%89%e6%8b%a9https%e7%9a%84%e5%bf%85%e8%a6%81%e6%80%a7%e5%92%8c%e7%96%91%e6%83%91">#</a>
</h2>
<h2 id="第5章-快速搭建一个https网站">
  第5章 快速搭建一个HTTPS网站
  <a class="anchor" href="#%e7%ac%ac5%e7%ab%a0-%e5%bf%ab%e9%80%9f%e6%90%ad%e5%bb%ba%e4%b8%80%e4%b8%aahttps%e7%bd%91%e7%ab%99">#</a>
</h2>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第1章-http介绍">第1章 HTTP介绍</a>
      <ul>
        <li><a href="#13-网络模型">1.3 网络模型</a></li>
        <li><a href="#14-协议安全分析">1.4 协议安全分析</a></li>
      </ul>
    </li>
    <li><a href="#第2章-密码学">第2章 密码学</a>
      <ul>
        <li><a href="#21-对于密码学的认知">2.1 对于密码学的认知</a></li>
        <li><a href="#22-随机数">2.2 随机数</a></li>
        <li><a href="#23-hash算法">2.3 Hash算法</a></li>
        <li><a href="#24-对称加密算法">2.4 对称加密算法</a></li>
        <li><a href="#25-消息验证码">2.5 消息验证码</a>
          <ul>
            <li><a href="#hash算法可以作为消息验证码吗">hash算法可以作为消息验证码吗？</a></li>
          </ul>
        </li>
        <li><a href="#26-公开密钥算法">2.6 公开密钥算法</a></li>
        <li><a href="#27-密钥">2.7 密钥</a></li>
        <li><a href="#28-密钥协商算法">2.8 密钥协商算法</a></li>
        <li><a href="#29-椭圆曲线密码学">2.9 椭圆曲线密码学</a></li>
        <li><a href="#210-数字签名">2.10 数字签名</a></li>
      </ul>
    </li>
    <li><a href="#第3章-宏观理解tls">第3章 宏观理解TLS</a>
      <ul>
        <li><a href="#32-tlsssl协议背后的算法">3.2 TLS/SSL协议背后的算法</a></li>
        <li><a href="#34-实施https网站的必备条件">3.4 实施HTTPS网站的必备条件</a></li>
        <li><a href="#35-从用户的角度看https">3.5 从用户的角度看HTTPS</a></li>
      </ul>
    </li>
    <li><a href="#第4章-选择https的必要性和疑惑">第4章 选择HTTPS的必要性和疑惑</a></li>
    <li><a href="#第5章-快速搭建一个https网站">第5章 快速搭建一个HTTPS网站</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












