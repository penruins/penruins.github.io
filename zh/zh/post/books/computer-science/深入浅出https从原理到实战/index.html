<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
2015年百度搜索引擎完成其历史上最大的系统性升级——全面由HTTP升级到HTTPS
2016年苹果公告要求App Store中的所有应用在2017年1月1日之后都必须使用HTTPS加密连接
2017年1月9日微信上线小程序后，要求开发者的所有服务端请求必须为HTTPS
同时Google已调整搜索引擎算法，让采用HTTPS的网站在搜索结果中排名更靠前，并宣布从2018年7月开始所有的HTTP网站将标记为“不安全”


  第1章 HTTP介绍
  #


HTTP的特点

客户端/服务器模型

客户端和服务器是否正确传输依赖于TCP这个协议。


HTTP是无状态的

所谓的无状态就是每次请求完成后，不会在客户端和服务器上保存任何的信息，对于客户端和服务器来说，根本不知道上一次请求的信息是什么，甚至不知道本次连接的对端是不是上次连接的那一端，它的生命周期随着TCP/IP连接的关闭结束了
无状态的设计已经不能适应新的情况，为了保持状态，出现了Cookie和Session技术，但是Cookie技术设计得非常不严谨，引发了很多安全问题。
介绍下Cookie是如何进行会话保持的，客户端第一次请求完成后，服务器会发送Cookie信息到客户端的计算机上，客户端下次请求的时候会携带该Cookie信息，这样服务器就知道该用户就是上一次请求的用户了。


HTTP是跨平台的

通过上面的讲解，读者知道HTTP就是具备一定规则的纯文本信息，任何开发语言都可以实现HTTP或者基于HTTP进行开发，开发出来的软件也很容易移植，受系统环境的影响非常少。


HTTP用途很广泛




  1.3 网络模型
  #


HTTP是应用层协议，应用层协议是TCP/IP的一部分
OSI模型是一个通用的网络协议标准，但实际使用的标准却是TCP/IP标准，TCP/IP包含的不仅仅是TCP或者IP，它是一个协议族，网络应用开发都需要掌握TCP/IP。
TCP/IP有两个最大的特点，分别是分层和封包/拆包机制
每一层和它的上下层都有标准的接口规范，每一层无须关心上下层是如何工作的，它只关心上下层是否正确基于规范实现了接口
应用层

如果没有应用层，那么网络中传输的数据没有任何意义，因为人类无法理解数据的含义。而有了应用层，软件就能解释应用层数据的含义。在Web应用中，有了HTTP和HTML标准，浏览器才能呈现对用户有意义的内容。
应用层协议有很多，比如HTTP、FTP、邮件协议，开发者开发的软件一般都是应用层协议软件。


传输层
网络层

网络层主要是IP这个协议，客户端和服务器传输的时候，会经过很多节点，IP就是选择一条最优的路径。每个终端上都有一张路由表，路由表负责将数据传输到下一个节点，下一个节点再传输到下下个节点，最终到达目的地址。


链路层

应用层、传输层、网络层都是虚拟的，只有链路层才是实体设备，包括光纤、网卡等设备。基于这些设备，数据最终才能到达终端。


接下来简单描述封包/拆包机制，对于客户端请求来说，传输层接收到应用层消息后，在HTTP数据包前面增加TCP包头，然后发送给网络层；网络层在TCP数据包前面加上IP包头发送给链路层；链路层在IP数据包前面加上以太网包头；最终服务器接收到完整的数据包。
然后服务器进行拆包：首先在网络层去除链路层包头；在传输层去除IP包头；在应用层去除TCP包头；最终得到完整的HTTP应用层数据。


  1.4 协议安全分析
  #


协议不安全的根本原因

数据没有加密
无法验证身份
数据易篡改




  第2章 密码学
  #


  2.1 对于密码学的认知
  #


OpenSSL

OpenSSL命令行功能非常强大，有很多的子命令和参数，如果不理解密码学算法，根本无法理解子命令和参数的含义，这是难学习的根本原因，也说明学习OpenSSL之前必须先掌握密码学算法。
不同版本的OpenSSL命令行工具在使用的时候有一些差别，同样一条命令，读者会发现在特定版本下可能无法正确运行。
OpenSSL命令行的帮助手册和文档描写得不是很通俗，很难进行系统的学习。
完成同样一个操作，OpenSSL命令行有许多方法实现，这可能会干扰读者的学习。




  2.2 随机数
  #


而对于PRNG来说，内部状态的数值来自于模拟的数值，称为种子（seed）。随机数生成器每次生成随机数的时候，内部状态的值都会变化，这样才能产生不一样的随机数，如果每次熵和种子是一样的，生成的随机数也是相同的，所以熵和种子对于随机数生成器非常重要。


  2.2.1 随机数的类型
  #


真正的随机数生成器

需要从物理设备获取


伪随机数生成器

通过算法获取


密码学伪随机数生成器

用于密码学





随机数的特性

效率
随机性
不可预测性
不可重现性




  2.2.2 随机数的工作原理
  #


  2.2.3 常见的随机数生成器
  #


  2.2.4 密码学算法中的随机数
  #


  2.3 Hash算法
  #


  2.3.1 加密基元
  #


加密基元就是一些基础的密码学算法，通过它们才能够构建更多的密码学算法、协议、应用程序


  2.3.2 Hash算法和密码学Hash算法
  #


  2.3.3 密码学Hash算法的特性
  #


由于Hash算法有很多功能，所以Hash算法有多种称呼，比如摘要算法（Message Digest Algorithms）、单向散列函数（Cryptographic One-way Hash Functions）。输出值也有多种称呼，比如摘要值、散列、指纹。读者看到这些名词的时候，都可以理解为Hash算法
密码学Hash算法的主要特性

相同的消息总是能得到同样的摘要值，特定的Hash算法，不管消息长度是多少，最终的摘要值长度是相同的。
不管多长的消息，Hash运算非常快速，这是非常重要的特性。
通过摘要值很难逆向计算出原始消息，Hash算法具备单向性，摘要值是不可逆的，这也是非常重要的特性。为了逆向计算出原始消息，唯一的方法就是采用暴力攻击、字典攻击、彩虹表，对不同的消息组合进行迭代运算，运算的结果如果匹配该消息的摘要值，表示该Hash算法不应该用于密码学。
原始消息一旦修改，即使是很轻微的修改，最终的摘要值也会产生变化。
很难找出两个不同的消息，并且它们的摘要值是相同的。




  2.3.4 Hash算法的用途
  #


文件比较
身份校验


  2.3.5 什么是安全的密码学Hash算法
  #


强抗碰撞性（Collision Resistance）
弱抗碰撞性（Second pre-image Resistance）
单向性（Pre-image Resistance）


  2.3.6 密码学Hash算法的分类
  #


MD5

MD5是一种比较常用的Hash算法，摘要值长度固定是128比特，MD5算法目前被证明已经不安全了，MD5算法违反了强抗碰撞性原则，但是还没有破坏单一性原则。
理论上经过2^80次运算就能产生碰撞，但目前最快只要经过2^63次运算就能破坏强抗碰撞性。


SHA

SHA（Secure Hash Algorithms）算法是美国国家标准与技术研究院（NIST）指定的算法，SHA算法不是一个算法，而是一组算法，主要分为三类算法。

SHA-1
SHA-2
SHA-3






  2.4 对称加密算法
  #


建议使用AES算法，该算法是对称加密算法的标准算法

美国国家标准与技术研究院（National Institute of Standards and Technology, NIST）对众多的对称加密算法进行了考核，从安全性和效率进行了多方面评测，最终选取Rijndael算法作为对称加密算法的标准。以Rijndael算法为原型，创建了AES（Advanced Encryption Standard）算法，AES就是最终的对称加密算法标准。Rijndael算法和AES算法略微不同，但在理解的时候可以认为是相同的算法。


流密码算法
块密码算法

迭代模式

**ECB模式（Electronic Codebook）**是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。

ECB模式（Electronic Codebook）是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。


**CBC模式（Cipher Block Chaining）**是比较常见的一种迭代模式，解决了ECB模式的安全问题。

迭代运算数据块不能并行处理，只有处理完第n个数据块，才能继续处理第n&#43;1个数据块。


**CTR模式（counter）**在迭代的时候，相当于是一个流密码的运行模式。每次迭代运算的时候要生成一个密钥流（keystream），生成密钥流的方法可以是任意的，但是各个密钥流之间是有关系的，最简单的方式就是密钥流不断递增，所以才叫作计数器模式。






  2.4.1 流密码算法
  #


  2.4.2 块密码算法
  #


  2.4.3 填充标准
  #


  2.4.4 对称加密算法实践
  #


  2.5 消息验证码
  #


MAC值一般和原始消息一起传输，原始消息可以选择加密，也可以选择不加密，通信双方会以相同的方式生成MAC值，然后进行比较
CBC-MAC算法
HMAC算法 Hash-based Message Authentication Code
加密算法不能提供完整性，加密的同时必须引入MAC算法避免消息被篡改
使用者结合对称加密算法和MAC算法，提供机密性和完整性的模式也叫作Authenticated Encryption（AE）加密模式，主要有三种

Encrypt-and-MAC (E&amp;M)
MAC-then-Encrypt (MtE)

这种模式（图2-12）先对消息进行MAC计算，然后将消息和MAC值组合在一起再进行加密，最终的加密值再发送给接收方。在HTTPS中，一般使用这种模式进行处理，比如AES-128-CBC#PKCS7-HMAC-SHA256模式。


Encrypt-then-MAC (EtM)


不管是Encrypt-and-MAC模式还是MAC-then-Encrypt模式，使用不当的话都会存在安全问题，目前建议使用Encrypt-then-MAC模式。需要强调的是，这三种模式使用者必须分别处理，一旦处理不当，就可能会存在安全风险，那有没有一种方法在底层直接提供加密和MAC运算呢？无须使用者分别处理加密和MAC运算，这就是接下来讲解的AEAD模式。
AEAD加密模式

CCM模式
GCM模式
ChaCha20-Poly1305




  2.5.1 什么是消息验证码
  #


在密码学应用中，很多情况下，传递的消息没有必要加密，只要确保消息是完整且没有被篡改即可
比如开发者开发了一组天气API，接口返回的数据并没有加密，原因可能如下

接口的数据并不重要，对隐私性要求不高
加密和解密过程很消耗性能


所以接口的设计目标仅仅是避免消息被篡改，读者可能说那很简单啊，接口消息通过Hash算法得到一个摘要值，摘要值和接口消息同时作为接口内容返回不就解决问题了吗？

攻击者对消息进行拦截，同时修改接口消息和消息的摘要值然后发送给接收方，接收方收到消息后，对接口消息计算摘要值，然后与接收到的摘要值进行比较，如果相同，接收方认为消息是完整的。可实际呢？消息虽然是完整的，但被篡改了，或者说消息被伪装了，但对于接收方来说，仅仅通过摘要值无法验证消息是不是篡改了


消息验证码算法的特点

证明消息没有被篡改，这和Hash算法类似。
消息是正确的发送者发送的，也就是说消息是经过验证的


如何确保消息是特定人发送的呢？在通信双方可以维护同一个密钥，只有拥有密钥的通信双方才能生成和验证消息验证码，消息验证码算法需要一个密钥，这和对称加密算法是一样的，通信双方在消息传递之前需要获得同样的密钥。


  2.5.2 MAC 算法的种类
  #


CBC-MAC算法

CBC-MAC算法从块密码算法的CBC分组模式演变而来，简单地说就是最后一个密文分组的值就是MAC值


HMAC算法

在HTTP中应用最多的MAC算法是HMAC算法
HMAC（Hash-based Message Authentication Code）算法使用Hash算法作为加密基元，HMAC结合Hash算法有多种变种，比如HMAC-SHA-1、HMAC-SHA256、HMAC-SHA512
读者不要误以为HMAC算法就是Hash算法加上一个密钥，HMAC算法只是基于Hash算法的，内部的实现还是相当复杂的




  2.5.3 消息验证码算法实践
  #


  2.5.4 加密算法不能提供完整性
  #


完整性的意思是消息没有被篡改，仅仅加密数据是无法保证数据完整性的，初听起来可能觉得很奇怪。攻击者如果没有密钥就无法破解原文，也就无法篡改，数据必然是完整的。遗憾的是攻击者虽然无法破解数据，但是可以修改密文的部分数据，然后发送给接收者，接收者通过密钥发现能够解密，但是解密出来的值实际上不是原文，消息已经被修改了，也就是说加密操作不能提供完整性。


  hash算法可以作为消息验证码吗？
  #

是的，哈希算法可以作为消息验证码（MAC）的一部分，但单独使用哈希算法并不能直接构成消息验证码。消息验证码（MAC）是一种用于验证消息完整性和真实性的技术，通常需要结合密钥来确保安全性。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="/zh/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/">
  <meta property="og:site_name" content="Penruins">
  <meta property="og:title" content="深入浅出HTTPS：从原理到实战">
  <meta property="og:description" content="2015年百度搜索引擎完成其历史上最大的系统性升级——全面由HTTP升级到HTTPS 2016年苹果公告要求App Store中的所有应用在2017年1月1日之后都必须使用HTTPS加密连接 2017年1月9日微信上线小程序后，要求开发者的所有服务端请求必须为HTTPS 同时Google已调整搜索引擎算法，让采用HTTPS的网站在搜索结果中排名更靠前，并宣布从2018年7月开始所有的HTTP网站将标记为“不安全” 第1章 HTTP介绍 # HTTP的特点 客户端/服务器模型 客户端和服务器是否正确传输依赖于TCP这个协议。 HTTP是无状态的 所谓的无状态就是每次请求完成后，不会在客户端和服务器上保存任何的信息，对于客户端和服务器来说，根本不知道上一次请求的信息是什么，甚至不知道本次连接的对端是不是上次连接的那一端，它的生命周期随着TCP/IP连接的关闭结束了 无状态的设计已经不能适应新的情况，为了保持状态，出现了Cookie和Session技术，但是Cookie技术设计得非常不严谨，引发了很多安全问题。 介绍下Cookie是如何进行会话保持的，客户端第一次请求完成后，服务器会发送Cookie信息到客户端的计算机上，客户端下次请求的时候会携带该Cookie信息，这样服务器就知道该用户就是上一次请求的用户了。 HTTP是跨平台的 通过上面的讲解，读者知道HTTP就是具备一定规则的纯文本信息，任何开发语言都可以实现HTTP或者基于HTTP进行开发，开发出来的软件也很容易移植，受系统环境的影响非常少。 HTTP用途很广泛 1.3 网络模型 # HTTP是应用层协议，应用层协议是TCP/IP的一部分 OSI模型是一个通用的网络协议标准，但实际使用的标准却是TCP/IP标准，TCP/IP包含的不仅仅是TCP或者IP，它是一个协议族，网络应用开发都需要掌握TCP/IP。 TCP/IP有两个最大的特点，分别是分层和封包/拆包机制 每一层和它的上下层都有标准的接口规范，每一层无须关心上下层是如何工作的，它只关心上下层是否正确基于规范实现了接口 应用层 如果没有应用层，那么网络中传输的数据没有任何意义，因为人类无法理解数据的含义。而有了应用层，软件就能解释应用层数据的含义。在Web应用中，有了HTTP和HTML标准，浏览器才能呈现对用户有意义的内容。 应用层协议有很多，比如HTTP、FTP、邮件协议，开发者开发的软件一般都是应用层协议软件。 传输层 网络层 网络层主要是IP这个协议，客户端和服务器传输的时候，会经过很多节点，IP就是选择一条最优的路径。每个终端上都有一张路由表，路由表负责将数据传输到下一个节点，下一个节点再传输到下下个节点，最终到达目的地址。 链路层 应用层、传输层、网络层都是虚拟的，只有链路层才是实体设备，包括光纤、网卡等设备。基于这些设备，数据最终才能到达终端。 接下来简单描述封包/拆包机制，对于客户端请求来说，传输层接收到应用层消息后，在HTTP数据包前面增加TCP包头，然后发送给网络层；网络层在TCP数据包前面加上IP包头发送给链路层；链路层在IP数据包前面加上以太网包头；最终服务器接收到完整的数据包。 然后服务器进行拆包：首先在网络层去除链路层包头；在传输层去除IP包头；在应用层去除TCP包头；最终得到完整的HTTP应用层数据。 1.4 协议安全分析 # 协议不安全的根本原因 数据没有加密 无法验证身份 数据易篡改 第2章 密码学 # 2.1 对于密码学的认知 # OpenSSL OpenSSL命令行功能非常强大，有很多的子命令和参数，如果不理解密码学算法，根本无法理解子命令和参数的含义，这是难学习的根本原因，也说明学习OpenSSL之前必须先掌握密码学算法。 不同版本的OpenSSL命令行工具在使用的时候有一些差别，同样一条命令，读者会发现在特定版本下可能无法正确运行。 OpenSSL命令行的帮助手册和文档描写得不是很通俗，很难进行系统的学习。 完成同样一个操作，OpenSSL命令行有许多方法实现，这可能会干扰读者的学习。 2.2 随机数 # 而对于PRNG来说，内部状态的数值来自于模拟的数值，称为种子（seed）。随机数生成器每次生成随机数的时候，内部状态的值都会变化，这样才能产生不一样的随机数，如果每次熵和种子是一样的，生成的随机数也是相同的，所以熵和种子对于随机数生成器非常重要。 2.2.1 随机数的类型 # 真正的随机数生成器 需要从物理设备获取 伪随机数生成器 通过算法获取 密码学伪随机数生成器 用于密码学 随机数的特性 效率 随机性 不可预测性 不可重现性 2.2.2 随机数的工作原理 # 2.2.3 常见的随机数生成器 # 2.2.4 密码学算法中的随机数 # 2.3 Hash算法 # 2.3.1 加密基元 # 加密基元就是一些基础的密码学算法，通过它们才能够构建更多的密码学算法、协议、应用程序 2.3.2 Hash算法和密码学Hash算法 # 2.3.3 密码学Hash算法的特性 # 由于Hash算法有很多功能，所以Hash算法有多种称呼，比如摘要算法（Message Digest Algorithms）、单向散列函数（Cryptographic One-way Hash Functions）。输出值也有多种称呼，比如摘要值、散列、指纹。读者看到这些名词的时候，都可以理解为Hash算法 密码学Hash算法的主要特性 相同的消息总是能得到同样的摘要值，特定的Hash算法，不管消息长度是多少，最终的摘要值长度是相同的。 不管多长的消息，Hash运算非常快速，这是非常重要的特性。 通过摘要值很难逆向计算出原始消息，Hash算法具备单向性，摘要值是不可逆的，这也是非常重要的特性。为了逆向计算出原始消息，唯一的方法就是采用暴力攻击、字典攻击、彩虹表，对不同的消息组合进行迭代运算，运算的结果如果匹配该消息的摘要值，表示该Hash算法不应该用于密码学。 原始消息一旦修改，即使是很轻微的修改，最终的摘要值也会产生变化。 很难找出两个不同的消息，并且它们的摘要值是相同的。 2.3.4 Hash算法的用途 # 文件比较 身份校验 2.3.5 什么是安全的密码学Hash算法 # 强抗碰撞性（Collision Resistance） 弱抗碰撞性（Second pre-image Resistance） 单向性（Pre-image Resistance） 2.3.6 密码学Hash算法的分类 # MD5 MD5是一种比较常用的Hash算法，摘要值长度固定是128比特，MD5算法目前被证明已经不安全了，MD5算法违反了强抗碰撞性原则，但是还没有破坏单一性原则。 理论上经过2^80次运算就能产生碰撞，但目前最快只要经过2^63次运算就能破坏强抗碰撞性。 SHA SHA（Secure Hash Algorithms）算法是美国国家标准与技术研究院（NIST）指定的算法，SHA算法不是一个算法，而是一组算法，主要分为三类算法。 SHA-1 SHA-2 SHA-3 2.4 对称加密算法 # 建议使用AES算法，该算法是对称加密算法的标准算法 美国国家标准与技术研究院（National Institute of Standards and Technology, NIST）对众多的对称加密算法进行了考核，从安全性和效率进行了多方面评测，最终选取Rijndael算法作为对称加密算法的标准。以Rijndael算法为原型，创建了AES（Advanced Encryption Standard）算法，AES就是最终的对称加密算法标准。Rijndael算法和AES算法略微不同，但在理解的时候可以认为是相同的算法。 流密码算法 块密码算法 迭代模式 **ECB模式（Electronic Codebook）**是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。 ECB模式（Electronic Codebook）是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。 **CBC模式（Cipher Block Chaining）**是比较常见的一种迭代模式，解决了ECB模式的安全问题。 迭代运算数据块不能并行处理，只有处理完第n个数据块，才能继续处理第n&#43;1个数据块。 **CTR模式（counter）**在迭代的时候，相当于是一个流密码的运行模式。每次迭代运算的时候要生成一个密钥流（keystream），生成密钥流的方法可以是任意的，但是各个密钥流之间是有关系的，最简单的方式就是密钥流不断递增，所以才叫作计数器模式。 2.4.1 流密码算法 # 2.4.2 块密码算法 # 2.4.3 填充标准 # 2.4.4 对称加密算法实践 # 2.5 消息验证码 # MAC值一般和原始消息一起传输，原始消息可以选择加密，也可以选择不加密，通信双方会以相同的方式生成MAC值，然后进行比较 CBC-MAC算法 HMAC算法 Hash-based Message Authentication Code 加密算法不能提供完整性，加密的同时必须引入MAC算法避免消息被篡改 使用者结合对称加密算法和MAC算法，提供机密性和完整性的模式也叫作Authenticated Encryption（AE）加密模式，主要有三种 Encrypt-and-MAC (E&amp;M) MAC-then-Encrypt (MtE) 这种模式（图2-12）先对消息进行MAC计算，然后将消息和MAC值组合在一起再进行加密，最终的加密值再发送给接收方。在HTTPS中，一般使用这种模式进行处理，比如AES-128-CBC#PKCS7-HMAC-SHA256模式。 Encrypt-then-MAC (EtM) 不管是Encrypt-and-MAC模式还是MAC-then-Encrypt模式，使用不当的话都会存在安全问题，目前建议使用Encrypt-then-MAC模式。需要强调的是，这三种模式使用者必须分别处理，一旦处理不当，就可能会存在安全风险，那有没有一种方法在底层直接提供加密和MAC运算呢？无须使用者分别处理加密和MAC运算，这就是接下来讲解的AEAD模式。 AEAD加密模式 CCM模式 GCM模式 ChaCha20-Poly1305 2.5.1 什么是消息验证码 # 在密码学应用中，很多情况下，传递的消息没有必要加密，只要确保消息是完整且没有被篡改即可 比如开发者开发了一组天气API，接口返回的数据并没有加密，原因可能如下 接口的数据并不重要，对隐私性要求不高 加密和解密过程很消耗性能 所以接口的设计目标仅仅是避免消息被篡改，读者可能说那很简单啊，接口消息通过Hash算法得到一个摘要值，摘要值和接口消息同时作为接口内容返回不就解决问题了吗？ 攻击者对消息进行拦截，同时修改接口消息和消息的摘要值然后发送给接收方，接收方收到消息后，对接口消息计算摘要值，然后与接收到的摘要值进行比较，如果相同，接收方认为消息是完整的。可实际呢？消息虽然是完整的，但被篡改了，或者说消息被伪装了，但对于接收方来说，仅仅通过摘要值无法验证消息是不是篡改了 消息验证码算法的特点 证明消息没有被篡改，这和Hash算法类似。 消息是正确的发送者发送的，也就是说消息是经过验证的 如何确保消息是特定人发送的呢？在通信双方可以维护同一个密钥，只有拥有密钥的通信双方才能生成和验证消息验证码，消息验证码算法需要一个密钥，这和对称加密算法是一样的，通信双方在消息传递之前需要获得同样的密钥。 2.5.2 MAC 算法的种类 # CBC-MAC算法 CBC-MAC算法从块密码算法的CBC分组模式演变而来，简单地说就是最后一个密文分组的值就是MAC值 HMAC算法 在HTTP中应用最多的MAC算法是HMAC算法 HMAC（Hash-based Message Authentication Code）算法使用Hash算法作为加密基元，HMAC结合Hash算法有多种变种，比如HMAC-SHA-1、HMAC-SHA256、HMAC-SHA512 读者不要误以为HMAC算法就是Hash算法加上一个密钥，HMAC算法只是基于Hash算法的，内部的实现还是相当复杂的 2.5.3 消息验证码算法实践 # 2.5.4 加密算法不能提供完整性 # 完整性的意思是消息没有被篡改，仅仅加密数据是无法保证数据完整性的，初听起来可能觉得很奇怪。攻击者如果没有密钥就无法破解原文，也就无法篡改，数据必然是完整的。遗憾的是攻击者虽然无法破解数据，但是可以修改密文的部分数据，然后发送给接收者，接收者通过密钥发现能够解密，但是解密出来的值实际上不是原文，消息已经被修改了，也就是说加密操作不能提供完整性。 hash算法可以作为消息验证码吗？ # 是的，哈希算法可以作为消息验证码（MAC）的一部分，但单独使用哈希算法并不能直接构成消息验证码。消息验证码（MAC）是一种用于验证消息完整性和真实性的技术，通常需要结合密钥来确保安全性。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="zh">
<title>深入浅出HTTPS：从原理到实战 | Penruins</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="/zh/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/">
<link rel="stylesheet" href="/book.min.26e661cf8028ea69ebe162050990c3a07de74e5bfe9389e880f2d6a7e5fa587c.css" >
  <script defer src="/fuse.min.js"></script>
  <script defer src="/zh.search.min.41d6857db2b1850e4b61eb17eb723d3a6d48c870cc1948033bf52af5e1ce2bdf.js" ></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/zh/"><span>Penruins</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>



  



  
    
  
    
  



<ul class="book-languages">
  <li>
    <input type="checkbox" id="languages" class="toggle" />
    <label for="languages" class="flex justify-between">
      <a role="button" class="flex align-center">
        <img src="/svg/translate.svg" class="book-icon" alt="Languages" />
        中文
      </a>
    </label>

    <ul>
      
      <li>
        <a href="/cn/">
          
        </a>
      </li>
      
      <li>
        <a href="/en/">
          English
        </a>
      </li>
      
    </ul>
  </li>
</ul>














  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Life</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/movies-log/" class="">观影记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/bilibili/" class="">bilibili</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/books/" class="">books</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/cycling/" class="">cycling</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/hiking/" class="">hiking</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/life-recommend/" class="">life recommand</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/learning-others-log/" class="">other learning</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/podcast/" class="">podcast</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/politics/" class="">politics</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/goal/" class="">goal</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/accumulation/" class="">accumulation</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/life/coffee/" class="">coffee</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Computer Science</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-855531983528655844a29f37632e7e30" class="toggle"  />
    <label for="section-855531983528655844a29f37632e7e30" class="flex justify-between">
      <a role="button" class="">Java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/java/" class="">java</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/mybatis/" class="">Mybatis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/java/jvm/" class="">jvm</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-recommend/" class="">推荐</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/computer-science-learning-log/" class="">学习记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/database/" class="">database</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/echarts/" class="">echarts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/github/" class="">github</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/ios/" class="">ios</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/job/" class="">job</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/mac/" class="">mac</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/raspberrypi/" class="">raspberry pi</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/security/" class="">security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/vue/" class="">vue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/algorithm/" class="">Algorithm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/computer-science/linux/" class="">linux</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Others</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/about-me/" class="">about me</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/others/english-learning/" class="">English Learning</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Books</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-70696d57febbe00561bcceac2d174d7c" class="toggle"  />
    <label for="section-70696d57febbe00561bcceac2d174d7c" class="flex justify-between">
      <a role="button" class="">Computer Science</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" class="">Java并发编程实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/java%E5%AE%9E%E6%88%98/" class="">Java实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="">Python神经网络编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="">Redis设计与实现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/" class="">Spring Cloud微服务：入门、实战与进阶</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E5%89%91%E6%8C%87offer/" class="">剑指Offer</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/" class="">深入浅出HTTPS：从原理到实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E6%94%B6%E5%89%B2-offer%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F/" class="">收割Offer：互联网大厂面经</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" class="">一本书讲透 ElasticSearch：原理、进阶与工程实践</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E7%AC%AC%E4%B8%89%E7%89%88/" class="">宏观经济学 第三版</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E7%BE%8E%E5%9B%BD%E5%9B%B0%E5%B1%80/" class="">美国困局</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E8%8B%B1%E4%BC%9F%E8%BE%BE-%E9%BB%84%E4%BB%81%E5%8B%8B%E4%B9%8B%E8%8A%AF/" class="">英伟达-黄仁勋之芯</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/zh/post/books/%E7%94%A8%E5%9C%B0%E5%9B%BE%E7%9C%8B%E6%87%82%E4%B8%96%E7%95%8C%E6%A0%BC%E5%B1%80/" class="">用地图看懂世界格局</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>深入浅出HTTPS：从原理到实战</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第1章-http介绍">第1章 HTTP介绍</a>
      <ul>
        <li><a href="#13-网络模型">1.3 网络模型</a></li>
        <li><a href="#14-协议安全分析">1.4 协议安全分析</a></li>
      </ul>
    </li>
    <li><a href="#第2章-密码学">第2章 密码学</a>
      <ul>
        <li><a href="#21-对于密码学的认知">2.1 对于密码学的认知</a></li>
        <li><a href="#22-随机数">2.2 随机数</a>
          <ul>
            <li><a href="#221-随机数的类型">2.2.1 随机数的类型</a></li>
            <li><a href="#222-随机数的工作原理">2.2.2 随机数的工作原理</a></li>
            <li><a href="#223-常见的随机数生成器">2.2.3 常见的随机数生成器</a></li>
            <li><a href="#224-密码学算法中的随机数">2.2.4 密码学算法中的随机数</a></li>
          </ul>
        </li>
        <li><a href="#23-hash算法">2.3 Hash算法</a>
          <ul>
            <li><a href="#231-加密基元">2.3.1 加密基元</a></li>
            <li><a href="#232-hash算法和密码学hash算法">2.3.2 Hash算法和密码学Hash算法</a></li>
            <li><a href="#233-密码学hash算法的特性">2.3.3 密码学Hash算法的特性</a></li>
            <li><a href="#234-hash算法的用途">2.3.4 Hash算法的用途</a></li>
            <li><a href="#235-什么是安全的密码学hash算法">2.3.5 什么是安全的密码学Hash算法</a></li>
            <li><a href="#236-密码学hash算法的分类">2.3.6 密码学Hash算法的分类</a></li>
          </ul>
        </li>
        <li><a href="#24-对称加密算法">2.4 对称加密算法</a>
          <ul>
            <li><a href="#241-流密码算法">2.4.1 流密码算法</a></li>
            <li><a href="#242-块密码算法">2.4.2 块密码算法</a></li>
            <li><a href="#243-填充标准">2.4.3 填充标准</a></li>
            <li><a href="#244-对称加密算法实践">2.4.4 对称加密算法实践</a></li>
          </ul>
        </li>
        <li><a href="#25-消息验证码">2.5 消息验证码</a>
          <ul>
            <li><a href="#251-什么是消息验证码">2.5.1 什么是消息验证码</a></li>
            <li><a href="#252-mac-算法的种类">2.5.2 MAC 算法的种类</a></li>
            <li><a href="#253-消息验证码算法实践">2.5.3 消息验证码算法实践</a></li>
            <li><a href="#254-加密算法不能提供完整性">2.5.4 加密算法不能提供完整性</a></li>
            <li><a href="#hash算法可以作为消息验证码吗">hash算法可以作为消息验证码吗？</a></li>
            <li><a href="#接收方怎么验证消息验证码">接收方怎么验证消息验证码？</a></li>
            <li><a href="#发送方什么时候非接收方提供密钥的">发送方什么时候非接收方提供密钥的？</a></li>
          </ul>
        </li>
        <li><a href="#26-公开密钥算法非对称加密">2.6 公开密钥算法(非对称加密)</a>
          <ul>
            <li><a href="#261-理解rsa的内部结构">2.6.1 理解RSA的内部结构</a></li>
            <li><a href="#262-pkcs标准">2.6.2 PKCS标准</a></li>
            <li><a href="#263-rsa加密算法的应用场景">2.6.3 RSA加密算法的应用场景</a></li>
            <li><a href="#264-rsa加密算法实践">2.6.4 RSA加密算法实践</a></li>
          </ul>
        </li>
        <li><a href="#27-密钥">2.7 密钥</a>
          <ul>
            <li><a href="#271-生成密钥">2.7.1 生成密钥</a></li>
            <li><a href="#272-口令和peb算法">2.7.2 口令和PEB算法</a></li>
            <li><a href="#273-密钥存储和传输">2.7.3 密钥存储和传输</a></li>
          </ul>
        </li>
        <li><a href="#28-密钥协商算法">2.8 密钥协商算法</a>
          <ul>
            <li><a href="#281-rsa密钥协商算法">2.8.1 RSA密钥协商算法</a></li>
            <li><a href="#282-dh密钥协商算法">2.8.2 DH密钥协商算法</a></li>
            <li><a href="#283-dh算法分类">2.8.3 DH算法分类</a></li>
            <li><a href="#284-dh密钥协商算法实践">2.8.4 DH密钥协商算法实践</a></li>
          </ul>
        </li>
        <li><a href="#29-椭圆曲线密码学">2.9 椭圆曲线密码学</a>
          <ul>
            <li><a href="#291-ecc算法的基本模型">2.9.1 ECC算法的基本模型</a></li>
            <li><a href="#292-使用openssl了解命名曲线">2.9.2 使用OpenSSL了解命名曲线</a></li>
            <li><a href="#293-ecdh协商算法">2.9.3 ECDH协商算法</a></li>
            <li><a href="#294-命名曲线">2.9.4 命名曲线</a></li>
          </ul>
        </li>
        <li><a href="#210-数字签名">2.10 数字签名</a>
          <ul>
            <li><a href="#2101-数字签名的用途">2.10.1 数字签名的用途</a></li>
            <li><a href="#2102-数字签名的流程">2.10.2 数字签名的流程</a></li>
            <li><a href="#2103-rsa数字签名算法">2.10.3 RSA数字签名算法</a></li>
            <li><a href="#2104-rsa数字签名实践">2.10.4 RSA数字签名实践</a></li>
          </ul>
        </li>
        <li><a href="#211-dsa数字签名算法">2.11 DSA数字签名算法</a>
          <ul>
            <li><a href="#防篡改和防伪造的区别是什么">防篡改和防伪造的区别是什么</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第3章-宏观理解tls">第3章 宏观理解TLS</a>
      <ul>
        <li><a href="#31-tlsssl-协议综述">3.1 TLS/SSL 协议综述</a></li>
        <li><a href="#32-tlsssl协议背后的算法">3.2 TLS/SSL协议背后的算法</a>
          <ul>
            <li><a href="#321-加密算法和mac算法">3.2.1 加密算法和MAC算法</a></li>
            <li><a href="#322-密钥协商算法">3.2.2 密钥协商算法</a></li>
            <li><a href="#323-前向安全性">3.2.3 前向安全性</a></li>
            <li><a href="#324-密钥衍生算法">3.2.4 密钥衍生算法</a>
              <ul>
                <li><a href="#密钥衍生算法在https是怎么应用的">密钥衍生算法在HTTPS是怎么应用的？</a></li>
                <li><a href="#在https中会使用密钥衍生算法生成哪些密钥能具体列举出来吗">在HTTPS中，会使用密钥衍生算法生成哪些密钥，能具体列举出来吗？</a></li>
              </ul>
            </li>
            <li><a href="#325-中间人攻击">3.2.5 中间人攻击</a>
              <ul>
                <li><a href="#客户端和服务器之间只传递预主密钥密钥块是两边分别计算出来的是这样吗">客户端和服务器之间只传递预主密钥，密钥块是两边分别计算出来的，是这样吗</a></li>
              </ul>
            </li>
            <li><a href="#326-pki">3.2.6 PKI</a></li>
          </ul>
        </li>
        <li><a href="#33-https总结">3.3 HTTPS总结</a>
          <ul>
            <li><a href="#331-握手">3.3.1 握手</a>
              <ul>
                <li><a href="#1-认证">1 认证</a></li>
                <li><a href="#2-密码套件协商">2 密码套件协商</a></li>
                <li><a href="#3-密钥协商">3 密钥协商</a></li>
                <li><a href="#4-握手消息完整性校验">4 握手消息完整性校验</a>
                  <ul>
                    <li><a href="#finished-消息包含的哈希值是怎么计算的以及是怎么比较的">Finished 消息包含的哈希值是怎么计算的，以及是怎么比较的</a></li>
                  </ul>
                </li>
                <li><a href="#使用charles来解密https请求内容的原理是什么">使用Charles来解密https请求内容的原理是什么？</a></li>
                <li><a href="#在使用charles进行https抓包的时候有些接口会连接失败这是什么原因">在使用charles进行https抓包的时候，有些接口会连接失败，这是什么原因</a></li>
              </ul>
            </li>
            <li><a href="#332-加密">3.3.2 加密</a></li>
          </ul>
        </li>
        <li><a href="#34-实施https网站的必备条件">3.4 实施HTTPS网站的必备条件</a>
          <ul>
            <li><a href="#341-证书和密钥对">3.4.1 证书和密钥对</a></li>
            <li><a href="#342-部署和配置https网站">3.4.2 部署和配置HTTPS网站</a></li>
            <li><a href="#343-全站https策略">3.4.3 全站HTTPS策略</a></li>
          </ul>
        </li>
        <li><a href="#35-从用户的角度看https">3.5 从用户的角度看HTTPS</a>
          <ul>
            <li><a href="#351-绿色小锁图标">3.5.1 绿色小锁图标</a></li>
            <li><a href="#352-tlsssl握手失败">3.5.2 TLS/SSL握手失败</a></li>
            <li><a href="#353-混合内容">3.5.3 混合内容</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第4章-选择https的必要性和疑惑">第4章 选择HTTPS的必要性和疑惑</a></li>
    <li><a href="#第5章-快速搭建一个https网站">第5章 快速搭建一个HTTPS网站</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><ul>
<li>2015年百度搜索引擎完成其历史上最大的系统性升级——全面由HTTP升级到HTTPS</li>
<li>2016年苹果公告要求App Store中的所有应用在2017年1月1日之后都必须使用HTTPS加密连接</li>
<li>2017年1月9日微信上线小程序后，要求开发者的所有服务端请求必须为HTTPS</li>
<li>同时Google已调整搜索引擎算法，让采用HTTPS的网站在搜索结果中排名更靠前，并宣布从2018年7月开始所有的HTTP网站将标记为“不安全”</li>
</ul>
<h2 id="第1章-http介绍">
  第1章 HTTP介绍
  <a class="anchor" href="#%e7%ac%ac1%e7%ab%a0-http%e4%bb%8b%e7%bb%8d">#</a>
</h2>
<ul>
<li>HTTP的特点
<ul>
<li><strong>客户端/服务器模型</strong>
<ul>
<li>客户端和服务器是否正确传输依赖于TCP这个协议。</li>
</ul>
</li>
<li><strong>HTTP是无状态的</strong>
<ul>
<li>所谓的无状态就是每次请求完成后，不会在客户端和服务器上保存任何的信息，对于客户端和服务器来说，根本不知道上一次请求的信息是什么，甚至不知道本次连接的对端是不是上次连接的那一端，它的生命周期随着TCP/IP连接的关闭结束了</li>
<li>无状态的设计已经不能适应新的情况，为了保持状态，出现了Cookie和Session技术，但是Cookie技术设计得非常不严谨，引发了很多安全问题。</li>
<li>介绍下Cookie是如何进行会话保持的，客户端第一次请求完成后，服务器会发送Cookie信息到客户端的计算机上，客户端下次请求的时候会携带该Cookie信息，这样服务器就知道该用户就是上一次请求的用户了。</li>
</ul>
</li>
<li><strong>HTTP是跨平台的</strong>
<ul>
<li>通过上面的讲解，读者知道HTTP就是具备一定规则的纯文本信息，任何开发语言都可以实现HTTP或者基于HTTP进行开发，开发出来的软件也很容易移植，受系统环境的影响非常少。</li>
</ul>
</li>
<li><strong>HTTP用途很广泛</strong></li>
</ul>
</li>
</ul>
<h3 id="13-网络模型">
  1.3 网络模型
  <a class="anchor" href="#13-%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b">#</a>
</h3>
<ul>
<li>HTTP是应用层协议，应用层协议是TCP/IP的一部分</li>
<li>OSI模型是一个通用的网络协议标准，但实际使用的标准却是TCP/IP标准，TCP/IP包含的不仅仅是TCP或者IP，它是一个协议族，网络应用开发都需要掌握TCP/IP。</li>
<li>TCP/IP有两个最大的特点，分别是分层和封包/拆包机制</li>
<li>每一层和它的上下层都有标准的接口规范，每一层无须关心上下层是如何工作的，它只关心上下层是否正确基于规范实现了接口</li>
<li><strong>应用层</strong>
<ul>
<li>如果没有应用层，那么网络中传输的数据没有任何意义，因为人类无法理解数据的含义。而有了应用层，软件就能解释应用层数据的含义。在Web应用中，有了HTTP和HTML标准，浏览器才能呈现对用户有意义的内容。</li>
<li>应用层协议有很多，比如HTTP、FTP、邮件协议，开发者开发的软件一般都是应用层协议软件。</li>
</ul>
</li>
<li><strong>传输层</strong></li>
<li><strong>网络层</strong>
<ul>
<li>网络层主要是IP这个协议，客户端和服务器传输的时候，会经过很多节点，IP就是选择一条最优的路径。每个终端上都有一张路由表，路由表负责将数据传输到下一个节点，下一个节点再传输到下下个节点，最终到达目的地址。</li>
</ul>
</li>
<li><strong>链路层</strong>
<ul>
<li>应用层、传输层、网络层都是虚拟的，只有链路层才是实体设备，包括光纤、网卡等设备。基于这些设备，数据最终才能到达终端。</li>
</ul>
</li>
<li>接下来简单描述封包/拆包机制，对于客户端请求来说，传输层接收到应用层消息后，在HTTP数据包前面增加TCP包头，然后发送给网络层；网络层在TCP数据包前面加上IP包头发送给链路层；链路层在IP数据包前面加上以太网包头；最终服务器接收到完整的数据包。</li>
<li>然后服务器进行拆包：首先在网络层去除链路层包头；在传输层去除IP包头；在应用层去除TCP包头；最终得到完整的HTTP应用层数据。</li>
</ul>
<h3 id="14-协议安全分析">
  1.4 协议安全分析
  <a class="anchor" href="#14-%e5%8d%8f%e8%ae%ae%e5%ae%89%e5%85%a8%e5%88%86%e6%9e%90">#</a>
</h3>
<ul>
<li>协议不安全的根本原因
<ul>
<li><strong>数据没有加密</strong></li>
<li><strong>无法验证身份</strong></li>
<li><strong>数据易篡改</strong></li>
</ul>
</li>
</ul>
<h2 id="第2章-密码学">
  第2章 密码学
  <a class="anchor" href="#%e7%ac%ac2%e7%ab%a0-%e5%af%86%e7%a0%81%e5%ad%a6">#</a>
</h2>
<h3 id="21-对于密码学的认知">
  2.1 对于密码学的认知
  <a class="anchor" href="#21-%e5%af%b9%e4%ba%8e%e5%af%86%e7%a0%81%e5%ad%a6%e7%9a%84%e8%ae%a4%e7%9f%a5">#</a>
</h3>
<ul>
<li>OpenSSL
<ul>
<li>OpenSSL命令行功能非常强大，有很多的子命令和参数，如果不理解密码学算法，根本无法理解子命令和参数的含义，这是难学习的根本原因，也说明学习OpenSSL之前必须先掌握密码学算法。</li>
<li>不同版本的OpenSSL命令行工具在使用的时候有一些差别，同样一条命令，读者会发现在特定版本下可能无法正确运行。</li>
<li>OpenSSL命令行的帮助手册和文档描写得不是很通俗，很难进行系统的学习。</li>
<li>完成同样一个操作，OpenSSL命令行有许多方法实现，这可能会干扰读者的学习。</li>
</ul>
</li>
</ul>
<h3 id="22-随机数">
  2.2 随机数
  <a class="anchor" href="#22-%e9%9a%8f%e6%9c%ba%e6%95%b0">#</a>
</h3>
<ul>
<li>而对于PRNG来说，内部状态的数值来自于模拟的数值，称为种子（seed）。随机数生成器每次生成随机数的时候，内部状态的值都会变化，这样才能产生不一样的随机数，如果每次熵和种子是一样的，生成的随机数也是相同的，所以熵和种子对于随机数生成器非常重要。</li>
</ul>
<h4 id="221-随机数的类型">
  2.2.1 随机数的类型
  <a class="anchor" href="#221-%e9%9a%8f%e6%9c%ba%e6%95%b0%e7%9a%84%e7%b1%bb%e5%9e%8b">#</a>
</h4>
<ul>
<li>真正的随机数生成器
<ul>
<li>需要从物理设备获取</li>
</ul>
</li>
<li>伪随机数生成器
<ul>
<li>通过算法获取</li>
</ul>
</li>
<li>密码学伪随机数生成器
<ul>
<li>用于密码学</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>随机数的特性
<ul>
<li>效率</li>
<li>随机性</li>
<li>不可预测性</li>
<li>不可重现性</li>
</ul>
</li>
</ul>
<h4 id="222-随机数的工作原理">
  2.2.2 随机数的工作原理
  <a class="anchor" href="#222-%e9%9a%8f%e6%9c%ba%e6%95%b0%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86">#</a>
</h4>
<h4 id="223-常见的随机数生成器">
  2.2.3 常见的随机数生成器
  <a class="anchor" href="#223-%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9a%8f%e6%9c%ba%e6%95%b0%e7%94%9f%e6%88%90%e5%99%a8">#</a>
</h4>
<h4 id="224-密码学算法中的随机数">
  2.2.4 密码学算法中的随机数
  <a class="anchor" href="#224-%e5%af%86%e7%a0%81%e5%ad%a6%e7%ae%97%e6%b3%95%e4%b8%ad%e7%9a%84%e9%9a%8f%e6%9c%ba%e6%95%b0">#</a>
</h4>
<h3 id="23-hash算法">
  2.3 Hash算法
  <a class="anchor" href="#23-hash%e7%ae%97%e6%b3%95">#</a>
</h3>
<h4 id="231-加密基元">
  2.3.1 加密基元
  <a class="anchor" href="#231-%e5%8a%a0%e5%af%86%e5%9f%ba%e5%85%83">#</a>
</h4>
<ul>
<li>加密基元就是一些基础的密码学算法，通过它们才能够构建更多的密码学算法、协议、应用程序</li>
</ul>
<h4 id="232-hash算法和密码学hash算法">
  2.3.2 Hash算法和密码学Hash算法
  <a class="anchor" href="#232-hash%e7%ae%97%e6%b3%95%e5%92%8c%e5%af%86%e7%a0%81%e5%ad%a6hash%e7%ae%97%e6%b3%95">#</a>
</h4>
<h4 id="233-密码学hash算法的特性">
  2.3.3 密码学Hash算法的特性
  <a class="anchor" href="#233-%e5%af%86%e7%a0%81%e5%ad%a6hash%e7%ae%97%e6%b3%95%e7%9a%84%e7%89%b9%e6%80%a7">#</a>
</h4>
<ul>
<li>由于Hash算法有很多功能，所以Hash算法有多种称呼，比如<strong>摘要算法（Message Digest Algorithms）</strong>、<strong>单向散列函数（Cryptographic One-way Hash Functions）</strong>。输出值也有多种称呼，比如<strong>摘要值</strong>、<strong>散列</strong>、<strong>指纹</strong>。读者看到这些名词的时候，都可以理解为Hash算法</li>
<li>密码学Hash算法的主要特性
<ul>
<li>相同的消息总是能得到同样的摘要值，特定的Hash算法，不管消息长度是多少，最终的摘要值<strong>长度是相同的</strong>。</li>
<li>不管多长的消息，<strong>Hash运算非常快速</strong>，这是非常重要的特性。</li>
<li>通过摘要值很难逆向计算出原始消息，Hash算法具备单向性，摘要值是<strong>不可逆</strong>的，这也是非常重要的特性。为了逆向计算出原始消息，唯一的方法就是采用暴力攻击、字典攻击、彩虹表，对不同的消息组合进行迭代运算，运算的结果如果匹配该消息的摘要值，表示该Hash算法不应该用于密码学。</li>
<li>原始消息一旦修改，即使是<strong>很轻微的修改，最终的摘要值也会产生变化</strong>。</li>
<li>很难找出两个不同的消息，并且它们的摘要值是相同的。</li>
</ul>
</li>
</ul>
<h4 id="234-hash算法的用途">
  2.3.4 Hash算法的用途
  <a class="anchor" href="#234-hash%e7%ae%97%e6%b3%95%e7%9a%84%e7%94%a8%e9%80%94">#</a>
</h4>
<ul>
<li>文件比较</li>
<li>身份校验</li>
</ul>
<h4 id="235-什么是安全的密码学hash算法">
  2.3.5 什么是安全的密码学Hash算法
  <a class="anchor" href="#235-%e4%bb%80%e4%b9%88%e6%98%af%e5%ae%89%e5%85%a8%e7%9a%84%e5%af%86%e7%a0%81%e5%ad%a6hash%e7%ae%97%e6%b3%95">#</a>
</h4>
<ul>
<li>强抗碰撞性（Collision Resistance）</li>
<li>弱抗碰撞性（Second pre-image Resistance）</li>
<li>单向性（Pre-image Resistance）</li>
</ul>
<h4 id="236-密码学hash算法的分类">
  2.3.6 密码学Hash算法的分类
  <a class="anchor" href="#236-%e5%af%86%e7%a0%81%e5%ad%a6hash%e7%ae%97%e6%b3%95%e7%9a%84%e5%88%86%e7%b1%bb">#</a>
</h4>
<ul>
<li><strong>MD5</strong>
<ul>
<li>MD5是一种比较常用的Hash算法，摘要值长度固定是128比特，MD5算法目前被证明已经不安全了，MD5算法违反了强抗碰撞性原则，但是还没有破坏单一性原则。</li>
<li>理论上经过2^80次运算就能产生碰撞，但目前最快只要经过2^63次运算就能破坏强抗碰撞性。</li>
</ul>
</li>
<li><strong>SHA</strong>
<ul>
<li>SHA（Secure Hash Algorithms）算法是美国国家标准与技术研究院（NIST）指定的算法，SHA算法不是一个算法，而是一组算法，主要分为三类算法。
<ul>
<li>SHA-1</li>
<li>SHA-2</li>
<li>SHA-3</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="24-对称加密算法">
  2.4 对称加密算法
  <a class="anchor" href="#24-%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95">#</a>
</h3>
<ul>
<li>建议使用<strong>AES算法</strong>，该算法是对称加密算法的标准算法
<ul>
<li>美国国家标准与技术研究院（National Institute of Standards and Technology, NIST）对众多的对称加密算法进行了考核，从安全性和效率进行了多方面评测，最终选取Rijndael算法作为对称加密算法的标准。以Rijndael算法为原型，创建了AES（Advanced Encryption Standard）算法，AES就是最终的对称加密算法标准。Rijndael算法和AES算法略微不同，但在理解的时候可以认为是相同的算法。</li>
</ul>
</li>
<li><strong>流密码算法</strong></li>
<li><strong>块密码算法</strong>
<ul>
<li>迭代模式
<ul>
<li>**ECB模式（Electronic Codebook）**是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。
<ul>
<li>ECB模式（Electronic Codebook）是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。</li>
</ul>
</li>
<li>**CBC模式（Cipher Block Chaining）**是比较常见的一种迭代模式，解决了ECB模式的安全问题。
<ul>
<li>迭代运算数据块不能并行处理，只有处理完第n个数据块，才能继续处理第n+1个数据块。</li>
</ul>
</li>
<li>**CTR模式（counter）**在迭代的时候，相当于是一个流密码的运行模式。每次迭代运算的时候要生成一个密钥流（keystream），生成密钥流的方法可以是任意的，但是各个密钥流之间是有关系的，最简单的方式就是密钥流不断递增，所以才叫作计数器模式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="241-流密码算法">
  2.4.1 流密码算法
  <a class="anchor" href="#241-%e6%b5%81%e5%af%86%e7%a0%81%e7%ae%97%e6%b3%95">#</a>
</h4>
<h4 id="242-块密码算法">
  2.4.2 块密码算法
  <a class="anchor" href="#242-%e5%9d%97%e5%af%86%e7%a0%81%e7%ae%97%e6%b3%95">#</a>
</h4>
<h4 id="243-填充标准">
  2.4.3 填充标准
  <a class="anchor" href="#243-%e5%a1%ab%e5%85%85%e6%a0%87%e5%87%86">#</a>
</h4>
<h4 id="244-对称加密算法实践">
  2.4.4 对称加密算法实践
  <a class="anchor" href="#244-%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95%e5%ae%9e%e8%b7%b5">#</a>
</h4>
<h3 id="25-消息验证码">
  2.5 消息验证码
  <a class="anchor" href="#25-%e6%b6%88%e6%81%af%e9%aa%8c%e8%af%81%e7%a0%81">#</a>
</h3>
<ul>
<li>MAC值一般和原始消息一起传输，原始消息可以选择加密，也可以选择不加密，通信双方会以相同的方式生成MAC值，然后进行比较</li>
<li>CBC-MAC算法</li>
<li>HMAC算法 Hash-based Message Authentication Code</li>
<li>加密算法不能提供完整性，加密的同时必须引入MAC算法避免消息被篡改</li>
<li>使用者结合对称加密算法和MAC算法，提供机密性和完整性的模式也叫作Authenticated Encryption（AE）加密模式，主要有三种
<ul>
<li>Encrypt-and-MAC (E&amp;M)</li>
<li>MAC-then-Encrypt (MtE)
<ul>
<li>这种模式（图2-12）先对消息进行MAC计算，然后将消息和MAC值组合在一起再进行加密，最终的加密值再发送给接收方。在HTTPS中，一般使用这种模式进行处理，比如AES-128-CBC#PKCS7-HMAC-SHA256模式。</li>
</ul>
</li>
<li>Encrypt-then-MAC (EtM)</li>
</ul>
</li>
<li>不管是Encrypt-and-MAC模式还是MAC-then-Encrypt模式，使用不当的话都会存在安全问题，目前建议使用Encrypt-then-MAC模式。需要强调的是，这三种模式使用者必须分别处理，一旦处理不当，就可能会存在安全风险，那有没有一种方法在底层直接提供加密和MAC运算呢？无须使用者分别处理加密和MAC运算，这就是接下来讲解的AEAD模式。</li>
<li>AEAD加密模式
<ul>
<li>CCM模式</li>
<li>GCM模式</li>
<li>ChaCha20-Poly1305</li>
</ul>
</li>
</ul>
<h4 id="251-什么是消息验证码">
  2.5.1 什么是消息验证码
  <a class="anchor" href="#251-%e4%bb%80%e4%b9%88%e6%98%af%e6%b6%88%e6%81%af%e9%aa%8c%e8%af%81%e7%a0%81">#</a>
</h4>
<ul>
<li>在密码学应用中，很多情况下，传递的消息没有必要加密，只要确保消息是完整且没有被篡改即可</li>
<li>比如开发者开发了一组天气API，接口返回的数据并没有加密，原因可能如下
<ul>
<li>接口的数据并不重要，对隐私性要求不高</li>
<li>加密和解密过程很消耗性能</li>
</ul>
</li>
<li>所以接口的设计目标仅仅是避免消息被篡改，读者可能说那很简单啊，接口消息通过Hash算法得到一个摘要值，摘要值和接口消息同时作为接口内容返回不就解决问题了吗？
<ul>
<li>攻击者对消息进行拦截，同时修改接口消息和消息的摘要值然后发送给接收方，接收方收到消息后，对接口消息计算摘要值，然后与接收到的摘要值进行比较，如果相同，接收方认为消息是完整的。可实际呢？消息虽然是完整的，但被篡改了，或者说消息被伪装了，但对于接收方来说，仅仅通过摘要值无法验证消息是不是篡改了</li>
</ul>
</li>
<li>消息验证码算法的特点
<ul>
<li>证明消息没有被篡改，这和Hash算法类似。</li>
<li>消息是正确的发送者发送的，也就是说消息是经过验证的</li>
</ul>
</li>
<li>如何确保消息是特定人发送的呢？在通信双方可以维护同一个密钥，只有拥有密钥的通信双方才能生成和验证消息验证码，消息验证码算法需要一个密钥，这和对称加密算法是一样的，通信双方在消息传递之前需要获得同样的密钥。</li>
</ul>
<h4 id="252-mac-算法的种类">
  2.5.2 MAC 算法的种类
  <a class="anchor" href="#252-mac-%e7%ae%97%e6%b3%95%e7%9a%84%e7%a7%8d%e7%b1%bb">#</a>
</h4>
<ul>
<li>CBC-MAC算法
<ul>
<li>CBC-MAC算法从块密码算法的CBC分组模式演变而来，简单地说就是最后一个密文分组的值就是MAC值</li>
</ul>
</li>
<li>HMAC算法
<ul>
<li>在HTTP中应用最多的MAC算法是HMAC算法</li>
<li>HMAC（Hash-based Message Authentication Code）算法使用Hash算法作为加密基元，HMAC结合Hash算法有多种变种，比如HMAC-SHA-1、HMAC-SHA256、HMAC-SHA512</li>
<li>读者不要误以为HMAC算法就是Hash算法加上一个密钥，HMAC算法只是基于Hash算法的，内部的实现还是相当复杂的</li>
</ul>
</li>
</ul>
<h4 id="253-消息验证码算法实践">
  2.5.3 消息验证码算法实践
  <a class="anchor" href="#253-%e6%b6%88%e6%81%af%e9%aa%8c%e8%af%81%e7%a0%81%e7%ae%97%e6%b3%95%e5%ae%9e%e8%b7%b5">#</a>
</h4>
<h4 id="254-加密算法不能提供完整性">
  2.5.4 加密算法不能提供完整性
  <a class="anchor" href="#254-%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95%e4%b8%8d%e8%83%bd%e6%8f%90%e4%be%9b%e5%ae%8c%e6%95%b4%e6%80%a7">#</a>
</h4>
<ul>
<li>完整性的意思是消息没有被篡改，仅仅加密数据是无法保证数据完整性的，初听起来可能觉得很奇怪。攻击者如果没有密钥就无法破解原文，也就无法篡改，数据必然是完整的。遗憾的是攻击者虽然无法破解数据，但是可以修改密文的部分数据，然后发送给接收者，接收者通过密钥发现能够解密，但是解密出来的值实际上不是原文，消息已经被修改了，也就是说加密操作不能提供完整性。</li>
</ul>
<h4 id="hash算法可以作为消息验证码吗">
  hash算法可以作为消息验证码吗？
  <a class="anchor" href="#hash%e7%ae%97%e6%b3%95%e5%8f%af%e4%bb%a5%e4%bd%9c%e4%b8%ba%e6%b6%88%e6%81%af%e9%aa%8c%e8%af%81%e7%a0%81%e5%90%97">#</a>
</h4>
<p>是的，哈希算法可以作为消息验证码（MAC）的一部分，但单独使用哈希算法并不能直接构成消息验证码。消息验证码（MAC）是一种用于验证消息<strong>完整性</strong>和<strong>真实性</strong>的技术，通常需要结合密钥来确保安全性。</p>
<p>哈希算法与MAC的区别</p>
<ul>
<li><strong>哈希算法</strong>：如SHA-256、MD5等，用于生成固定长度的哈希值，确保数据完整性，<strong>但不涉及密钥，无法防止篡改</strong>。</li>
<li><strong>消息验证码（MAC）</strong>：结合哈希算法和密钥，生成一个与消息和密钥相关的验证码，确保消息未被篡改且来自可信来源。</li>
</ul>
<p>使用哈希算法构建MAC</p>
<p>常见的方法是<strong>HMAC（Hash-based Message Authentication Code）</strong>，它通过以下步骤生成MAC：</p>
<ol>
<li>将密钥与一个固定值（如<code>ipad</code>）异或，生成<code>k_ipad</code>。</li>
<li>将<code>k_ipad</code>与消息拼接，计算哈希值。</li>
<li>将密钥与另一个固定值（如<code>opad</code>）异或，生成<code>k_opad</code>。</li>
<li>将<code>k_opad</code>与步骤2的哈希值拼接，再次计算哈希值，得到最终的MAC。</li>
</ol>
<p>示例</p>
<p>假设使用SHA-256和密钥<code>key</code>，消息为<code>message</code>，HMAC生成过程如下：</p>
<ol>
<li>生成<code>k_ipad</code>和<code>k_opad</code>。</li>
<li>计算<code>hash(k_ipad + message)</code>。</li>
<li>计算<code>hash(k_opad + hash(k_ipad + message))</code>，得到MAC。</li>
</ol>
<p>总结</p>
<p>哈希算法可以作为MAC的基础，但单独使用无法提供完整的安全性。HMAC等结合密钥的方法才能确保消息的完整性和真实性。</p>
<h4 id="接收方怎么验证消息验证码">
  接收方怎么验证消息验证码？
  <a class="anchor" href="#%e6%8e%a5%e6%94%b6%e6%96%b9%e6%80%8e%e4%b9%88%e9%aa%8c%e8%af%81%e6%b6%88%e6%81%af%e9%aa%8c%e8%af%81%e7%a0%81">#</a>
</h4>
<p>接收方验证消息验证码（MAC）的过程需要确保消息的完整性和真实性。以下是验证步骤的详细说明：</p>
<hr>
<p><strong>验证过程</strong></p>
<ol>
<li>
<p><strong>接收消息和MAC</strong>：</p>
<ul>
<li>接收方从发送方获取消息（明文）和对应的MAC值。</li>
</ul>
</li>
<li>
<p><strong>重新计算MAC</strong>：</p>
<ul>
<li>接收方使用与发送方相同的<strong>密钥</strong>和<strong>哈希算法</strong>（如HMAC-SHA256），对接收到的消息重新计算MAC值。</li>
</ul>
</li>
<li>
<p><strong>比较MAC值</strong>：</p>
<ul>
<li>将接收方计算出的MAC值与发送方提供的MAC值进行比较。</li>
<li>如果两者一致，说明消息未被篡改且来自可信来源。</li>
<li>如果不一致，说明消息可能被篡改或来源不可信。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>具体步骤示例</strong></p>
<p>假设使用HMAC-SHA256算法，密钥为<code>key</code>，消息为<code>message</code>，发送方提供的MAC值为<code>received_mac</code>。</p>
<ol>
<li>
<p><strong>接收方重新计算MAC</strong>：</p>
<ul>
<li>使用HMAC-SHA256算法，输入密钥<code>key</code>和消息<code>message</code>，计算出新的MAC值，记为<code>computed_mac</code>。</li>
</ul>
</li>
<li>
<p><strong>比较MAC值</strong>：</p>
<ul>
<li>比较<code>computed_mac</code>和<code>received_mac</code>：
<ul>
<li>如果<code>computed_mac == received_mac</code>，验证通过。</li>
<li>如果<code>computed_mac != received_mac</code>，验证失败。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>注意事项</strong></p>
<ol>
<li>
<p><strong>密钥的安全性</strong>：</p>
<ul>
<li>密钥必须通过安全渠道共享，且只有发送方和接收方知道。如果密钥泄露，攻击者可以伪造MAC。</li>
</ul>
</li>
<li>
<p><strong>哈希算法的选择</strong>：</p>
<ul>
<li>使用安全的哈希算法（如SHA-256、SHA-3），避免使用已被破解的算法（如MD5、SHA-1）。</li>
</ul>
</li>
<li>
<p><strong>防止重放攻击</strong>：</p>
<ul>
<li>MAC只能验证消息的完整性和真实性，但不能防止重放攻击。如果需要防止重放攻击，可以结合时间戳或序列号。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>伪代码示例</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> hmac
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> hashlib
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">verify_mac</span>(message, received_mac, key):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 重新计算MAC</span>
</span></span><span style="display:flex;"><span>    computed_mac <span style="color:#f92672">=</span> hmac<span style="color:#f92672">.</span>new(key<span style="color:#f92672">.</span>encode(), message<span style="color:#f92672">.</span>encode(), hashlib<span style="color:#f92672">.</span>sha256)<span style="color:#f92672">.</span>hexdigest()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 比较MAC值</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> computed_mac <span style="color:#f92672">==</span> received_mac:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>  <span style="color:#75715e"># 验证通过</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>  <span style="color:#75715e"># 验证失败</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 示例</span>
</span></span><span style="display:flex;"><span>message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello, World!&#34;</span>
</span></span><span style="display:flex;"><span>received_mac <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e&#34;</span>
</span></span><span style="display:flex;"><span>key <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;secret_key&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> verify_mac(message, received_mac, key):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;MAC验证成功：消息未被篡改。&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;MAC验证失败：消息可能被篡改或来源不可信。&#34;</span>)
</span></span></code></pre></div><hr>
<p><strong>总结</strong></p>
<p>接收方通过重新计算MAC并与接收到的MAC值进行比较来验证消息的完整性和真实性。这一过程依赖于共享密钥的安全性以及哈希算法的强度。</p>
<h4 id="发送方什么时候非接收方提供密钥的">
  发送方什么时候非接收方提供密钥的？
  <a class="anchor" href="#%e5%8f%91%e9%80%81%e6%96%b9%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e9%9d%9e%e6%8e%a5%e6%94%b6%e6%96%b9%e6%8f%90%e4%be%9b%e5%af%86%e9%92%a5%e7%9a%84">#</a>
</h4>
<p>发送方和接收方之间的<strong>密钥共享</strong>是消息验证码（MAC）安全性的核心。密钥必须在通信开始之前通过<strong>安全渠道</strong>共享，且不能被第三方获取。以下是密钥共享的常见方式和时机：</p>
<hr>
<p><strong>1. 预先共享密钥（Pre-shared Key, PSK）</strong></p>
<ul>
<li><strong>时机</strong>：在通信开始之前，发送方和接收方通过安全的线下或线上渠道共享密钥。</li>
<li><strong>方式</strong>：
<ul>
<li>线下交换：面对面交换密钥（如写在纸上或通过硬件设备）。</li>
<li>安全通信协议：通过安全的通信协议（如TLS/SSL）在线交换密钥。</li>
</ul>
</li>
<li><strong>适用场景</strong>：
<ul>
<li>小规模系统或固定设备之间的通信（如物联网设备）。</li>
<li>需要长期使用的密钥。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2. 密钥协商协议</strong></p>
<ul>
<li><strong>时机</strong>：在通信开始时，通过密钥协商协议动态生成共享密钥。</li>
<li><strong>方式</strong>：
<ul>
<li>使用<strong>Diffie-Hellman密钥交换</strong>等协议，在不安全的信道中安全地生成共享密钥。</li>
<li>结合公钥加密（如RSA）确保密钥交换的安全性。</li>
</ul>
</li>
<li><strong>适用场景</strong>：
<ul>
<li>需要动态生成密钥的场景（如即时通信、HTTPS）。</li>
<li>大规模分布式系统。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>3. 基于公钥基础设施（PKI）的密钥分发</strong></p>
<ul>
<li><strong>时机</strong>：在通信开始时，通过公钥加密技术分发密钥。</li>
<li><strong>方式</strong>：
<ul>
<li>发送方使用接收方的公钥加密密钥，接收方使用自己的私钥解密。</li>
<li>结合数字证书验证公钥的真实性。</li>
</ul>
</li>
<li><strong>适用场景</strong>：
<ul>
<li>需要高安全性的场景（如银行交易、政府通信）。</li>
<li>大规模系统中身份验证和密钥分发。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>4. 密钥派生</strong></p>
<ul>
<li><strong>时机</strong>：在通信过程中，通过主密钥派生出会话密钥。</li>
<li><strong>方式</strong>：
<ul>
<li>使用密钥派生函数（如HKDF）从主密钥派生出新的密钥。</li>
<li>主密钥可以通过预先共享或密钥协商获得。</li>
</ul>
</li>
<li><strong>适用场景</strong>：
<ul>
<li>需要频繁更换密钥的场景（如实时通信）。</li>
<li>增强密钥安全性。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>密钥共享的安全性要求</strong></p>
<ol>
<li><strong>保密性</strong>：
<ul>
<li>密钥在传输和存储过程中必须保密，不能被第三方获取。</li>
</ul>
</li>
<li><strong>完整性</strong>：
<ul>
<li>密钥在传输过程中不能被篡改。</li>
</ul>
</li>
<li><strong>真实性</strong>：
<ul>
<li>密钥必须来自可信的发送方。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>示例场景</strong></p>
<ol>
<li><strong>HTTPS通信</strong>：
<ul>
<li>客户端和服务器通过TLS握手协议协商对称密钥，用于后续的MAC计算和加密。</li>
</ul>
</li>
<li><strong>物联网设备</strong>：
<ul>
<li>设备在出厂时预置共享密钥，用于设备与服务器之间的通信。</li>
</ul>
</li>
<li><strong>即时通信</strong>：
<ul>
<li>使用Diffie-Hellman密钥交换生成会话密钥，用于消息的MAC验证和加密。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>总结</strong></p>
<p>发送方和接收方之间的密钥共享通常在通信开始之前或通信开始时通过安全渠道完成。具体方式包括预先共享密钥、密钥协商协议、公钥加密技术或密钥派生。密钥的安全性直接决定了MAC的有效性，因此密钥管理是消息验证码系统的关键环节。</p>
<h3 id="26-公开密钥算法非对称加密">
  2.6 公开密钥算法(非对称加密)
  <a class="anchor" href="#26-%e5%85%ac%e5%bc%80%e5%af%86%e9%92%a5%e7%ae%97%e6%b3%95%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86">#</a>
</h3>
<ul>
<li>相比对称加密算法来说，公开密钥算法尤其是RSA算法运算非常缓慢，一般情况下，需要加密的明文数据都非常大，如果使用公开密钥算法进行加密，运算性能会惨不忍睹。<strong>公开密钥算法在密码学中一般进行密钥协商或者数字签名，因为这两者运算的数据相对较小。</strong></li>
<li>公开密钥算法最重要和最广泛使用的算法就是RSA算法，该算法是Ron Rivest、Adi Shamir、Leonard Adleman三个人创建的，以三个人名字的首字母命名。</li>
<li>和对称密钥算法一样，公开密钥算法也有使用标准，公开密钥算法的标准称为PKCS（Public Key Cryptography Standards），这个标准由很多的子标准组成，指导使用者正确地使用公开密钥算法。</li>
<li>RSA加密算法的应用场景
<ul>
<li>单步加密</li>
<li>双向加密</li>
</ul>
</li>
</ul>
<h4 id="261-理解rsa的内部结构">
  2.6.1 理解RSA的内部结构
  <a class="anchor" href="#261-%e7%90%86%e8%a7%a3rsa%e7%9a%84%e5%86%85%e9%83%a8%e7%bb%93%e6%9e%84">#</a>
</h4>
<h4 id="262-pkcs标准">
  2.6.2 PKCS标准
  <a class="anchor" href="#262-pkcs%e6%a0%87%e5%87%86">#</a>
</h4>
<h4 id="263-rsa加密算法的应用场景">
  2.6.3 RSA加密算法的应用场景
  <a class="anchor" href="#263-rsa%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h4>
<h4 id="264-rsa加密算法实践">
  2.6.4 RSA加密算法实践
  <a class="anchor" href="#264-rsa%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95%e5%ae%9e%e8%b7%b5">#</a>
</h4>
<h3 id="27-密钥">
  2.7 密钥
  <a class="anchor" href="#27-%e5%af%86%e9%92%a5">#</a>
</h3>
<ul>
<li>口令（password或者passphrase）也可以认为是一种密钥，都需要保密，不能泄露。口令和密钥最大的区别在于口令更容易生成、更容易记忆，一般情况下口令记录在人脑中，口令可以认为是一种弱密钥，由固定的字母、数字、符号组成，长度也有一定的限制。</li>
<li>在密码学中很少直接用口令进行加密，容易受到暴力攻击和字典攻击，暴力攻击的原理在于口令都是由固定的字母、数字、符号组成的，攻击者可以生成所有可能的口令，然后使用口令迭代去解密，一旦成功解密，就表示口令被暴力破解了。</li>
<li>字典攻击本质上也是一种暴力攻击，只是能够加快破解效率（时间和空间），人类一般使用常见的字母、数字、符号组合成口令（比如很多人喜欢用字母password作为口令），攻击者可以将常见的口令保存在一张字典中，然后用字典中的口令迭代去解密密文。除了字典攻击，还有彩虹表攻击方式，破解的关键点就在于口令相对容易猜测和预测。</li>
<li>密钥存储和传输</li>
</ul>
<h4 id="271-生成密钥">
  2.7.1 生成密钥
  <a class="anchor" href="#271-%e7%94%9f%e6%88%90%e5%af%86%e9%92%a5">#</a>
</h4>
<h4 id="272-口令和peb算法">
  2.7.2 口令和PEB算法
  <a class="anchor" href="#272-%e5%8f%a3%e4%bb%a4%e5%92%8cpeb%e7%ae%97%e6%b3%95">#</a>
</h4>
<h4 id="273-密钥存储和传输">
  2.7.3 密钥存储和传输
  <a class="anchor" href="#273-%e5%af%86%e9%92%a5%e5%ad%98%e5%82%a8%e5%92%8c%e4%bc%a0%e8%be%93">#</a>
</h4>
<h3 id="28-密钥协商算法">
  2.8 密钥协商算法
  <a class="anchor" href="#28-%e5%af%86%e9%92%a5%e5%8d%8f%e5%95%86%e7%ae%97%e6%b3%95">#</a>
</h3>
<ul>
<li><strong>RSA密钥协商算法</strong></li>
<li><strong>DH密钥协商算法</strong>
<ul>
<li>Diffie-Hellman算法，简称DH算法，是Whitfield Diffie和Martin Hellman在1976年公布的一个公开密钥算法，它的历史比RSA公开密钥算法更悠久。</li>
<li>使用RSA密钥协商算法传输会话密钥的时候，会话密钥完全由客户端控制，并没有服务器的参与，所以叫作密钥传输。</li>
<li>而DH算法确切地说，实现的是密钥交换或者密钥协商，DH算法在进行密钥协商的时候，通信双方的任何一方无法独自计算出一个会话密钥，通信双方各自保留一部分关键信息，再将另外一部分信息告诉对方，双方有了全部信息才能共同计算出相同的会话密钥。</li>
</ul>
</li>
</ul>
<h4 id="281-rsa密钥协商算法">
  2.8.1 RSA密钥协商算法
  <a class="anchor" href="#281-rsa%e5%af%86%e9%92%a5%e5%8d%8f%e5%95%86%e7%ae%97%e6%b3%95">#</a>
</h4>
<h4 id="282-dh密钥协商算法">
  2.8.2 DH密钥协商算法
  <a class="anchor" href="#282-dh%e5%af%86%e9%92%a5%e5%8d%8f%e5%95%86%e7%ae%97%e6%b3%95">#</a>
</h4>
<ul>
<li>Diffie-Hellman算法，简称DH算法，是Whitfield Diffie和Martin Hellman在1976年公布的一个公开密钥算法，它的历史比RSA公开密钥算法更悠久。</li>
<li>使用RSA密钥协商算法传输会话密钥的时候，会话密钥完全由客户端控制，并没有服务器的参与，所以叫作密钥传输。</li>
<li>而DH算法确切地说，实现的是密钥交换或者密钥协商，DH算法在进行密钥协商的时候，通信双方的任何一方无法独自计算出一个会话密钥，通信双方各自保留一部分关键信息，再将另外一部分信息告诉对方，双方有了全部信息才能共同计算出相同的会话密钥。</li>
<li>客户端和服务器端协商会话密钥的时候，需要互相传递消息，消息即使被挟持，攻击者也无法计算出会话密钥，因为攻击者没有足够的信息（通信双方各自保留的信息）计算出同样的会话密钥。</li>
<li>参数文件
<ul>
<li>在使用DH算法之前，先要生成一些公共参数，这些参数是公开的，无须担心攻击者能够看到这些参数值，这些参数可以由客户端或者服务器端生成，一般由服务器端生成。参数在协商密钥之前必须发给对端。</li>
<li>参数有两个，分别是p和g, p是一个很大的质数，建议长度在1024比特以上，这个长度也决定了DH算法的安全程度，g表示为一个生成器，这个值很小，可以是2或者5。通过参数，服务器端和客户端会生各自生成一个DH密钥对，私钥需要保密。</li>
</ul>
</li>
<li>DH算法处理过程
<ul>
<li>通信双方的任何一方可以生成公共参数p和g，这两个数是公开的，被截获了也没有任何关系，一般情况下由通信双方的服务器端计算。</li>
<li>客户端连接服务器端，服务器端将参数发送给客户端。</li>
<li>客户端根据公开参数生成一个随机数a，这个随机数是私钥，只有客户端知道，且不会进行发送，然后计算Yc = (g ^ a) mod p, Yc就是公钥，需要发送给服务器端。</li>
<li>服务器端根据公开参数生成一个随机数b，这个随机数是私钥，需要服务器端保密，然后计算Ys = (g ^ b) mod p, Ys是公钥，需要发送给客户端。</li>
<li>客户端发送Yc数值给服务器端，服务器端计算Z = (Yc ^ b) mod p。</li>
<li>服务器端发送Ys数值给发送方，客户端计算Z = (Ys ^ a) mod p。</li>
<li>服务器端和客户端生成的Z就是会话密钥，协商完成。</li>
</ul>
</li>
<li>这里的关键点就是私钥a和b不应该泄露，分别由通信双方维护，另外Ys和Yc进行互换才能完成协商，这两个值被截获对攻击者来说没有任何价值。换句话说，只要私钥不发生泄露，攻击者即使有了Ys和Yc也不会计算出会话密钥。</li>
<li>看到幂运算和求模过程，就知道DH算法和RSA算法一样，如果需要破解密钥，就必须面临离散对数和因式分解问题。和其他公开密钥算法一样，只要确保一定的密钥长度，DH算法具有很高的安全性。RSA和DH密钥对一样能够受到暴力攻击，提高密钥对的长度能够有效避免攻击。</li>
</ul>
<h4 id="283-dh算法分类">
  2.8.3 DH算法分类
  <a class="anchor" href="#283-dh%e7%ae%97%e6%b3%95%e5%88%86%e7%b1%bb">#</a>
</h4>
<ul>
<li>静态DH算法(DH算法)
<ul>
<li>静态DH算法，p和g两个参数永远是固定的，而且服务器的公钥（Ys）也是固定的。和RSA密钥协商算法一样，一旦服务器对应的DH私钥泄露，就不能提供前向安全性。静态DH算法的好处就是避免在初始化连接时服务器频繁生成参数p和g，因为该过程是非常消耗CPU运算的。</li>
</ul>
</li>
<li>临时DH算法(EDH算法)
<ul>
<li>在每次初始化连接的时候，服务器都会重新生成DH密钥对，DH密钥对仅仅保存在内存中，不像RSA那样私钥是保存在磁盘中的，攻击者即使从内存中破解了私钥，也仅仅影响本次通信，因为每次初始化的时候密钥对是动态变化的。更安全的是，协商出会话密钥后，a和b两个私钥可以丢弃，进一步提升了安全性，在有限的时间、有效的空间生成了密钥对。</li>
</ul>
</li>
</ul>
<h4 id="284-dh密钥协商算法实践">
  2.8.4 DH密钥协商算法实践
  <a class="anchor" href="#284-dh%e5%af%86%e9%92%a5%e5%8d%8f%e5%95%86%e7%ae%97%e6%b3%95%e5%ae%9e%e8%b7%b5">#</a>
</h4>
<h3 id="29-椭圆曲线密码学">
  2.9 椭圆曲线密码学
  <a class="anchor" href="#29-%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e5%af%86%e7%a0%81%e5%ad%a6">#</a>
</h3>
<ul>
<li>为了保证DH的密钥对不被破解，提升安全性的主要手段就是增加密钥对的长度，但是长度越长，性能越低。公开密钥算法是一个O(n)操作，n就是密钥对的长度，n越小，操作越快。为了解决性能问题，需要了解下椭圆曲线密码学（Elliptic Curve Cryptography），简称为ECC。</li>
<li>ECC是新一代的公开密钥算法，主要的优点就是安全性，极短的密钥能够提供很大的安全性。比如224比特的ECC密钥和2048比特的RSA密钥可以达到同样的安全水平，由于ECC密钥具有很短的长度，运算速度非常快。ECC基于非常复杂的算法，到目前位置，对于ECC进行逆操作还是很难的，数学上被证明是不可破解的，ECC算法的优势就是性能和安全性非常高。</li>
<li>在具体应用的时候，ECC可以结合其他公开密钥算法形成更快、更安全的公开密钥算法，比如结合DH密钥协商算法组成ECDH密钥协商算法，结合数字签名DSA算法组成ECDSA数字签名算法。</li>
</ul>
<h4 id="291-ecc算法的基本模型">
  2.9.1 ECC算法的基本模型
  <a class="anchor" href="#291-ecc%e7%ae%97%e6%b3%95%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a8%a1%e5%9e%8b">#</a>
</h4>
<h4 id="292-使用openssl了解命名曲线">
  2.9.2 使用OpenSSL了解命名曲线
  <a class="anchor" href="#292-%e4%bd%bf%e7%94%a8openssl%e4%ba%86%e8%a7%a3%e5%91%bd%e5%90%8d%e6%9b%b2%e7%ba%bf">#</a>
</h4>
<h4 id="293-ecdh协商算法">
  2.9.3 ECDH协商算法
  <a class="anchor" href="#293-ecdh%e5%8d%8f%e5%95%86%e7%ae%97%e6%b3%95">#</a>
</h4>
<h4 id="294-命名曲线">
  2.9.4 命名曲线
  <a class="anchor" href="#294-%e5%91%bd%e5%90%8d%e6%9b%b2%e7%ba%bf">#</a>
</h4>
<h3 id="210-数字签名">
  2.10 数字签名
  <a class="anchor" href="#210-%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d">#</a>
</h3>
<h4 id="2101-数字签名的用途">
  2.10.1 数字签名的用途
  <a class="anchor" href="#2101-%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d%e7%9a%84%e7%94%a8%e9%80%94">#</a>
</h4>
<ul>
<li>身份验证</li>
<li>私钥只有密钥对的生成者持有，如果不考虑密钥泄露的问题，私钥拥有者使用密钥（注意不是加密操作）签署一条消息，然后发送给任意的接收方，接收方只要拥有私钥对应的公钥，就能成功反解签署消息，由于只有私钥持有者才能“签署”消息，不能抵赖说这条签署消息不是他发送的，这就是数字签名技术的全部。</li>
</ul>
<h4 id="2102-数字签名的流程">
  2.10.2 数字签名的流程
  <a class="anchor" href="#2102-%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d%e7%9a%84%e6%b5%81%e7%a8%8b">#</a>
</h4>
<h4 id="2103-rsa数字签名算法">
  2.10.3 RSA数字签名算法
  <a class="anchor" href="#2103-rsa%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d%e7%ae%97%e6%b3%95">#</a>
</h4>
<ul>
<li>RSA算法的用途非常广泛，可以进行数字签名。和RSA加密算法相似，不同的是，RSA加密算法是<strong>公钥加密，私钥解密</strong>；RSA签名算法是<strong>私钥签名，公钥验证签名</strong>。</li>
</ul>
<h4 id="2104-rsa数字签名实践">
  2.10.4 RSA数字签名实践
  <a class="anchor" href="#2104-rsa%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d%e5%ae%9e%e8%b7%b5">#</a>
</h4>
<h3 id="211-dsa数字签名算法">
  2.11 DSA数字签名算法
  <a class="anchor" href="#211-dsa%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d%e7%ae%97%e6%b3%95">#</a>
</h3>
<h4 id="防篡改和防伪造的区别是什么">
  防篡改和防伪造的区别是什么
  <a class="anchor" href="#%e9%98%b2%e7%af%a1%e6%94%b9%e5%92%8c%e9%98%b2%e4%bc%aa%e9%80%a0%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88">#</a>
</h4>
<p><strong>防篡改</strong>和<strong>防伪造</strong>是信息安全中的两个重要概念，虽然它们都涉及数据的完整性和真实性，但它们的关注点和应用场景有所不同。以下是它们的区别：</p>
<hr>
<p><strong>1. 防篡改（Tamper Resistance）</strong></p>
<ul>
<li><strong>定义</strong>：防止数据在传输或存储过程中被未经授权的修改。</li>
<li><strong>关注点</strong>：确保数据的<strong>完整性</strong>，即数据未被篡改。</li>
<li><strong>实现方式</strong>：
<ul>
<li>使用哈希算法（如SHA-256）生成数据的哈希值，接收方通过比较哈希值验证数据是否被篡改。</li>
<li>使用消息验证码（MAC）或数字签名，结合密钥确保数据的完整性。</li>
</ul>
</li>
<li><strong>应用场景</strong>：
<ul>
<li>文件传输：确保文件在传输过程中未被修改。</li>
<li>软件更新：确保下载的软件包未被篡改。</li>
<li>数据库记录：确保存储的数据未被恶意修改。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2. 防伪造（Forgery Resistance）</strong></p>
<ul>
<li><strong>定义</strong>：防止攻击者伪造数据或身份，冒充合法用户或系统。</li>
<li><strong>关注点</strong>：确保数据的<strong>真实性</strong>，即数据来源可信。</li>
<li><strong>实现方式</strong>：
<ul>
<li>使用数字签名，发送方用私钥对数据签名，接收方用公钥验证签名，确保数据来自可信来源。</li>
<li>使用公钥基础设施（PKI）和数字证书，验证用户或系统的身份。</li>
</ul>
</li>
<li><strong>应用场景</strong>：
<ul>
<li>身份认证：防止攻击者冒充合法用户登录系统。</li>
<li>电子合同：确保合同签署者的身份真实。</li>
<li>区块链交易：确保交易发起者的身份真实。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>对比总结</strong></p>
<table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>防篡改</strong></th>
          <th><strong>防伪造</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>目标</strong></td>
          <td>确保数据未被修改</td>
          <td>确保数据来源可信</td>
      </tr>
      <tr>
          <td><strong>关注点</strong></td>
          <td>数据完整性</td>
          <td>数据真实性</td>
      </tr>
      <tr>
          <td><strong>实现技术</strong></td>
          <td>哈希算法、MAC</td>
          <td>数字签名、PKI</td>
      </tr>
      <tr>
          <td><strong>典型应用</strong></td>
          <td>文件传输、软件更新</td>
          <td>身份认证、电子合同</td>
      </tr>
  </tbody>
</table>
<hr>
<p><strong>示例</strong></p>
<ol>
<li><strong>防篡改</strong>：
<ul>
<li>发送方发送文件并附带哈希值，接收方计算哈希值并比对，确保文件未被篡改。</li>
</ul>
</li>
<li><strong>防伪造</strong>：
<ul>
<li>发送方用私钥对文件签名，接收方用发送方的公钥验证签名，确保文件来自可信来源。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>总结</strong></p>
<ul>
<li><strong>防篡改</strong>关注的是数据是否被修改，确保数据的完整性。</li>
<li><strong>防伪造</strong>关注的是数据是否来自可信来源，确保数据的真实性。
两者通常结合使用，以同时保障数据的完整性和真实性。例如，数字签名既可以防篡改（验证数据完整性），也可以防伪造（验证数据来源）。</li>
</ul>
<h2 id="第3章-宏观理解tls">
  第3章 宏观理解TLS
  <a class="anchor" href="#%e7%ac%ac3%e7%ab%a0-%e5%ae%8f%e8%a7%82%e7%90%86%e8%a7%a3tls">#</a>
</h2>
<ul>
<li>解决HTTP三大问题的通用解决方案就是TLS协议</li>
<li>读者可能听说过**TLS（Transport Layer Security）<strong>协议，也可能听说过</strong>SSL（Secure Sockets Layer）**协议，在理解的时候可以认为两者是一样的，TLS协议是SSL协议的升级版，本书使用TLS/SSL协议代表TLS协议或者SSL协议。</li>
<li>TLS/SSL协议位于应用层协议和TCP之间，构建在TCP之上，由TCP协议保证数据传输的可靠性，任何数据到达TCP之前，都经过TLS/SSL协议处理。</li>
<li>对于应用层协议来说，它无须过多改变，引入TLS/SSL协议即可保证数据机密性和完整性。任何应用层协议（HTTP、SMTP、FTP、其他自定义应用层协议）都可以结合TLS/SSL协议。</li>
<li>TLS/SSL协议一般构建在TCP之上，也可以构建在UDP之上，称为DTLS（Datagram Transport Layer Security）协议，DTLS协议在Web中使用得比较少。</li>
</ul>
<h3 id="31-tlsssl-协议综述">
  3.1 TLS/SSL 协议综述
  <a class="anchor" href="#31-tlsssl-%e5%8d%8f%e8%ae%ae%e7%bb%bc%e8%bf%b0">#</a>
</h3>
<h3 id="32-tlsssl协议背后的算法">
  3.2 TLS/SSL协议背后的算法
  <a class="anchor" href="#32-tlsssl%e5%8d%8f%e8%ae%ae%e8%83%8c%e5%90%8e%e7%9a%84%e7%ae%97%e6%b3%95">#</a>
</h3>
<ul>
<li>为了对数据进行加密，可以采用对称加密算法或者公开密钥加密算法，有加密算法必定就有MAC算法，两者是一个整体。</li>
<li>使用何种密钥协商算法也是由客户端和服务器端共同决定的，或者说由密码套件决定，对于HTTPS来说，在连接阶段必须协商出一个双方认可的密码套件，密码套件是各个密码学算法组合。
<ul>
<li>在HTTPS中，一般采用RSA或者DH算法协商预备主密钥</li>
</ul>
</li>
</ul>
<h4 id="321-加密算法和mac算法">
  3.2.1 加密算法和MAC算法
  <a class="anchor" href="#321-%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95%e5%92%8cmac%e7%ae%97%e6%b3%95">#</a>
</h4>
<ul>
<li>为了对数据进行加密，可以采用对称加密算法或者公开密钥加密算法，有加密算法必定就有MAC算法，两者是一个整体</li>
<li>使用公开密钥加密算法的缺点就是运算慢，尤其是HTTP传输的数据都非常大，所以在大部分Web应用中很少使用公开密钥算法进行加密解密运算。唯一的可行方案就是对称加密算法，比如AES、DES算法。在Web应用中使用比较多的MAC算法是HMAC算法，比如HMAC-SHA-1、HMAC-SHA256算法。</li>
<li>协商
<ul>
<li>本章处处可见协商两个字，所以会重点描述协商的概念，在TLS/SSL协议中，协商的另外一个关键名词就是密码套件（CipherSuite），协商的结果就是双方都认可的密码套件，密码套件决定了本次连接采用哪一种<strong>加密算法</strong>、<strong>密钥协商算法</strong>、<strong>HMAC算法</strong></li>
</ul>
</li>
</ul>
<h4 id="322-密钥协商算法">
  3.2.2 密钥协商算法
  <a class="anchor" href="#322-%e5%af%86%e9%92%a5%e5%8d%8f%e5%95%86%e7%ae%97%e6%b3%95">#</a>
</h4>
<ul>
<li>不管采用哪种密钥协商算法，客户端和服务器端最终会协商出<strong>预备主密钥（Premaster Secret）</strong>，预备主密钥转换为<strong>主密钥</strong>，主密钥最终再转换为<strong>密钥块</strong>。</li>
<li>预备主密钥的特点
<ul>
<li>每个客户端和服务器端初始化连接的时候生成预备主密钥，每次的值都是不一样的。</li>
<li>预备主密钥在会话结束后（连接关闭后），会自动释放，这是很关键的特性，预备主密钥不会持久保存。</li>
<li>预备主密钥必须保证是机密的，确保攻击者无法解密出预备主密钥，也无法猜测出预备主密钥。</li>
</ul>
</li>
<li>在HTTPS中，一般采用RSA或者DH算法协商预备主密钥
<ul>
<li>RSA
<ul>
<li>客户端向服务器端发起连接请求，服务器端发送RSA密钥对的公钥给客户端。</li>
<li>客户端通过随机数生成器生成一个预备主密钥，用服务器的公钥加密并发送给服务器端。</li>
<li>服务器解密预备主密钥，假如能够正确解密，则说明客户端和服务器端共同协商出一个预备主密钥。</li>
</ul>
</li>
<li>DH算法
<ul>
<li>流程
<ul>
<li>客户端向服务器端发起连接请求</li>
<li>服务器端生成一个RSA密钥对，并将公钥发送给客户端</li>
<li>服务器端生成DH参数和服务器DH密钥对，用RSA私钥签名DH参数和服务器DH公钥，最后将签名值、DH参数、服务器DH公钥发送给客户端</li>
<li>客户端通过服务器RSA的公钥验证签名，获取到DH参数和服务器DH公钥</li>
<li>客户端通过DH参数生成客户端的DH密钥对，并将客户端DH公钥发送给服务器端</li>
<li>客户端通过客户端DH私钥和服务器端DH公钥计算出预备主密钥</li>
<li>服务器端接收到客户端的DH公钥，结合服务器的DH私钥计算出预备主密钥。</li>
<li>最终客户端和服务器端计算出的预备主密钥能够保持一致。</li>
</ul>
</li>
<li>分类
<ul>
<li>静态DH算法</li>
<li>临时DH算法(EDH算法)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>在HTTPS中，服务器在发送DH参数和服务器DH公钥之前会对这两个值进行签名运算，确保传递的值没有被篡改和伪造，也可以看出HTTPS就是使用多种算法确保安全性</li>
<li>在HTTPS中，使用DH密钥协商算法需要客户端和服务器端经过多次通信才能协商出预备主密钥，而RSA密钥协商算法只要很少的步骤就能协商出。</li>
</ul>
<h4 id="323-前向安全性">
  3.2.3 前向安全性
  <a class="anchor" href="#323-%e5%89%8d%e5%90%91%e5%ae%89%e5%85%a8%e6%80%a7">#</a>
</h4>
<ul>
<li>前向安全性（Perfect Forward Secrecy）是TLS/SSL协议中很重要的一个话题，必须充分理解。RSA密钥协商算法和静态DH算法都不能确保前向安全</li>
<li>对于动态DH算法来说，客户端每次连接的时候，DH密钥对都是重新生成的，即使在某次连接中泄露了，也仅仅会导致本次连接中的加密数据被破解，安全风险相对较小。</li>
</ul>
<h4 id="324-密钥衍生算法">
  3.2.4 密钥衍生算法
  <a class="anchor" href="#324-%e5%af%86%e9%92%a5%e8%a1%8d%e7%94%9f%e7%ae%97%e6%b3%95">#</a>
</h4>
<blockquote>
<p>**密钥衍生算法（Key Derivation Function, KDF）**是一种用于从初始密钥（如密码或主密钥）生成一个或多个密钥的密码学算法。它的主要目的是增强密钥的安全性，并生成适合特定用途的密钥（如加密密钥、认证密钥等）。</p></blockquote>
<h5 id="密钥衍生算法在https是怎么应用的">
  密钥衍生算法在HTTPS是怎么应用的？
  <a class="anchor" href="#%e5%af%86%e9%92%a5%e8%a1%8d%e7%94%9f%e7%ae%97%e6%b3%95%e5%9c%a8https%e6%98%af%e6%80%8e%e4%b9%88%e5%ba%94%e7%94%a8%e7%9a%84">#</a>
</h5>
<p>密钥衍生算法在HTTPS中的应用主要体现在安全地生成会话密钥，确保客户端与服务器之间的通信安全。具体来说，这个过程通常涉及以下几个步骤：</p>
<ol>
<li>
<p><strong>握手协议</strong>：当客户端（如浏览器）尝试与服务器建立HTTPS连接时，首先会通过SSL/TLS握手协议开始通信。在这个过程中，双方会交换一些必要的信息用于生成对称密钥。</p>
</li>
<li>
<p><strong>密钥交换算法</strong>：为了安全地协商出一个共享的秘密（即预主密钥），客户端和服务器可能会使用诸如RSA、Diffie-Hellman等密钥交换算法。例如，在基于RSA的密钥交换中，客户端生成一个随机的预主密钥并用服务器的公钥加密后发送给服务器；而在Diffie-Hellman方法中，则是通过数学运算来安全地生成共享秘密。</p>
</li>
<li>
<p><strong>密钥衍生函数（KDF）</strong>：一旦预主密钥确定下来，就会使用密钥衍生函数（如HKDF或PBKDF2）从预主密钥生成实际使用的对称密钥。这些函数接受输入（如预主密钥、客户端和服务器随机数等）并通过一系列操作生成最终用于加密通信的密钥。这一步骤增强了安全性，因为它增加了攻击者预测密钥的难度。</p>
</li>
<li>
<p><strong>数据加密</strong>：使用上述过程中生成的对称密钥，客户端和服务器就可以采用对称加密算法（如AES）来加密和解密它们之间传输的数据，保证了数据的保密性和完整性。</p>
</li>
</ol>
<p>总之，密钥衍生算法在HTTPS中的作用至关重要，它不仅保障了密钥的安全生成，还提高了整个通信过程的安全性，防止潜在的信息泄露和中间人攻击。</p>
<h5 id="在https中会使用密钥衍生算法生成哪些密钥能具体列举出来吗">
  在HTTPS中，会使用密钥衍生算法生成哪些密钥，能具体列举出来吗？
  <a class="anchor" href="#%e5%9c%a8https%e4%b8%ad%e4%bc%9a%e4%bd%bf%e7%94%a8%e5%af%86%e9%92%a5%e8%a1%8d%e7%94%9f%e7%ae%97%e6%b3%95%e7%94%9f%e6%88%90%e5%93%aa%e4%ba%9b%e5%af%86%e9%92%a5%e8%83%bd%e5%85%b7%e4%bd%93%e5%88%97%e4%b8%be%e5%87%ba%e6%9d%a5%e5%90%97">#</a>
</h5>
<p>在HTTPS（实际上是其底层的SSL/TLS协议）中，密钥衍生算法用于生成多个密钥和参数，以确保通信的安全性。以下是通过密钥衍生过程通常会生成的一些关键元素：</p>
<ol>
<li>
<p><strong>客户端写密钥（Client Write Key）</strong>：这是用来加密从客户端发送到服务器的数据的对称密钥。</p>
</li>
<li>
<p><strong>服务器写密钥（Server Write Key）</strong>：相对地，这是用来加密从服务器发送到客户端的数据的对称密钥。</p>
</li>
<li>
<p><strong>客户端写MAC密钥（Client Write MAC Key）</strong>：用于客户端数据完整性验证的消息认证码(MAC)密钥，在现代TLS版本中被基于哈希的消息认证码(HMAC)替代。</p>
</li>
<li>
<p><strong>服务器写MAC密钥（Server Write MAC Key）</strong>：用于服务器数据完整性验证的消息认证码(MAC)密钥，在现代TLS版本中也被基于哈希的消息认证码(HMAC)替代。</p>
</li>
<li>
<p><strong>初始化向量（IV）</strong>：对于某些加密模式（如CBC模式），需要一个初始化向量来确保即使是相同的数据块使用相同的密钥加密时也会产生不同的输出。不过，在使用AEAD（如GCM模式）的情况下，这个IV有时也被称为nonce，并且它与密钥一起用于提供数据完整性和保密性。</p>
</li>
<li>
<p><strong>临时密钥材料（Ephemeral Keys）</strong>：在一些密钥交换机制中，例如短暂的Diffie-Hellman（DHE或ECDHE），会产生临时密钥材料用于一次性的密钥协商，增加了前向安全性。</p>
</li>
</ol>
<p>这些密钥和参数是通过密钥衍生函数（KDF），比如在TLS 1.2及之前使用的PRF（伪随机函数），以及在TLS 1.3中更明确地定义的KDFs（如HKDF）从预主密钥、客户端随机数、服务器随机数等信息派生出来的。每个连接都会生成一套新的密钥，从而保证了通信的安全性和隐私保护。</p>
<h4 id="325-中间人攻击">
  3.2.5 中间人攻击
  <a class="anchor" href="#325-%e4%b8%ad%e9%97%b4%e4%ba%ba%e6%94%bb%e5%87%bb">#</a>
</h4>
<ul>
<li>所谓中间人攻击就是服务器传递给客户端的公钥可能被攻击者替换，这样安全性就荡然无存了。
<ul>
<li>客户端向服务器端发起连接请求，期望获取服务器的RSA公钥，攻击者劫持了这个请求。</li>
<li>攻击者自己生成一对RSA密钥对，然后将攻击者的RSA公钥发送给客户端。</li>
<li>攻击者然后再向服务器端发送请求，服务器生成RSA密钥对，将RSA公钥发送给客户端，实际上是发送给攻击者。</li>
<li>客户端通过攻击者的公钥加密密钥块并发送给服务器，实际上是发送给攻击者。</li>
<li>攻击者用自己的RSA私钥解密了密钥块A，然后自己生成一个密钥块B，用服务器的RSA公钥加密后发送给服务器端。</li>
<li>服务器端接收到请求后，用自己的RSA私钥解密出攻击者的密钥块B。</li>
<li>客户端使用攻击者的密钥块A，采用AES算法加密数据并发送给服务器端，实际上是发送给攻击者。</li>
<li>攻击者使用自己的密钥块A、采用AES算法解密出明文，客户端相当于泄露了隐私，攻击者使用密钥块B，采用AES算法加密明文后发送给服务器。</li>
<li>服务器使用密钥块B，采用AES算法加密数据并发送给攻击者。</li>
<li>攻击者使用密钥块B，采用AES算法解密出明文数据，此时客户端和服务器端的加密数据被成功破解。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在SSL/TLS协议（HTTPS的安全基础）中，&ldquo;密钥块&rdquo;（Key Block）是一个概念，它指的是通过密钥衍生函数（KDF）从预主密钥生成的一系列加密材料的集合。这个密钥块包含了用于保护客户端和服务器之间通信所需的所有密钥和参数。</p></blockquote>
<h5 id="客户端和服务器之间只传递预主密钥密钥块是两边分别计算出来的是这样吗">
  客户端和服务器之间只传递预主密钥，密钥块是两边分别计算出来的，是这样吗
  <a class="anchor" href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e5%92%8c%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%b9%8b%e9%97%b4%e5%8f%aa%e4%bc%a0%e9%80%92%e9%a2%84%e4%b8%bb%e5%af%86%e9%92%a5%e5%af%86%e9%92%a5%e5%9d%97%e6%98%af%e4%b8%a4%e8%be%b9%e5%88%86%e5%88%ab%e8%ae%a1%e7%ae%97%e5%87%ba%e6%9d%a5%e7%9a%84%e6%98%af%e8%bf%99%e6%a0%b7%e5%90%97">#</a>
</h5>
<p>是的，您的理解基本正确。在SSL/TLS协议中，客户端和服务器之间并不会直接传递完整的密钥块，而是通过交换信息来安全地生成一个预主密钥（Pre-Master Secret），然后各自独立地使用这个预主密钥以及双方在握手初期交换的随机数（Client Random和Server Random）来计算出最终的密钥材料，即所谓的密钥块（Key Block）。具体过程如下：</p>
<ol>
<li>
<p><strong>密钥交换</strong>：根据所采用的具体密钥交换算法（如RSA、Diffie-Hellman等），客户端和服务器会进行一系列的操作来安全地确定一个预主密钥。例如，在基于RSA的密钥交换中，客户端生成一个预主密钥并用服务器的公钥加密后发送给服务器；而在Diffie-Hellman方法中，则是通过数学运算来安全地生成共享的秘密。</p>
</li>
<li>
<p><strong>生成密钥块</strong>：一旦预主密钥确定下来，客户端和服务器都会使用相同的密钥衍生函数（KDF），比如TLS 1.2中的伪随机函数（PRF）或TLS 1.3中的HKDF，结合预主密钥和之前交换的随机数值，分别独立计算出所需的密钥材料。这包括了客户端写密钥、服务器写密钥、客户端写MAC密钥、服务器写MAC密钥（在TLS 1.2及之前版本中）、初始化向量（IV）或nonce等。</p>
</li>
<li>
<p><strong>独立计算的优势</strong>：这种方式不仅减少了通信负担，还增强了安全性。因为预主密钥本身并不直接用于加密通信，而是用于派生出实际使用的对称密钥和其他安全参数。即使攻击者能够拦截到所有公开交换的信息，他们也无法轻易推算出最终的密钥材料，除非他们能破解密钥交换算法或者预测KDF的结果。</p>
</li>
</ol>
<p>因此，客户端和服务器确实只交换必要的信息以确定预主密钥，并且之后各自独立计算出密钥块，这种机制确保了通信的安全性和效率。</p>
<h4 id="326-pki">
  3.2.6 PKI
  <a class="anchor" href="#326-pki">#</a>
</h4>
<ul>
<li>和身份证一样，CA机构会签发一张证书（可以理解为就是一张身份证），证书中包含了一些关键信息，比如服务器的主机、服务器的公钥</li>
<li>CA机构也拥有一个密钥对，比如RSA密钥对（与服务器的RSA密钥对没有任何关系），它用私钥对证书进行数字签名，将签名的证书发送给服务器。浏览器再连接服务器，服务器发送证书给浏览器，浏览器拥有CA机构的公钥（内嵌在浏览器中），然后校验证书的签名，一旦校验成功，就代表这个证书是可信的CA机构签发的。</li>
</ul>
<h3 id="33-https总结">
  3.3 HTTPS总结
  <a class="anchor" href="#33-https%e6%80%bb%e7%bb%93">#</a>
</h3>
<h4 id="331-握手">
  3.3.1 握手
  <a class="anchor" href="#331-%e6%8f%a1%e6%89%8b">#</a>
</h4>
<h5 id="1-认证">
  1 认证
  <a class="anchor" href="#1-%e8%ae%a4%e8%af%81">#</a>
</h5>
<ul>
<li>客户端在进行密钥交换之前，必须认证服务器的身份，否则就会存在中间人攻击，而服务器实体并不能自己证明自己，所以需要通过CA机构来进行认证，认证的技术解决方案就是签名的数字证书。证书中会说明CA机构采用的数字签名算法，客户端获取到证书后，会采用相应的签名算法进行验证，一旦验证通过，则表示客户端成功认证了服务器端的身份。</li>
</ul>
<h5 id="2-密码套件协商">
  2 密码套件协商
  <a class="anchor" href="#2-%e5%af%86%e7%a0%81%e5%a5%97%e4%bb%b6%e5%8d%8f%e5%95%86">#</a>
</h5>
<ul>
<li>密码套件是一系列密码学算法的组合，主要包括多个密码学算法
<ul>
<li>身份验证算法</li>
<li>密码协商算法</li>
<li>加密算法或者加密模式</li>
<li>HMAC算法的加密基元</li>
<li>PRF算法的加密基元，需要注意的是，不同的TLS/SSL协议版本、密码套件，PRF算法最终使用的加密基元和HMAC算法使用的加密基元是不一样的</li>
</ul>
</li>
<li><code>TLS_密钥协商_身份验证_WITH_加密算法_HMAC或PRF算法</code></li>
<li>密码套件的例子
<ul>
<li><code>TLS_DH_RSA_WITH_AES_CBC_128_SHA</code>
<ul>
<li>RSA：身份验证算法，这个称呼具备一定的干扰性，本例中的RSA表示证书中包含的服务器公钥是RSA公钥，对于不同的密钥协商算法，RSA公钥的作用也不一样。读者可能会问，为何没有涉及身份验证，身份验证对应的数字签名算法由证书指定，客户端获取到证书的时候，证书会说明该证书由何种数字签名算法签名，验证证书签名的公钥和服务器的公钥没有任何关系。</li>
<li>DH：表示密钥协商算法，用来协商出预备主密钥（PremasterSecret），那么客户端如何获取DH参数呢？服务器会发送DH参数和服务器DH公钥。</li>
<li>AES_CBC_128，表示加密算法，用于保证机密性，在本例中使用的是AES对称加密算法、加密模式是CBC模式、密钥长度是128比特。</li>
<li>SHA：表示HMAC算法，用于保证完整性，在本例中是HMAC_SHA1算法。</li>
<li>PRF算法：PRF算法采用的加密基元不一定是SHA1算法，由TLS/SSL协议版本和协商出的密码套件决定。</li>
</ul>
</li>
<li><code>TLS_RSA_WITH_AES_CBC_128_SHA</code></li>
</ul>
</li>
<li>理解密码套件的几个关键点
<ul>
<li>密码套件是密码学算法的组合，但并不是随便组合的，每一种密码套件都由IANA指定和分配。</li>
<li>不同的TLS/SSL版本，密码套件的解释有细微的差别，比如在TLS v1.0版本中，PRF具体使用的算法是硬编码的（不依赖于密码套件），是HMAC-MD5和HMAC-SHA1算法的组合，而在TLS v1.2版本中，PRF默认采用的是HMAC-SHA256算法。</li>
<li>不同的TLS/SSL版本，有不同的密码套件组合，主要是从安全性和性能的角度考虑，版本越高，包含的密码套件安全性就更高，也会废弃一些相对不安全的密码套件。</li>
<li>密码套件在服务器端是可以配置的，比如Nginx服务器可以通过指令配置密码套件，可以去除一些不安全的密码套件。</li>
<li>客户端和服务器端选择密码套件的基本原则就是优先级，从安全角度看应该由服务器决定协商出的最终密码套件。</li>
<li>密码套件仅仅是一个配置，不代表服务器就支持该套件，比如服务器可以配置TLS_ECDHE_WITH_ECDSA_AES_128_GCM_SHA256套件，但是服务器上并没有ECDSA密钥对，那么最终不能协商出该密码套件。</li>
</ul>
</li>
</ul>
<h5 id="3-密钥协商">
  3 密钥协商
  <a class="anchor" href="#3-%e5%af%86%e9%92%a5%e5%8d%8f%e5%95%86">#</a>
</h5>
<ul>
<li>如果使用RSA密钥协商算法，那么服务器的密钥对非常重要，服务器的公钥不仅仅要进行身份验证，还要进行密钥协商，一旦私钥泄露，就失去了前向安全性。</li>
<li>如果使用静态DH算法，服务器证书中会包含固定的DH参数和DH公钥，也会失去前向安全性，所以现在密码套件很少支持DH算法，CA机构在签发证书的时候也不会包含DH参数和DH公钥。</li>
<li>为了保持前向安全性，目前使用最多的密钥协商算法就是DHE算法和ECDHE算法，这两个算法和服务器的密钥对关系不大，也就是说密钥的协商不取决于服务器的密钥对，所以服务器的私钥即使泄露，也不会造成太大的安全风险。</li>
</ul>
<h5 id="4-握手消息完整性校验">
  4 握手消息完整性校验
  <a class="anchor" href="#4-%e6%8f%a1%e6%89%8b%e6%b6%88%e6%81%af%e5%ae%8c%e6%95%b4%e6%80%a7%e6%a0%a1%e9%aa%8c">#</a>
</h5>
<ul>
<li>握手过程中传递的消息全部是明文传输的，任何攻击者都能截获，握手消息存在被篡改的可能性</li>
<li>读者会说不是有身份验证了吗，怎么还存在中间人攻击？确实是这样，证书校验能够确保服务器的真实身份，但密钥协商是身份校验之后的过程，攻击者无法攻击身份校验过程，但可以在后续的握手过程中篡改消息</li>
<li>下面简单描述TLS/SSL协议如何对消息进行加密和完整性保护
<ul>
<li>客户端将发送和接收到的所有握手消息组合在一起，然后计算出摘要数据，握手层使用密钥块对摘要数据进行加密和完整性保护，然后发送给服务器。</li>
<li>服务器接收到验证消息后，使用加密块解密出摘要数据。</li>
<li>紧接着服务器自行计算发送和接收的所有握手消息，再计算出消息的摘要数据，如果摘要数据和解密出的摘要数据相同，代表客户端发送的消息没有被篡改。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Finished消息：客户端和服务器各自发送“Finished”消息，这些消息包含整个握手过程的一个哈希值（通常是基于之前所有握手消息的摘要），并用新协商的密钥进行加密。这一步骤用于最终验证握手过程的完整性和一致性。
完整性校验：通过比较收到的“Finished”消息中的哈希值与本地计算出的握手消息摘要是否一致，双方可以确认对方确实参与了相同的握手流程，且没有发生任何篡改。</p></blockquote>
<h6 id="finished-消息包含的哈希值是怎么计算的以及是怎么比较的">
  Finished 消息包含的哈希值是怎么计算的，以及是怎么比较的
  <a class="anchor" href="#finished-%e6%b6%88%e6%81%af%e5%8c%85%e5%90%ab%e7%9a%84%e5%93%88%e5%b8%8c%e5%80%bc%e6%98%af%e6%80%8e%e4%b9%88%e8%ae%a1%e7%ae%97%e7%9a%84%e4%bb%a5%e5%8f%8a%e6%98%af%e6%80%8e%e4%b9%88%e6%af%94%e8%be%83%e7%9a%84">#</a>
</h6>
<p>在SSL/TLS握手过程中，&ldquo;Finished&quot;消息中的哈希值是通过特定的计算方法生成的，并且用于确保握手过程的完整性和一致性。以下是详细的步骤和机制说明：</p>
<p>计算 &ldquo;Finished&rdquo; 消息中的哈希值</p>
<ol>
<li>
<p><strong>握手上下文（Handshake Context）</strong>：</p>
<ul>
<li>在整个握手过程中，客户端和服务器会交换一系列的消息，如Client Hello、Server Hello、Certificate、Server Key Exchange、Client Key Exchange等。</li>
<li>这些消息的内容会被收集起来形成一个握手上下文（handshake context），通常是一个字节流，包含了所有已发送和接收的手握消息。</li>
</ul>
</li>
<li>
<p><strong>PRF（伪随机函数）或HKDF</strong>：</p>
<ul>
<li>SSL/TLS使用伪随机函数（PRF）或基于哈希的消息认证码（HMAC）来生成密钥材料和其他安全参数。</li>
<li>在TLS 1.2及之前版本中，PRF被用来生成“Finished”消息中的验证数据（verify_data）。</li>
<li>在TLS 1.3中，使用了更现代的HKDF（Key Derivation Function）来进行类似的计算。</li>
</ul>
</li>
<li>
<p><strong>计算哈希值</strong>：</p>
<ul>
<li><strong>TLS 1.2及之前版本</strong>：
<ul>
<li>PRF根据以下公式计算出“Finished”消息中的verify_data：
<pre tabindex="0"><code>verify_data = PRF(master_secret, &#34;client finished&#34;, Hash(handshake_messages)) [for client]
verify_data = PRF(master_secret, &#34;server finished&#34;, Hash(handshake_messages)) [for server]
</code></pre></li>
<li>其中：
<ul>
<li><code>master_secret</code> 是通过密钥交换算法生成的主密钥。</li>
<li><code>&quot;client finished&quot;</code> 或 <code>&quot;server finished&quot;</code> 是标签字符串，用于区分客户端和服务器的计算。</li>
<li><code>Hash(handshake_messages)</code> 是对所有握手消息进行哈希运算的结果（通常是SHA-256或其他协商的哈希算法）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>TLS 1.3</strong>：
<ul>
<li>使用HKDF提取和扩展函数来生成verify_data：
<pre tabindex="0"><code>verify_data = HKDF-Expand-Label(transcript_hash, &#34;finished&#34;, &#34;&#34;, length)
</code></pre></li>
<li>其中：
<ul>
<li><code>transcript_hash</code> 是所有握手消息的哈希摘要。</li>
<li><code>&quot;finished&quot;</code> 是标签字符串。</li>
<li><code>length</code> 是所需输出的长度。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>发送和比较 &ldquo;Finished&rdquo; 消息</p>
<ol>
<li>
<p><strong>客户端发送 &ldquo;Finished&rdquo; 消息</strong>：</p>
<ul>
<li>客户端根据上述方法计算出自己的verify_data，并将其作为“Finished”消息的一部分加密后发送给服务器。</li>
</ul>
</li>
<li>
<p><strong>服务器发送 &ldquo;Finished&rdquo; 消息</strong>：</p>
<ul>
<li>服务器同样按照相同的方法计算出自己的verify_data，并将其作为“Finished”消息的一部分加密后发送给客户端。</li>
</ul>
</li>
<li>
<p><strong>比较哈希值</strong>：</p>
<ul>
<li>
<p><strong>客户端验证服务器的 “Finished” 消息</strong>：</p>
<ul>
<li>客户端收到服务器的“Finished”消息后，解密并从中提取出verify_data。</li>
<li>然后，客户端使用相同的PRF或HKDF算法，基于自己记录的所有握手消息重新计算预期的verify_data。</li>
<li>如果计算结果与接收到的verify_data匹配，则认为握手过程未被篡改，服务器的身份是可信的。</li>
</ul>
</li>
<li>
<p><strong>服务器验证客户端的 “Finished” 消息</strong>：</p>
<ul>
<li>同样地，服务器也会对接收到的客户端“Finished”消息进行验证，确保客户端参与了相同的握手流程，并且没有发生任何篡改。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>示例</p>
<p>假设在一个TLS 1.2握手过程中：</p>
<ul>
<li>握手消息包括：Client Hello、Server Hello、Certificate、Server Key Exchange、Client Key Exchange、Change Cipher Spec。</li>
<li>客户端和服务器各自计算出 <code>Hash(handshake_messages)</code>。</li>
<li>使用PRF和 <code>master_secret</code> 计算出各自的verify_data：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>Client Finished: PRF(master_secret, &#34;client finished&#34;, Hash(handshake_messages))
</span></span><span style="display:flex;"><span>Server Finished: PRF(master_secret, &#34;server finished&#34;, Hash(handshake_messages))
</span></span></code></pre></div></li>
<li>双方将这些verify_data作为“Finished”消息的一部分发送给对方，并在接收到对方的“Finished”消息时重新计算verify_data进行比较。</li>
</ul>
<p>通过这种方式，&ldquo;Finished&quot;消息不仅确认了双方已经成功完成了密钥交换，还验证了整个握手过程的完整性和一致性，从而有效防止了中间人攻击和其他形式的数据篡改。</p>
<hr>
<h5 id="使用charles来解密https请求内容的原理是什么">
  使用Charles来解密https请求内容的原理是什么？
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8charles%e6%9d%a5%e8%a7%a3%e5%af%86https%e8%af%b7%e6%b1%82%e5%86%85%e5%ae%b9%e7%9a%84%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88">#</a>
</h5>
<p>使用Charles等代理工具解密HTTPS请求内容的基本原理涉及到中间人（Man-in-the-Middle, MITM）技术的应用。以下是详细步骤和原理说明：</p>
<p>基本原理</p>
<ol>
<li>
<p><strong>安装Charles的根证书</strong>：</p>
<ul>
<li>为了能够解密HTTPS流量，用户首先需要在设备或浏览器中安装Charles提供的自签名根证书。</li>
<li>这个证书使得Charles可以作为受信任的CA（证书颁发机构），从而生成用于与目标网站通信的伪造证书。</li>
</ul>
</li>
<li>
<p><strong>拦截HTTPS连接</strong>：</p>
<ul>
<li>当客户端尝试建立一个HTTPS连接时，Charles作为代理服务器会拦截这个请求。</li>
<li>Charles代替原始服务器向客户端发送自己签发的伪造证书（基于之前安装的根证书），而不是服务器的真实证书。</li>
</ul>
</li>
<li>
<p><strong>客户端验证伪造证书</strong>：</p>
<ul>
<li>客户端收到伪造证书后，会根据已安装的信任证书列表进行验证。</li>
<li>因为用户已经安装了Charles的根证书，所以客户端认为这个伪造证书是有效的，并继续建立加密连接。</li>
</ul>
</li>
<li>
<p><strong>双向解密与重新加密</strong>：</p>
<ul>
<li>Charles能够解密从客户端发来的加密请求，因为它拥有对应的私钥（用于伪造证书的那一对公私钥）。</li>
<li>解密后的明文信息被显示给用户查看。</li>
<li>然后，Charles使用目标服务器的真实证书与服务器建立另一个独立的HTTPS连接，并将请求转发给服务器。</li>
<li>对于响应数据，Charles同样先从服务器接收加密响应，解密，展示给用户，再用伪造证书加密返回给客户端。</li>
</ul>
</li>
</ol>
<p>注意事项</p>
<ul>
<li>
<p><strong>安全性风险</strong>：虽然这种方法对于调试和开发非常有用，但它也存在显著的安全隐患。如果恶意软件利用类似的技术，它可以窃听用户的敏感信息。因此，在公共网络或不受信任的环境中不应该随意安装未知来源的根证书。</p>
</li>
<li>
<p><strong>透明度和同意</strong>：实际操作中，使用这类工具通常要求明确告知用户并获得其同意，尤其是在涉及处理个人敏感信息时。</p>
</li>
</ul>
<p>通过这种方式，Charles能够在不破坏原有HTTPS加密机制的前提下，实现对HTTPS流量的监控和分析。这对于开发者来说是一个强大的工具，可以帮助他们调试应用程序、检查API调用以及确保网络安全配置正确无误。然而，使用此类工具时应谨慎考虑隐私和安全问题。</p>
<hr>
<h5 id="在使用charles进行https抓包的时候有些接口会连接失败这是什么原因">
  在使用charles进行https抓包的时候，有些接口会连接失败，这是什么原因
  <a class="anchor" href="#%e5%9c%a8%e4%bd%bf%e7%94%a8charles%e8%bf%9b%e8%a1%8chttps%e6%8a%93%e5%8c%85%e7%9a%84%e6%97%b6%e5%80%99%e6%9c%89%e4%ba%9b%e6%8e%a5%e5%8f%a3%e4%bc%9a%e8%bf%9e%e6%8e%a5%e5%a4%b1%e8%b4%a5%e8%bf%99%e6%98%af%e4%bb%80%e4%b9%88%e5%8e%9f%e5%9b%a0">#</a>
</h5>
<p>在使用Charles进行HTTPS抓包时，如果某些接口连接失败，可能有以下几个原因：</p>
<ol>
<li>
<p><strong>证书未正确安装</strong></p>
<ul>
<li><strong>客户端未信任Charles的根证书</strong>：确保已在客户端（如手机或浏览器）上正确安装并信任了Charles的根证书。对于移动设备，还需要特别注意是否针对该设备类型正确配置了证书。</li>
<li><strong>应用不支持自定义证书</strong>：一些应用程序为了增强安全性，内置了对特定证书颁发机构（CA）的信任列表，并拒绝接受非官方或用户安装的证书。这种情况下，即使你安装了Charles的证书，这些应用也不会信任它，从而导致HTTPS请求失败。</li>
</ul>
</li>
<li>
<p><strong>SSL Pinning</strong></p>
<ul>
<li><strong>SSL Pinning技术的应用</strong>：部分应用程序实施了SSL Pinning（SSL锁定），这是一种安全措施，通过硬编码服务器的公钥或证书到应用程序中，强制要求与预设的服务器证书匹配。如果检测到中间人代理（如Charles）提供的伪造证书，即使这个证书是被系统信任的，应用程序也会拒绝建立连接。</li>
</ul>
</li>
<li>
<p><strong>网络配置问题</strong></p>
<ul>
<li><strong>代理设置错误</strong>：确保设备或浏览器已经正确设置了Charles作为HTTP/HTTPS代理。如果代理设置有误，可能导致请求无法正常路由到目标服务器。</li>
<li><strong>防火墙或网络限制</strong>：某些网络环境可能设置了严格的防火墙规则或代理策略，阻止了通过第三方代理软件发送的请求。</li>
</ul>
</li>
<li>
<p><strong>服务器端限制</strong></p>
<ul>
<li><strong>IP地址黑名单</strong>：有些服务器可能会维护一个黑名单，列出不允许访问其资源的IP地址范围。如果你正在使用的代理服务器的IP地址被列入黑名单，那么通过该代理发出的所有请求都可能被服务器拒绝。</li>
<li><strong>请求频率限制</strong>：频繁的抓包测试可能会触发服务器的速率限制机制，导致部分请求被拒绝。</li>
</ul>
</li>
</ol>
<p>解决方法</p>
<ul>
<li><strong>检查并重新安装证书</strong>：确保Charles的根证书已正确安装并在设备上被信任。对于移动端，按照Charles的官方指南进行操作。</li>
<li><strong>绕过SSL Pinning</strong>：对于支持修改的应用程序，可以尝试关闭SSL Pinning功能；不过，这通常需要反编译应用，修改代码后再重新打包，这对大多数普通用户来说较为复杂且可能违反服务条款。</li>
<li><strong>确认代理设置</strong>：仔细检查设备上的代理设置，确保它们指向了运行Charles的主机和端口。</li>
<li><strong>测试不同网络环境</strong>：尝试切换到不同的网络环境，排除因当前网络设置导致的问题。</li>
<li><strong>联系服务提供商</strong>：如果是由于服务器端限制（如黑名单、速率限制等）导致的问题，可能需要联系服务提供商解决。</li>
</ul>
<p>理解上述潜在原因后，你可以针对性地排查问题所在，并采取相应的解决措施。如果是在开发环境中遇到此类问题，开发者还可以利用调试工具或日志来进一步诊断具体的故障点。</p>
<hr>
<h4 id="332-加密">
  3.3.2 加密
  <a class="anchor" href="#332-%e5%8a%a0%e5%af%86">#</a>
</h4>
<h3 id="34-实施https网站的必备条件">
  3.4 实施HTTPS网站的必备条件
  <a class="anchor" href="#34-%e5%ae%9e%e6%96%bdhttps%e7%bd%91%e7%ab%99%e7%9a%84%e5%bf%85%e5%a4%87%e6%9d%a1%e4%bb%b6">#</a>
</h3>
<h4 id="341-证书和密钥对">
  3.4.1 证书和密钥对
  <a class="anchor" href="#341-%e8%af%81%e4%b9%a6%e5%92%8c%e5%af%86%e9%92%a5%e5%af%b9">#</a>
</h4>
<h4 id="342-部署和配置https网站">
  3.4.2 部署和配置HTTPS网站
  <a class="anchor" href="#342-%e9%83%a8%e7%bd%b2%e5%92%8c%e9%85%8d%e7%bd%aehttps%e7%bd%91%e7%ab%99">#</a>
</h4>
<h4 id="343-全站https策略">
  3.4.3 全站HTTPS策略
  <a class="anchor" href="#343-%e5%85%a8%e7%ab%99https%e7%ad%96%e7%95%a5">#</a>
</h4>
<h3 id="35-从用户的角度看https">
  3.5 从用户的角度看HTTPS
  <a class="anchor" href="#35-%e4%bb%8e%e7%94%a8%e6%88%b7%e7%9a%84%e8%a7%92%e5%ba%a6%e7%9c%8bhttps">#</a>
</h3>
<h4 id="351-绿色小锁图标">
  3.5.1 绿色小锁图标
  <a class="anchor" href="#351-%e7%bb%bf%e8%89%b2%e5%b0%8f%e9%94%81%e5%9b%be%e6%a0%87">#</a>
</h4>
<h4 id="352-tlsssl握手失败">
  3.5.2 TLS/SSL握手失败
  <a class="anchor" href="#352-tlsssl%e6%8f%a1%e6%89%8b%e5%a4%b1%e8%b4%a5">#</a>
</h4>
<h4 id="353-混合内容">
  3.5.3 混合内容
  <a class="anchor" href="#353-%e6%b7%b7%e5%90%88%e5%86%85%e5%ae%b9">#</a>
</h4>
<h2 id="第4章-选择https的必要性和疑惑">
  第4章 选择HTTPS的必要性和疑惑
  <a class="anchor" href="#%e7%ac%ac4%e7%ab%a0-%e9%80%89%e6%8b%a9https%e7%9a%84%e5%bf%85%e8%a6%81%e6%80%a7%e5%92%8c%e7%96%91%e6%83%91">#</a>
</h2>
<h2 id="第5章-快速搭建一个https网站">
  第5章 快速搭建一个HTTPS网站
  <a class="anchor" href="#%e7%ac%ac5%e7%ab%a0-%e5%bf%ab%e9%80%9f%e6%90%ad%e5%bb%ba%e4%b8%80%e4%b8%aahttps%e7%bd%91%e7%ab%99">#</a>
</h2>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第1章-http介绍">第1章 HTTP介绍</a>
      <ul>
        <li><a href="#13-网络模型">1.3 网络模型</a></li>
        <li><a href="#14-协议安全分析">1.4 协议安全分析</a></li>
      </ul>
    </li>
    <li><a href="#第2章-密码学">第2章 密码学</a>
      <ul>
        <li><a href="#21-对于密码学的认知">2.1 对于密码学的认知</a></li>
        <li><a href="#22-随机数">2.2 随机数</a>
          <ul>
            <li><a href="#221-随机数的类型">2.2.1 随机数的类型</a></li>
            <li><a href="#222-随机数的工作原理">2.2.2 随机数的工作原理</a></li>
            <li><a href="#223-常见的随机数生成器">2.2.3 常见的随机数生成器</a></li>
            <li><a href="#224-密码学算法中的随机数">2.2.4 密码学算法中的随机数</a></li>
          </ul>
        </li>
        <li><a href="#23-hash算法">2.3 Hash算法</a>
          <ul>
            <li><a href="#231-加密基元">2.3.1 加密基元</a></li>
            <li><a href="#232-hash算法和密码学hash算法">2.3.2 Hash算法和密码学Hash算法</a></li>
            <li><a href="#233-密码学hash算法的特性">2.3.3 密码学Hash算法的特性</a></li>
            <li><a href="#234-hash算法的用途">2.3.4 Hash算法的用途</a></li>
            <li><a href="#235-什么是安全的密码学hash算法">2.3.5 什么是安全的密码学Hash算法</a></li>
            <li><a href="#236-密码学hash算法的分类">2.3.6 密码学Hash算法的分类</a></li>
          </ul>
        </li>
        <li><a href="#24-对称加密算法">2.4 对称加密算法</a>
          <ul>
            <li><a href="#241-流密码算法">2.4.1 流密码算法</a></li>
            <li><a href="#242-块密码算法">2.4.2 块密码算法</a></li>
            <li><a href="#243-填充标准">2.4.3 填充标准</a></li>
            <li><a href="#244-对称加密算法实践">2.4.4 对称加密算法实践</a></li>
          </ul>
        </li>
        <li><a href="#25-消息验证码">2.5 消息验证码</a>
          <ul>
            <li><a href="#251-什么是消息验证码">2.5.1 什么是消息验证码</a></li>
            <li><a href="#252-mac-算法的种类">2.5.2 MAC 算法的种类</a></li>
            <li><a href="#253-消息验证码算法实践">2.5.3 消息验证码算法实践</a></li>
            <li><a href="#254-加密算法不能提供完整性">2.5.4 加密算法不能提供完整性</a></li>
            <li><a href="#hash算法可以作为消息验证码吗">hash算法可以作为消息验证码吗？</a></li>
            <li><a href="#接收方怎么验证消息验证码">接收方怎么验证消息验证码？</a></li>
            <li><a href="#发送方什么时候非接收方提供密钥的">发送方什么时候非接收方提供密钥的？</a></li>
          </ul>
        </li>
        <li><a href="#26-公开密钥算法非对称加密">2.6 公开密钥算法(非对称加密)</a>
          <ul>
            <li><a href="#261-理解rsa的内部结构">2.6.1 理解RSA的内部结构</a></li>
            <li><a href="#262-pkcs标准">2.6.2 PKCS标准</a></li>
            <li><a href="#263-rsa加密算法的应用场景">2.6.3 RSA加密算法的应用场景</a></li>
            <li><a href="#264-rsa加密算法实践">2.6.4 RSA加密算法实践</a></li>
          </ul>
        </li>
        <li><a href="#27-密钥">2.7 密钥</a>
          <ul>
            <li><a href="#271-生成密钥">2.7.1 生成密钥</a></li>
            <li><a href="#272-口令和peb算法">2.7.2 口令和PEB算法</a></li>
            <li><a href="#273-密钥存储和传输">2.7.3 密钥存储和传输</a></li>
          </ul>
        </li>
        <li><a href="#28-密钥协商算法">2.8 密钥协商算法</a>
          <ul>
            <li><a href="#281-rsa密钥协商算法">2.8.1 RSA密钥协商算法</a></li>
            <li><a href="#282-dh密钥协商算法">2.8.2 DH密钥协商算法</a></li>
            <li><a href="#283-dh算法分类">2.8.3 DH算法分类</a></li>
            <li><a href="#284-dh密钥协商算法实践">2.8.4 DH密钥协商算法实践</a></li>
          </ul>
        </li>
        <li><a href="#29-椭圆曲线密码学">2.9 椭圆曲线密码学</a>
          <ul>
            <li><a href="#291-ecc算法的基本模型">2.9.1 ECC算法的基本模型</a></li>
            <li><a href="#292-使用openssl了解命名曲线">2.9.2 使用OpenSSL了解命名曲线</a></li>
            <li><a href="#293-ecdh协商算法">2.9.3 ECDH协商算法</a></li>
            <li><a href="#294-命名曲线">2.9.4 命名曲线</a></li>
          </ul>
        </li>
        <li><a href="#210-数字签名">2.10 数字签名</a>
          <ul>
            <li><a href="#2101-数字签名的用途">2.10.1 数字签名的用途</a></li>
            <li><a href="#2102-数字签名的流程">2.10.2 数字签名的流程</a></li>
            <li><a href="#2103-rsa数字签名算法">2.10.3 RSA数字签名算法</a></li>
            <li><a href="#2104-rsa数字签名实践">2.10.4 RSA数字签名实践</a></li>
          </ul>
        </li>
        <li><a href="#211-dsa数字签名算法">2.11 DSA数字签名算法</a>
          <ul>
            <li><a href="#防篡改和防伪造的区别是什么">防篡改和防伪造的区别是什么</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第3章-宏观理解tls">第3章 宏观理解TLS</a>
      <ul>
        <li><a href="#31-tlsssl-协议综述">3.1 TLS/SSL 协议综述</a></li>
        <li><a href="#32-tlsssl协议背后的算法">3.2 TLS/SSL协议背后的算法</a>
          <ul>
            <li><a href="#321-加密算法和mac算法">3.2.1 加密算法和MAC算法</a></li>
            <li><a href="#322-密钥协商算法">3.2.2 密钥协商算法</a></li>
            <li><a href="#323-前向安全性">3.2.3 前向安全性</a></li>
            <li><a href="#324-密钥衍生算法">3.2.4 密钥衍生算法</a>
              <ul>
                <li><a href="#密钥衍生算法在https是怎么应用的">密钥衍生算法在HTTPS是怎么应用的？</a></li>
                <li><a href="#在https中会使用密钥衍生算法生成哪些密钥能具体列举出来吗">在HTTPS中，会使用密钥衍生算法生成哪些密钥，能具体列举出来吗？</a></li>
              </ul>
            </li>
            <li><a href="#325-中间人攻击">3.2.5 中间人攻击</a>
              <ul>
                <li><a href="#客户端和服务器之间只传递预主密钥密钥块是两边分别计算出来的是这样吗">客户端和服务器之间只传递预主密钥，密钥块是两边分别计算出来的，是这样吗</a></li>
              </ul>
            </li>
            <li><a href="#326-pki">3.2.6 PKI</a></li>
          </ul>
        </li>
        <li><a href="#33-https总结">3.3 HTTPS总结</a>
          <ul>
            <li><a href="#331-握手">3.3.1 握手</a>
              <ul>
                <li><a href="#1-认证">1 认证</a></li>
                <li><a href="#2-密码套件协商">2 密码套件协商</a></li>
                <li><a href="#3-密钥协商">3 密钥协商</a></li>
                <li><a href="#4-握手消息完整性校验">4 握手消息完整性校验</a>
                  <ul>
                    <li><a href="#finished-消息包含的哈希值是怎么计算的以及是怎么比较的">Finished 消息包含的哈希值是怎么计算的，以及是怎么比较的</a></li>
                  </ul>
                </li>
                <li><a href="#使用charles来解密https请求内容的原理是什么">使用Charles来解密https请求内容的原理是什么？</a></li>
                <li><a href="#在使用charles进行https抓包的时候有些接口会连接失败这是什么原因">在使用charles进行https抓包的时候，有些接口会连接失败，这是什么原因</a></li>
              </ul>
            </li>
            <li><a href="#332-加密">3.3.2 加密</a></li>
          </ul>
        </li>
        <li><a href="#34-实施https网站的必备条件">3.4 实施HTTPS网站的必备条件</a>
          <ul>
            <li><a href="#341-证书和密钥对">3.4.1 证书和密钥对</a></li>
            <li><a href="#342-部署和配置https网站">3.4.2 部署和配置HTTPS网站</a></li>
            <li><a href="#343-全站https策略">3.4.3 全站HTTPS策略</a></li>
          </ul>
        </li>
        <li><a href="#35-从用户的角度看https">3.5 从用户的角度看HTTPS</a>
          <ul>
            <li><a href="#351-绿色小锁图标">3.5.1 绿色小锁图标</a></li>
            <li><a href="#352-tlsssl握手失败">3.5.2 TLS/SSL握手失败</a></li>
            <li><a href="#353-混合内容">3.5.3 混合内容</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第4章-选择https的必要性和疑惑">第4章 选择HTTPS的必要性和疑惑</a></li>
    <li><a href="#第5章-快速搭建一个https网站">第5章 快速搭建一个HTTPS网站</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












