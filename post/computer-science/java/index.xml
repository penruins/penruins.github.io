<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Penruins</title>
    <link>/post/computer-science/java/</link>
    <description>Recent content on Penruins</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="/post/computer-science/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>java basic</title>
      <link>/post/computer-science/java/java-basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/post/computer-science/java/java-basic/</guid>
      <description>&lt;h1 id=&#34;java-basic&#34;&gt;&#xA;  java basic&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java-basic&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;mess&#34;&gt;&#xA;  mess&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mess&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;八大数据类型&#34;&gt;&#xA;  八大数据类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%ab%e5%a4%a7%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;byte&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;char&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;short&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;long&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;float&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;double&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;transient-关键字的作用是什么&#34;&gt;&#xA;  transient 关键字的作用是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#transient-%e5%85%b3%e9%94%ae%e5%ad%97%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在一个类中如果变量被 transient 关键字修饰，在对类的对象进行序列化的时候就会忽略这个变量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;什么是深拷贝什么是浅拷贝&#34;&gt;&#xA;  什么是深拷贝？什么是浅拷贝？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e6%b7%b1%e6%8b%b7%e8%b4%9d%e4%bb%80%e4%b9%88%e6%98%af%e6%b5%85%e6%8b%b7%e8%b4%9d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;深拷贝：递归地复制对象及其所有嵌套的子对象，生成一个完全独立的新对象。两个对象之间不共享引用&lt;/li&gt;&#xA;&lt;li&gt;浅拷贝：创建一个新的对象，但只复制对象的最外层属性的引用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;string&#34;&gt;&#xA;  String&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#string&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;equals与--区别&#34;&gt;&#xA;  equals与 == 区别&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#equals%e4%b8%8e--%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;equals&lt;/code&gt; 比较的是两个字符串的内容是否是相等的&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 比较的是两个变量指向的引用是否是相等的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;stringbuilder-stringbuffer区别&#34;&gt;&#xA;  StringBuilder StringBuffer区别&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuilder-stringbuffer%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;StringBuilder 线程不安全&lt;/li&gt;&#xA;&lt;li&gt;StringBuffer 线程安全&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;stringbuffer-是怎么保证线程安全的&#34;&gt;&#xA;  StringBuffer 是怎么保证线程安全的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuffer-%e6%98%af%e6%80%8e%e4%b9%88%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对字符串操作的方法都通过 synchronized 关键字修饰，保证线程安全&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;stringbuffer-和-stringbuilder-字符串在底层是以什么数据结构保存的&#34;&gt;&#xA;  StringBuffer 和 StringBuilder 字符串在底层是以什么数据结构保存的&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuffer-%e5%92%8c-stringbuilder-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%9c%a8%e5%ba%95%e5%b1%82%e6%98%af%e4%bb%a5%e4%bb%80%e4%b9%88%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%bf%9d%e5%ad%98%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;两个类都继承子 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 均使用 &lt;code&gt;char[] value&lt;/code&gt; 保存字符串数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;hashmap&#34;&gt;&#xA;  HashMap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;hashmap底层的数据结构是怎样的&#34;&gt;&#xA;  HashMap底层的数据结构是怎样的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap%e5%ba%95%e5%b1%82%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;java 1.8 之前 数组 + 链表&lt;/li&gt;&#xA;&lt;li&gt;java 1.8 之后 数组 + 链表/红黑树&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;hashmap-是否线程安全如何保证线程安全&#34;&gt;&#xA;  HashMap 是否线程安全，如何保证线程安全&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap-%e6%98%af%e5%90%a6%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不是线程安全的&lt;/li&gt;&#xA;&lt;li&gt;如何保证线程安全&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Collections.synchronizedMap()&lt;/li&gt;&#xA;&lt;li&gt;ConcurrentHashMap&lt;/li&gt;&#xA;&lt;li&gt;读写锁 ReadWriteLock&lt;/li&gt;&#xA;&lt;li&gt;局部使用 HashMap&lt;/li&gt;&#xA;&lt;li&gt;初始化写，后续只读&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;hashmap-get-时间复杂度&#34;&gt;&#xA;  HashMap get 时间复杂度&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap-get-%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最好的情况是O(1)&lt;/li&gt;&#xA;&lt;li&gt;若发生哈希碰撞，对应到桶之后还需要查询链表或红黑树，时间复杂度下降到O(N)或O(logN)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;hashmap-和-hashtable-有什么区别&#34;&gt;&#xA;  HashMap 和 Hashtable 有什么区别？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap-%e5%92%8c-hashtable-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程安全性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HashMap是线程不安全的，HashTable是线程安全的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;对空值的支持&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HashMap的key和value都支持空值，HashTable不支持key或value为空值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;list&#34;&gt;&#xA;  List&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#list&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;collection-和-collections-有什么区别&#34;&gt;&#xA;  Collection 和 Collections 有什么区别？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#collection-%e5%92%8c-collections-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Collection 是集合类的一个接口&lt;/li&gt;&#xA;&lt;li&gt;Collections 是集合的一个工具类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;linkedlist-删除时间复杂度&#34;&gt;&#xA;  LinkedList 删除时间复杂度&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linkedlist-%e5%88%a0%e9%99%a4%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除头和尾的时间复杂度为O(1)，因为在LinkedList中维护了头和尾2个指针&lt;/li&gt;&#xA;&lt;li&gt;其他位置的时间复杂度为O(n)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;函数式编程&#34;&gt;&#xA;  函数式编程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;java的函数式编程包含哪些内容&#34;&gt;&#xA;  java的函数式编程包含哪些内容？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e7%9a%84%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%8c%85%e5%90%ab%e5%93%aa%e4%ba%9b%e5%86%85%e5%ae%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;java的函数式编程的概念中将只包含一个方法的接口称为函数式接口，可以通过Lambda表达式简化匿名类的定义&lt;/li&gt;&#xA;&lt;li&gt;提供流操作了API，可以将集合的迭代操作变为链式操作，提供了并行处理集合的方法&lt;/li&gt;&#xA;&lt;li&gt;提供了Optional类用来处理空指针的情况&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;io&#34;&gt;&#xA;  I/O&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#io&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;网络io分为哪几种&#34;&gt;&#xA;  网络io分为哪几种&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bd%91%e7%bb%9cio%e5%88%86%e4%b8%ba%e5%93%aa%e5%87%a0%e7%a7%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;网络 I/O 模型主要分为以下五种：&lt;/p&gt;</description>
    </item>
    <item>
      <title>java</title>
      <link>/post/computer-science/java/java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/post/computer-science/java/java/</guid>
      <description>&lt;h1 id=&#34;string&#34;&gt;&#xA;  String&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#string&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;stringbuffer-是怎么保证线程安全的&#34;&gt;&#xA;  StringBuffer 是怎么保证线程安全的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuffer-%e6%98%af%e6%80%8e%e4%b9%88%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt; 是通过 &lt;strong&gt;同步机制&lt;/strong&gt; 来保证线程安全的。具体来说，它的所有关键方法（如 &lt;code&gt;append()&lt;/code&gt;、&lt;code&gt;insert()&lt;/code&gt;、&lt;code&gt;delete()&lt;/code&gt;、&lt;code&gt;reverse()&lt;/code&gt; 等）都使用了 &lt;code&gt;synchronized&lt;/code&gt; 关键字进行修饰，确保同一时间只有一个线程可以执行这些方法&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;2&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;7&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-同步方法&#34;&gt;&#xA;  1. &lt;strong&gt;同步方法&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e5%90%8c%e6%ad%a5%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt; 的方法在设计时都加了 &lt;code&gt;synchronized&lt;/code&gt; 关键字，例如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; StringBuffer &lt;span style=&#34;color:#a6e22e&#34;&gt;append&lt;/span&gt;(String str) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 方法实现&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种机制确保了在多线程环境下，只有一个线程可以访问和修改 &lt;code&gt;StringBuffer&lt;/code&gt; 的内容，避免了竞态条件（Race Condition）和数据不一致的问题&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;2&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-锁机制&#34;&gt;&#xA;  2. &lt;strong&gt;锁机制&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%e9%94%81%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt; 内部使用了一个锁对象（即 &lt;code&gt;this&lt;/code&gt; 锁），当一个线程调用 &lt;code&gt;StringBuffer&lt;/code&gt; 的同步方法时，会获取这个锁，其他线程必须等待锁释放后才能继续执行。这种锁机制保证了线程间的同步&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;7&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-性能影响&#34;&gt;&#xA;  3. &lt;strong&gt;性能影响&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%e6%80%a7%e8%83%bd%e5%bd%b1%e5%93%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;虽然 &lt;code&gt;StringBuffer&lt;/code&gt; 的同步机制确保了线程安全，但也带来了性能开销。因为在多线程环境下，每次只能有一个线程操作 &lt;code&gt;StringBuffer&lt;/code&gt;，其他线程会被阻塞。因此，在单线程环境下，推荐使用性能更高的 &lt;code&gt;StringBuilder&lt;/code&gt;，它没有同步机制&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;5&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;8&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-适用场景&#34;&gt;&#xA;  4. &lt;strong&gt;适用场景&lt;/strong&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;多线程环境&lt;/strong&gt;：如果需要在多线程环境下对字符串进行操作，&lt;code&gt;StringBuffer&lt;/code&gt; 是合适的选择，因为它确保了线程安全&lt;a href=&#34;@ref&#34;&gt;2&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;9&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;单线程环境&lt;/strong&gt;：在单线程环境下，建议使用 &lt;code&gt;StringBuilder&lt;/code&gt;，因为它没有同步开销，性能更高&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;8&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;总结&#34;&gt;&#xA;  总结&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%bb%e7%bb%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt; 通过 &lt;code&gt;synchronized&lt;/code&gt; 关键字实现的同步机制，确保了多线程环境下的线程安全性。虽然这种机制带来了性能开销，但在需要线程安全的场景下，它是一个可靠的选择&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;2&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;7&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;stringbuffer-和-stringbuilder-字符串在底层是以什么数据结构保存的&#34;&gt;&#xA;  StringBuffer 和 StringBuilder 字符串在底层是以什么数据结构保存的&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuffer-%e5%92%8c-stringbuilder-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%9c%a8%e5%ba%95%e5%b1%82%e6%98%af%e4%bb%a5%e4%bb%80%e4%b9%88%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%bf%9d%e5%ad%98%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt; 和 &lt;code&gt;StringBuilder&lt;/code&gt; 在底层都是使用 &lt;strong&gt;字符数组（&lt;code&gt;char[]&lt;/code&gt;）&lt;/strong&gt; 来保存字符串数据的。具体来说，它们继承了 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 类，而 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 类中定义了一个 &lt;code&gt;char[] value&lt;/code&gt; 数组，用于存储字符序列&lt;a href=&#34;@ref&#34;&gt;1&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;3&lt;/a&gt;&lt;a href=&#34;@ref&#34;&gt;4&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>concurrent</title>
      <link>/post/computer-science/java/concurrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/post/computer-science/java/concurrent/</guid>
      <description>&lt;h1 id=&#34;concurrent&#34;&gt;&#xA;  concurrent&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#concurrent&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;synchronized&#34;&gt;&#xA;  synchronized&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;synchronized-的底层原理是什么&#34;&gt;&#xA;  synchronized 的底层原理是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized-%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于 jvm 的 Monitor 机制&lt;/li&gt;&#xA;&lt;li&gt;通过进入和退出 Monitor 对象来实现方法和代码块的同步&lt;/li&gt;&#xA;&lt;li&gt;字节码指令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;monitorenter&lt;/code&gt; 获取 Monitor 的所有权&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;monitorexit&lt;/code&gt; 释放 Monitor 的所有权&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;同步方法的实现&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ACC_SYNCHRONIZED 标志：当方法被 synchronized 修饰时，JVM 会在方法常量池中设置 ACC_SYNCHRONIZED 标志。&lt;/li&gt;&#xA;&lt;li&gt;调用方法时，JVM 检查该标志。如果设置了，线程必须先获取 Monitor 才能执行方法，执行完成后释放 Monitor&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;锁的优化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为了提升性能，JVM 对 synchronized 进行了优化，包括&#xA;&lt;ul&gt;&#xA;&lt;li&gt;偏向锁（Biased Locking）：当锁始终由同一线程持有时，JVM 会将锁标记为偏向锁，减少锁获取的开销&lt;/li&gt;&#xA;&lt;li&gt;轻量级锁（Lightweight Locking）：当存在多个线程交替执行时，JVM 会将锁升级为轻量级锁，通过 CAS 操作减少阻塞&lt;/li&gt;&#xA;&lt;li&gt;重量级锁（Heavyweight Locking）：当锁竞争激烈时，JVM 会将锁升级为重量级锁，依赖于操作系统的互斥量（Mutex）实现&lt;/li&gt;&#xA;&lt;li&gt;自旋锁（Spin Locking）：当线程无法获取锁时，会进行有限次数的自旋尝试，避免直接进入阻塞状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;concurrenthashmap&#34;&gt;&#xA;  ConcurrentHashMap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#concurrenthashmap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;concurrentlinkedhashmap&#34;&gt;&#xA;  ConcurrentLinkedHashMap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#concurrentlinkedhashmap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;比较-concurrenthash-和-concurrentlinkedhashmap&#34;&gt;&#xA;  比较 ConcurrentHash 和 ConcurrentLinkedHashMap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%af%94%e8%be%83-concurrenthash-%e5%92%8c-concurrentlinkedhashmap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在ConcurrentHashMap的基础上，增加了&lt;strong&gt;双向链表&lt;/strong&gt;来维护插入顺序或访问顺序&lt;/li&gt;&#xA;&lt;li&gt;支持LRU缓存淘汰策略，通过Weigher计算存储单元数，自动清理最近最少使用的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;线程池&#34;&gt;&#xA;  线程池&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;线程池的核心参数&#34;&gt;&#xA;  线程池的核心参数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e6%a0%b8%e5%bf%83%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;核心线程数 corePoolSize&lt;/li&gt;&#xA;&lt;li&gt;最大线程数 maximumPoolSize&lt;/li&gt;&#xA;&lt;li&gt;空闲线程存活时间 keepAliveTime&lt;/li&gt;&#xA;&lt;li&gt;时间单位 unit&lt;/li&gt;&#xA;&lt;li&gt;任务队列 workQueue&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ArrayBlockingQueue 基于数组的&lt;strong&gt;有界&lt;/strong&gt;队列&lt;/li&gt;&#xA;&lt;li&gt;LinkedBlockingQueue 基于链表的&lt;strong&gt;无界&lt;/strong&gt;队列&lt;/li&gt;&#xA;&lt;li&gt;SynchronousQueue 不存储元素的队列，直接交给线程处理&lt;/li&gt;&#xA;&lt;li&gt;PriorityBlockingQueue 支持优先级的&lt;strong&gt;无界&lt;/strong&gt;队列&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;线程工厂 threadFactory&lt;/li&gt;&#xA;&lt;li&gt;拒绝策略 handler&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AbortPolicy 抛弃任务并抛出异常 RejectedExecutionException&lt;/li&gt;&#xA;&lt;li&gt;DiscardPolicy 抛弃任务但不抛出异常&lt;/li&gt;&#xA;&lt;li&gt;CallerRunsPolicy 由提交任务的线程自己执行任务&lt;/li&gt;&#xA;&lt;li&gt;DiscardOldestPolicy 抛弃优先级最低的任务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;线程池的关键参数比如核心线程数等待队列拒绝策略在创建的时候做什么考虑&#34;&gt;&#xA;  线程池的关键参数，比如核心线程数、等待队列、拒绝策略，在创建的时候做什么考虑&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%85%b3%e9%94%ae%e5%8f%82%e6%95%b0%e6%af%94%e5%a6%82%e6%a0%b8%e5%bf%83%e7%ba%bf%e7%a8%8b%e6%95%b0%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5%e5%9c%a8%e5%88%9b%e5%bb%ba%e7%9a%84%e6%97%b6%e5%80%99%e5%81%9a%e4%bb%80%e4%b9%88%e8%80%83%e8%99%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;核心线程数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;任务类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU密集型: CPU核数 + 1&lt;/li&gt;&#xA;&lt;li&gt;IO密集型: CPU核数 * 2&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;最大线程数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;默认设置为与核心线程数一致，减少创建线程和销毁线程的开销&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;等待队列&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无界队列: 任务量稳定的场景, 但可能导致内存溢出&lt;/li&gt;&#xA;&lt;li&gt;有界队列: 任务量波动的场景&lt;/li&gt;&#xA;&lt;li&gt;同步队列: 适合任务量较少的场景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;拒绝策略&#xA;&lt;ul&gt;&#xA;&lt;li&gt;任务重要性: 如果任务不能丢弃，使用 CallerRunsPolicy(由提交任务的线程自己执行任务)&lt;/li&gt;&#xA;&lt;li&gt;系统容错性: 如果任务可以丢弃, 使用 DiscardPolicy(抛弃任务但不抛出异常) 和 DiscardOldestPolicy(抛弃优先级最低的任务)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;线程空闲时间&#xA;&lt;ul&gt;&#xA;&lt;li&gt;任务波动性: 如果任务波动较大，可以设置较短的空闲时间，及时回收线程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果在出现任务峰值的时候，创建线程锁产生的开销要如何处理？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;线程工厂&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程命名: 自定义线程名称，便于监控与查询问题&lt;/li&gt;&#xA;&lt;li&gt;线程优先级: 根据任务重要性设置线程优先级&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;线程池拒绝策略有哪些你项目通常选用哪个遇到重要场景触发拒绝策略必须需要处理任务你如何处理&#34;&gt;&#xA;  线程池拒绝策略有哪些，你项目通常选用哪个，遇到重要场景触发拒绝策略必须需要处理任务你如何处理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bd%a0%e9%a1%b9%e7%9b%ae%e9%80%9a%e5%b8%b8%e9%80%89%e7%94%a8%e5%93%aa%e4%b8%aa%e9%81%87%e5%88%b0%e9%87%8d%e8%a6%81%e5%9c%ba%e6%99%af%e8%a7%a6%e5%8f%91%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5%e5%bf%85%e9%a1%bb%e9%9c%80%e8%a6%81%e5%a4%84%e7%90%86%e4%bb%bb%e5%8a%a1%e4%bd%a0%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程池拒绝策略&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AbortPolicy 抛异常&lt;/li&gt;&#xA;&lt;li&gt;CallerRunsPolicy&lt;/li&gt;&#xA;&lt;li&gt;DiscardPolicy 不抛异常&lt;/li&gt;&#xA;&lt;li&gt;DiscardOldestPolicy&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;项目中常用哪个？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以容忍丢失的情况 DiscardPolicy DiscardOldestPolicy&lt;/li&gt;&#xA;&lt;li&gt;不允许有丢弃的情况：CallerRunsPolicy&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;重要场景触发拒绝策略的处理方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 CallerRunsPolicy&lt;/li&gt;&#xA;&lt;li&gt;自定义拒绝策略：增加自定义异常处理器，将拒绝的任务添加到外部的消息队列中，后续再进行提交&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;动态调整线程池的参数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;监控线程池的状态，动态调整 corePoolSize, maximumPoolSize, queueCapacity, 以应对突发流量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;如何实现动态线程池&#34;&gt;&#xA;  如何实现动态线程池？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过线程池的方法设置&lt;strong&gt;核心线程数&lt;/strong&gt;、&lt;strong&gt;最大线程数&lt;/strong&gt;、&lt;strong&gt;最大空闲时间&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;jdk-创建线程池有哪些方式&#34;&gt;&#xA;  JDK 创建线程池有哪些方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdk-%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%9c%89%e5%93%aa%e4%ba%9b%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过 &lt;code&gt;Executors&lt;/code&gt; 工厂类创建&#xA;&lt;ul&gt;&#xA;&lt;li&gt;newFixedThreadPool&lt;/li&gt;&#xA;&lt;li&gt;newCachedThreadPool&lt;/li&gt;&#xA;&lt;li&gt;newSingleThreadExecutor&lt;/li&gt;&#xA;&lt;li&gt;newScheduledThreadPool&lt;/li&gt;&#xA;&lt;li&gt;newSingleThreadScheduledExecutor&lt;/li&gt;&#xA;&lt;li&gt;newWorkStealingPool&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通过 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 手动指定参数创建&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;进程间通信&#34;&gt;&#xA;  进程间通信&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;管道 Pipe&lt;/li&gt;&#xA;&lt;li&gt;消息队列 Message Queue&lt;/li&gt;&#xA;&lt;li&gt;共享内存 Shared Memory&lt;/li&gt;&#xA;&lt;li&gt;信号 Signal&#xA;&lt;ul&gt;&#xA;&lt;li&gt;kill&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;信号量 Semaphore&lt;/li&gt;&#xA;&lt;li&gt;套接字 Socket&lt;/li&gt;&#xA;&lt;li&gt;文件 File&lt;/li&gt;&#xA;&lt;li&gt;内存映射文件 Memory-Mapped File&lt;/li&gt;&#xA;&lt;li&gt;远程过程调用 RPC, Remote Procedure Call&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;juc&#34;&gt;&#xA;  JUC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#juc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;juc-包下的7大类&#34;&gt;&#xA;  JUC 包下的7大类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#juc-%e5%8c%85%e4%b8%8b%e7%9a%847%e5%a4%a7%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;原子变量类（&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; 包）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于实现无锁的线程安全操作，基于CAS（Compare and Swap）机制：&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;AtomicInteger&lt;/code&gt;：原子操作的整型变量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;AtomicLong&lt;/code&gt;：原子操作的长整型变量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;AtomicBoolean&lt;/code&gt;：原子操作的布尔变量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;AtomicReference&amp;lt;V&amp;gt;&lt;/code&gt;：原子操作的引用类型变量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;AtomicStampedReference&amp;lt;V&amp;gt;&lt;/code&gt;：带版本戳的原子引用，解决ABA问题。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;锁和同步器类（&lt;code&gt;java.util.concurrent.locks&lt;/code&gt; 包）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提供更灵活的锁机制，替代传统的&lt;code&gt;synchronized&lt;/code&gt;关键字：&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;：可重入锁，支持公平锁和非公平锁。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;：读写锁，支持读多写少的场景。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;StampedLock&lt;/code&gt;：基于邮戳的锁，提供乐观读锁。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Condition&lt;/code&gt;：条件变量，用于线程间的等待和唤醒。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;并发集合类（&lt;code&gt;java.util.concurrent&lt;/code&gt; 包）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程安全的集合类，优化了高并发场景下的性能：&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;：线程安全的哈希表，采用分段锁或CAS机制。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;：写时复制的线程安全列表，适合读多写少的场景。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;：无界的线程安全队列，基于CAS实现。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;同步工具类&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于线程间的协作和同步：&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;：计数器门闩，等待一组线程完成。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CyclicBarrier&lt;/code&gt;：循环栅栏，等待一组线程到达同步点。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;：信号量，控制同时访问资源的线程数量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Phaser&lt;/code&gt;：更灵活的同步器，支持动态注册线程和多次同步。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;线程池框架（&lt;code&gt;java.util.concurrent&lt;/code&gt; 包）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于管理线程的生命周期和任务调度：&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ExecutorService&lt;/code&gt;：线程池接口，提供任务提交、关闭等功能。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;：可自定义的线程池实现。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ScheduledExecutorService&lt;/code&gt;：支持定时任务和周期任务的线程池。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ForkJoinPool&lt;/code&gt;：用于分治算法和并行流的线程池。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;阻塞队列类（&lt;code&gt;java.util.concurrent&lt;/code&gt; 包）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程安全的阻塞队列，用于生产者-消费者模型：&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;：基于数组的&lt;strong&gt;有界&lt;/strong&gt;阻塞队列。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;：基于链表的&lt;strong&gt;无界&lt;/strong&gt;阻塞队列。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;PriorityBlockingQueue&lt;/code&gt;：支持优先级的无界阻塞队列。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;其他工具类&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Future&amp;lt;V&amp;gt;&lt;/code&gt;：表示异步计算的结果。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CompletableFuture&amp;lt;V&amp;gt;&lt;/code&gt;：支持异步编程的增强版&lt;code&gt;Future&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Exchanger&amp;lt;V&amp;gt;&lt;/code&gt;：用于线程间交换数据的工具。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;threadlocal&#34;&gt;&#xA;  ThreadLocal&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadlocal&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;threadlocal-原理&#34;&gt;&#xA;  ThreadLocal 原理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadlocal-%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每一个线程都维护一个对象副本，每个线程独立地访问和操作各自的副本&lt;/li&gt;&#xA;&lt;li&gt;数据是保存在 Thread 父类的 ThreadLocalMap 中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;锁&#34;&gt;&#xA;  锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;java里的锁有哪些&#34;&gt;&#xA;  Java里的锁有哪些&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e9%87%8c%e7%9a%84%e9%94%81%e6%9c%89%e5%93%aa%e4%ba%9b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;锁的类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;synchronized 内置锁&lt;/li&gt;&#xA;&lt;li&gt;ReentrantLock 可重入锁&lt;/li&gt;&#xA;&lt;li&gt;ReadWriteLock 读写锁&lt;/li&gt;&#xA;&lt;li&gt;StampedLock 邮戳锁&lt;/li&gt;&#xA;&lt;li&gt;Condition 条件锁&#xA;&lt;ul&gt;&#xA;&lt;li&gt;与ReentrantLock 配合使用，实现线程间的等待和唤醒&lt;/li&gt;&#xA;&lt;li&gt;类似于 Object.wait() 和 Object.notify()，但更灵活&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;LockSupport&lt;/li&gt;&#xA;&lt;li&gt;Semaphore 信号量&lt;/li&gt;&#xA;&lt;li&gt;CountDownLatch 倒计时锁&lt;/li&gt;&#xA;&lt;li&gt;CyclicBarrier 循环屏障&lt;/li&gt;&#xA;&lt;li&gt;Phaser 阶段锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;不同的锁的使用场景&#xA;&lt;ul&gt;&#xA;&lt;li&gt;简单场景：使用 synchronized&lt;/li&gt;&#xA;&lt;li&gt;复杂场景：使用 ReentrantLock、ReadWriteLock 或 StampedLock&lt;/li&gt;&#xA;&lt;li&gt;线程协作：使用 Condition、CountDownLatch、CyclicBarrier 或 Phaser&lt;/li&gt;&#xA;&lt;li&gt;资源限制：使用 Semaphore&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;锁升级&#34;&gt;&#xA;  锁升级&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81%e5%8d%87%e7%ba%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;锁升级的过程&#34;&gt;&#xA;  锁升级的过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81%e5%8d%87%e7%ba%a7%e7%9a%84%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;锁机制根据竞争情况自动或手动调整锁的粒度和强度的过程，目的是在保证线程安全的同时优化性能&lt;/li&gt;&#xA;&lt;li&gt;在Java中，锁升级特指synchronized关键字的优化机制。JDK 1.6后，为了减少锁操作的开销，JVM引入了&lt;strong&gt;偏向锁&lt;/strong&gt;、&lt;strong&gt;轻量级锁&lt;/strong&gt;、&lt;strong&gt;重量级锁&lt;/strong&gt;三种状态，锁状态只能从低到高单向升级，不可降级&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;锁升级的4个阶段是什么&#34;&gt;&#xA;  锁升级的4个阶段是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81%e5%8d%87%e7%ba%a7%e7%9a%844%e4%b8%aa%e9%98%b6%e6%ae%b5%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;无锁状态&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;共享对象没有被任何线程锁定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;首次通过 synchronized 获取锁时，JVM讲锁标记为偏向锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当多线程竞争偏向锁时，JVM讲锁由偏向锁转换为轻量级锁&lt;/li&gt;&#xA;&lt;li&gt;通过CAS实现&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;重量级锁&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;轻量级锁自旋失败（如自旋次数超过阈值）或高并发竞争激烈时&lt;/li&gt;&#xA;&lt;li&gt;依赖操作系统的互斥量 Mutex&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;公平非公平&#34;&gt;&#xA;  公平、非公平&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%ac%e5%b9%b3%e9%9d%9e%e5%85%ac%e5%b9%b3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;什么是公平锁非公平锁&#34;&gt;&#xA;  什么是公平锁、非公平锁？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e5%85%ac%e5%b9%b3%e9%94%81%e9%9d%9e%e5%85%ac%e5%b9%b3%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;公平锁：线程根据申请锁的顺序获取锁&lt;/li&gt;&#xA;&lt;li&gt;非公平锁：允许线程直接获取锁，而不用考虑申请锁的顺序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;synchronized-是公平的还是不公平的&#34;&gt;&#xA;  synchronized 是公平的还是不公平的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized-%e6%98%af%e5%85%ac%e5%b9%b3%e7%9a%84%e8%bf%98%e6%98%af%e4%b8%8d%e5%85%ac%e5%b9%b3%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不公平的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;reentrantlock-公平性&#34;&gt;&#xA;  ReentrantLock 公平性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reentrantlock-%e5%85%ac%e5%b9%b3%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以在构造可重入锁时指定是公平锁还是非公平锁&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AQS AbstractQueuedSynchronizer的队列机制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FairSync 维护一个 FIFO 的队列&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;cas&#34;&gt;&#xA;  CAS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是cas&#34;&gt;&#xA;  什么是CAS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afcas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个原子性的硬件指令 compare and swap 比较并交换。多线程的场景下，只有一个线程能比较成功并交换值，其他线程比较失败不执行交换&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;aqs&#34;&gt;&#xA;  AQS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aqs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是aqs&#34;&gt;&#xA;  什么是AQS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afaqs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 用于构造锁和同步器类的基础类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aqs的核心概念是什么&#34;&gt;&#xA;  AQS的核心概念是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aqs%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步状态&lt;/li&gt;&#xA;&lt;li&gt;等待队列&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aqs的模板方法有哪些&#34;&gt;&#xA;  AQS的模板方法有哪些？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aqs%e7%9a%84%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;tryAcquire&lt;/li&gt;&#xA;&lt;li&gt;tryRelease&lt;/li&gt;&#xA;&lt;li&gt;tryAcquireShared&lt;/li&gt;&#xA;&lt;li&gt;tryAcquireReleased&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;aba-问题&#34;&gt;&#xA;  ABA 问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aba-%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;aba问题产生的原因是什么&#34;&gt;&#xA;  ABA问题产生的原因是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aba%e9%97%ae%e9%a2%98%e4%ba%a7%e7%94%9f%e7%9a%84%e5%8e%9f%e5%9b%a0%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 CAS 实现无锁数据结构，因为CAS只关注数据是否一致，没有关注数据是否更改过&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;如何解决aba问题&#34;&gt;&#xA;  如何解决ABA问题？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3aba%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用版本号, 比如使用原子变量类&lt;code&gt;AtomicStampedReference&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;jdk提供的原子变量类会存在aba问题吗&#34;&gt;&#xA;  JDK提供的原子变量类会存在ABA问题吗？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdk%e6%8f%90%e4%be%9b%e7%9a%84%e5%8e%9f%e5%ad%90%e5%8f%98%e9%87%8f%e7%b1%bb%e4%bc%9a%e5%ad%98%e5%9c%a8aba%e9%97%ae%e9%a2%98%e5%90%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>jvm</title>
      <link>/post/computer-science/java/jvm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/post/computer-science/java/jvm/</guid>
      <description>&lt;h1 id=&#34;jvm&#34;&gt;&#xA;  jvm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;jmm&#34;&gt;&#xA;  JMM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jmm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;java的jvm内存模型-java-memory-model&#34;&gt;&#xA;  Java的JVM内存模型 Java Memory Model&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e7%9a%84jvm%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b-java-memory-model&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主内存 Main Memory&lt;/li&gt;&#xA;&lt;li&gt;工作内存 Working Memory&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;jmm-的核心问题&#34;&gt;&#xA;  JMM 的核心问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jmm-%e7%9a%84%e6%a0%b8%e5%bf%83%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可见性&lt;/li&gt;&#xA;&lt;li&gt;原子性&lt;/li&gt;&#xA;&lt;li&gt;有序性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;内存机制&#34;&gt;&#xA;  内存机制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;jvm的内存机制是怎样的&#34;&gt;&#xA;  &lt;code&gt;JVM&lt;/code&gt;的内存机制是怎样的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm%e7%9a%84%e5%86%85%e5%ad%98%e6%9c%ba%e5%88%b6%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;jvm 的内存区域&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;程序计数器 Program Counter&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录当前线程的指令地址，用于记录线程恢复运行状态后执行指令的地址&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;虚拟机栈 Java Virtual Machine Stack&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于记录方法调用链&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;本地方法栈 Native Method Stack&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;类似于Java虚拟机栈，用于记录本地方法的调用链&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;堆 Heap&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于保存实例化的对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;方法区 Method Area&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录加载到内存中的类相关的信息&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;直接内存 Direct Memory&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;非阻塞式的IO操作的内存分配&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;垃圾回收机制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;标记-清除算法&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标记存活对象，清除未标记对象，但会产生内存碎片&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;标记-复制算法&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将存活对象复制到另一个内存区域，适用于新生代，效率高但内存利用率低&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;标记-整理算法&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标记存活对象后，将对象向一端移动，整理内存空间，适用于老年代&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;分代收集算法&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据对象生命周期将堆分为新生代和老年代，分别采用不同的回收算法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;jvm的内存模型中哪些是线程私有的&#34;&gt;&#xA;  JVM的内存模型中哪些是线程私有的？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm%e7%9a%84%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e4%b8%ad%e5%93%aa%e4%ba%9b%e6%98%af%e7%ba%bf%e7%a8%8b%e7%a7%81%e6%9c%89%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序计数器 Program Counter&lt;/li&gt;&#xA;&lt;li&gt;Java 虚拟机栈 Java Virtual Stack&lt;/li&gt;&#xA;&lt;li&gt;本地方法栈 Native Method Stack&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;垃圾回收&#34;&gt;&#xA;  垃圾回收&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;垃圾回收算法有哪些&#34;&gt;&#xA;  垃圾回收算法有哪些&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e7%ae%97%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标记-清除算法&lt;/li&gt;&#xA;&lt;li&gt;标记-复制算法&lt;/li&gt;&#xA;&lt;li&gt;标记-整理算法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote class=&#34;book-hint info&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;Reference&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mybatis</title>
      <link>/post/computer-science/java/mybatis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/post/computer-science/java/mybatis/</guid>
      <description>&lt;h2 id=&#34;mybatis是怎么进行事务管理的-2025-02-08&#34;&gt;&#xA;  mybatis是怎么进行事务管理的 2025-02-08&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mybatis%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9b%e8%a1%8c%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86%e7%9a%84-2025-02-08&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;MyBatis 通过集成外部事务管理器（如 Spring 或 Java EE 容器）或使用内置的 JDBC 事务管理机制来管理事务。以下是 MyBatis 事务管理的主要方式：&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-使用-jdbc-事务管理&#34;&gt;&#xA;  1. 使用 JDBC 事务管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e4%bd%bf%e7%94%a8-jdbc-%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;MyBatis 默认使用 JDBC 的事务管理，通过 &lt;code&gt;java.sql.Connection&lt;/code&gt; 实现。具体步骤如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;开启事务&lt;/strong&gt;：调用 &lt;code&gt;Connection.setAutoCommit(false)&lt;/code&gt; 关闭自动提交。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;提交事务&lt;/strong&gt;：调用 &lt;code&gt;Connection.commit()&lt;/code&gt; 提交事务。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;回滚事务&lt;/strong&gt;：调用 &lt;code&gt;Connection.rollback()&lt;/code&gt; 回滚事务。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;示例代码：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SqlSession sqlSession &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sqlSessionFactory.&lt;span style=&#34;color:#a6e22e&#34;&gt;openSession&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 执行数据库操作&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;insert&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;insertUser&amp;#34;&lt;/span&gt;,user);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;updateUser&amp;#34;&lt;/span&gt;,user);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 提交事务&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;commit&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Exception e){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 回滚事务&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;rollback&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 关闭 SqlSession&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sqlSession.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-集成-spring-事务管理&#34;&gt;&#xA;  2. 集成 Spring 事务管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%e9%9b%86%e6%88%90-spring-%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;MyBatis 通常与 Spring 集成，利用 Spring 的事务管理功能。Spring 提供了声明式和编程式事务管理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>spring</title>
      <link>/post/computer-science/java/spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/post/computer-science/java/spring/</guid>
      <description>&lt;h1 id=&#34;spring&#34;&gt;&#xA;  Spring&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是spring&#34;&gt;&#xA;  什么是Spring&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afspring&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring是一个java开发框架&lt;/li&gt;&#xA;&lt;li&gt;它的核心特性是&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;控制反转&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;依赖注入&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;面向切面编程&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;声明式事务管理&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;模块化设计&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;spring-mvc&#34;&gt;&#xA;  Spring MVC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;spring-mvc-流程&#34;&gt;&#xA;  Spring MVC 流程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc-%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;流程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户发送请求&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 调用 &lt;code&gt;HandlerMapping&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 调用 &lt;code&gt;HandlerAdapter&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Controller 处理请求&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 调用 &lt;code&gt;ViewResolver&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;视图渲染 ModelAndView -&amp;gt; ViewResolver -&amp;gt; View&lt;/li&gt;&#xA;&lt;li&gt;返回响应&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;核心组件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;：前端控制器，负责请求的分发和协调&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HandlerMapping&lt;/strong&gt;：根据请求 URL 查找对应的 Handler&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HandlerAdapter&lt;/strong&gt;：适配并执行 Handler&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Controller&lt;/strong&gt;：处理具体的业务逻辑&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ViewResolver&lt;/strong&gt;：解析视图名称，生成具体的 View 对象&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;：负责视图的渲染&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;bean&#34;&gt;&#xA;  Bean&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;bean的生命周期&#34;&gt;&#xA;  Bean的生命周期&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bean的实例化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过反射调用 Bean 的构造函数，创建Bean的实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;填充属性（依赖注入）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring根据配置文件或注解，将依赖的Bean注入到当前Bean中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;调用Aware接口&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果Bean实现了Spring的&lt;code&gt;Aware&lt;/code&gt;接口，Spring会调用对应的回调方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;BeanPostProcessor&lt;/code&gt; 的前置处理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring调用所有&lt;code&gt;BeanPostProcessor&lt;/code&gt;的&lt;code&gt;postProcessBeforeInitialization()&lt;/code&gt;方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;执行初始化方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring会调用Bean的初始化方法。&lt;/li&gt;&#xA;&lt;li&gt;@PostConstruct&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;BeanPostProcessor的后置处理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring调用所有&lt;code&gt;BeanPostProcessor&lt;/code&gt;的&lt;code&gt;postProcessAfterInitialization()&lt;/code&gt;方法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Bean初始化完成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bean已经完全初始化，可以被其他Bean使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Bean的使用&lt;/li&gt;&#xA;&lt;li&gt;Bean的销毁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;bean的作用域&#34;&gt;&#xA;  Bean的作用域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Singleton（单例）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;默认作用域，单例模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Prototype（原型）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每次请求创建新实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Request（请求）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个 HTTP 请求创建一个实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Session（会话）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个 HTTP Session 创建一个实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Application（应用）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;整个 ServletContext 生命周期内有效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;WebSocket&#xA;&lt;ul&gt;&#xA;&lt;li&gt;WebSocket 会话生命周期内有效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;spring-循环依赖如何解决&#34;&gt;&#xA;  spring 循环依赖如何解决？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;三级缓存&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;singletonObjects&lt;/code&gt;：一级缓存，存储经历了完整生命周期的Bean对象&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;earlySingletonObjects&lt;/code&gt;：二级缓存，存储提前暴露出来的Bean对象，其生命周期未结束，属性未完全填充&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;singletonFactories&lt;/code&gt;：三级缓存，存储生成Bean的工厂&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;ioc&#34;&gt;&#xA;  IOC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ioc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是ioc&#34;&gt;&#xA;  什么是IOC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afioc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IOC是控制反转的意思，在一个程序中对象的创建与管理由一个容器负责，对象之间的引用通过注入(属性填充)的方式从容器中获取，降低了代码之间的耦合度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;ioc-的核心概念是什么&#34;&gt;&#xA;  IOC 的核心概念是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ioc-%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;依赖注入&lt;/li&gt;&#xA;&lt;li&gt;控制反转&lt;/li&gt;&#xA;&lt;li&gt;IOC容器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;举一个-spring-的容器&#34;&gt;&#xA;  举一个 Spring 的容器？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%be%e4%b8%80%e4%b8%aa-spring-%e7%9a%84%e5%ae%b9%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;WebApplicationContext&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;ioc-的优势是什么&#34;&gt;&#xA;  IOC 的优势是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ioc-%e7%9a%84%e4%bc%98%e5%8a%bf%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;降低耦合度&lt;/li&gt;&#xA;&lt;li&gt;提高可测试性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;注入模拟对象进行测试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;增强可扩展性&lt;/li&gt;&#xA;&lt;li&gt;优化资源管理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;容器管理对象的创建和销毁，避免资源浪费&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;aop&#34;&gt;&#xA;  AOP&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是aop&#34;&gt;&#xA;  什么是AOP？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afaop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AOP 是一种&lt;strong&gt;编程范式&lt;/strong&gt;, 通过将横切关注点与业务代码分离，提高代码的可维护性与可重用性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aop的核心概念是什么&#34;&gt;&#xA;  AOP的核心概念是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;切面 &lt;strong&gt;Aspect&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;连接点 &lt;strong&gt;Join Point&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序执行过程中可以插入切面的点（方法的调用或异常的处理）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通知 &lt;strong&gt;Advice&lt;/strong&gt; 切面在连接点执行的操作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;@Before&lt;/li&gt;&#xA;&lt;li&gt;@After&lt;/li&gt;&#xA;&lt;li&gt;@Around&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;切入点 &lt;strong&gt;Pointcut&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义在哪些连接点上应用通知，通常通过表达式来匹配&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;织入 &lt;strong&gt;Weaving&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将切面应用到目标对象并创建代理对象的过程，可以在编译期、类加载期或运行期进行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aop的应用场景&#34;&gt;&#xA;  AOP的应用场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;日志记录&lt;/li&gt;&#xA;&lt;li&gt;事务管理&lt;/li&gt;&#xA;&lt;li&gt;权限控制&lt;/li&gt;&#xA;&lt;li&gt;性能监控&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录方法执行时间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aop的实现方式&#34;&gt;&#xA;  AOP的实现方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JDK动态代理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现了接口的类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CGLIB代理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;未实现接口的类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;事务&#34;&gt;&#xA;  事务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;transaction的底层原理是什么&#34;&gt;&#xA;  @Transaction的底层原理是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#transaction%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;spring的事务管理机制，结合AOP和动态代理技术实现事务的控制和管理&lt;/li&gt;&#xA;&lt;li&gt;事务管理核心组件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事务管理器&lt;/li&gt;&#xA;&lt;li&gt;事务拦截器&lt;/li&gt;&#xA;&lt;li&gt;事务属性源&lt;/li&gt;&#xA;&lt;li&gt;事务代理对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;实现流程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代理对象的创建&lt;/li&gt;&#xA;&lt;li&gt;事务拦截器的应用 TransactionInterceptor&lt;/li&gt;&#xA;&lt;li&gt;事务的开启与提交&lt;/li&gt;&#xA;&lt;li&gt;事务的传播行为&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;transactional-事务传播机制&#34;&gt;&#xA;  @Transactional 事务传播机制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#transactional-%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当一个事务方法调用另一个事务方法时，事务应该如何传递或处理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;REQUIRED&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果当前存在事务，则加入该事务；如果不存在事务，则创建一个新事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SUPPORTS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果当前存在事务，则加入该事务；如果不存在事务，则以非事务方式执行&lt;/li&gt;&#xA;&lt;li&gt;场景：适用于查询操作，是否在事务中执行均可&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;MANDATORY&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果当前存在事务，则加入该事务；如果不存在事务，则抛出异常&lt;/li&gt;&#xA;&lt;li&gt;场景：强制要求调用方必须在事务中调用该方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;REQUIRES_NEW&lt;/li&gt;&#xA;&lt;li&gt;NOT_SUPPORTED&lt;/li&gt;&#xA;&lt;li&gt;NEVER&lt;/li&gt;&#xA;&lt;li&gt;NESTED&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>spring boot</title>
      <link>/post/computer-science/java/springboot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/post/computer-science/java/springboot/</guid>
      <description>&lt;h1 id=&#34;spring-boot&#34;&gt;&#xA;  spring boot&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-boot&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;aop&#34;&gt;&#xA;  AOP&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;为什么要使用aop&#34;&gt;&#xA;  为什么要使用AOP？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8aop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;aop的术语和流程&#34;&gt;&#xA;  AOP的术语和流程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop%e7%9a%84%e6%9c%af%e8%af%ad%e5%92%8c%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;aop开发详解&#34;&gt;&#xA;  AOP开发详解&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop%e5%bc%80%e5%8f%91%e8%af%a6%e8%a7%a3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;确定拦截目标&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要拦截什么类的什么方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;开发切面&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;@Aspect&lt;/code&gt; 注解的一个类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;@Before&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;@After&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;@AfterReturning&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;@AfterThrowing&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;定义切点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;环绕通知&#34;&gt;&#xA;  环绕通知&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%8e%af%e7%bb%95%e9%80%9a%e7%9f%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一般而言，只有在需要大幅度修改原有目标对象的服务逻辑时才使用它，一般情况下尽量不要使用它。环绕通知是一个取代整个流程的通知，当然它也提供了回调原有流程的能力&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;引入&#34;&gt;&#xA;  引入&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%95%e5%85%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;通知获取参数&#34;&gt;&#xA;  通知获取参数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%9a%e7%9f%a5%e8%8e%b7%e5%8f%96%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;织入&#34;&gt;&#xA;  织入&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%87%e5%85%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;织入是一个生成动态代理对象并且将切面和目标对象方法编入约定流程的过程&lt;/li&gt;&#xA;&lt;li&gt;本书中采用先声明接口再提供一个实现类的形式来提供服务类，这也是Spring推荐的方式，但是是否拥有接口并不是AOP的强制要求&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在Java中，当前有多种方式实现动态代理，我们之前谈到的CGLIB只是其中的一种，业界比较流行的还有JDK和Javassist等。Spring采用了JDK和CGLIB，对于JDK动态代理的要求是被代理的目标对象必须拥有接口，而对于CGLIB动态代理则不做要求。因此，在默认的情况下，Spring会按照这样的一条规则处理：当需要使用AOP的类拥有接口时，它会以JDK动态代理的方式运行，否则以CGLIB动态代理的方式运行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;多个切面&#34;&gt;&#xA;  多个切面&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%9a%e4%b8%aa%e5%88%87%e9%9d%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;数据库事务&#34;&gt;&#xA;  数据库事务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ba%93%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;jdbc的数据库事务&#34;&gt;&#xA;  JDBC的数据库事务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdbc%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;spring声明式事务的使用&#34;&gt;&#xA;  Spring声明式事务的使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring%e5%a3%b0%e6%98%8e%e5%bc%8f%e4%ba%8b%e5%8a%a1%e7%9a%84%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;声明式事务是使用注解@Transactional进行标注的，这个注解可以标注在类或者方法上，当它标注在类上时，表示这个类所有公共的(public)非静态的方法都将启用事务功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;spring事务管理器&#34;&gt;&#xA;  Spring事务管理器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在Spring中，事务管理器的顶层接口为 &lt;code&gt;TransactionManager&lt;/code&gt;，这个接口没有任何方法定义，这是因为这个接口下又可以划分两大类事务管理器&#xA;&lt;ul&gt;&#xA;&lt;li&gt;响应式编程的事务管理器&lt;/li&gt;&#xA;&lt;li&gt;非响应式编程的事务管理器&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;PlatformTransactionManager&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;getTransaction 获取事务，返回事务状态&lt;/li&gt;&#xA;&lt;li&gt;commit 提交事务&lt;/li&gt;&#xA;&lt;li&gt;rollback 回滚事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;在Spring Boot中，添加Maven依赖&lt;code&gt;mybatis-spring-boot-starter&lt;/code&gt;之后，会自动创建&lt;code&gt;JdbcTransactionManager&lt;/code&gt;对象作为事务管理器&lt;/li&gt;&#xA;&lt;li&gt;如果依赖&lt;code&gt;spring-boot-starter-data-jpa&lt;/code&gt;，则会自动创建&lt;code&gt;JpaTransactionManager&lt;/code&gt;对象作为事务管理器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;隔离级别&#34;&gt;&#xA;  隔离级别&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在企业的生产实践中，选择隔离级别一般会以读写提交为主，它能够防止脏读，但不能避免不可重复读和幻读&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;传播行为&#34;&gt;&#xA;  传播行为&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%a0%e6%92%ad%e8%a1%8c%e4%b8%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;执行一个批量任务，它会处理很多的交易，绝大部分交易可以顺利完成，但是也有极少数的交易因为特殊原因不能完成而发生异常，这时我们不应该因为极少数的交易不能完成而回滚批量任务调用的其他交易，使得那些本能完成的交易也不能完成了&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在执行一个批量任务的过程中，调用多个交易时，如果有一些交易发生异常，只回滚那些出现异常的交易，而不回滚整个批量任务，这样就能够使得那些没有问题的交易顺利完成，而有问题的交易则不做任何事情&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;在Spring中，当一个方法调用另一个方法时，可以让事务采取不同的策略工作，如新建事务或者挂起当前事务等，这便是事务的传播行为&lt;/li&gt;&#xA;&lt;li&gt;7种传播行为&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;REQUIRED&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要事务，它是默认传播行为。如果当前存在事务，就沿用当前事务；否则新建一个事务运行该方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SUPPORTS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;支持事务。如果当前存在事务，就沿用当前事务；否则继续采用无事务的方式运行该方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;MANDATORY&#xA;&lt;ul&gt;&#xA;&lt;li&gt;必须使用事务。如果当前没有事务，则会抛出异常；如果存在当前事务，则沿用当前事务运行该方法￼&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;REQUIRES_NEW&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无论当前事务是否存在，都会创建新事务运行该方法，这样新事务就可以拥有新的锁和隔离级别等特性，与当前事务相互独立￼&lt;/li&gt;&#xA;&lt;li&gt;e.g.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在进行数据同步的时候，不用将整个同步过程都设置为一个事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;NOT_SUPPORTED&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不支持事务，当前存在事务时，将挂起事务，运行方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;NEVER&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不支持事务，如果当前存在事务，则抛出异常，否则继续采用无事务的方式运行该方法￼&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;NESTED&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在当前方法调用方法时，如果被调用的方法发生异常，只回滚被调用的方法运行过的SQL语句，而不回滚当前方法的事务&lt;/li&gt;&#xA;&lt;li&gt;原理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在大部分的数据库中，一段SQL语句中可以设置一个标志位，运行后面的SQL语句时如果有问题，只回滚到这个标志位的数据状态，而不会让这个标志位之前的SQL语句也回滚。这个标志位在数据库概念中被称为保存点(save point)。从加粗日志部分可以看到，Spring生成了nested事务，也可以看到保存点的释放，可见Spring也是使用保存点技术来完成让子事务回滚而不致使当前事务回滚的工作。&lt;/li&gt;&#xA;&lt;li&gt;注意，并不是所有数据库都支持保存点技术，因此Spring内部有这样的规则：当数据库支持保存点技术时，就启用保存点技术；如果不能支持，就新建一个事务来运行代码，即等价于REQUIRES_NEW传播行为&lt;/li&gt;&#xA;&lt;li&gt;NESTED 和 REQUIRES_NEW 的区别&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NESTED传播行为和REQUIRES_NEW传播行为是有区别的：NESTED传播行为会沿用当前事务，以保存点技术为主；REQUIRES_NEW传播行为则创建新的事务，事务的提交和回滚也是独立的，它拥有独立上下文（例如隔离级别和超时时间等），这是在应用中需要注意的地方。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;占用事务时间过长&#34;&gt;&#xA;  占用事务时间过长&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%a0%e7%94%a8%e4%ba%8b%e5%8a%a1%e6%97%b6%e9%97%b4%e8%bf%87%e9%95%bf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;transactional自调用失效问题&#34;&gt;&#xA;  @Transactional自调用失效问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#transactional%e8%87%aa%e8%b0%83%e7%94%a8%e5%a4%b1%e6%95%88%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;spring-data-redis&#34;&gt;&#xA;  spring-data-redis&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-data-redis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Reference&#xA;&lt;ul&gt;&#xA;&lt;li&gt;《深入迁出 Spring Boot 3.x》7.1 spring-data-redis项目简介&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;lettuce-vs-jedis&#34;&gt;&#xA;  Lettuce vs Jedis&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lettuce-vs-jedis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在Java中有很多种与Redis连接的驱动，目前使用比较广泛的是Lettuce和Jedis，它们是类似的，不过自Spring Boot 2.0发布以来，默认使用的是Lettuce&lt;/li&gt;&#xA;&lt;li&gt;Lettuce是基于Netty框架的事件驱动的Redis客户端，其方法调用是异步的，其API也是线程安全的，因此多个线程可以操作单个Lettuce连接来完成各种操作，并且Lettuce支持连接池。Lettuce线程可以被多个请求公用，且不会产生频繁创建和关闭Lettuce连接的开销，因此比较适合应用于高并发网站。&lt;/li&gt;&#xA;&lt;li&gt;Jedis是同步的，不支持异步，Jedis客户端连接不是线程安全的，需要为每个请求创建和关闭一个Jedis连接，所以一般通过连接池来使用Jedis客户端连接。Jedis不太适合在高并发网站使用，当遇到高并发场景时，Jedis连接池无法避免频繁创建和关闭Jedis连接，因为这会造成十分大的系统开销&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;redistemplate和-stringredistemplate&#34;&gt;&#xA;  RedisTemplate和 StringRedisTemplate&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redistemplate%e5%92%8c-stringredistemplate&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;StringRedisTemplate是RedisTemplate的子类，从名称就可以看出，StringRedisTemplate专门用于操作字符串&lt;/li&gt;&#xA;&lt;li&gt;RedisTemplate，它是一个强大的类，会自动从RedisConnectionFactory工厂中获取连接，然后执行对应的Redis命令，最后还会关闭Redis的连接。这些操作都被封装在RedisTemplate中，所以开发者并不需要关注Redis连接的闭合问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;spring对redis数据类型操作的封装&#34;&gt;&#xA;  Spring对Redis数据类型操作的封装&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring%e5%af%b9redis%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e6%93%8d%e4%bd%9c%e7%9a%84%e5%b0%81%e8%a3%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ValueOperations 字符串操作接口&lt;/li&gt;&#xA;&lt;li&gt;HashOperations 哈希操作接口&lt;/li&gt;&#xA;&lt;li&gt;ListOperations 列表（链表）操作接口&lt;/li&gt;&#xA;&lt;li&gt;SetOperations 集合操作接口&lt;/li&gt;&#xA;&lt;li&gt;ZSetOperations 有序集合操作接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 获取字符串操作接口&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForValue&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 获取哈希操作接口&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForHash&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 获取列表（链表）操作接口&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForList&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 获取集合操作接口&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForSet&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 获取有序集合操作接口&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForZSet&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;sessioncallback-和-rediscallback-接口&#34;&gt;&#xA;  SessionCallback 和 RedisCallback 接口&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sessioncallback-%e5%92%8c-rediscallback-%e6%8e%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;redis事务&#34;&gt;&#xA;  Redis事务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redis%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;使用-redis-流水线&#34;&gt;&#xA;  使用 Redis 流水线&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8-redis-%e6%b5%81%e6%b0%b4%e7%ba%bf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在默认的情况下，Redis客户端把命令逐条发送到Redis服务器，这样做显然性能不高。在关系数据库中我们可以批量运行语句，也就是只有需要运行SQL语句时，才一次性地发送所有SQL语句去运行，这样性能就提高了许多。类似地，Redis也可以批量执行命令，这便是流水线(pipeline)技术，在很多情况下并不是Redis性能不佳，而是网络传输的速度慢造成瓶颈，使用流水线技术可以在需要执行很多命令时大幅度地提升Redis的性能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;使用-redis发布--订阅&#34;&gt;&#xA;  使用 Redis发布 / 订阅&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8-redis%e5%8f%91%e5%b8%83--%e8%ae%a2%e9%98%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;使用-lua-脚本&#34;&gt;&#xA;  使用 Lua 脚本&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8-lua-%e8%84%9a%e6%9c%ac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在Redis中运行Lua脚本具备原子性，且Lua脚本具备更加强大的计算能力，在高并发环境中需要保证数据一致性时，使用Lua脚本方案比使用Redis自身提供的事务更好&lt;/li&gt;&#xA;&lt;li&gt;Redis提供了两种运行Lua的方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一种是直接发送Lua脚本到Redis服务器运行&lt;/li&gt;&#xA;&lt;li&gt;另一种是先把Lua脚本发送给Redis服务器，Redis服务器对Lua脚本进行缓存，然后返回一个32位的SHA1编码，之后只需要发送SHA1和相关参数给Redis服务器便可以运行了。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这里需要解释为什么会存在通过32位编码运行Lua脚本的方法。如果Lua脚本很长，那么就需要通过网络传递脚本给Redis服务器运行，而现实的情况是网络的传递速度往往跟不上Redis的运行速度，因此网络速度就会成为Redis运行的瓶颈。如果只传递32位编码和参数，那么需要通过网络传输的消息就少了许多，这样就可以提高系统的性能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;使用-spring-缓存注解操作-redis&#34;&gt;&#xA;  使用 Spring 缓存注解操作 Redis&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8-spring-%e7%bc%93%e5%ad%98%e6%b3%a8%e8%a7%a3%e6%93%8d%e4%bd%9c-redis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;@CachePut&lt;/code&gt; 将方法返回的结果存储到缓存中&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;@Cacheable&lt;/code&gt; 先通过定义的键从缓存中查询，如果可以查询到数据则返回，否则运行该方法，返回数据，并且将返回的结果存储到缓存中&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;@CacheEvict&lt;/code&gt; 通过定义的键移除缓存&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;缓存注解自调用失效问题&#34;&gt;&#xA;  缓存注解自调用失效问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%93%e5%ad%98%e6%b3%a8%e8%a7%a3%e8%87%aa%e8%b0%83%e7%94%a8%e5%a4%b1%e6%95%88%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h4 id=&#34;自定义缓存管理器&#34;&gt;&#xA;  自定义缓存管理器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%ae%9a%e4%b9%89%e7%bc%93%e5%ad%98%e7%ae%a1%e7%90%86%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h2 id=&#34;异步线程池&#34;&gt;&#xA;  异步线程池&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;异步消息-rabbitmq&#34;&gt;&#xA;  异步消息 RabbitMQ&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5%e6%b6%88%e6%81%af-rabbitmq&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;定时任务&#34;&gt;&#xA;  定时任务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;spring-boot-monitor&#34;&gt;&#xA;  Spring-boot-monitor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-boot-monitor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;好久没维护了，服务有上下文资源会请求不到，这。。。。。。。&lt;/li&gt;&#xA;&lt;li&gt;单机监控SpringBoot应用指标&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.pomit.cn/SpringBootMonitor/#/&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
