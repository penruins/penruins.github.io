<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Penruins</title>
    <link>/post/computer-science/java/spring/</link>
    <description>Recent content on Penruins</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="/post/computer-science/java/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>spring</title>
      <link>/post/computer-science/java/spring/spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/post/computer-science/java/spring/spring/</guid>
      <description>&lt;h1 id=&#34;spring&#34;&gt;&#xA;  Spring&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/huanzi-qch/springBoot&#34;&gt;huanzi-qch/springBoot&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SpringBoot系列Demo代码&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;什么是spring&#34;&gt;&#xA;  什么是Spring&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afspring&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring是一个java开发框架&lt;/li&gt;&#xA;&lt;li&gt;它的核心特性是&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;控制反转&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;依赖注入&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;面向切面编程&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;声明式事务管理&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;模块化设计&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;spring-mvc&#34;&gt;&#xA;  Spring MVC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;spring-mvc-流程&#34;&gt;&#xA;  Spring MVC 流程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc-%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;流程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户发送请求&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 调用 &lt;code&gt;HandlerMapping&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 调用 &lt;code&gt;HandlerAdapter&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Controller 处理请求&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 调用 &lt;code&gt;ViewResolver&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;视图渲染 ModelAndView -&amp;gt; ViewResolver -&amp;gt; View&lt;/li&gt;&#xA;&lt;li&gt;返回响应&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;核心组件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;：前端控制器，负责请求的分发和协调&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HandlerMapping&lt;/strong&gt;：根据请求 URL 查找对应的 Handler&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HandlerAdapter&lt;/strong&gt;：适配并执行 Handler&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Controller&lt;/strong&gt;：处理具体的业务逻辑&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ViewResolver&lt;/strong&gt;：解析视图名称，生成具体的 View 对象&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;：负责视图的渲染&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;bean&#34;&gt;&#xA;  Bean&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;bean的生命周期&#34;&gt;&#xA;  Bean的生命周期&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bean的实例化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过反射调用 Bean 的构造函数，创建Bean的实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;填充属性（依赖注入）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring根据配置文件或注解，将依赖的Bean注入到当前Bean中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;调用Aware接口&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果Bean实现了Spring的&lt;code&gt;Aware&lt;/code&gt;接口，Spring会调用对应的回调方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;BeanPostProcessor&lt;/code&gt; 的前置处理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring调用所有&lt;code&gt;BeanPostProcessor&lt;/code&gt;的&lt;code&gt;postProcessBeforeInitialization()&lt;/code&gt;方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;执行初始化方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring会调用Bean的初始化方法。&lt;/li&gt;&#xA;&lt;li&gt;@PostConstruct&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;BeanPostProcessor的后置处理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring调用所有&lt;code&gt;BeanPostProcessor&lt;/code&gt;的&lt;code&gt;postProcessAfterInitialization()&lt;/code&gt;方法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Bean初始化完成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bean已经完全初始化，可以被其他Bean使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Bean的使用&lt;/li&gt;&#xA;&lt;li&gt;Bean的销毁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;bean的作用域&#34;&gt;&#xA;  Bean的作用域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Singleton（单例）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;默认作用域，单例模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Prototype（原型）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每次请求创建新实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Request（请求）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个 HTTP 请求创建一个实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Session（会话）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个 HTTP Session 创建一个实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Application（应用）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;整个 ServletContext 生命周期内有效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;WebSocket&#xA;&lt;ul&gt;&#xA;&lt;li&gt;WebSocket 会话生命周期内有效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;spring-循环依赖如何解决&#34;&gt;&#xA;  spring 循环依赖如何解决？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;三级缓存&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;singletonObjects&lt;/code&gt;：一级缓存，存储经历了完整生命周期的Bean对象&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;earlySingletonObjects&lt;/code&gt;：二级缓存，存储提前暴露出来的Bean对象，其生命周期未结束，属性未完全填充&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;singletonFactories&lt;/code&gt;：三级缓存，存储生成Bean的工厂&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;ioc&#34;&gt;&#xA;  IOC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ioc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是ioc&#34;&gt;&#xA;  什么是IOC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afioc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IOC是控制反转的意思，在一个程序中对象的创建与管理由一个容器负责，对象之间的引用通过注入(属性填充)的方式从容器中获取，降低了代码之间的耦合度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;ioc-的核心概念是什么&#34;&gt;&#xA;  IOC 的核心概念是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ioc-%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;依赖注入&lt;/li&gt;&#xA;&lt;li&gt;控制反转&lt;/li&gt;&#xA;&lt;li&gt;IOC容器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;举一个-spring-的容器&#34;&gt;&#xA;  举一个 Spring 的容器？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%be%e4%b8%80%e4%b8%aa-spring-%e7%9a%84%e5%ae%b9%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;WebApplicationContext&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;ioc-的优势是什么&#34;&gt;&#xA;  IOC 的优势是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ioc-%e7%9a%84%e4%bc%98%e5%8a%bf%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;降低耦合度&lt;/li&gt;&#xA;&lt;li&gt;提高可测试性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;注入模拟对象进行测试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;增强可扩展性&lt;/li&gt;&#xA;&lt;li&gt;优化资源管理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;容器管理对象的创建和销毁，避免资源浪费&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;aop&#34;&gt;&#xA;  AOP&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是aop&#34;&gt;&#xA;  什么是AOP？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afaop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AOP 是一种&lt;strong&gt;编程范式&lt;/strong&gt;, 通过将横切关注点与业务代码分离，提高代码的可维护性与可重用性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aop的核心概念是什么&#34;&gt;&#xA;  AOP的核心概念是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;切面 &lt;strong&gt;Aspect&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;连接点 &lt;strong&gt;Join Point&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序执行过程中可以插入切面的点（方法的调用或异常的处理）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通知 &lt;strong&gt;Advice&lt;/strong&gt; 切面在连接点执行的操作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;@Before&lt;/li&gt;&#xA;&lt;li&gt;@After&lt;/li&gt;&#xA;&lt;li&gt;@Around&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;切入点 &lt;strong&gt;Pointcut&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义在哪些连接点上应用通知，通常通过表达式来匹配&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;织入 &lt;strong&gt;Weaving&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将切面应用到目标对象并创建代理对象的过程，可以在编译期、类加载期或运行期进行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aop的应用场景&#34;&gt;&#xA;  AOP的应用场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;日志记录&lt;/li&gt;&#xA;&lt;li&gt;事务管理&lt;/li&gt;&#xA;&lt;li&gt;权限控制&lt;/li&gt;&#xA;&lt;li&gt;性能监控&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录方法执行时间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aop的实现方式&#34;&gt;&#xA;  AOP的实现方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JDK动态代理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现了接口的类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CGLIB代理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;未实现接口的类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;事务&#34;&gt;&#xA;  事务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>spring transaction</title>
      <link>/post/computer-science/java/spring/spring-transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/post/computer-science/java/spring/spring-transaction/</guid>
      <description>&lt;h1 id=&#34;transaction的底层原理是什么&#34;&gt;&#xA;  @Transaction的底层原理是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#transaction%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;spring的事务管理机制，结合AOP和动态代理技术实现事务的控制和管理&lt;/li&gt;&#xA;&lt;li&gt;事务管理核心组件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事务管理器&lt;/li&gt;&#xA;&lt;li&gt;事务拦截器&lt;/li&gt;&#xA;&lt;li&gt;事务属性源&lt;/li&gt;&#xA;&lt;li&gt;事务代理对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;实现流程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代理对象的创建&lt;/li&gt;&#xA;&lt;li&gt;事务拦截器的应用 TransactionInterceptor&lt;/li&gt;&#xA;&lt;li&gt;事务的开启与提交&lt;/li&gt;&#xA;&lt;li&gt;事务的传播行为&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;transactional-事务传播机制&#34;&gt;&#xA;  @Transactional 事务传播机制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#transactional-%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当一个事务方法调用另一个事务方法时，事务应该如何传递或处理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;REQUIRED&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果当前存在事务，则加入该事务；如果不存在事务，则创建一个新事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SUPPORTS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果当前存在事务，则加入该事务；如果不存在事务，则以非事务方式执行&lt;/li&gt;&#xA;&lt;li&gt;场景：适用于查询操作，是否在事务中执行均可&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;MANDATORY&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果当前存在事务，则加入该事务；如果不存在事务，则抛出异常&lt;/li&gt;&#xA;&lt;li&gt;场景：强制要求调用方必须在事务中调用该方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;REQUIRES_NEW&lt;/li&gt;&#xA;&lt;li&gt;NOT_SUPPORTED&lt;/li&gt;&#xA;&lt;li&gt;NEVER&lt;/li&gt;&#xA;&lt;li&gt;NESTED&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
