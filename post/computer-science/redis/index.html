<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  redis
  #


  redis基本数据类型, 使用场景
  #


5大基本类型

String 字符串

常用场景：

缓存：存储用户信息、配置信息等。
计数器：如文章阅读量、点赞数等。
分布式锁：通过 SETNX 命令实现。




Hash 哈希

常用场景：

存储用户信息：如用户 ID 作为 key，用户属性（姓名、年龄等）作为 field-value 对。
存储商品信息：如商品 ID 作为 key，商品详情（价格、库存等）作为 field-value 对。




List 列表

常用场景：

消息队列：通过 LPUSH 和 RPOP 实现简单的消息队列。
最新消息列表：如微博的时间线、朋友圈动态等。




Set 集合

常用场景：

标签系统：如文章标签、用户兴趣标签等。
去重：如统计独立 IP 访问量。




Sorted Set 有序集合

常用场景：

排行榜：如游戏积分排行榜、热搜榜等。
延迟队列：通过分数存储时间戳，按时间顺序处理任务。








  什么是缓存击穿 缓存穿透 缓存雪崩
  #


缓存击穿 Cache Breakdown

热点数据过期的同时有大量的请求访问该热点数据，导致数据库负载突然增加
解决办法

使用互斥锁，同时只能一个线程读取数据库中的数据后保存到缓存中，其他线程等待读取缓存中的值




缓存穿透 Cache Penetration

查询的数据在缓存和数据库中都不存在
解决办法

缓存空值
布隆过滤器
参数校验






  简单动态字符串
  #


  链表
  #


  字典
  #


  跳跃表
  #


  整数集合
  #


  压缩列表
  #


  对象
  #


  数据库
  #


  redis 集群
  #


  redis 的集群模式有哪些？
  #


主从模式

主节点负责写操作，从节点负责读操作，实现读写分离


哨兵模式

在主从复制的基础上，增加了自动故障转移功能。哨兵节点监控主从节点的状态，当主节点故障时，自动选举从节点为主节点


cluster模式

通过数据分片（Sharding）实现分布式存储，支持自动故障转移和负载均衡




  redis 数据如何进行分片？
  #


槽位计算：通过 CRC16(key) % 16384 计算键（key）所属的槽位
槽位分配：每个节点负责维护一部分槽位，槽位分布均匀，支持动态扩容和缩容
数据路由：客户端请求时，先计算 key 的槽位，然后根据槽位找到对应的节点


  分片的实现方案有哪些？
  #


客户端分片 Redis-rb Predis
代理分片（客户端与Redis节点之间增加代理层 Twemproxy）

增加了系统的复杂性和延迟




  主从
  #


Reference

《Redis设计与实现》 第15章 复制


在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）
进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致”，或者简称“一致”。


  旧版复制功能的实现
  #


同步 sync

同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态
步骤

1）从服务器向主服务器发送SYNC命令。
2）收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
3）当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。
4）主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。




命令传播 command propagate

命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态




  旧版复制功能的缺陷
  #


在Redis中，从服务器对主服务器的复制可以分为以下两种情况

初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同

对于初次复制来说，旧版复制功能能够很好地完成任务


断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器

对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低




SYNC命令是一个非常耗费资源的操作

1）主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。
2）主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响。
3）接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。
因为SYNC命令是一个如此耗费资源的操作，所以Redis有必要保证在真正有需要时才执行SYNC命令。




  新版复制功能的实现
  #


为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作
PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式

其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步
而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态




  部分重同步的实现
  #


部分重同步功能由以下三个部分构成：

主服务器的复制偏移量（replication offset）和从服务器的复制偏移量

执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量

主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N
从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N


通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态

如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的
相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态




主服务器的复制积压缓冲区（replication backlog）

复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB

和普通先进先出队列随着元素的增加和减少而动态调整长度不同，固定长度先进先出队列的长度是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列


当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面
主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量
当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作

如果offset偏移量之后的数据（也即是偏移量offset&#43;1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作
相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作


根据需要调整复制积压缓冲区的大小

Redis为复制积压缓冲区设置的默认大小为1MB，如果主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间比较长，那么这个大小也许并不合适
如果复制积压缓冲区的大小设置得不恰当，那么PSYNC命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要

如果复制积压缓冲区的大小设置得不恰当，那么PSYNC命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要

其中second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）
而write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）
例如，如果主服务器平均每秒产生1 MB的写数据，而从服务器断线之后平均要5秒才能重新连接上主服务器，那么复制积压缓冲区的大小就不能低于5MB。
为了安全起见，可以将复制积压缓冲区的大小设为2secondwrite_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理








服务器的运行ID（run ID）

每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID
运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成
当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来
当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID

如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作
相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作








  PSYNC 命令的实现
  #


  复制的实现
  #


  心跳检测
  #


  Sentinel
  #


Sentinel（哨岗、哨兵）是Redis的高可用性（high availability）解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求


  集群
  #


Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能


  节点
  #


一个Redis集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群


  槽指派
  #


Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽
当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）


  在集群中执行命令
  #


当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己

如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令
如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令




  重新分片
  #


Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。
重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求


  ASK错误
  #


  复制与故障转移
  #


Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求


  消息
  #


集群中的各个节点通过发送和接收消息（message）来进行通信，我们称发送消息的节点为发送者（sender），接收消息的节点为接收者（receiver）
节点发送的消息主要有以下五种

MEET
PING
PONG
FAIL
PUBLISH


">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="/post/computer-science/redis/">
  <meta property="og:site_name" content="Penruins">
  <meta property="og:title" content="redis">
  <meta property="og:description" content="redis # redis基本数据类型, 使用场景 # 5大基本类型 String 字符串 常用场景： 缓存：存储用户信息、配置信息等。 计数器：如文章阅读量、点赞数等。 分布式锁：通过 SETNX 命令实现。 Hash 哈希 常用场景： 存储用户信息：如用户 ID 作为 key，用户属性（姓名、年龄等）作为 field-value 对。 存储商品信息：如商品 ID 作为 key，商品详情（价格、库存等）作为 field-value 对。 List 列表 常用场景： 消息队列：通过 LPUSH 和 RPOP 实现简单的消息队列。 最新消息列表：如微博的时间线、朋友圈动态等。 Set 集合 常用场景： 标签系统：如文章标签、用户兴趣标签等。 去重：如统计独立 IP 访问量。 Sorted Set 有序集合 常用场景： 排行榜：如游戏积分排行榜、热搜榜等。 延迟队列：通过分数存储时间戳，按时间顺序处理任务。 什么是缓存击穿 缓存穿透 缓存雪崩 # 缓存击穿 Cache Breakdown 热点数据过期的同时有大量的请求访问该热点数据，导致数据库负载突然增加 解决办法 使用互斥锁，同时只能一个线程读取数据库中的数据后保存到缓存中，其他线程等待读取缓存中的值 缓存穿透 Cache Penetration 查询的数据在缓存和数据库中都不存在 解决办法 缓存空值 布隆过滤器 参数校验 简单动态字符串 # 链表 # 字典 # 跳跃表 # 整数集合 # 压缩列表 # 对象 # 数据库 # redis 集群 # redis 的集群模式有哪些？ # 主从模式 主节点负责写操作，从节点负责读操作，实现读写分离 哨兵模式 在主从复制的基础上，增加了自动故障转移功能。哨兵节点监控主从节点的状态，当主节点故障时，自动选举从节点为主节点 cluster模式 通过数据分片（Sharding）实现分布式存储，支持自动故障转移和负载均衡 redis 数据如何进行分片？ # 槽位计算：通过 CRC16(key) % 16384 计算键（key）所属的槽位 槽位分配：每个节点负责维护一部分槽位，槽位分布均匀，支持动态扩容和缩容 数据路由：客户端请求时，先计算 key 的槽位，然后根据槽位找到对应的节点 分片的实现方案有哪些？ # 客户端分片 Redis-rb Predis 代理分片（客户端与Redis节点之间增加代理层 Twemproxy） 增加了系统的复杂性和延迟 主从 # Reference 《Redis设计与实现》 第15章 复制 在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave） 进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致”，或者简称“一致”。 旧版复制功能的实现 # 同步 sync 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态 步骤 1）从服务器向主服务器发送SYNC命令。 2）收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。 3）当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。 4）主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。 命令传播 command propagate 命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态 旧版复制功能的缺陷 # 在Redis中，从服务器对主服务器的复制可以分为以下两种情况 初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同 对于初次复制来说，旧版复制功能能够很好地完成任务 断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器 对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低 SYNC命令是一个非常耗费资源的操作 1）主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。 2）主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响。 3）接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。 因为SYNC命令是一个如此耗费资源的操作，所以Redis有必要保证在真正有需要时才执行SYNC命令。 新版复制功能的实现 # 为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作 PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式 其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步 而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态 部分重同步的实现 # 部分重同步功能由以下三个部分构成： 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量 执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N 通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的 相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态 主服务器的复制积压缓冲区（replication backlog） 复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB 和普通先进先出队列随着元素的增加和减少而动态调整长度不同，固定长度先进先出队列的长度是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列 当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面 主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量 当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作 如果offset偏移量之后的数据（也即是偏移量offset&#43;1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作 相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作 根据需要调整复制积压缓冲区的大小 Redis为复制积压缓冲区设置的默认大小为1MB，如果主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间比较长，那么这个大小也许并不合适 如果复制积压缓冲区的大小设置得不恰当，那么PSYNC命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要 如果复制积压缓冲区的大小设置得不恰当，那么PSYNC命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要 其中second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算） 而write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和） 例如，如果主服务器平均每秒产生1 MB的写数据，而从服务器断线之后平均要5秒才能重新连接上主服务器，那么复制积压缓冲区的大小就不能低于5MB。 为了安全起见，可以将复制积压缓冲区的大小设为2secondwrite_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理 服务器的运行ID（run ID） 每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成 当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来 当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID 如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作 相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作 PSYNC 命令的实现 # 复制的实现 # 心跳检测 # Sentinel # Sentinel（哨岗、哨兵）是Redis的高可用性（high availability）解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求 集群 # Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能 节点 # 一个Redis集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群 槽指派 # Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽 当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail） 在集群中执行命令 # 当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己 如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令 如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令 重新分片 # Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。 重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求 ASK错误 # 复制与故障转移 # Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求 消息 # 集群中的各个节点通过发送和接收消息（message）来进行通信，我们称发送消息的节点为发送者（sender），接收消息的节点为接收者（receiver） 节点发送的消息主要有以下五种 MEET PING PONG FAIL PUBLISH">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:modified_time" content="2025-08-02T23:34:21+08:00">
<title>redis | Penruins</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="/post/computer-science/redis/">
<link rel="stylesheet" href="/book.min.906e34f8c022f0b84a196adcca9b010338f8538635067c7b810a46d6dd81c80c.css" >
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.353c25b35f04562155bf7ad84c740108a4c81193681549b7c0f0b9b812d07c0b.js" ></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Penruins</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-1f044d5fe299e2a50ad480135136465e" class="toggle"  />
    <label for="section-1f044d5fe299e2a50ad480135136465e" class="flex justify-between">
      <a role="button" class="">Life</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/life/%E6%91%98%E6%8A%84%E5%88%86%E4%BA%AB/" class="">摘抄分享</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/%E6%96%B0%E7%9F%A5/" class="">新知</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/movies-log/" class="">观影记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/bilibili/" class="">bilibili</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/cycling/" class="">cycling</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/hiking/" class="">hiking</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/life-recommend/" class="">life recommand</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/learning-others-log/" class="">other learning</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/podcast/" class="">podcast</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/politics/" class="">politics</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/goal/" class="">goal</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/coffee/" class="">coffee</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/article/" class="">article</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/books/" class="">books</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0e80d916dfbf49a298199837cff9b464" class="toggle" checked />
    <label for="section-0e80d916dfbf49a298199837cff9b464" class="flex justify-between">
      <a role="button" class="">Computer Science</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/computer-science/" class="">computer science</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-7ab6eb16d87ee717ab25cc84269ec7f9" class="toggle"  />
    <label for="section-7ab6eb16d87ee717ab25cc84269ec7f9" class="flex justify-between">
      <a role="button" class="">Big Data</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/big-data/hadoop/" class="">hadoop</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/big-data/hbase/" class="">hbase</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/big-data/hive/" class="">hive</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-859fd182f99952efd6ae86320529c63d" class="toggle"  />
    <label for="section-859fd182f99952efd6ae86320529c63d" class="flex justify-between">
      <a role="button" class="">Database</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/database/" class="">database</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/druid/" class="">druid</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/elasticsearch/" class="">elasticsearch</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/mycat/" class="">mycat</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/mysql/" class="">mysql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/postgresql/" class="">postgresql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/shardingsphere/" class="">shardingsphere</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/sql/" class="">SQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/mongodb/" class="">Penruins</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-08231b363489d85c9f808700d743ce65" class="toggle"  />
    <label for="section-08231b363489d85c9f808700d743ce65" class="flex justify-between">
      <a role="button" class="">Distributed System</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-92803a0b927e7b223b49867047da77ad" class="toggle"  />
    <label for="section-92803a0b927e7b223b49867047da77ad" class="flex justify-between">
      <a role="button" class="">Message Queue</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/message-queue/kafka/" class="">kafka</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/message-queue/message-queue/" class="">Message Queue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/message-queue/rabbitmq/" class="">rabbitmq</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/distributed-system/" class="">distributed system</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/sentinel/" class="">Sentinel</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/spring-cloud/" class="">Spring Cloud</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/spring-cloud-alibaba/" class="">Spring Cloud Alibaba</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ca0677f03580f20779b09f474723b113" class="toggle"  />
    <label for="section-ca0677f03580f20779b09f474723b113" class="flex justify-between">
      <a role="button" class="">Java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/java/java-basic/" class="">java basic</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/java/java/" class="">java</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/java/concurrent/" class="">concurrent</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/java/jvm/" class="">jvm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/java/mybatis/" class="">Mybatis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/java/spring/" class="">spring</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/java/springboot/" class="">spring boot</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-38c4d1edc00af801a5cead99c216a484" class="toggle"  />
    <label for="section-38c4d1edc00af801a5cead99c216a484" class="flex justify-between">
      <a role="button" class="">Monitor</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/monitor/prometheus/" class="">prometheus</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-580097d540eb28e9fcf7fd7cfd7cf3f5" class="toggle"  />
    <label for="section-580097d540eb28e9fcf7fd7cfd7cf3f5" class="flex justify-between">
      <a role="button" class="">Tools</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/tools/idea/" class="">IDEA</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/computer-science-recommend/" class="">推荐</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/computer-science-learning-log/" class="">学习记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/echarts/" class="">echarts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/github/" class="">github</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/ios/" class="">ios</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/job/" class="">job</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/linux/" class="">linux</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/mac/" class="">mac</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/raspberrypi/" class="">raspberry pi</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/redis/" class="active">redis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/security/" class="">security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/vue/" class="">vue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/algorithm/" class="">Algorithm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/cloud/" class="">Cloud</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/hugo/" class="">Hugo</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/nacos/" class="">Nacos</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/artificial-intelligence/" class="">Artificial Intelligence</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/crawler/" class="">crawler</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/jenkins/" class="">Jenkins</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/nexus/" class="">Nexus</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/python/" class="">Python</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/vim/" class="">vim</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="">系统设计</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Others</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/others/about-me/" class="">about me</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/others/english-learning/" class="">English Learning</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/post/others/f1/" class="">F1</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Sports</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/sports/cycling/" class="">cycling</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/sports/table-tennis/" class="">table tennis</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Books</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3045b94b25ef0b17b04a92aba83672b7" class="toggle"  />
    <label for="section-3045b94b25ef0b17b04a92aba83672b7" class="flex justify-between">
      <a role="button" class="">Computer Science</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" class="">Java并发编程实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="">Python神经网络编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="">Redis设计与实现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/" class="">Spring Cloud微服务：入门、实战与进阶</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" class="">一本书讲透 ElasticSearch：原理、进阶与工程实践</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/books/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E7%AC%AC%E4%B8%89%E7%89%88/" class="">宏观经济学 第三版</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/books/%E8%8B%B1%E4%BC%9F%E8%BE%BE-%E9%BB%84%E4%BB%81%E5%8B%8B%E4%B9%8B%E8%8A%AF/" class="">英伟达-黄仁勋之芯</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/blog/2025/2025-03-31-shardingsphere-prometheus-%E9%85%8D%E7%BD%AE/" class="">2025 03 31 Shardingsphere Prometheus 配置</a>
  

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>redis</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#redis">redis</a>
      <ul>
        <li><a href="#redis基本数据类型-使用场景">redis基本数据类型, 使用场景</a></li>
        <li><a href="#什么是缓存击穿-缓存穿透-缓存雪崩">什么是缓存击穿 缓存穿透 缓存雪崩</a></li>
        <li><a href="#简单动态字符串">简单动态字符串</a></li>
        <li><a href="#链表">链表</a></li>
        <li><a href="#字典">字典</a></li>
        <li><a href="#跳跃表">跳跃表</a></li>
        <li><a href="#整数集合">整数集合</a></li>
        <li><a href="#压缩列表">压缩列表</a></li>
        <li><a href="#对象">对象</a></li>
        <li><a href="#数据库">数据库</a></li>
        <li><a href="#redis-集群">redis 集群</a>
          <ul>
            <li><a href="#redis-的集群模式有哪些">redis 的集群模式有哪些？</a></li>
            <li><a href="#redis-数据如何进行分片">redis 数据如何进行分片？</a></li>
            <li><a href="#分片的实现方案有哪些">分片的实现方案有哪些？</a></li>
            <li><a href="#主从">主从</a>
              <ul>
                <li><a href="#旧版复制功能的实现">旧版复制功能的实现</a></li>
                <li><a href="#旧版复制功能的缺陷">旧版复制功能的缺陷</a></li>
                <li><a href="#新版复制功能的实现">新版复制功能的实现</a></li>
                <li><a href="#部分重同步的实现">部分重同步的实现</a></li>
                <li><a href="#psync-命令的实现">PSYNC 命令的实现</a></li>
                <li><a href="#复制的实现">复制的实现</a></li>
                <li><a href="#心跳检测">心跳检测</a></li>
              </ul>
            </li>
            <li><a href="#sentinel">Sentinel</a></li>
            <li><a href="#集群">集群</a>
              <ul>
                <li><a href="#节点">节点</a></li>
                <li><a href="#槽指派">槽指派</a></li>
                <li><a href="#在集群中执行命令">在集群中执行命令</a></li>
                <li><a href="#重新分片">重新分片</a></li>
                <li><a href="#ask错误">ASK错误</a></li>
                <li><a href="#复制与故障转移">复制与故障转移</a></li>
                <li><a href="#消息">消息</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="redis">
  redis
  <a class="anchor" href="#redis">#</a>
</h1>
<h2 id="redis基本数据类型-使用场景">
  redis基本数据类型, 使用场景
  <a class="anchor" href="#redis%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b-%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h2>
<ul>
<li>5大基本类型
<ul>
<li><strong>String 字符串</strong>
<ul>
<li>常用场景：
<ul>
<li>缓存：存储用户信息、配置信息等。</li>
<li>计数器：如文章阅读量、点赞数等。</li>
<li>分布式锁：通过 SETNX 命令实现。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Hash 哈希</strong>
<ul>
<li>常用场景：
<ul>
<li>存储用户信息：如用户 ID 作为 key，用户属性（姓名、年龄等）作为 field-value 对。</li>
<li>存储商品信息：如商品 ID 作为 key，商品详情（价格、库存等）作为 field-value 对。</li>
</ul>
</li>
</ul>
</li>
<li><strong>List 列表</strong>
<ul>
<li>常用场景：
<ul>
<li>消息队列：通过 LPUSH 和 RPOP 实现简单的消息队列。</li>
<li>最新消息列表：如微博的时间线、朋友圈动态等。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Set 集合</strong>
<ul>
<li>常用场景：
<ul>
<li>标签系统：如文章标签、用户兴趣标签等。</li>
<li>去重：如统计独立 IP 访问量。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Sorted Set 有序集合</strong>
<ul>
<li>常用场景：
<ul>
<li>排行榜：如游戏积分排行榜、热搜榜等。</li>
<li>延迟队列：通过分数存储时间戳，按时间顺序处理任务。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="什么是缓存击穿-缓存穿透-缓存雪崩">
  什么是缓存击穿 缓存穿透 缓存雪崩
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf-%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f-%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9">#</a>
</h2>
<ul>
<li><strong>缓存击穿 Cache Breakdown</strong>
<ul>
<li>热点数据过期的同时有大量的请求访问该热点数据，导致数据库负载突然增加</li>
<li>解决办法
<ul>
<li>使用互斥锁，同时只能一个线程读取数据库中的数据后保存到缓存中，其他线程等待读取缓存中的值</li>
</ul>
</li>
</ul>
</li>
<li><strong>缓存穿透 Cache Penetration</strong>
<ul>
<li>查询的数据在缓存和数据库中都不存在</li>
<li>解决办法
<ul>
<li>缓存空值</li>
<li>布隆过滤器</li>
<li>参数校验</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="简单动态字符串">
  简单动态字符串
  <a class="anchor" href="#%e7%ae%80%e5%8d%95%e5%8a%a8%e6%80%81%e5%ad%97%e7%ac%a6%e4%b8%b2">#</a>
</h2>
<h2 id="链表">
  链表
  <a class="anchor" href="#%e9%93%be%e8%a1%a8">#</a>
</h2>
<h2 id="字典">
  字典
  <a class="anchor" href="#%e5%ad%97%e5%85%b8">#</a>
</h2>
<h2 id="跳跃表">
  跳跃表
  <a class="anchor" href="#%e8%b7%b3%e8%b7%83%e8%a1%a8">#</a>
</h2>
<h2 id="整数集合">
  整数集合
  <a class="anchor" href="#%e6%95%b4%e6%95%b0%e9%9b%86%e5%90%88">#</a>
</h2>
<h2 id="压缩列表">
  压缩列表
  <a class="anchor" href="#%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8">#</a>
</h2>
<h2 id="对象">
  对象
  <a class="anchor" href="#%e5%af%b9%e8%b1%a1">#</a>
</h2>
<h2 id="数据库">
  数据库
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93">#</a>
</h2>
<h2 id="redis-集群">
  redis 集群
  <a class="anchor" href="#redis-%e9%9b%86%e7%be%a4">#</a>
</h2>
<h3 id="redis-的集群模式有哪些">
  redis 的集群模式有哪些？
  <a class="anchor" href="#redis-%e7%9a%84%e9%9b%86%e7%be%a4%e6%a8%a1%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b">#</a>
</h3>
<ul>
<li><strong>主从模式</strong>
<ul>
<li>主节点负责写操作，从节点负责读操作，实现读写分离</li>
</ul>
</li>
<li><strong>哨兵模式</strong>
<ul>
<li>在主从复制的基础上，增加了自动故障转移功能。哨兵节点监控主从节点的状态，当主节点故障时，自动选举从节点为主节点</li>
</ul>
</li>
<li><strong>cluster模式</strong>
<ul>
<li>通过数据分片（Sharding）实现分布式存储，支持自动故障转移和负载均衡</li>
</ul>
</li>
</ul>
<h3 id="redis-数据如何进行分片">
  redis 数据如何进行分片？
  <a class="anchor" href="#redis-%e6%95%b0%e6%8d%ae%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e5%88%86%e7%89%87">#</a>
</h3>
<ul>
<li>槽位计算：通过 CRC16(key) % 16384 计算键（key）所属的槽位</li>
<li>槽位分配：每个节点负责维护一部分槽位，槽位分布均匀，支持动态扩容和缩容</li>
<li>数据路由：客户端请求时，先计算 key 的槽位，然后根据槽位找到对应的节点</li>
</ul>
<h3 id="分片的实现方案有哪些">
  分片的实现方案有哪些？
  <a class="anchor" href="#%e5%88%86%e7%89%87%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%a1%88%e6%9c%89%e5%93%aa%e4%ba%9b">#</a>
</h3>
<ul>
<li>客户端分片 Redis-rb Predis</li>
<li>代理分片（客户端与Redis节点之间增加代理层 Twemproxy）
<ul>
<li>增加了系统的复杂性和延迟</li>
</ul>
</li>
</ul>
<h3 id="主从">
  主从
  <a class="anchor" href="#%e4%b8%bb%e4%bb%8e">#</a>
</h3>
<ul>
<li>Reference
<ul>
<li>《Redis设计与实现》 第15章 复制</li>
</ul>
</li>
<li>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）</li>
<li>进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致”，或者简称“一致”。</li>
</ul>
<h4 id="旧版复制功能的实现">
  旧版复制功能的实现
  <a class="anchor" href="#%e6%97%a7%e7%89%88%e5%a4%8d%e5%88%b6%e5%8a%9f%e8%83%bd%e7%9a%84%e5%ae%9e%e7%8e%b0">#</a>
</h4>
<ul>
<li>同步 sync
<ul>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态</li>
<li>步骤
<ul>
<li>1）从服务器向主服务器发送SYNC命令。</li>
<li>2）收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</li>
<li>3）当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。</li>
<li>4）主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。</li>
</ul>
</li>
</ul>
</li>
<li>命令传播 command propagate
<ul>
<li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态</li>
</ul>
</li>
</ul>
<h4 id="旧版复制功能的缺陷">
  旧版复制功能的缺陷
  <a class="anchor" href="#%e6%97%a7%e7%89%88%e5%a4%8d%e5%88%b6%e5%8a%9f%e8%83%bd%e7%9a%84%e7%bc%ba%e9%99%b7">#</a>
</h4>
<ul>
<li>在Redis中，从服务器对主服务器的复制可以分为以下两种情况
<ul>
<li>初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同
<ul>
<li>对于初次复制来说，旧版复制功能能够很好地完成任务</li>
</ul>
</li>
<li>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器
<ul>
<li>对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低</li>
</ul>
</li>
</ul>
</li>
<li>SYNC命令是一个非常耗费资源的操作
<ul>
<li>1）主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。</li>
<li>2）主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响。</li>
<li>3）接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。</li>
<li>因为SYNC命令是一个如此耗费资源的操作，所以Redis有必要保证在真正有需要时才执行SYNC命令。</li>
</ul>
</li>
</ul>
<h4 id="新版复制功能的实现">
  新版复制功能的实现
  <a class="anchor" href="#%e6%96%b0%e7%89%88%e5%a4%8d%e5%88%b6%e5%8a%9f%e8%83%bd%e7%9a%84%e5%ae%9e%e7%8e%b0">#</a>
</h4>
<ul>
<li>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用<strong>PSYNC</strong>命令代替SYNC命令来执行复制时的同步操作</li>
<li>PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式
<ul>
<li>其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步</li>
<li>而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li>
</ul>
</li>
</ul>
<h4 id="部分重同步的实现">
  部分重同步的实现
  <a class="anchor" href="#%e9%83%a8%e5%88%86%e9%87%8d%e5%90%8c%e6%ad%a5%e7%9a%84%e5%ae%9e%e7%8e%b0">#</a>
</h4>
<ul>
<li>部分重同步功能由以下三个部分构成：
<ul>
<li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量
<ul>
<li>执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量
<ul>
<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li>
<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li>
</ul>
</li>
<li>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态
<ul>
<li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li>
<li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</li>
</ul>
</li>
</ul>
</li>
<li>主服务器的复制积压缓冲区（replication backlog）
<ul>
<li>复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB
<ul>
<li>和普通先进先出队列随着元素的增加和减少而动态调整长度不同，固定长度先进先出队列的长度是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列</li>
</ul>
</li>
<li>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面</li>
<li>主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量</li>
<li>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作
<ul>
<li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作</li>
<li>相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作</li>
</ul>
</li>
<li>根据需要调整复制积压缓冲区的大小
<ul>
<li>Redis为复制积压缓冲区设置的默认大小为1MB，如果主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间比较长，那么这个大小也许并不合适</li>
<li>如果复制积压缓冲区的大小设置得不恰当，那么PSYNC命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要
<ul>
<li>如果复制积压缓冲区的大小设置得不恰当，那么PSYNC命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要
<ul>
<li>其中second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）</li>
<li>而write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）</li>
<li>例如，如果主服务器平均每秒产生1 MB的写数据，而从服务器断线之后平均要5秒才能重新连接上主服务器，那么复制积压缓冲区的大小就不能低于5MB。</li>
<li>为了安全起见，可以将复制积压缓冲区的大小设为2<em>second</em>write_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>服务器的运行ID（run ID）
<ul>
<li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID</li>
<li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成</li>
<li>当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来</li>
<li>当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID
<ul>
<li>如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作</li>
<li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="psync-命令的实现">
  PSYNC 命令的实现
  <a class="anchor" href="#psync-%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0">#</a>
</h4>
<h4 id="复制的实现">
  复制的实现
  <a class="anchor" href="#%e5%a4%8d%e5%88%b6%e7%9a%84%e5%ae%9e%e7%8e%b0">#</a>
</h4>
<h4 id="心跳检测">
  心跳检测
  <a class="anchor" href="#%e5%bf%83%e8%b7%b3%e6%a3%80%e6%b5%8b">#</a>
</h4>
<h3 id="sentinel">
  Sentinel
  <a class="anchor" href="#sentinel">#</a>
</h3>
<ul>
<li>Sentinel（哨岗、哨兵）是Redis的高可用性（high availability）解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求</li>
</ul>
<h3 id="集群">
  集群
  <a class="anchor" href="#%e9%9b%86%e7%be%a4">#</a>
</h3>
<ul>
<li>Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能</li>
</ul>
<h4 id="节点">
  节点
  <a class="anchor" href="#%e8%8a%82%e7%82%b9">#</a>
</h4>
<ul>
<li>一个Redis集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群</li>
</ul>
<h4 id="槽指派">
  槽指派
  <a class="anchor" href="#%e6%a7%bd%e6%8c%87%e6%b4%be">#</a>
</h4>
<ul>
<li>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽</li>
<li>当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）</li>
</ul>
<h4 id="在集群中执行命令">
  在集群中执行命令
  <a class="anchor" href="#%e5%9c%a8%e9%9b%86%e7%be%a4%e4%b8%ad%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4">#</a>
</h4>
<ul>
<li>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己
<ul>
<li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令</li>
<li>如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令</li>
</ul>
</li>
</ul>
<h4 id="重新分片">
  重新分片
  <a class="anchor" href="#%e9%87%8d%e6%96%b0%e5%88%86%e7%89%87">#</a>
</h4>
<ul>
<li>Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。</li>
<li>重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求</li>
</ul>
<h4 id="ask错误">
  ASK错误
  <a class="anchor" href="#ask%e9%94%99%e8%af%af">#</a>
</h4>
<h4 id="复制与故障转移">
  复制与故障转移
  <a class="anchor" href="#%e5%a4%8d%e5%88%b6%e4%b8%8e%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb">#</a>
</h4>
<ul>
<li>Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求</li>
</ul>
<h4 id="消息">
  消息
  <a class="anchor" href="#%e6%b6%88%e6%81%af">#</a>
</h4>
<ul>
<li>集群中的各个节点通过发送和接收消息（message）来进行通信，我们称发送消息的节点为发送者（sender），接收消息的节点为接收者（receiver）</li>
<li>节点发送的消息主要有以下五种
<ul>
<li>MEET</li>
<li>PING</li>
<li>PONG</li>
<li>FAIL</li>
<li>PUBLISH</li>
</ul>
</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/penruins/penruins.github.io/commit/80526640b6f3182247783f76fc106393b5ba98e2" title='Last modified by liuxiang | August 2, 2025' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="" />
      <span>August 2, 2025</span>
    </a>
  </div>




</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#redis">redis</a>
      <ul>
        <li><a href="#redis基本数据类型-使用场景">redis基本数据类型, 使用场景</a></li>
        <li><a href="#什么是缓存击穿-缓存穿透-缓存雪崩">什么是缓存击穿 缓存穿透 缓存雪崩</a></li>
        <li><a href="#简单动态字符串">简单动态字符串</a></li>
        <li><a href="#链表">链表</a></li>
        <li><a href="#字典">字典</a></li>
        <li><a href="#跳跃表">跳跃表</a></li>
        <li><a href="#整数集合">整数集合</a></li>
        <li><a href="#压缩列表">压缩列表</a></li>
        <li><a href="#对象">对象</a></li>
        <li><a href="#数据库">数据库</a></li>
        <li><a href="#redis-集群">redis 集群</a>
          <ul>
            <li><a href="#redis-的集群模式有哪些">redis 的集群模式有哪些？</a></li>
            <li><a href="#redis-数据如何进行分片">redis 数据如何进行分片？</a></li>
            <li><a href="#分片的实现方案有哪些">分片的实现方案有哪些？</a></li>
            <li><a href="#主从">主从</a>
              <ul>
                <li><a href="#旧版复制功能的实现">旧版复制功能的实现</a></li>
                <li><a href="#旧版复制功能的缺陷">旧版复制功能的缺陷</a></li>
                <li><a href="#新版复制功能的实现">新版复制功能的实现</a></li>
                <li><a href="#部分重同步的实现">部分重同步的实现</a></li>
                <li><a href="#psync-命令的实现">PSYNC 命令的实现</a></li>
                <li><a href="#复制的实现">复制的实现</a></li>
                <li><a href="#心跳检测">心跳检测</a></li>
              </ul>
            </li>
            <li><a href="#sentinel">Sentinel</a></li>
            <li><a href="#集群">集群</a>
              <ul>
                <li><a href="#节点">节点</a></li>
                <li><a href="#槽指派">槽指派</a></li>
                <li><a href="#在集群中执行命令">在集群中执行命令</a></li>
                <li><a href="#重新分片">重新分片</a></li>
                <li><a href="#ask错误">ASK错误</a></li>
                <li><a href="#复制与故障转移">复制与故障转移</a></li>
                <li><a href="#消息">消息</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












