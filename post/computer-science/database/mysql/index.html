<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="mysql# MySQL知识体系的三驾马车 MySQL是怎样跑起来的读书笔记 #13 binlog# redo log 和 binlog日志# redo log 重做日志 Redo log是InnoDB存储引擎特有的物理日志，主要保证事务的持久性和崩溃恢复能力(crash-safe)。当MySQL实例意外宕机时，InnoDB可以通过redo log恢复已提交但未写入数据文件的事务，确保数据不会丢失 Redo log采用&#34;预写日志(WAL, Write-Ahead Logging)“机制：在数据页修改前，先记录日志到redo log buffer，再根据策略刷盘到redo log文件 刷盘策略 通过innodb_flush_log_at_trx_commit 参数控制 0：每秒刷盘一次，事务提交时不刷盘(可能丢失1秒数据) 1：每次事务提交都刷盘(默认，最安全) 2：写入OS缓存，不立即刷盘(仅MySQL崩溃安全，服务器宕机可能丢失数据) bin log 二进制日志 Binlog是MySQL Server层维护的逻辑日志，记录所有引起数据变更的SQL语句或行变更 主要用于 主从复制：从库通过重放主库的binlog实现数据同步 时间点恢复：结合全量备份和binlog可实现任意时间点的数据恢复 数据归档：记录数据库所有变更历史 三种格式 STATEMENT：记录SQL原文(默认)，可能因函数(如NOW())导致主从不一致 ROW：记录行数据变更(最安全)，但日志量大 MIXED：混合模式，根据语句自动选择格式 刷盘控制 通过 sync_binlog 参数控制 0：由系统决定刷盘时机 1：每次事务提交都刷盘(最安全) N：每N个事务刷盘一次(平衡性能与安全性) 两阶段提交：保证日志一致性 Prepare阶段：写入redo log并标记为prepare状态 写入binlog Commit阶段：将redo log标记为commit状态 读写分离# SpringBoot&#43;Mybatis-Plus实现mysql读写分离方案 在 Spring Boot 中优雅地实现读写分离 【读写分离】SpringBoot整合多数据源实现读写分离（一） Repeatable Read级别中的幻读问题如何通过间隙锁解决？# 在 MySQL 的 Repeatable Read 隔离级别中，幻读问题通过 间隙锁（Gap Lock） 和 Next-Key Lock 来解决。以下是详细的机制和实现方式：
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="/post/computer-science/database/mysql/">
  <meta property="og:site_name" content="Penruins">
  <meta property="og:title" content="mysql">
  <meta property="og:description" content="mysql# MySQL知识体系的三驾马车 MySQL是怎样跑起来的读书笔记 #13 binlog# redo log 和 binlog日志# redo log 重做日志 Redo log是InnoDB存储引擎特有的物理日志，主要保证事务的持久性和崩溃恢复能力(crash-safe)。当MySQL实例意外宕机时，InnoDB可以通过redo log恢复已提交但未写入数据文件的事务，确保数据不会丢失 Redo log采用&#34;预写日志(WAL, Write-Ahead Logging)“机制：在数据页修改前，先记录日志到redo log buffer，再根据策略刷盘到redo log文件 刷盘策略 通过innodb_flush_log_at_trx_commit 参数控制 0：每秒刷盘一次，事务提交时不刷盘(可能丢失1秒数据) 1：每次事务提交都刷盘(默认，最安全) 2：写入OS缓存，不立即刷盘(仅MySQL崩溃安全，服务器宕机可能丢失数据) bin log 二进制日志 Binlog是MySQL Server层维护的逻辑日志，记录所有引起数据变更的SQL语句或行变更 主要用于 主从复制：从库通过重放主库的binlog实现数据同步 时间点恢复：结合全量备份和binlog可实现任意时间点的数据恢复 数据归档：记录数据库所有变更历史 三种格式 STATEMENT：记录SQL原文(默认)，可能因函数(如NOW())导致主从不一致 ROW：记录行数据变更(最安全)，但日志量大 MIXED：混合模式，根据语句自动选择格式 刷盘控制 通过 sync_binlog 参数控制 0：由系统决定刷盘时机 1：每次事务提交都刷盘(最安全) N：每N个事务刷盘一次(平衡性能与安全性) 两阶段提交：保证日志一致性 Prepare阶段：写入redo log并标记为prepare状态 写入binlog Commit阶段：将redo log标记为commit状态 读写分离# SpringBoot&#43;Mybatis-Plus实现mysql读写分离方案 在 Spring Boot 中优雅地实现读写分离 【读写分离】SpringBoot整合多数据源实现读写分离（一） Repeatable Read级别中的幻读问题如何通过间隙锁解决？# 在 MySQL 的 Repeatable Read 隔离级别中，幻读问题通过 间隙锁（Gap Lock） 和 Next-Key Lock 来解决。以下是详细的机制和实现方式：">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:modified_time" content="2026-01-28T23:53:42+08:00">


  <meta itemprop="name" content="mysql">
  <meta itemprop="description" content="mysql# MySQL知识体系的三驾马车 MySQL是怎样跑起来的读书笔记 #13 binlog# redo log 和 binlog日志# redo log 重做日志 Redo log是InnoDB存储引擎特有的物理日志，主要保证事务的持久性和崩溃恢复能力(crash-safe)。当MySQL实例意外宕机时，InnoDB可以通过redo log恢复已提交但未写入数据文件的事务，确保数据不会丢失 Redo log采用&#34;预写日志(WAL, Write-Ahead Logging)“机制：在数据页修改前，先记录日志到redo log buffer，再根据策略刷盘到redo log文件 刷盘策略 通过innodb_flush_log_at_trx_commit 参数控制 0：每秒刷盘一次，事务提交时不刷盘(可能丢失1秒数据) 1：每次事务提交都刷盘(默认，最安全) 2：写入OS缓存，不立即刷盘(仅MySQL崩溃安全，服务器宕机可能丢失数据) bin log 二进制日志 Binlog是MySQL Server层维护的逻辑日志，记录所有引起数据变更的SQL语句或行变更 主要用于 主从复制：从库通过重放主库的binlog实现数据同步 时间点恢复：结合全量备份和binlog可实现任意时间点的数据恢复 数据归档：记录数据库所有变更历史 三种格式 STATEMENT：记录SQL原文(默认)，可能因函数(如NOW())导致主从不一致 ROW：记录行数据变更(最安全)，但日志量大 MIXED：混合模式，根据语句自动选择格式 刷盘控制 通过 sync_binlog 参数控制 0：由系统决定刷盘时机 1：每次事务提交都刷盘(最安全) N：每N个事务刷盘一次(平衡性能与安全性) 两阶段提交：保证日志一致性 Prepare阶段：写入redo log并标记为prepare状态 写入binlog Commit阶段：将redo log标记为commit状态 读写分离# SpringBoot&#43;Mybatis-Plus实现mysql读写分离方案 在 Spring Boot 中优雅地实现读写分离 【读写分离】SpringBoot整合多数据源实现读写分离（一） Repeatable Read级别中的幻读问题如何通过间隙锁解决？# 在 MySQL 的 Repeatable Read 隔离级别中，幻读问题通过 间隙锁（Gap Lock） 和 Next-Key Lock 来解决。以下是详细的机制和实现方式：">
  <meta itemprop="dateModified" content="2026-01-28T23:53:42+08:00">
  <meta itemprop="wordCount" content="2072">

<title>mysql | Penruins</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="/post/computer-science/database/mysql/">
<link rel="stylesheet" href="/book.min.046c94b4d56ca1e27a3321bf6a99735a798394415354c65db9553d1c3032d929.css" >


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.93770e7ea6ba9ddf3c0c520ba45857d1f9bcd3561c6d4c018ee56bb416d68671.js" ></script>



  
</head>
<body dir="ltr" class="book-kind-page book-type-post">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Penruins</span>
  </a>
</h2>


<div class="book-search hidden">
  <input id="book-search-input" type="text" 
    placeholder="Search"
    aria-label="Search"
    maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>













  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-d673e25af27f33796c279e3a05cc634f" class="toggle"  />
    <label for="section-d673e25af27f33796c279e3a05cc634f" class="flex">
      <a role="button" class="">
        Life</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/life/%E6%96%B0%E7%9F%A5/" class="">
      新知</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/bilibili/" class="">
      bilibili</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/cycling/" class="">
      cycling</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/hiking/" class="">
      hiking</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/life/" class="">
      life</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/learning-others-log/" class="">
      other learning</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/podcast/" class="">
      podcast</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/politics/" class="">
      politics</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/goal/" class="">
      goal</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/coffee/" class="">
      coffee</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/article/" class="">
      article</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/law/" class="">
      law</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/life/my-history/" class="">
      my history</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e52270c7d6707875ea89b3ec9b091983" class="toggle" checked />
    <label for="section-e52270c7d6707875ea89b3ec9b091983" class="flex">
      <a role="button" class="">
        Computer Science</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f834cb9837867b0fca71e863c9ed2d28" class="toggle"  />
    <label for="section-f834cb9837867b0fca71e863c9ed2d28" class="flex">
      <a role="button" class="">
        Algorithm</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/algorithm/algorithm/" class="">
      Algorithm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/algorithm/algorithm-practice-%E5%89%91%E6%8C%87-offer/" class="">
      algorithm practice 剑指 offer</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/algorithm/%E5%89%91%E6%8C%87offer%E8%BF%99%E6%9C%AC%E4%B9%A6%E4%B8%AD%E6%AF%8F%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AF%B9%E5%BA%94leetcode%E7%9A%84%E9%A2%98%E7%9B%AE/" class="">
      剑指offer题目对应</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/algorithm/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/" class="">
      面试经典 150 题</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-12ae84c3ad3679302ffec2ab120d7fb0" class="toggle"  />
    <label for="section-12ae84c3ad3679302ffec2ab120d7fb0" class="flex">
      <a role="button" class="">
        Big Data</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/big-data/hadoop/" class="">
      hadoop</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/big-data/hbase/" class="">
      hbase</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/big-data/hive/" class="">
      hive</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-256c0c0348e7dc55386785c98f7fa516" class="toggle" checked />
    <label for="section-256c0c0348e7dc55386785c98f7fa516" class="flex">
      <a role="button" class="">
        Database</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/database/" class="">
      database</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/druid/" class="">
      druid</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/elasticsearch/" class="">
      elasticsearch</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/mycat/" class="">
      mycat</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/mysql/" class="active">
      mysql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/postgresql/" class="">
      postgresql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/shardingsphere/" class="">
      shardingsphere</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/sql/" class="">
      SQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/database/mongodb/" class="">
      Penruins</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f46c5b5e1e52cbfb9fb92b25409b5352" class="toggle"  />
    <label for="section-f46c5b5e1e52cbfb9fb92b25409b5352" class="flex">
      <a role="button" class="">
        Distributed System</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-98c822a4c30374b08c20bbb746ca28ff" class="toggle"  />
    <label for="section-98c822a4c30374b08c20bbb746ca28ff" class="flex">
      <a role="button" class="">
        Message Queue</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/message-queue/kafka/" class="">
      kafka</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/message-queue/message-queue/" class="">
      Message Queue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/message-queue/rabbitmq/" class="">
      rabbitmq</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/distributed-system/" class="">
      distributed system</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/sentinel/" class="">
      Sentinel</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/spring-cloud/" class="">
      Spring Cloud</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/distributed-system/spring-cloud-alibaba/" class="">
      Spring Cloud Alibaba</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-51f600e6ef5b531bcd84ecd789276516" class="toggle"  />
    <label for="section-51f600e6ef5b531bcd84ecd789276516" class="flex">
      <a role="button" class="">
        Monitor</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/monitor/prometheus/" class="">
      prometheus</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b11c61a955da170f736b6dbde7b6e083" class="toggle"  />
    <label for="section-b11c61a955da170f736b6dbde7b6e083" class="flex">
      <a role="button" class="">
        Tools</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/tools/idea/" class="">
      IDEA</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/computer-science-recommend/" class="">
      推荐</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/computer-science-learning-log/" class="">
      学习记录</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/github/" class="">
      github</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/job/" class="">
      job</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/redis/" class="">
      redis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/security/" class="">
      security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/cloud/" class="">
      Cloud</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2f97889f3f0b1ca7ff547a7c288df6f0" class="toggle"  />
    <label for="section-2f97889f3f0b1ca7ff547a7c288df6f0" class="flex">
      <a role="button" class="">
        Front End</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/front-end/echarts/" class="">
      echarts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/front-end/vue/" class="">
      vue</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-529cbb550ade3cc11293cf67d1d534f0" class="toggle"  />
    <label for="section-529cbb550ade3cc11293cf67d1d534f0" class="flex">
      <a role="button" class="">
        Micro Service</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/micro-service/nacos/" class="">
      Nacos</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/micro-service/micro-service/" class="">
      micro service</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-53c205cf4e6c3e5d00ec77a3728f3fde" class="toggle"  />
    <label for="section-53c205cf4e6c3e5d00ec77a3728f3fde" class="flex">
      <a role="button" class="">
        Operating System</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/operating-system/ios/" class="">
      IOS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/operating-system/mac/" class="">
      mac</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/operating-system/raspberrypi/" class="">
      raspberry pi</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/operating-system/powershell/" class="">
      powershell</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/operating-system/windows/" class="">
      windows</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-fb5af4ccc08ed8db9c0d17ca2e0e9dff" class="toggle"  />
    <label for="section-fb5af4ccc08ed8db9c0d17ca2e0e9dff" class="flex">
      <a role="button" class="">
        Software</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6c1b5eb9fa302a23733b5ce342165515" class="toggle"  />
    <label for="section-6c1b5eb9fa302a23733b5ce342165515" class="flex">
      <a role="button" class="">
        CI/CD</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/ci-cd/docker/" class="">
      docker</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/ci-cd/gitlab/" class="">
      Gitlab</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/ci-cd/jenkins/" class="">
      Jenkins</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/ci-cd/maven/" class="">
      maven</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/ci-cd/nexus/" class="">
      Nexus</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/ci-cd/orbstack/" class="">
      OrbStack</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/crawler/" class="">
      crawler</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/python/" class="">
      Python</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/reddison/" class="">
      reddison</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/vim/" class="">
      vim</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="">
      系统设计</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/computer-science/%E8%BF%90%E7%BB%B4/" class="">
      运维</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3b7129f485a86f816ed70cb52a2a5843" class="toggle"  />
    <label for="section-3b7129f485a86f816ed70cb52a2a5843" class="flex">
      <a role="button" class="">
        History</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/history/chinese-history/" class="">
      Chinese History</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-27743f5ad758a53b0d2d97b463de9ca0" class="toggle"  />
    <label for="section-27743f5ad758a53b0d2d97b463de9ca0" class="flex">
      <a role="button" class="">
        Others</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/others/about-me/" class="">
      about me</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/post/others/economy/" class="">
      Economy</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/others/f1/" class="">
      F1</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-7cf7927dd7be57fd9ac871554e5eab30" class="toggle"  />
    <label for="section-7cf7927dd7be57fd9ac871554e5eab30" class="flex">
      <a role="button" class="">
        Science</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/science/biology/" class="">
      biology</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c86d83c6ab9662a5734c7c938687f51c" class="toggle"  />
    <label for="section-c86d83c6ab9662a5734c7c938687f51c" class="flex">
      <a role="button" class="">
        Sports</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/sports/cycling/" class="">
      cycling</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/sports/table-tennis/" class="">
      table tennis</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a7716b8c5e1ddba36a22182d4f60014c" class="toggle"  />
    <label for="section-a7716b8c5e1ddba36a22182d4f60014c" class="flex">
      <a role="button" class="">
        Wl Public</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6fc9a7b0dd6392ef81e392a65430999b" class="toggle"  />
    <label for="section-6fc9a7b0dd6392ef81e392a65430999b" class="flex">
      <a role="button" class="">
        Books</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-06aae5e89825d313a1291f1996bfc76d" class="toggle"  />
    <label for="section-06aae5e89825d313a1291f1996bfc76d" class="flex">
      <a role="button" class="">
        Computer Science</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" class="">
      Java并发编程实战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="">
      Python神经网络编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="">
      Redis设计与实现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/" class="">
      Spring Cloud微服务：入门、实战与进阶</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" class="">
      一本书讲透 ElasticSearch：原理、进阶与工程实践</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/books/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E7%AC%AC%E4%B8%89%E7%89%88/" class="">
      宏观经济学 第三版</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/post/books/%E8%8B%B1%E4%BC%9F%E8%BE%BE-%E9%BB%84%E4%BB%81%E5%8B%8B%E4%B9%8B%E8%8A%AF/" class="">
      英伟达-黄仁勋之芯</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-aea2a4e9afcf7a8e876e21f2b858e5ae" class="toggle"  />
    <label for="section-aea2a4e9afcf7a8e876e21f2b858e5ae" class="flex">
      <a role="button" class="">
        Tools</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/post/tools/obsidian/" class="">
      obsidian</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>













</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header hidden">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>mysql</h3>

  <label for="toc-control">
    
    <img src="/icons/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#mysql">mysql</a>
      <ul>
        <li><a href="#binlog">binlog</a>
          <ul>
            <li><a href="#redo-log-和-binlog日志">redo log 和 binlog日志</a></li>
          </ul>
        </li>
        <li><a href="#读写分离">读写分离</a></li>
        <li><a href="#repeatable-read级别中的幻读问题如何通过间隙锁解决">Repeatable Read级别中的幻读问题如何通过间隙锁解决？</a>
          <ul>
            <li><a href="#1-幻读的定义">1. <strong>幻读的定义</strong></a></li>
            <li><a href="#2-间隙锁gap-lock">2. <strong>间隙锁（Gap Lock）</strong></a></li>
            <li><a href="#3-next-key-lock">3. <strong>Next-Key Lock</strong></a></li>
            <li><a href="#4-间隙锁的适用场景">4. <strong>间隙锁的适用场景</strong></a></li>
            <li><a href="#5-间隙锁的注意事项">5. <strong>间隙锁的注意事项</strong></a></li>
            <li><a href="#6-示例">6. <strong>示例</strong></a></li>
            <li><a href="#总结">总结</a></li>
          </ul>
        </li>
        <li><a href="#mysql-有哪些索引类型">mysql 有哪些索引类型</a>
          <ul>
            <li><a href="#1-b树索引">1. <strong>B+树索引</strong></a></li>
            <li><a href="#2-哈希索引">2. <strong>哈希索引</strong></a></li>
            <li><a href="#3-全文索引fulltext">3. <strong>全文索引（FULLTEXT）</strong></a></li>
            <li><a href="#4-空间索引spatial">4. <strong>空间索引（SPATIAL）</strong></a></li>
            <li><a href="#5-主键索引">5. <strong>主键索引</strong></a></li>
            <li><a href="#6-唯一索引">6. <strong>唯一索引</strong></a></li>
            <li><a href="#7-普通索引">7. <strong>普通索引</strong></a></li>
            <li><a href="#8-组合索引">8. <strong>组合索引</strong></a></li>
            <li><a href="#9-前缀索引">9. <strong>前缀索引</strong></a></li>
            <li><a href="#10-覆盖索引">10. <strong>覆盖索引</strong></a></li>
            <li><a href="#总结-1"><strong>总结</strong></a></li>
          </ul>
        </li>
        <li><a href="#repeatable-read级别中的幻读问题如何通过间隙锁解决-1">Repeatable Read级别中的幻读问题如何通过间隙锁解决？</a>
          <ul>
            <li><a href="#1-幻读的定义-1">1. <strong>幻读的定义</strong></a></li>
            <li><a href="#2-间隙锁gap-lock-1">2. <strong>间隙锁（Gap Lock）</strong></a></li>
            <li><a href="#3-next-key-lock-1">3. <strong>Next-Key Lock</strong></a></li>
            <li><a href="#4-间隙锁的适用场景-1">4. <strong>间隙锁的适用场景</strong></a></li>
            <li><a href="#5-间隙锁的注意事项-1">5. <strong>间隙锁的注意事项</strong></a></li>
            <li><a href="#6-示例-1">6. <strong>示例</strong></a></li>
            <li><a href="#总结-2">总结</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#分区">分区</a>
      <ul>
        <li><a href="#mysql-可以做分区吗">mysql 可以做分区吗</a>
          <ul>
            <li><a href="#1-mysql-分区的版本支持">1. <strong>MySQL 分区的版本支持</strong></a></li>
            <li><a href="#2-分区的实现方式">2. <strong>分区的实现方式</strong></a></li>
            <li><a href="#3-分区的适用场景">3. <strong>分区的适用场景</strong></a></li>
            <li><a href="#4-分区的优点">4. <strong>分区的优点</strong></a></li>
            <li><a href="#5-分区的限制">5. <strong>分区的限制</strong></a></li>
            <li><a href="#6-分区示例">6. <strong>分区示例</strong></a></li>
            <li><a href="#总结-3">总结</a></li>
          </ul>
        </li>
        <li><a href="#提供一个按日期月份进行分区的例子">提供一个按日期月份进行分区的例子</a>
          <ul>
            <li><a href="#1-创建表并按月份分区">1. <strong>创建表并按月份分区</strong></a></li>
            <li><a href="#2-插入数据">2. <strong>插入数据</strong></a></li>
            <li><a href="#3-查询分区数据">3. <strong>查询分区数据</strong></a></li>
            <li><a href="#4-动态添加分区">4. <strong>动态添加分区</strong></a></li>
            <li><a href="#5-删除旧分区">5. <strong>删除旧分区</strong></a></li>
            <li><a href="#6-总结">6. <strong>总结</strong></a></li>
          </ul>
        </li>
        <li><a href="#在mysql中分区可以在之后动态新增吗">在mysql中分区可以在之后动态新增吗</a>
          <ul>
            <li><a href="#1-手动添加分区">1. <strong>手动添加分区</strong></a></li>
            <li><a href="#2-使用存储过程自动添加分区">2. <strong>使用存储过程自动添加分区</strong></a></li>
            <li><a href="#3-使用定时任务自动添加分区">3. <strong>使用定时任务自动添加分区</strong></a></li>
            <li><a href="#4-注意事项">4. <strong>注意事项</strong></a></li>
            <li><a href="#总结-4">总结</a></li>
          </ul>
        </li>
        <li><a href="#过多的分区可能导致性能下降这个问题该如何处理">过多的分区可能导致性能下降，这个问题该如何处理</a>
          <ul>
            <li><a href="#1-合理设计分区策略">1. <strong>合理设计分区策略</strong></a></li>
            <li><a href="#2-合并小分区">2. <strong>合并小分区</strong></a></li>
            <li><a href="#3-使用子分区">3. <strong>使用子分区</strong></a></li>
            <li><a href="#4-定期清理和归档数据">4. <strong>定期清理和归档数据</strong></a></li>
            <li><a href="#5-优化查询和索引">5. <strong>优化查询和索引</strong></a></li>
            <li><a href="#6-监控和调整">6. <strong>监控和调整</strong></a></li>
            <li><a href="#7-避免过度分区">7. <strong>避免过度分区</strong></a></li>
          </ul>
        </li>
        <li><a href="#如何评估一个表是否需要进行分区">如何评估一个表是否需要进行分区</a>
          <ul>
            <li><a href="#1-数据量大小">1. <strong>数据量大小</strong></a></li>
            <li><a href="#2-查询模式">2. <strong>查询模式</strong></a></li>
            <li><a href="#3-数据管理需求">3. <strong>数据管理需求</strong></a></li>
            <li><a href="#4-硬件资源">4. <strong>硬件资源</strong></a></li>
            <li><a href="#5-业务需求">5. <strong>业务需求</strong></a></li>
            <li><a href="#6-分区键选择">6. <strong>分区键选择</strong></a></li>
            <li><a href="#7-分区的优缺点权衡">7. <strong>分区的优缺点权衡</strong></a></li>
            <li><a href="#总结-5">总结</a></li>
          </ul>
        </li>
        <li><a href="#分区表和非分区表在性能上有什么具体区别">分区表和非分区表在性能上有什么具体区别</a>
          <ul>
            <li><a href="#1-查询性能">1. <strong>查询性能</strong></a></li>
            <li><a href="#2-插入性能">2. <strong>插入性能</strong></a></li>
            <li><a href="#3-删除性能">3. <strong>删除性能</strong></a></li>
            <li><a href="#4-维护性能">4. <strong>维护性能</strong></a></li>
            <li><a href="#5-索引性能">5. <strong>索引性能</strong></a></li>
            <li><a href="#6-存储性能">6. <strong>存储性能</strong></a></li>
            <li><a href="#总结-6">总结</a></li>
          </ul>
        </li>
        <li><a href="#分区表在不同数据库系统中有什么区别">分区表在不同数据库系统中有什么区别</a>
          <ul>
            <li><a href="#1-mysql-分区表">1. <strong>MySQL 分区表</strong></a></li>
            <li><a href="#2-oracle-分区表">2. <strong>Oracle 分区表</strong></a></li>
            <li><a href="#3-postgresql-分区表">3. <strong>PostgreSQL 分区表</strong></a></li>
            <li><a href="#4-主要区别">4. <strong>主要区别</strong></a></li>
            <li><a href="#总结-7">总结</a></li>
          </ul>
        </li>
        <li><a href="#如何选择合适的分区键">如何选择合适的分区键</a>
          <ul>
            <li><a href="#1-频繁查询的列">1. <strong>频繁查询的列</strong></a></li>
            <li><a href="#2-数据分布性">2. <strong>数据分布性</strong></a></li>
            <li><a href="#3-单一列或多列组合">3. <strong>单一列或多列组合</strong></a></li>
            <li><a href="#4-避免过度分区">4. <strong>避免过度分区</strong></a></li>
            <li><a href="#5-考虑分区类型">5. <strong>考虑分区类型</strong></a></li>
            <li><a href="#6-维护和管理">6. <strong>维护和管理</strong></a></li>
            <li><a href="#7-测试和调整">7. <strong>测试和调整</strong></a></li>
            <li><a href="#8-业务需求">8. <strong>业务需求</strong></a></li>
            <li><a href="#9-数据量和查询模式">9. <strong>数据量和查询模式</strong></a></li>
            <li><a href="#10-事务处理模式">10. <strong>事务处理模式</strong></a></li>
            <li><a href="#总结-8">总结</a></li>
          </ul>
        </li>
        <li><a href="#分区对数据库的水平扩展有什么影响">分区对数据库的水平扩展有什么影响</a></li>
        <li><a href="#有哪些常见的错误分区键选择案例">有哪些常见的错误分区键选择案例？</a>
          <ul>
            <li><a href="#1-选择低基数列作为分区键">1. <strong>选择低基数列作为分区键</strong></a></li>
            <li><a href="#2-选择高基数列但数据分布不均的列">2. <strong>选择高基数列但数据分布不均的列</strong></a></li>
            <li><a href="#3-选择频繁更新的列作为分区键">3. <strong>选择频繁更新的列作为分区键</strong></a></li>
            <li><a href="#4-选择与查询条件无关的列作为分区键">4. <strong>选择与查询条件无关的列作为分区键</strong></a></li>
            <li><a href="#5-选择表达式或函数作为分区键">5. <strong>选择表达式或函数作为分区键</strong></a></li>
            <li><a href="#6-选择分区键时忽略业务需求">6. <strong>选择分区键时忽略业务需求</strong></a></li>
            <li><a href="#7-选择分区键时忽略数据增长模式">7. <strong>选择分区键时忽略数据增长模式</strong></a></li>
            <li><a href="#8-选择分区键时忽略存储引擎限制">8. <strong>选择分区键时忽略存储引擎限制</strong></a></li>
            <li><a href="#9-选择分区键时忽略分区数量限制">9. <strong>选择分区键时忽略分区数量限制</strong></a></li>
            <li><a href="#10-选择分区键时忽略维护成本">10. <strong>选择分区键时忽略维护成本</strong></a></li>
            <li><a href="#总结-9">总结</a></li>
          </ul>
        </li>
        <li><a href="#如何评估分区键的选择是否会对查询性能产生显著影响">如何评估分区键的选择是否会对查询性能产生显著影响？</a></li>
      </ul>
    </li>
    <li><a href="#备份">备份</a>
      <ul>
        <li><a href="#how-to-back-up-and-restore-a-database-in-mysql">How to Back Up and Restore a Database in MySQL</a></li>
        <li><a href="#mysqldump-官方文档">mysqldump 官方文档</a>
          <ul>
            <li><a href="#performance-and-scalability-considerations">Performance and Scalability Considerations</a></li>
          </ul>
        </li>
        <li><a href="#logic-backup-逻辑备份">logic backup 逻辑备份</a></li>
        <li><a href="#mysql-shell-dump-utilities">MySQL Shell dump utilities</a></li>
        <li><a href="#backing-up-mysql-part-6-physical-vs-logical-backups">Backing Up MySQL Part 6: Physical vs. Logical Backups</a></li>
        <li><a href="#可以在mysql还在运行时执行-mysqldump-吗">可以在mysql还在运行时执行 mysqldump 吗？</a></li>
        <li><a href="#脚本中如何输入密码">脚本中如何输入密码</a></li>
        <li><a href="#reference">reference</a></li>
      </ul>
    </li>
    <li><a href="#reference-1">Reference</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="mysql">mysql<a class="anchor" href="#mysql">#</a></h1>
<ul>
<li><a href="https://plantegg.github.io/2019/05/26/MySQL%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%89%E9%A9%BE%E9%A9%AC%E8%BD%A6/">MySQL知识体系的三驾马车</a></li>
<li><a href="https://github.com/yihong0618/gitblog/issues/13">MySQL是怎样跑起来的读书笔记 #13</a></li>
</ul>
<h2 id="binlog">binlog<a class="anchor" href="#binlog">#</a></h2>
<h3 id="redo-log-和-binlog日志">redo log 和 binlog日志<a class="anchor" href="#redo-log-%e5%92%8c-binlog%e6%97%a5%e5%bf%97">#</a></h3>
<ul>
<li>redo log 重做日志
<ul>
<li>Redo log是InnoDB存储引擎特有的物理日志，主要保证事务的持久性和崩溃恢复能力(crash-safe)。当MySQL实例意外宕机时，InnoDB可以通过redo log恢复已提交但未写入数据文件的事务，确保数据不会丢失</li>
<li>Redo log采用&quot;预写日志(WAL, Write-Ahead Logging)&ldquo;机制：在数据页修改前，先记录日志到redo log buffer，再根据策略刷盘到redo log文件</li>
<li>刷盘策略
<ul>
<li>通过<code>innodb_flush_log_at_trx_commit</code> 参数控制
<ul>
<li>0：每秒刷盘一次，事务提交时不刷盘(可能丢失1秒数据)</li>
<li>1：每次事务提交都刷盘(默认，最安全)</li>
<li>2：写入OS缓存，不立即刷盘(仅MySQL崩溃安全，服务器宕机可能丢失数据)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>bin log 二进制日志
<ul>
<li>Binlog是MySQL Server层维护的逻辑日志，记录所有引起数据变更的SQL语句或行变更</li>
<li>主要用于
<ul>
<li>主从复制：从库通过重放主库的binlog实现数据同步</li>
<li>时间点恢复：结合全量备份和binlog可实现任意时间点的数据恢复</li>
<li>数据归档：记录数据库所有变更历史</li>
</ul>
</li>
<li>三种格式
<ul>
<li>STATEMENT：记录SQL原文(默认)，可能因函数(如NOW())导致主从不一致</li>
<li>ROW：记录行数据变更(最安全)，但日志量大</li>
<li>MIXED：混合模式，根据语句自动选择格式</li>
</ul>
</li>
<li>刷盘控制
<ul>
<li>通过 <code>sync_binlog</code> 参数控制
<ul>
<li>0：由系统决定刷盘时机</li>
<li>1：每次事务提交都刷盘(最安全)</li>
<li>N：每N个事务刷盘一次(平衡性能与安全性)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>两阶段提交：保证日志一致性
<ul>
<li>Prepare阶段：写入redo log并标记为prepare状态</li>
<li>写入binlog</li>
<li>Commit阶段：将redo log标记为commit状态</li>
</ul>
</li>
</ul>
<h2 id="读写分离">读写分离<a class="anchor" href="#%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb">#</a></h2>
<ul>
<li><a href="https://blog.csdn.net/AAAAABBBBBYYYYY/article/details/110875245">SpringBoot+Mybatis-Plus实现mysql读写分离方案</a></li>
<li><a href="https://springdoc.cn/spring-boot-implement-read-write-separation/">在 Spring Boot 中优雅地实现读写分离</a></li>
<li><a href="https://blog.csdn.net/qq_33101675/article/details/114396476">【读写分离】SpringBoot整合多数据源实现读写分离（一）</a></li>
</ul>
<h2 id="repeatable-read级别中的幻读问题如何通过间隙锁解决">Repeatable Read级别中的幻读问题如何通过间隙锁解决？<a class="anchor" href="#repeatable-read%e7%ba%a7%e5%88%ab%e4%b8%ad%e7%9a%84%e5%b9%bb%e8%af%bb%e9%97%ae%e9%a2%98%e5%a6%82%e4%bd%95%e9%80%9a%e8%bf%87%e9%97%b4%e9%9a%99%e9%94%81%e8%a7%a3%e5%86%b3">#</a></h2>
<p>在 MySQL 的 <strong>Repeatable Read</strong> 隔离级别中，幻读问题通过 <strong>间隙锁（Gap Lock）</strong> 和 <strong>Next-Key Lock</strong> 来解决。以下是详细的机制和实现方式：</p>
<hr>
<h3 id="1-幻读的定义">1. <strong>幻读的定义</strong><a class="anchor" href="#1-%e5%b9%bb%e8%af%bb%e7%9a%84%e5%ae%9a%e4%b9%89">#</a></h3>
<p>幻读是指在同一事务中，多次执行相同的范围查询时，返回的结果集不一致。例如：</p>
<ul>
<li>事务 A 第一次查询 <code>SELECT * FROM t WHERE id &gt; 10</code>，返回 5 条记录。</li>
<li>事务 B 插入了一条 <code>id = 15</code> 的记录并提交。</li>
<li>事务 A 再次查询时，返回了 6 条记录，这就是幻读。</li>
</ul>
<hr>
<h3 id="2-间隙锁gap-lock">2. <strong>间隙锁（Gap Lock）</strong><a class="anchor" href="#2-%e9%97%b4%e9%9a%99%e9%94%81gap-lock">#</a></h3>
<ul>
<li><strong>定义</strong>：间隙锁是锁住索引记录之间的间隙（即范围），而不是锁住具体的记录。</li>
<li><strong>作用</strong>：防止其他事务在范围内插入新数据，从而避免幻读。</li>
</ul>
<p>例如，表 <code>t</code> 中有以下记录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>id: 10, 20, 30</span></span></code></pre></div><p>如果事务 A 执行 <code>SELECT * FROM t WHERE id &gt; 10 AND id &lt; 30</code>，间隙锁会锁住 <code>(10, 20)</code> 和 <code>(20, 30)</code> 两个区间，阻止其他事务插入 <code>id = 15</code> 或 <code>id = 25</code> 的记录。</p>
<hr>
<h3 id="3-next-key-lock">3. <strong>Next-Key Lock</strong><a class="anchor" href="#3-next-key-lock">#</a></h3>
<ul>
<li><strong>定义</strong>：Next-Key Lock 是 <strong>记录锁（Record Lock）</strong> 和 <strong>间隙锁（Gap Lock）</strong> 的结合，锁住记录及其前后的间隙。</li>
<li><strong>作用</strong>：在范围查询中，Next-Key Lock 不仅锁住符合条件的记录，还锁住记录之间的间隙，从而彻底防止幻读。</li>
</ul>
<p>例如，表 <code>t</code> 中有以下记录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>id: 10, 20, 30</span></span></code></pre></div><p>如果事务 A 执行 <code>SELECT * FROM t WHERE id &gt; 10 AND id &lt; 30</code>，Next-Key Lock 会锁住：</p>
<ul>
<li><code>(10, 20]</code>：锁住记录 <code>20</code> 和间隙 <code>(10, 20)</code>。</li>
<li><code>(20, 30]</code>：锁住记录 <code>30</code> 和间隙 <code>(20, 30)</code>。</li>
</ul>
<p>这样，其他事务无法在 <code>(10, 30)</code> 范围内插入新记录，避免了幻读。</p>
<hr>
<h3 id="4-间隙锁的适用场景">4. <strong>间隙锁的适用场景</strong><a class="anchor" href="#4-%e9%97%b4%e9%9a%99%e9%94%81%e7%9a%84%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af">#</a></h3>
<ul>
<li><strong>范围查询</strong>：如 <code>WHERE id &gt; 10 AND id &lt; 30</code>。</li>
<li><strong>唯一索引</strong>：在唯一索引的等值查询中，如果记录不存在，间隙锁会锁住该值的区间，防止插入。</li>
<li><strong>非唯一索引</strong>：在非唯一索引的等值查询中，间隙锁会锁住所有可能的区间。</li>
</ul>
<hr>
<h3 id="5-间隙锁的注意事项">5. <strong>间隙锁的注意事项</strong><a class="anchor" href="#5-%e9%97%b4%e9%9a%99%e9%94%81%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">#</a></h3>
<ul>
<li><strong>性能开销</strong>：间隙锁会锁定一个范围，可能导致并发性能下降，尤其是在高并发写入场景中。</li>
<li><strong>死锁风险</strong>：间隙锁可能增加死锁的概率，因为多个事务可能互相等待对方释放间隙锁。</li>
</ul>
<hr>
<h3 id="6-示例">6. <strong>示例</strong><a class="anchor" href="#6-%e7%a4%ba%e4%be%8b">#</a></h3>
<p>假设表 <code>t</code> 中有以下记录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>id: 10, 20, 30</span></span></code></pre></div><p>事务 A 执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">BEGIN</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> t <span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">10</span> <span style="color:#66d9ef">AND</span> id <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">30</span> <span style="color:#66d9ef">FOR</span> <span style="color:#66d9ef">UPDATE</span>;</span></span></code></pre></div><p>此时，事务 A 会锁住 <code>(10, 20]</code> 和 <code>(20, 30]</code>。</p>
<p>事务 B 尝试插入 <code>id = 15</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t (id) <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">15</span>);</span></span></code></pre></div><p>由于间隙锁的存在，事务 B 会被阻塞，直到事务 A 提交或回滚。</p>
<hr>
<h3 id="总结">总结<a class="anchor" href="#%e6%80%bb%e7%bb%93">#</a></h3>
<p>在 <strong>Repeatable Read</strong> 隔离级别中，MySQL 通过 <strong>间隙锁</strong> 和 <strong>Next-Key Lock</strong> 解决了幻读问题：</p>
<ul>
<li>间隙锁锁住索引记录之间的间隙，防止新数据插入。</li>
<li>Next-Key Lock 结合记录锁和间隙锁，彻底避免幻读。</li>
</ul>
<p>这种机制在保证数据一致性的同时，可能会对并发性能产生一定影响，因此在设计高并发系统时需要权衡。</p>
<h2 id="mysql-有哪些索引类型">mysql 有哪些索引类型<a class="anchor" href="#mysql-%e6%9c%89%e5%93%aa%e4%ba%9b%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%9e%8b">#</a></h2>
<p>MySQL 支持多种索引类型，每种索引类型都有其特定的适用场景和特点。以下是 MySQL 中常见的索引类型及其简要说明：</p>
<hr>
<h3 id="1-b树索引">1. <strong>B+树索引</strong><a class="anchor" href="#1-b%e6%a0%91%e7%b4%a2%e5%bc%95">#</a></h3>
<ul>
<li><strong>特点</strong>：基于 B+ 树实现，支持等值查询、范围查询和排序操作。</li>
<li><strong>适用场景</strong>：主键索引、唯一索引和普通索引<a href="@ref">1</a><a href="@ref">4</a><a href="@ref">5</a>。</li>
<li><strong>示例</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_name <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">table_name</span> (<span style="color:#66d9ef">column_name</span>);</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="2-哈希索引">2. <strong>哈希索引</strong><a class="anchor" href="#2-%e5%93%88%e5%b8%8c%e7%b4%a2%e5%bc%95">#</a></h3>
<ul>
<li><strong>特点</strong>：基于哈希表实现，查询效率高，但仅支持精确匹配，不支持范围查询和排序。</li>
<li><strong>适用场景</strong>：精确匹配查询，例如 <code>MEMORY</code> 存储引擎默认使用哈希索引<a href="@ref">3</a><a href="@ref">4</a><a href="@ref">5</a>。</li>
<li><strong>示例</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_name <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">table_name</span> <span style="color:#66d9ef">USING</span> HASH (<span style="color:#66d9ef">column_name</span>);</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="3-全文索引fulltext">3. <strong>全文索引（FULLTEXT）</strong><a class="anchor" href="#3-%e5%85%a8%e6%96%87%e7%b4%a2%e5%bc%95fulltext">#</a></h3>
<ul>
<li><strong>特点</strong>：用于高效地执行全文搜索，支持自然语言模式和布尔模式搜索。</li>
<li><strong>适用场景</strong>：大量文本内容的搜索，如博客、文章和评论<a href="@ref">1</a><a href="@ref">4</a><a href="@ref">5</a>。</li>
<li><strong>示例</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> FULLTEXT <span style="color:#66d9ef">INDEX</span> idx_name <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">table_name</span> (<span style="color:#66d9ef">column_name</span>);</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="4-空间索引spatial">4. <strong>空间索引（SPATIAL）</strong><a class="anchor" href="#4-%e7%a9%ba%e9%97%b4%e7%b4%a2%e5%bc%95spatial">#</a></h3>
<ul>
<li><strong>特点</strong>：专为地理数据设计，用于处理二维空间数据。</li>
<li><strong>适用场景</strong>：地理位置查询和空间数据分析<a href="@ref">1</a><a href="@ref">4</a><a href="@ref">5</a>。</li>
<li><strong>示例</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> SPATIAL <span style="color:#66d9ef">INDEX</span> idx_name <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">table_name</span> (<span style="color:#66d9ef">column_name</span>);</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="5-主键索引">5. <strong>主键索引</strong><a class="anchor" href="#5-%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95">#</a></h3>
<ul>
<li><strong>特点</strong>：每个表只能有一个主键索引，保证表中每行数据唯一标识。</li>
<li><strong>适用场景</strong>：确保表中每行数据唯一<a href="@ref">1</a><a href="@ref">5</a>。</li>
<li><strong>示例</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">table_name</span> <span style="color:#66d9ef">ADD</span> <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (<span style="color:#66d9ef">column_name</span>);</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="6-唯一索引">6. <strong>唯一索引</strong><a class="anchor" href="#6-%e5%94%af%e4%b8%80%e7%b4%a2%e5%bc%95">#</a></h3>
<ul>
<li><strong>特点</strong>：保证索引列的值唯一，但可以包含 NULL 值。</li>
<li><strong>适用场景</strong>：唯一标识某些字段（如邮箱、用户名）<a href="@ref">1</a><a href="@ref">5</a>。</li>
<li><strong>示例</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">UNIQUE</span> <span style="color:#66d9ef">INDEX</span> idx_name <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">table_name</span> (<span style="color:#66d9ef">column_name</span>);</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="7-普通索引">7. <strong>普通索引</strong><a class="anchor" href="#7-%e6%99%ae%e9%80%9a%e7%b4%a2%e5%bc%95">#</a></h3>
<ul>
<li><strong>特点</strong>：最基本的索引类型，没有任何限制，仅用于提高查询效率。</li>
<li><strong>适用场景</strong>：频繁查询但无唯一性要求的列<a href="@ref">1</a><a href="@ref">5</a>。</li>
<li><strong>示例</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_name <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">table_name</span> (<span style="color:#66d9ef">column_name</span>);</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="8-组合索引">8. <strong>组合索引</strong><a class="anchor" href="#8-%e7%bb%84%e5%90%88%e7%b4%a2%e5%bc%95">#</a></h3>
<ul>
<li><strong>特点</strong>：在多个列上创建的索引，遵循“最左前缀匹配原则”。</li>
<li><strong>适用场景</strong>：多条件联合查询<a href="@ref">1</a><a href="@ref">5</a>。</li>
<li><strong>示例</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_name <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">table_name</span> (column1, column2);</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="9-前缀索引">9. <strong>前缀索引</strong><a class="anchor" href="#9-%e5%89%8d%e7%bc%80%e7%b4%a2%e5%bc%95">#</a></h3>
<ul>
<li><strong>特点</strong>：对字符串列的前 N 个字符建立索引，减少索引存储空间，但可能增加重复值。</li>
<li><strong>适用场景</strong>：长字符串列（如 URL、邮箱地址）<a href="@ref">1</a><a href="@ref">5</a>。</li>
<li><strong>示例</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_name <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">table_name</span> (<span style="color:#66d9ef">column_name</span>(<span style="color:#ae81ff">10</span>));</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="10-覆盖索引">10. <strong>覆盖索引</strong><a class="anchor" href="#10-%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95">#</a></h3>
<ul>
<li><strong>特点</strong>：查询的所有列都在索引中，避免回表操作，提高查询性能。</li>
<li><strong>适用场景</strong>：查询涉及索引列<a href="@ref">5</a>。</li>
<li><strong>示例</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_name <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">table_name</span> (column1, column2);</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="总结-1"><strong>总结</strong><a class="anchor" href="#%e6%80%bb%e7%bb%93-1">#</a></h3>
<p>MySQL 提供了多种索引类型，每种索引都有其特定的适用场景和优缺点。根据业务需求和数据特点选择合适的索引类型，可以显著提高查询性能和数据库效率。</p>
<table>
  <thead>
      <tr>
          <th><strong>索引类型</strong></th>
          <th><strong>特点</strong></th>
          <th><strong>适用场景</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>B+树索引</td>
          <td>支持等值查询、范围查询和排序</td>
          <td>主键索引、唯一索引、普通索引</td>
      </tr>
      <tr>
          <td>哈希索引</td>
          <td>仅支持精确匹配，查询效率高</td>
          <td>精确匹配查询</td>
      </tr>
      <tr>
          <td>全文索引</td>
          <td>支持全文搜索和模糊查询</td>
          <td>文本内容搜索（如博客、文章）</td>
      </tr>
      <tr>
          <td>空间索引</td>
          <td>专为地理数据设计，支持二维空间查询</td>
          <td>地理位置查询和空间数据分析</td>
      </tr>
      <tr>
          <td>主键索引</td>
          <td>保证表中每行数据唯一</td>
          <td>唯一标识每行数据</td>
      </tr>
      <tr>
          <td>唯一索引</td>
          <td>保证列值唯一，支持快速查询</td>
          <td>唯一性要求的列（如邮箱、用户名）</td>
      </tr>
      <tr>
          <td>普通索引</td>
          <td>无约束条件，仅提高查询效率</td>
          <td>频繁查询但无唯一性要求的列</td>
      </tr>
      <tr>
          <td>组合索引</td>
          <td>多列组合索引，遵循最左前缀原则</td>
          <td>多条件联合查询</td>
      </tr>
      <tr>
          <td>前缀索引</td>
          <td>对字符串列的前 N 个字符建立索引，减少存储空间</td>
          <td>长字符串列（如 URL、邮箱地址）</td>
      </tr>
      <tr>
          <td>覆盖索引</td>
          <td>查询的所有列都在索引中，避免回表操作</td>
          <td>查询涉及索引列</td>
      </tr>
  </tbody>
</table>
<p>希望这些信息能帮助你更好地理解和使用 MySQL 的索引类型！</p>
<h2 id="repeatable-read级别中的幻读问题如何通过间隙锁解决-1">Repeatable Read级别中的幻读问题如何通过间隙锁解决？<a class="anchor" href="#repeatable-read%e7%ba%a7%e5%88%ab%e4%b8%ad%e7%9a%84%e5%b9%bb%e8%af%bb%e9%97%ae%e9%a2%98%e5%a6%82%e4%bd%95%e9%80%9a%e8%bf%87%e9%97%b4%e9%9a%99%e9%94%81%e8%a7%a3%e5%86%b3-1">#</a></h2>
<p>在 MySQL 的 <strong>Repeatable Read</strong> 隔离级别中，幻读问题通过 <strong>间隙锁（Gap Lock）</strong> 和 <strong>Next-Key Lock</strong> 来解决。以下是详细的机制和实现方式：</p>
<hr>
<h3 id="1-幻读的定义-1">1. <strong>幻读的定义</strong><a class="anchor" href="#1-%e5%b9%bb%e8%af%bb%e7%9a%84%e5%ae%9a%e4%b9%89-1">#</a></h3>
<p>幻读是指在同一事务中，多次执行相同的范围查询时，返回的结果集不一致。例如：</p>
<ul>
<li>事务 A 第一次查询 <code>SELECT * FROM t WHERE id &gt; 10</code>，返回 5 条记录。</li>
<li>事务 B 插入了一条 <code>id = 15</code> 的记录并提交。</li>
<li>事务 A 再次查询时，返回了 6 条记录，这就是幻读。</li>
</ul>
<hr>
<h3 id="2-间隙锁gap-lock-1">2. <strong>间隙锁（Gap Lock）</strong><a class="anchor" href="#2-%e9%97%b4%e9%9a%99%e9%94%81gap-lock-1">#</a></h3>
<ul>
<li><strong>定义</strong>：间隙锁是锁住索引记录之间的间隙（即范围），而不是锁住具体的记录。</li>
<li><strong>作用</strong>：防止其他事务在范围内插入新数据，从而避免幻读。</li>
</ul>
<p>例如，表 <code>t</code> 中有以下记录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>id: 10, 20, 30</span></span></code></pre></div><p>如果事务 A 执行 <code>SELECT * FROM t WHERE id &gt; 10 AND id &lt; 30</code>，间隙锁会锁住 <code>(10, 20)</code> 和 <code>(20, 30)</code> 两个区间，阻止其他事务插入 <code>id = 15</code> 或 <code>id = 25</code> 的记录。</p>
<hr>
<h3 id="3-next-key-lock-1">3. <strong>Next-Key Lock</strong><a class="anchor" href="#3-next-key-lock-1">#</a></h3>
<ul>
<li><strong>定义</strong>：Next-Key Lock 是 <strong>记录锁（Record Lock）</strong> 和 <strong>间隙锁（Gap Lock）</strong> 的结合，锁住记录及其前后的间隙。</li>
<li><strong>作用</strong>：在范围查询中，Next-Key Lock 不仅锁住符合条件的记录，还锁住记录之间的间隙，从而彻底防止幻读。</li>
</ul>
<p>例如，表 <code>t</code> 中有以下记录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>id: 10, 20, 30</span></span></code></pre></div><p>如果事务 A 执行 <code>SELECT * FROM t WHERE id &gt; 10 AND id &lt; 30</code>，Next-Key Lock 会锁住：</p>
<ul>
<li><code>(10, 20]</code>：锁住记录 <code>20</code> 和间隙 <code>(10, 20)</code>。</li>
<li><code>(20, 30]</code>：锁住记录 <code>30</code> 和间隙 <code>(20, 30)</code>。</li>
</ul>
<p>这样，其他事务无法在 <code>(10, 30)</code> 范围内插入新记录，避免了幻读。</p>
<hr>
<h3 id="4-间隙锁的适用场景-1">4. <strong>间隙锁的适用场景</strong><a class="anchor" href="#4-%e9%97%b4%e9%9a%99%e9%94%81%e7%9a%84%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af-1">#</a></h3>
<ul>
<li><strong>范围查询</strong>：如 <code>WHERE id &gt; 10 AND id &lt; 30</code>。</li>
<li><strong>唯一索引</strong>：在唯一索引的等值查询中，如果记录不存在，间隙锁会锁住该值的区间，防止插入。</li>
<li><strong>非唯一索引</strong>：在非唯一索引的等值查询中，间隙锁会锁住所有可能的区间。</li>
</ul>
<hr>
<h3 id="5-间隙锁的注意事项-1">5. <strong>间隙锁的注意事项</strong><a class="anchor" href="#5-%e9%97%b4%e9%9a%99%e9%94%81%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9-1">#</a></h3>
<ul>
<li><strong>性能开销</strong>：间隙锁会锁定一个范围，可能导致并发性能下降，尤其是在高并发写入场景中。</li>
<li><strong>死锁风险</strong>：间隙锁可能增加死锁的概率，因为多个事务可能互相等待对方释放间隙锁。</li>
</ul>
<hr>
<h3 id="6-示例-1">6. <strong>示例</strong><a class="anchor" href="#6-%e7%a4%ba%e4%be%8b-1">#</a></h3>
<p>假设表 <code>t</code> 中有以下记录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>id: 10, 20, 30</span></span></code></pre></div><p>事务 A 执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">BEGIN</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> t
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">AND</span> id <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">30</span> <span style="color:#66d9ef">FOR</span> <span style="color:#66d9ef">UPDATE</span>;</span></span></code></pre></div><p>此时，事务 A 会锁住 <code>(10, 20]</code> 和 <code>(20, 30]</code>。</p>
<p>事务 B 尝试插入 <code>id = 15</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t (id)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">15</span>);</span></span></code></pre></div><p>由于间隙锁的存在，事务 B 会被阻塞，直到事务 A 提交或回滚。</p>
<hr>
<h3 id="总结-2">总结<a class="anchor" href="#%e6%80%bb%e7%bb%93-2">#</a></h3>
<p>在 <strong>Repeatable Read</strong> 隔离级别中，MySQL 通过 <strong>间隙锁</strong> 和 <strong>Next-Key Lock</strong> 解决了幻读问题：</p>
<ul>
<li>间隙锁锁住索引记录之间的间隙，防止新数据插入。</li>
<li>Next-Key Lock 结合记录锁和间隙锁，彻底避免幻读。</li>
</ul>
<p>这种机制在保证数据一致性的同时，可能会对并发性能产生一定影响，因此在设计高并发系统时需要权衡。</p>
<h1 id="分区">分区<a class="anchor" href="#%e5%88%86%e5%8c%ba">#</a></h1>
<h2 id="mysql-可以做分区吗">mysql 可以做分区吗<a class="anchor" href="#mysql-%e5%8f%af%e4%bb%a5%e5%81%9a%e5%88%86%e5%8c%ba%e5%90%97">#</a></h2>
<p>是的，MySQL 支持分区功能。通过分区，可以将一张大表的数据在物理上分割成多个较小的部分（称为分区），每个分区可以独立存储和管理。分区功能在处理大数据量时非常有用，能够显著提高查询性能和数据管理的灵活性<a href="@ref">1</a>。</p>
<p>以下是 MySQL 分区功能的一些关键点：</p>
<hr>
<h3 id="1-mysql-分区的版本支持">1. <strong>MySQL 分区的版本支持</strong><a class="anchor" href="#1-mysql-%e5%88%86%e5%8c%ba%e7%9a%84%e7%89%88%e6%9c%ac%e6%94%af%e6%8c%81">#</a></h3>
<ul>
<li>MySQL 从 <strong>5.1.5</strong> 版本开始支持分区功能，但仅限于使用 InnoDB 和 MyISAM 存储引擎的表<a href="@ref">1</a>。</li>
<li>在 MySQL 5.1 版本中，分区功能是 pre-alpha 版本，不建议在生产环境中使用<a href="@ref">2</a>。</li>
<li>从 MySQL 5.5 版本开始，分区功能逐渐成熟，并支持更多的数据类型和分区方式<a href="@ref">2</a>。</li>
</ul>
<hr>
<h3 id="2-分区的实现方式">2. <strong>分区的实现方式</strong><a class="anchor" href="#2-%e5%88%86%e5%8c%ba%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f">#</a></h3>
<p>MySQL 提供了多种分区方式，常见的有：</p>
<ul>
<li><strong>RANGE 分区</strong>：根据某个字段的连续范围（如日期、数值）进行分区<a href="@ref">3</a>。</li>
<li><strong>LIST 分区</strong>：根据某个字段的离散值（如状态、地区）进行分区<a href="@ref">3</a>。</li>
<li><strong>HASH 分区</strong>：根据哈希函数将数据均匀分布到多个分区中<a href="@ref">3</a>。</li>
<li><strong>KEY 分区</strong>：类似于 HASH 分区，但分区键可以是非整数类型<a href="@ref">3</a>。</li>
</ul>
<hr>
<h3 id="3-分区的适用场景">3. <strong>分区的适用场景</strong><a class="anchor" href="#3-%e5%88%86%e5%8c%ba%e7%9a%84%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af">#</a></h3>
<ul>
<li><strong>大数据量表</strong>：当单表数据量过大（如数百万或数十亿条记录）时，分区可以减少查询扫描的数据量<a href="@ref">4</a>。</li>
<li><strong>时间范围查询</strong>：例如按日期分区的日志表，查询特定时间段的数据时只需扫描相关分区<a href="@ref">5</a>。</li>
<li><strong>数据管理</strong>：分区可以简化数据的备份、恢复和删除操作，例如删除某个时间段的数据只需删除对应的分区<a href="@ref">4</a>。</li>
</ul>
<hr>
<h3 id="4-分区的优点">4. <strong>分区的优点</strong><a class="anchor" href="#4-%e5%88%86%e5%8c%ba%e7%9a%84%e4%bc%98%e7%82%b9">#</a></h3>
<ul>
<li><strong>提高查询性能</strong>：查询时只需扫描相关分区，而不是整个表<a href="@ref">1</a>。</li>
<li><strong>简化数据管理</strong>：可以对每个分区独立进行维护操作（如备份、删除）<a href="@ref">4</a>。</li>
<li><strong>优化存储</strong>：可以将不同分区的数据存储在不同的磁盘上，提高存储效率和安全性<a href="@ref">1</a>。</li>
</ul>
<hr>
<h3 id="5-分区的限制">5. <strong>分区的限制</strong><a class="anchor" href="#5-%e5%88%86%e5%8c%ba%e7%9a%84%e9%99%90%e5%88%b6">#</a></h3>
<ul>
<li><strong>分区键选择</strong>：分区键必须是表的主键或唯一索引的一部分<a href="@ref">2</a>。</li>
<li><strong>存储引擎限制</strong>：并非所有存储引擎都支持分区，例如 CSV 和 FEDERATED 存储引擎不支持分区<a href="@ref">1</a>。</li>
<li><strong>复杂性增加</strong>：分区策略的设计和管理需要一定的经验，不合理的分区可能导致性能问题<a href="@ref">1</a>。</li>
</ul>
<hr>
<h3 id="6-分区示例">6. <strong>分区示例</strong><a class="anchor" href="#6-%e5%88%86%e5%8c%ba%e7%a4%ba%e4%be%8b">#</a></h3>
<p>以下是一个按日期范围分区的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> sales (
</span></span><span style="display:flex;"><span>    id INT,
</span></span><span style="display:flex;"><span>    amount DECIMAL(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>),
</span></span><span style="display:flex;"><span>    sale_date DATE
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>PARTITION <span style="color:#66d9ef">BY</span> RANGE (<span style="color:#66d9ef">YEAR</span>(sale_date)) (
</span></span><span style="display:flex;"><span>    PARTITION p0 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">2020</span>),
</span></span><span style="display:flex;"><span>    PARTITION p1 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">2021</span>),
</span></span><span style="display:flex;"><span>    PARTITION p2 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">2022</span>)
</span></span><span style="display:flex;"><span>);</span></span></code></pre></div><p>在这个例子中，<code>sales</code> 表按 <code>sale_date</code> 字段的年份进行分区，查询特定年份的数据时只需扫描对应的分区<a href="@ref">3</a>。</p>
<hr>
<h3 id="总结-3">总结<a class="anchor" href="#%e6%80%bb%e7%bb%93-3">#</a></h3>
<p>MySQL 的分区功能在处理大数据量时非常有用，能够显著提高查询性能和数据管理的灵活性。但需要注意的是，分区功能需要合理设计，并且对存储引擎和分区键有一定的限制<a href="@ref">1</a><a href="@ref">2</a><a href="@ref">3</a>。</p>
<h2 id="提供一个按日期月份进行分区的例子">提供一个按日期月份进行分区的例子<a class="anchor" href="#%e6%8f%90%e4%be%9b%e4%b8%80%e4%b8%aa%e6%8c%89%e6%97%a5%e6%9c%9f%e6%9c%88%e4%bb%bd%e8%bf%9b%e8%a1%8c%e5%88%86%e5%8c%ba%e7%9a%84%e4%be%8b%e5%ad%90">#</a></h2>
<p>以下是一个按日期月份进行分区的 MySQL 示例：</p>
<h3 id="1-创建表并按月份分区">1. <strong>创建表并按月份分区</strong><a class="anchor" href="#1-%e5%88%9b%e5%bb%ba%e8%a1%a8%e5%b9%b6%e6%8c%89%e6%9c%88%e4%bb%bd%e5%88%86%e5%8c%ba">#</a></h3>
<p>创建一个表 <code>orders</code>，并按照 <code>order_date</code> 字段的年份和月份进行分区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> orders
</span></span><span style="display:flex;"><span>(
</span></span><span style="display:flex;"><span>    id            INT AUTO_INCREMENT <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>    order_date    DATE <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>    customer_name VARCHAR(<span style="color:#ae81ff">100</span>),
</span></span><span style="display:flex;"><span>    total_amount  DECIMAL(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>) PARTITION <span style="color:#66d9ef">BY</span> RANGE (<span style="color:#66d9ef">YEAR</span>(order_date) <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">MONTH</span>(order_date)) (
</span></span><span style="display:flex;"><span>    PARTITION p202001 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202002</span>), <span style="color:#75715e">-- 2020年1月
</span></span></span><span style="display:flex;"><span>    PARTITION p202002 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202003</span>), <span style="color:#75715e">-- 2020年2月
</span></span></span><span style="display:flex;"><span>    PARTITION p202003 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202004</span>), <span style="color:#75715e">-- 2020年3月
</span></span></span><span style="display:flex;"><span>    PARTITION p202004 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202005</span>), <span style="color:#75715e">-- 2020年4月
</span></span></span><span style="display:flex;"><span>    PARTITION p202005 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202006</span>), <span style="color:#75715e">-- 2020年5月
</span></span></span><span style="display:flex;"><span>    PARTITION p202006 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202007</span>), <span style="color:#75715e">-- 2020年6月
</span></span></span><span style="display:flex;"><span>    PARTITION p202007 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202008</span>), <span style="color:#75715e">-- 2020年7月
</span></span></span><span style="display:flex;"><span>    PARTITION p202008 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202009</span>), <span style="color:#75715e">-- 2020年8月
</span></span></span><span style="display:flex;"><span>    PARTITION p202009 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202010</span>), <span style="color:#75715e">-- 2020年9月
</span></span></span><span style="display:flex;"><span>    PARTITION p202010 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202011</span>), <span style="color:#75715e">-- 2020年10月
</span></span></span><span style="display:flex;"><span>    PARTITION p202011 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202012</span>), <span style="color:#75715e">-- 2020年11月
</span></span></span><span style="display:flex;"><span>    PARTITION p202012 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202101</span>), <span style="color:#75715e">-- 2020年12月
</span></span></span><span style="display:flex;"><span>    PARTITION p202101 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202102</span>), <span style="color:#75715e">-- 2021年1月
</span></span></span><span style="display:flex;"><span>    PARTITION p_max <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#66d9ef">MAXVALUE</span>)  <span style="color:#75715e">-- 其他月份
</span></span></span><span style="display:flex;"><span>);</span></span></code></pre></div><p>在这个例子中：</p>
<ul>
<li>使用 <code>PARTITION BY RANGE</code> 按照 <code>order_date</code> 字段的年份和月份进行分区。</li>
<li>每个分区对应一个月份，例如 <code>p202001</code> 包含 2020 年 1 月的数据，<code>p202002</code> 包含 2020 年 2 月的数据，依此类推。</li>
<li><code>MAXVALUE</code> 分区用于存储超出定义范围的数据<a href="@ref">1</a><a href="@ref">3</a>。</li>
</ul>
<hr>
<h3 id="2-插入数据">2. <strong>插入数据</strong><a class="anchor" href="#2-%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae">#</a></h3>
<p>插入一些示例数据：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> orders (order_date, customer_name, total_amount) <span style="color:#66d9ef">VALUES</span>
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;2020-01-15&#39;</span>, <span style="color:#e6db74">&#39;Alice&#39;</span>, <span style="color:#ae81ff">100</span>.<span style="color:#ae81ff">00</span>),
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;2020-02-20&#39;</span>, <span style="color:#e6db74">&#39;Bob&#39;</span>, <span style="color:#ae81ff">200</span>.<span style="color:#ae81ff">00</span>),
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;2020-03-25&#39;</span>, <span style="color:#e6db74">&#39;Charlie&#39;</span>, <span style="color:#ae81ff">300</span>.<span style="color:#ae81ff">00</span>);</span></span></code></pre></div><hr>
<h3 id="3-查询分区数据">3. <strong>查询分区数据</strong><a class="anchor" href="#3-%e6%9f%a5%e8%af%a2%e5%88%86%e5%8c%ba%e6%95%b0%e6%8d%ae">#</a></h3>
<p>查询特定月份的数据时，MySQL 只会扫描对应的分区，从而提高查询性能：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- 查询 2020 年 1 月的数据
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> orders PARTITION (p202001);</span></span></code></pre></div><hr>
<h3 id="4-动态添加分区">4. <strong>动态添加分区</strong><a class="anchor" href="#4-%e5%8a%a8%e6%80%81%e6%b7%bb%e5%8a%a0%e5%88%86%e5%8c%ba">#</a></h3>
<p>如果需要动态添加新分区，可以使用以下 SQL 语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> orders REORGANIZE PARTITION p_max <span style="color:#66d9ef">INTO</span> (
</span></span><span style="display:flex;"><span>    PARTITION p202201 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">202202</span>), <span style="color:#75715e">-- 2022 年 1 月
</span></span></span><span style="display:flex;"><span>    PARTITION p_max <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#66d9ef">MAXVALUE</span>) <span style="color:#75715e">-- 其他月份
</span></span></span><span style="display:flex;"><span>    );</span></span></code></pre></div><hr>
<h3 id="5-删除旧分区">5. <strong>删除旧分区</strong><a class="anchor" href="#5-%e5%88%a0%e9%99%a4%e6%97%a7%e5%88%86%e5%8c%ba">#</a></h3>
<p>如果某些分区的数据不再需要，可以删除旧分区以释放空间：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> orders <span style="color:#66d9ef">DROP</span> PARTITION p202001;</span></span></code></pre></div><hr>
<h3 id="6-总结">6. <strong>总结</strong><a class="anchor" href="#6-%e6%80%bb%e7%bb%93">#</a></h3>
<p>通过按月份分区，可以显著提高大数据量表的查询性能，并简化数据管理（如删除旧数据、添加新分区等）<a href="@ref">1</a><a href="@ref">3</a>。</p>
<h2 id="在mysql中分区可以在之后动态新增吗">在mysql中分区可以在之后动态新增吗<a class="anchor" href="#%e5%9c%a8mysql%e4%b8%ad%e5%88%86%e5%8c%ba%e5%8f%af%e4%bb%a5%e5%9c%a8%e4%b9%8b%e5%90%8e%e5%8a%a8%e6%80%81%e6%96%b0%e5%a2%9e%e5%90%97">#</a></h2>
<p>是的，MySQL 支持在创建表后动态新增分区。以下是实现动态新增分区的几种常见方法：</p>
<hr>
<h3 id="1-手动添加分区">1. <strong>手动添加分区</strong><a class="anchor" href="#1-%e6%89%8b%e5%8a%a8%e6%b7%bb%e5%8a%a0%e5%88%86%e5%8c%ba">#</a></h3>
<p>使用 <code>ALTER TABLE</code> 语句可以手动为已存在的分区表添加新的分区。例如，按年份分区的表可以动态添加新年的分区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> mytable
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ADD</span> PARTITION (
</span></span><span style="display:flex;"><span>    PARTITION p2025 <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">LESS</span> <span style="color:#66d9ef">THAN</span> (<span style="color:#ae81ff">2026</span>)
</span></span><span style="display:flex;"><span>);</span></span></code></pre></div><p>这种方法适用于已知未来分区需求的情况，但不能自动处理新增数据的分区。</p>
<hr>
<h3 id="2-使用存储过程自动添加分区">2. <strong>使用存储过程自动添加分区</strong><a class="anchor" href="#2-%e4%bd%bf%e7%94%a8%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e8%87%aa%e5%8a%a8%e6%b7%bb%e5%8a%a0%e5%88%86%e5%8c%ba">#</a></h3>
<p>通过编写存储过程，可以动态检测当前数据的时间范围，并自动添加新的分区。以下是一个按年份自动添加分区的存储过程示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">DELIMITER</span> <span style="color:#f92672">//</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">PROCEDURE</span> create_new_partition()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">BEGIN</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">DECLARE</span> current_year INT;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">YEAR</span>(CURDATE()) <span style="color:#66d9ef">INTO</span> current_year;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SET</span> <span style="color:#f92672">@</span>partition_name <span style="color:#f92672">=</span> CONCAT(<span style="color:#e6db74">&#39;p&#39;</span>, current_year);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SET</span> <span style="color:#f92672">@</span><span style="color:#66d9ef">sql</span> <span style="color:#f92672">=</span> CONCAT(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;ALTER TABLE mytable ADD PARTITION (PARTITION &#39;</span>, <span style="color:#f92672">@</span>partition_name, <span style="color:#e6db74">&#39; VALUES LESS THAN (&#39;</span>, current_year <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;))&#39;</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">PREPARE</span> stmt <span style="color:#66d9ef">FROM</span> <span style="color:#f92672">@</span><span style="color:#66d9ef">sql</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">EXECUTE</span> stmt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">DEALLOCATE</span> <span style="color:#66d9ef">PREPARE</span> stmt;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">END</span> <span style="color:#f92672">//</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DELIMITER</span> ;</span></span></code></pre></div><p>调用该存储过程即可为当前年份添加分区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CALL</span> create_new_partition();</span></span></code></pre></div><hr>
<h3 id="3-使用定时任务自动添加分区">3. <strong>使用定时任务自动添加分区</strong><a class="anchor" href="#3-%e4%bd%bf%e7%94%a8%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%e8%87%aa%e5%8a%a8%e6%b7%bb%e5%8a%a0%e5%88%86%e5%8c%ba">#</a></h3>
<p>通过 MySQL 的事件调度器，可以定期执行存储过程，实现自动新增分区。例如，每年年初自动添加新年的分区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> EVENT create_partition_event
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ON</span> SCHEDULE
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">EVERY</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">YEAR</span>
</span></span><span style="display:flex;"><span>    STARTS <span style="color:#e6db74">&#39;2025-01-01 00:00:00&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DO</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">CALL</span> create_new_partition();</span></span></code></pre></div><p>这种方法适用于需要长期自动维护分区的场景<a href="@ref">1</a>。</p>
<hr>
<h3 id="4-注意事项">4. <strong>注意事项</strong><a class="anchor" href="#4-%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">#</a></h3>
<ul>
<li><strong>分区键限制</strong>：分区键必须是主键或唯一键的一部分。如果分区键未包含在主键或唯一键中，需要先修改表结构<a href="@ref">3</a>。</li>
<li><strong>分区数量</strong>：过多的分区可能导致性能下降，建议根据实际需求合理设计分区策略<a href="@ref">1</a>。</li>
<li><strong>数据一致性</strong>：在动态添加分区时，确保新增分区不会影响现有数据的查询和维护。</li>
</ul>
<hr>
<h3 id="总结-4">总结<a class="anchor" href="#%e6%80%bb%e7%bb%93-4">#</a></h3>
<p>MySQL 支持动态新增分区，可以通过手动添加、存储过程或定时任务实现。具体选择哪种方式，取决于业务需求和数据增长模式。如果需要自动化管理，推荐使用存储过程结合定时任务的方式<a href="@ref">1</a><a href="@ref">2</a>。</p>
<h2 id="过多的分区可能导致性能下降这个问题该如何处理">过多的分区可能导致性能下降，这个问题该如何处理<a class="anchor" href="#%e8%bf%87%e5%a4%9a%e7%9a%84%e5%88%86%e5%8c%ba%e5%8f%af%e8%83%bd%e5%af%bc%e8%87%b4%e6%80%a7%e8%83%bd%e4%b8%8b%e9%99%8d%e8%bf%99%e4%b8%aa%e9%97%ae%e9%a2%98%e8%af%a5%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86">#</a></h2>
<p>过多的分区确实可能导致性能下降，主要原因是分区数量过多会增加元数据管理的复杂性、查询优化器的负担以及维护成本。以下是一些处理过多分区问题的解决方案：</p>
<hr>
<h3 id="1-合理设计分区策略">1. <strong>合理设计分区策略</strong><a class="anchor" href="#1-%e5%90%88%e7%90%86%e8%ae%be%e8%ae%a1%e5%88%86%e5%8c%ba%e7%ad%96%e7%95%a5">#</a></h3>
<ul>
<li><strong>选择合适的分区键</strong>：分区键应具有较高的基数和均匀的数据分布，避免数据倾斜。例如，按时间分区时，确保每个时间段的数据量相对均衡<a href="@ref">1</a>。</li>
<li><strong>控制分区数量</strong>：根据业务需求和数据量，合理设置分区数量。避免分区过细，导致每个分区数据量过小<a href="@ref">3</a>。</li>
</ul>
<hr>
<h3 id="2-合并小分区">2. <strong>合并小分区</strong><a class="anchor" href="#2-%e5%90%88%e5%b9%b6%e5%b0%8f%e5%88%86%e5%8c%ba">#</a></h3>
<ul>
<li>如果某些分区数据量过小，可以通过合并分区来减少分区数量。例如，将多个小时间范围的分区合并为一个较大的分区<a href="@ref">1</a>。</li>
<li>使用 <code>ALTER TABLE ... REORGANIZE PARTITION</code> 语句动态合并分区。</li>
</ul>
<hr>
<h3 id="3-使用子分区">3. <strong>使用子分区</strong><a class="anchor" href="#3-%e4%bd%bf%e7%94%a8%e5%ad%90%e5%88%86%e5%8c%ba">#</a></h3>
<ul>
<li>对于需要更细粒度分区的场景，可以使用子分区（复合分区）。例如，先按年份分区，再按月进行子分区。这样可以减少主分区的数量，同时保持细粒度的数据管理<a href="@ref">1</a>。</li>
</ul>
<hr>
<h3 id="4-定期清理和归档数据">4. <strong>定期清理和归档数据</strong><a class="anchor" href="#4-%e5%ae%9a%e6%9c%9f%e6%b8%85%e7%90%86%e5%92%8c%e5%bd%92%e6%a1%a3%e6%95%b0%e6%8d%ae">#</a></h3>
<ul>
<li>对于历史数据，可以定期清理或归档到其他存储中，减少当前表的分区数量<a href="@ref">7</a>。</li>
<li>使用 <code>ALTER TABLE ... DROP PARTITION</code> 删除不再需要的分区。</li>
</ul>
<hr>
<h3 id="5-优化查询和索引">5. <strong>优化查询和索引</strong><a class="anchor" href="#5-%e4%bc%98%e5%8c%96%e6%9f%a5%e8%af%a2%e5%92%8c%e7%b4%a2%e5%bc%95">#</a></h3>
<ul>
<li><strong>利用分区裁剪</strong>：确保查询条件能够充分利用分区键，减少需要扫描的分区数量<a href="@ref">1</a>。</li>
<li><strong>创建合适的索引</strong>：在分区表上创建本地索引（Local Index），避免全局索引带来的性能开销<a href="@ref">1</a>。</li>
</ul>
<hr>
<h3 id="6-监控和调整">6. <strong>监控和调整</strong><a class="anchor" href="#6-%e7%9b%91%e6%8e%a7%e5%92%8c%e8%b0%83%e6%95%b4">#</a></h3>
<ul>
<li><strong>监控分区性能</strong>：通过监控工具（如 <code>information_schema.PARTITIONS</code>）分析分区表的使用情况，及时调整分区策略<a href="@ref">3</a>。</li>
<li><strong>动态调整分区</strong>：根据数据增长和查询模式的变化，动态调整分区数量和规则<a href="@ref">1</a>。</li>
</ul>
<hr>
<h3 id="7-避免过度分区">7. <strong>避免过度分区</strong><a class="anchor" href="#7-%e9%81%bf%e5%85%8d%e8%bf%87%e5%ba%a6%e5%88%86%e5%8c%ba">#</a></h3>
<ul>
<li><strong>评估分区必要性</strong>：对于数据量较小的表，分区可能不会带来显著的性能提升，反而增加管理复杂度。在这种情况下，可以考虑不使用分区<a href="@ref">3</a>。</li>
</ul>
<hr>
<p>通过上述方法，可以有效减少过多分区带来的性能问题，同时充分利用分区表的优势<a href="@ref">1</a><a href="@ref">3</a><a href="@ref">7</a>。</p>
<h2 id="如何评估一个表是否需要进行分区">如何评估一个表是否需要进行分区<a class="anchor" href="#%e5%a6%82%e4%bd%95%e8%af%84%e4%bc%b0%e4%b8%80%e4%b8%aa%e8%a1%a8%e6%98%af%e5%90%a6%e9%9c%80%e8%a6%81%e8%bf%9b%e8%a1%8c%e5%88%86%e5%8c%ba">#</a></h2>
<p>评估一个表是否需要进行分区时，可以从以下几个方面综合考虑：</p>
<hr>
<h3 id="1-数据量大小">1. <strong>数据量大小</strong><a class="anchor" href="#1-%e6%95%b0%e6%8d%ae%e9%87%8f%e5%a4%a7%e5%b0%8f">#</a></h3>
<ul>
<li><strong>大数据量表</strong>：如果表的数据量非常大（例如数百万或数十亿条记录），分区可以显著提高查询性能，减少扫描的数据量<a href="@ref">1</a>。</li>
<li><strong>小数据量表</strong>：对于数据量较小的表，分区可能不会带来明显的性能提升，反而增加管理复杂度<a href="@ref">3</a>。</li>
</ul>
<hr>
<h3 id="2-查询模式">2. <strong>查询模式</strong><a class="anchor" href="#2-%e6%9f%a5%e8%af%a2%e6%a8%a1%e5%bc%8f">#</a></h3>
<ul>
<li><strong>范围查询</strong>：如果查询经常基于某个字段的范围（如时间范围、数值范围），分区可以通过分区裁剪（Partition Pruning）减少扫描的数据量，提高查询效率<a href="@ref">1</a>。</li>
<li><strong>全表扫描</strong>：如果查询需要扫描整个表，分区的优势可能不明显<a href="@ref">3</a>。</li>
</ul>
<hr>
<h3 id="3-数据管理需求">3. <strong>数据管理需求</strong><a class="anchor" href="#3-%e6%95%b0%e6%8d%ae%e7%ae%a1%e7%90%86%e9%9c%80%e6%b1%82">#</a></h3>
<ul>
<li><strong>数据归档和清理</strong>：如果需要定期删除或归档历史数据，分区可以简化操作（如删除整个分区），提高效率<a href="@ref">1</a><a href="@ref">3</a>。</li>
<li><strong>备份和恢复</strong>：分区表可以针对单个分区进行备份和恢复，减少维护时间和资源消耗<a href="@ref">1</a>。</li>
</ul>
<hr>
<h3 id="4-硬件资源">4. <strong>硬件资源</strong><a class="anchor" href="#4-%e7%a1%ac%e4%bb%b6%e8%b5%84%e6%ba%90">#</a></h3>
<ul>
<li><strong>存储性能</strong>：分区可以将不同分区的数据存储在不同的磁盘上，提高存储效率和安全性<a href="@ref">1</a>。</li>
<li><strong>分区数量</strong>：过多的分区可能导致元数据管理复杂化，增加性能开销，建议分区数量不宜过多（一般不超过1000个）<a href="@ref">1</a>。</li>
</ul>
<hr>
<h3 id="5-业务需求">5. <strong>业务需求</strong><a class="anchor" href="#5-%e4%b8%9a%e5%8a%a1%e9%9c%80%e6%b1%82">#</a></h3>
<ul>
<li><strong>时间范围数据</strong>：对于按时间排序的数据（如日志、交易记录），按时间分区可以显著提高查询性能<a href="@ref">1</a>。</li>
<li><strong>数据增长模式</strong>：如果数据量快速增长，分区可以更好地应对未来的数据管理需求<a href="@ref">3</a>。</li>
</ul>
<hr>
<h3 id="6-分区键选择">6. <strong>分区键选择</strong><a class="anchor" href="#6-%e5%88%86%e5%8c%ba%e9%94%ae%e9%80%89%e6%8b%a9">#</a></h3>
<ul>
<li><strong>分区键的基数</strong>：分区键应具有较高的基数和均匀的数据分布，避免数据倾斜<a href="@ref">1</a>。</li>
<li><strong>分区键的限制</strong>：分区键必须是表的主键或唯一索引的一部分<a href="@ref">1</a>。</li>
</ul>
<hr>
<h3 id="7-分区的优缺点权衡">7. <strong>分区的优缺点权衡</strong><a class="anchor" href="#7-%e5%88%86%e5%8c%ba%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9%e6%9d%83%e8%a1%a1">#</a></h3>
<ul>
<li><strong>优点</strong>：提高查询性能、简化数据管理、支持并行查询<a href="@ref">1</a><a href="@ref">3</a>。</li>
<li><strong>缺点</strong>：增加复杂性、可能导致索引效率下降、存储空间需求增加<a href="@ref">1</a><a href="@ref">3</a>。</li>
</ul>
<hr>
<h3 id="总结-5">总结<a class="anchor" href="#%e6%80%bb%e7%bb%93-5">#</a></h3>
<p>评估一个表是否需要进行分区时，需要综合考虑数据量、查询模式、数据管理需求、硬件资源和业务需求等因素。对于大数据量表且查询模式适合分区的场景，分区可以显著提高性能和管理效率；但对于小数据量表或查询模式不适合分区的场景，分区可能得不偿失<a href="@ref">1</a><a href="@ref">3</a>。</p>
<h2 id="分区表和非分区表在性能上有什么具体区别">分区表和非分区表在性能上有什么具体区别<a class="anchor" href="#%e5%88%86%e5%8c%ba%e8%a1%a8%e5%92%8c%e9%9d%9e%e5%88%86%e5%8c%ba%e8%a1%a8%e5%9c%a8%e6%80%a7%e8%83%bd%e4%b8%8a%e6%9c%89%e4%bb%80%e4%b9%88%e5%85%b7%e4%bd%93%e5%8c%ba%e5%88%ab">#</a></h2>
<p>分区表和非分区表在性能上的区别主要体现在以下几个方面：</p>
<hr>
<h3 id="1-查询性能">1. <strong>查询性能</strong><a class="anchor" href="#1-%e6%9f%a5%e8%af%a2%e6%80%a7%e8%83%bd">#</a></h3>
<ul>
<li><strong>分区表</strong>：
<ul>
<li><strong>优点</strong>：通过分区裁剪（Partition Pruning），查询时只需扫描相关分区，而不是整个表，从而显著减少 I/O 操作和查询时间。</li>
<li><strong>缺点</strong>：如果查询条件无法利用分区键，或者需要扫描多个分区，查询性能可能比非分区表更差。</li>
</ul>
</li>
<li><strong>非分区表</strong>：
<ul>
<li><strong>优点</strong>：对于小数据量或简单查询，性能通常较好，因为不需要额外的分区管理开销。</li>
<li><strong>缺点</strong>：对于大数据量表，查询时需要扫描整个表，性能可能较差。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-插入性能">2. <strong>插入性能</strong><a class="anchor" href="#2-%e6%8f%92%e5%85%a5%e6%80%a7%e8%83%bd">#</a></h3>
<ul>
<li><strong>分区表</strong>：
<ul>
<li><strong>优点</strong>：插入数据时，MySQL 可以根据分区键快速定位目标分区，减少插入操作的复杂度。</li>
<li><strong>缺点</strong>：如果分区数量过多，插入操作可能涉及更多的元数据管理，影响性能。</li>
</ul>
</li>
<li><strong>非分区表</strong>：
<ul>
<li><strong>优点</strong>：插入操作简单，通常性能较好。</li>
<li><strong>缺点</strong>：对于大数据量表，插入性能可能受到表锁或行锁的影响。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-删除性能">3. <strong>删除性能</strong><a class="anchor" href="#3-%e5%88%a0%e9%99%a4%e6%80%a7%e8%83%bd">#</a></h3>
<ul>
<li><strong>分区表</strong>：
<ul>
<li><strong>优点</strong>：删除整个分区时，只需删除分区文件，操作非常高效。例如，删除历史数据时，只需删除对应的分区，而不是逐条删除数据。</li>
<li><strong>缺点</strong>：删除单个记录时，性能与非分区表类似。</li>
</ul>
</li>
<li><strong>非分区表</strong>：
<ul>
<li><strong>优点</strong>：删除单个记录时性能较好。</li>
<li><strong>缺点</strong>：删除大量数据时，需要逐条删除，性能较差。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-维护性能">4. <strong>维护性能</strong><a class="anchor" href="#4-%e7%bb%b4%e6%8a%a4%e6%80%a7%e8%83%bd">#</a></h3>
<ul>
<li><strong>分区表</strong>：
<ul>
<li><strong>优点</strong>：备份、恢复和优化操作可以针对单个分区进行，减少维护时间和资源消耗。</li>
<li><strong>缺点</strong>：分区数量过多时，维护操作可能涉及更多的元数据管理，增加复杂性。</li>
</ul>
</li>
<li><strong>非分区表</strong>：
<ul>
<li><strong>优点</strong>：维护操作简单，通常性能较好。</li>
<li><strong>缺点</strong>：对于大数据量表，维护操作（如备份、优化）可能需要更多时间和资源。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-索引性能">5. <strong>索引性能</strong><a class="anchor" href="#5-%e7%b4%a2%e5%bc%95%e6%80%a7%e8%83%bd">#</a></h3>
<ul>
<li><strong>分区表</strong>：
<ul>
<li><strong>优点</strong>：可以在每个分区上创建本地索引，减少索引大小，提高索引查询性能。</li>
<li><strong>缺点</strong>：如果查询条件无法利用分区键，可能需要扫描多个分区的索引，性能可能较差。</li>
</ul>
</li>
<li><strong>非分区表</strong>：
<ul>
<li><strong>优点</strong>：索引查询性能通常较好，尤其是对于小数据量表。</li>
<li><strong>缺点</strong>：对于大数据量表，索引可能变得非常大，影响查询性能。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-存储性能">6. <strong>存储性能</strong><a class="anchor" href="#6-%e5%ad%98%e5%82%a8%e6%80%a7%e8%83%bd">#</a></h3>
<ul>
<li><strong>分区表</strong>：
<ul>
<li><strong>优点</strong>：可以将不同分区存储在不同的磁盘上，提高存储效率和安全性。</li>
<li><strong>缺点</strong>：分区数量过多可能导致存储碎片化，影响性能。</li>
</ul>
</li>
<li><strong>非分区表</strong>：
<ul>
<li><strong>优点</strong>：存储结构简单，通常性能较好。</li>
<li><strong>缺点</strong>：对于大数据量表，存储性能可能受到单文件大小的限制。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结-6">总结<a class="anchor" href="#%e6%80%bb%e7%bb%93-6">#</a></h3>
<p>分区表和非分区表在性能上的区别主要取决于数据量、查询模式和维护需求：</p>
<ul>
<li><strong>分区表</strong>适合大数据量表，尤其是需要按时间范围或其他规则管理数据的场景，可以显著提高查询、插入和删除性能。但需要注意合理设计分区策略，避免分区过多带来的性能问题。</li>
<li><strong>非分区表</strong>适合小数据量表或简单查询场景，性能通常较好，但处理大数据量时可能表现较差。</li>
</ul>
<p>选择分区表还是非分区表，应根据具体业务需求和数据特点进行权衡。</p>
<h2 id="分区表在不同数据库系统中有什么区别">分区表在不同数据库系统中有什么区别<a class="anchor" href="#%e5%88%86%e5%8c%ba%e8%a1%a8%e5%9c%a8%e4%b8%8d%e5%90%8c%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">#</a></h2>
<p>分区表在不同数据库系统（如 MySQL、Oracle、PostgreSQL）中的实现和特性存在一些差异，以下是主要区别的总结：</p>
<hr>
<h3 id="1-mysql-分区表">1. <strong>MySQL 分区表</strong><a class="anchor" href="#1-mysql-%e5%88%86%e5%8c%ba%e8%a1%a8">#</a></h3>
<ul>
<li><strong>支持版本</strong>：从 MySQL 5.1 开始支持分区功能，后续版本逐步增强<a href="@ref">2</a>。</li>
<li><strong>分区类型</strong>：支持范围分区（RANGE）、列表分区（LIST）、哈希分区（HASH）和键值分区（KEY）<a href="@ref">3</a>。</li>
<li><strong>分区策略</strong>：
<ul>
<li>通用分区策略（Generic Partitioning）：由 MySQL Server 层管理分区，存在性能问题，如首次访问时需打开所有分区<a href="@ref">2</a>。</li>
<li>本地分区策略（Native Partitioning）：从 MySQL 5.7 开始，由存储引擎（如 InnoDB）管理分区，性能更优<a href="@ref">2</a>。</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li>提高查询性能，支持分区裁剪（Partition Pruning）。</li>
<li>简化数据管理，如快速删除或清理分区<a href="@ref">3</a>。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>分区数量过多可能导致性能下降。</li>
<li>DDL 操作需要锁定所有分区，影响并发性<a href="@ref">2</a>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-oracle-分区表">2. <strong>Oracle 分区表</strong><a class="anchor" href="#2-oracle-%e5%88%86%e5%8c%ba%e8%a1%a8">#</a></h3>
<ul>
<li><strong>分区类型</strong>：支持范围分区（RANGE）、列表分区（LIST）、哈希分区（HASH）、复合分区（如 RANGE-HASH）、间隔分区（Interval Partitioning）、参考分区（Referential Partitioning）等<a href="@ref">4</a><a href="@ref">5</a>。</li>
<li><strong>优点</strong>：
<ul>
<li>提高查询性能，支持并行查询。</li>
<li>支持分区独立备份和恢复，增强可用性。</li>
<li>可以将分区映射到不同磁盘，分散 I/O 压力<a href="@ref">4</a>。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>已存在的表不能直接转化为分区表，需通过在线重定义功能实现<a href="@ref">4</a>。</li>
<li>分区数量受限，每个表的分区或子分区总数不能超过 1023 个<a href="@ref">4</a>。</li>
</ul>
</li>
<li><strong>适用场景</strong>：单表数据量过大（如超过 2GB 或 1000 万条记录），或需要按时间范围删除数据<a href="@ref">4</a>。</li>
</ul>
<hr>
<h3 id="3-postgresql-分区表">3. <strong>PostgreSQL 分区表</strong><a class="anchor" href="#3-postgresql-%e5%88%86%e5%8c%ba%e8%a1%a8">#</a></h3>
<ul>
<li><strong>支持版本</strong>：从 PostgreSQL 10 开始支持声明分区（Declarative Partitioning）<a href="@ref">6</a>。</li>
<li><strong>分区类型</strong>：支持范围分区（RANGE）、列表分区（LIST）、哈希分区（HASH）和混合分区<a href="@ref">6</a>。</li>
<li><strong>优点</strong>：
<ul>
<li>改善查询性能，支持分区裁剪。</li>
<li>分区表对业务透明，维护方便<a href="@ref">6</a>。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>分区表的创建和管理相对复杂。</li>
<li>分区数量过多可能影响性能<a href="@ref">6</a>。</li>
</ul>
</li>
<li><strong>特点</strong>：
<ul>
<li>分区表是逻辑上的单个表，物理上由多个子表组成。</li>
<li>支持在分区上单独创建索引和约束<a href="@ref">6</a>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-主要区别">4. <strong>主要区别</strong><a class="anchor" href="#4-%e4%b8%bb%e8%a6%81%e5%8c%ba%e5%88%ab">#</a></h3>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>MySQL</th>
          <th>Oracle</th>
          <th>PostgreSQL</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>分区类型</strong></td>
          <td>RANGE, LIST, HASH, KEY</td>
          <td>RANGE, LIST, HASH, 复合分区等</td>
          <td>RANGE, LIST, HASH, 混合分区</td>
      </tr>
      <tr>
          <td><strong>分区策略</strong></td>
          <td>通用分区策略（早期）、本地分区策略（5.7+）</td>
          <td>由存储引擎管理</td>
          <td>声明分区（10+）</td>
      </tr>
      <tr>
          <td><strong>分区数量限制</strong></td>
          <td>无明确限制，但过多分区影响性能</td>
          <td>每个表的分区或子分区总数≤1023</td>
          <td>无明确限制，但过多分区影响性能</td>
      </tr>
      <tr>
          <td><strong>分区表转换</strong></td>
          <td>不支持直接转换</td>
          <td>支持在线重定义表</td>
          <td>不支持直接转换</td>
      </tr>
      <tr>
          <td><strong>适用场景</strong></td>
          <td>大数据量表、时间范围查询</td>
          <td>大数据量表、并行查询</td>
          <td>大数据量表、时间范围查询</td>
      </tr>
      <tr>
          <td><strong>优点</strong></td>
          <td>提高查询性能、简化数据管理</td>
          <td>提高查询性能、支持分区独立备份</td>
          <td>改善查询性能、维护方便</td>
      </tr>
      <tr>
          <td><strong>缺点</strong></td>
          <td>分区过多影响性能、DDL 锁所有分区</td>
          <td>分区表转换复杂、分区数量受限</td>
          <td>分区管理复杂、分区过多影响性能</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="总结-7">总结<a class="anchor" href="#%e6%80%bb%e7%bb%93-7">#</a></h3>
<p>分区表在 MySQL、Oracle 和 PostgreSQL 中的实现各有特点：</p>
<ul>
<li><strong>MySQL</strong>：分区功能简单易用，但分区数量过多可能影响性能。</li>
<li><strong>Oracle</strong>：分区类型丰富，支持复杂的分区策略，但分区表转换和分区数量受限。</li>
<li><strong>PostgreSQL</strong>：分区功能灵活，但分区管理相对复杂。</li>
</ul>
<p>选择哪种数据库的分区表，需根据具体业务需求和数据特点进行权衡。</p>
<h2 id="如何选择合适的分区键">如何选择合适的分区键<a class="anchor" href="#%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e5%88%86%e5%8c%ba%e9%94%ae">#</a></h2>
<p>选择合适的分区键是优化数据库分区表性能的关键步骤。以下是选择分区键的一些建议和策略：</p>
<h3 id="1-频繁查询的列">1. <strong>频繁查询的列</strong><a class="anchor" href="#1-%e9%a2%91%e7%b9%81%e6%9f%a5%e8%af%a2%e7%9a%84%e5%88%97">#</a></h3>
<p>分区键应该是经常用于查询的列，如订单号、用户ID等。这样，当根据这些列进行查询时，数据库可以迅速定位到相应的分区，从而提高查询速度<a href="@ref">1</a>。</p>
<h3 id="2-数据分布性">2. <strong>数据分布性</strong><a class="anchor" href="#2-%e6%95%b0%e6%8d%ae%e5%88%86%e5%b8%83%e6%80%a7">#</a></h3>
<p>分区键应具有较好的数据分布性，以避免数据热点和倾斜。如果数据分布不均，某些分区可能会包含大量数据，而其他分区则数据稀少，这将导致性能下降<a href="@ref">1</a><a href="@ref">2</a>。</p>
<h3 id="3-单一列或多列组合">3. <strong>单一列或多列组合</strong><a class="anchor" href="#3-%e5%8d%95%e4%b8%80%e5%88%97%e6%88%96%e5%a4%9a%e5%88%97%e7%bb%84%e5%90%88">#</a></h3>
<p>分区键可以是单一列，也可以是多个列的组合，具体取决于数据的特性和查询需求。多列组合可以提供更精细的分区策略，但也可能增加维护的复杂性<a href="@ref">1</a><a href="@ref">3</a>。</p>
<h3 id="4-避免过度分区">4. <strong>避免过度分区</strong><a class="anchor" href="#4-%e9%81%bf%e5%85%8d%e8%bf%87%e5%ba%a6%e5%88%86%e5%8c%ba">#</a></h3>
<p>虽然分区可以提高性能，但过度的分区可能导致元数据管理复杂性和查询开销的增加。因此，应根据实际数据量和查询频率合理选择分区数<a href="@ref">1</a><a href="@ref">2</a>。</p>
<h3 id="5-考虑分区类型">5. <strong>考虑分区类型</strong><a class="anchor" href="#5-%e8%80%83%e8%99%91%e5%88%86%e5%8c%ba%e7%b1%bb%e5%9e%8b">#</a></h3>
<p>MySQL支持多种分区类型，如范围分区（RANGE）、哈希分区（HASH）、键值分区（KEY）和列表分区（LIST）。选择哪种类型取决于数据的特性和查询需求。例如，范围分区适用于按日期或数字范围查询的场景<a href="@ref">1</a><a href="@ref">3</a>。</p>
<h3 id="6-维护和管理">6. <strong>维护和管理</strong><a class="anchor" href="#6-%e7%bb%b4%e6%8a%a4%e5%92%8c%e7%ae%a1%e7%90%86">#</a></h3>
<p>分区表的维护需要额外的工作，特别是在删除和添加分区时。因此，在选择分区键时，也应考虑未来的维护需求<a href="@ref">1</a><a href="@ref">3</a>。</p>
<h3 id="7-测试和调整">7. <strong>测试和调整</strong><a class="anchor" href="#7-%e6%b5%8b%e8%af%95%e5%92%8c%e8%b0%83%e6%95%b4">#</a></h3>
<p>在实际应用中，应通过性能测试来验证分区键的选择是否有效。如果发现性能瓶颈或数据倾斜问题，应及时调整分区策略<a href="@ref">1</a><a href="@ref">2</a>。</p>
<h3 id="8-业务需求">8. <strong>业务需求</strong><a class="anchor" href="#8-%e4%b8%9a%e5%8a%a1%e9%9c%80%e6%b1%82">#</a></h3>
<p>分区键的选择应与业务场景紧密结合，以满足数据查询和事务处理的需求。例如，在电商平台中，用户ID和订单日期是常见的分区键<a href="@ref">2</a>。</p>
<h3 id="9-数据量和查询模式">9. <strong>数据量和查询模式</strong><a class="anchor" href="#9-%e6%95%b0%e6%8d%ae%e9%87%8f%e5%92%8c%e6%9f%a5%e8%af%a2%e6%a8%a1%e5%bc%8f">#</a></h3>
<p>对于大数据量表，选择适当的分区键可以有效分摊存储和处理压力，提高查询性能。对于频繁查询同一数据范围的场景，选择包含该范围的列作为分区键，可以减少数据跨分区访问，优化查询效率<a href="@ref">2</a>。</p>
<h3 id="10-事务处理模式">10. <strong>事务处理模式</strong><a class="anchor" href="#10-%e4%ba%8b%e5%8a%a1%e5%a4%84%e7%90%86%e6%a8%a1%e5%bc%8f">#</a></h3>
<p>分区键的选择应确保事务操作的一致性，避免数据写入同一分区导致冲突。对于并发事务较多的场景，选择能够唯一标识事务对象的列作为分区键，可以保证事务的原子性和隔离性<a href="@ref">2</a>。</p>
<h3 id="总结-8">总结<a class="anchor" href="#%e6%80%bb%e7%bb%93-8">#</a></h3>
<p>通过综合考虑查询频率、数据分布性、列的组合、分区类型以及未来的维护需求等因素，可以制定出有效的分区策略来提高数据库性能<a href="@ref">1</a><a href="@ref">2</a><a href="@ref">3</a>。</p>
<h2 id="分区对数据库的水平扩展有什么影响">分区对数据库的水平扩展有什么影响<a class="anchor" href="#%e5%88%86%e5%8c%ba%e5%af%b9%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e6%b0%b4%e5%b9%b3%e6%89%a9%e5%b1%95%e6%9c%89%e4%bb%80%e4%b9%88%e5%bd%b1%e5%93%8d">#</a></h2>
<h2 id="有哪些常见的错误分区键选择案例">有哪些常见的错误分区键选择案例？<a class="anchor" href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e9%94%99%e8%af%af%e5%88%86%e5%8c%ba%e9%94%ae%e9%80%89%e6%8b%a9%e6%a1%88%e4%be%8b">#</a></h2>
<p>在选择分区键时，常见的错误包括选择不适当的分区键，导致分区表性能下降或管理复杂化。以下是一些常见的错误分区键选择案例：</p>
<h3 id="1-选择低基数列作为分区键">1. <strong>选择低基数列作为分区键</strong><a class="anchor" href="#1-%e9%80%89%e6%8b%a9%e4%bd%8e%e5%9f%ba%e6%95%b0%e5%88%97%e4%bd%9c%e4%b8%ba%e5%88%86%e5%8c%ba%e9%94%ae">#</a></h3>
<p>低基数列（如性别、状态）包含的离散值较少，如果用作分区键，会导致分区数量不足，无法有效分散数据，从而无法达到提升性能的效果。</p>
<ul>
<li><strong>示例</strong>：使用 <code>gender</code> 列（只有 &lsquo;男&rsquo; 和 &lsquo;女&rsquo; 两个值）作为分区键，只能创建两个分区，无法有效分散数据。</li>
</ul>
<hr>
<h3 id="2-选择高基数列但数据分布不均的列">2. <strong>选择高基数列但数据分布不均的列</strong><a class="anchor" href="#2-%e9%80%89%e6%8b%a9%e9%ab%98%e5%9f%ba%e6%95%b0%e5%88%97%e4%bd%86%e6%95%b0%e6%8d%ae%e5%88%86%e5%b8%83%e4%b8%8d%e5%9d%87%e7%9a%84%e5%88%97">#</a></h3>
<p>高基数列（如用户ID、订单号）虽然包含大量离散值，但如果数据分布不均，某些分区可能包含大量数据，而其他分区数据稀少，导致数据倾斜。</p>
<ul>
<li><strong>示例</strong>：使用 <code>user_id</code> 列作为分区键，但大部分订单集中在少数用户上，导致某些分区数据量过大。</li>
</ul>
<hr>
<h3 id="3-选择频繁更新的列作为分区键">3. <strong>选择频繁更新的列作为分区键</strong><a class="anchor" href="#3-%e9%80%89%e6%8b%a9%e9%a2%91%e7%b9%81%e6%9b%b4%e6%96%b0%e7%9a%84%e5%88%97%e4%bd%9c%e4%b8%ba%e5%88%86%e5%8c%ba%e9%94%ae">#</a></h3>
<p>如果分区键的值频繁更新，会导致数据在分区之间频繁移动，增加维护开销，并可能影响性能。</p>
<ul>
<li><strong>示例</strong>：使用 <code>order_status</code> 列作为分区键，但订单状态经常变化，导致数据需要频繁迁移到不同的分区。</li>
</ul>
<hr>
<h3 id="4-选择与查询条件无关的列作为分区键">4. <strong>选择与查询条件无关的列作为分区键</strong><a class="anchor" href="#4-%e9%80%89%e6%8b%a9%e4%b8%8e%e6%9f%a5%e8%af%a2%e6%9d%a1%e4%bb%b6%e6%97%a0%e5%85%b3%e7%9a%84%e5%88%97%e4%bd%9c%e4%b8%ba%e5%88%86%e5%8c%ba%e9%94%ae">#</a></h3>
<p>分区键应与查询条件紧密相关，否则无法利用分区裁剪（Partition Pruning）优化查询性能。</p>
<ul>
<li><strong>示例</strong>：使用 <code>product_id</code> 列作为分区键，但查询条件通常是按 <code>order_date</code> 查询，导致无法利用分区优化查询。</li>
</ul>
<hr>
<h3 id="5-选择表达式或函数作为分区键">5. <strong>选择表达式或函数作为分区键</strong><a class="anchor" href="#5-%e9%80%89%e6%8b%a9%e8%a1%a8%e8%be%be%e5%bc%8f%e6%88%96%e5%87%bd%e6%95%b0%e4%bd%9c%e4%b8%ba%e5%88%86%e5%8c%ba%e9%94%ae">#</a></h3>
<p>使用表达式或函数作为分区键可能导致分区键值计算复杂化，增加查询优化器的负担，并可能影响分区裁剪效果。</p>
<ul>
<li><strong>示例</strong>：使用 <code>YEAR(order_date)</code> 作为分区键，虽然可以按年份分区，但查询条件可能无法直接匹配分区键，导致性能下降。</li>
</ul>
<hr>
<h3 id="6-选择分区键时忽略业务需求">6. <strong>选择分区键时忽略业务需求</strong><a class="anchor" href="#6-%e9%80%89%e6%8b%a9%e5%88%86%e5%8c%ba%e9%94%ae%e6%97%b6%e5%bf%bd%e7%95%a5%e4%b8%9a%e5%8a%a1%e9%9c%80%e6%b1%82">#</a></h3>
<p>分区键的选择应与业务需求紧密结合，否则可能导致分区表无法满足业务场景的查询或管理需求。</p>
<ul>
<li><strong>示例</strong>：在电商平台中，使用 <code>product_id</code> 作为分区键，但业务场景通常是按用户或订单日期查询，导致分区表无法优化查询性能。</li>
</ul>
<hr>
<h3 id="7-选择分区键时忽略数据增长模式">7. <strong>选择分区键时忽略数据增长模式</strong><a class="anchor" href="#7-%e9%80%89%e6%8b%a9%e5%88%86%e5%8c%ba%e9%94%ae%e6%97%b6%e5%bf%bd%e7%95%a5%e6%95%b0%e6%8d%ae%e5%a2%9e%e9%95%bf%e6%a8%a1%e5%bc%8f">#</a></h3>
<p>如果分区键无法适应数据增长模式，可能导致分区表无法有效管理数据。</p>
<ul>
<li><strong>示例</strong>：使用 <code>order_date</code> 作为分区键，但数据增长过快，导致分区数量过多，影响性能。</li>
</ul>
<hr>
<h3 id="8-选择分区键时忽略存储引擎限制">8. <strong>选择分区键时忽略存储引擎限制</strong><a class="anchor" href="#8-%e9%80%89%e6%8b%a9%e5%88%86%e5%8c%ba%e9%94%ae%e6%97%b6%e5%bf%bd%e7%95%a5%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e9%99%90%e5%88%b6">#</a></h3>
<p>某些存储引擎对分区表的支持有限，选择分区键时应考虑存储引擎的限制。</p>
<ul>
<li><strong>示例</strong>：在使用 CSV 或 FEDERATED 存储引擎时，分区功能不支持，选择分区键会导致错误。</li>
</ul>
<hr>
<h3 id="9-选择分区键时忽略分区数量限制">9. <strong>选择分区键时忽略分区数量限制</strong><a class="anchor" href="#9-%e9%80%89%e6%8b%a9%e5%88%86%e5%8c%ba%e9%94%ae%e6%97%b6%e5%bf%bd%e7%95%a5%e5%88%86%e5%8c%ba%e6%95%b0%e9%87%8f%e9%99%90%e5%88%b6">#</a></h3>
<p>某些数据库系统对分区数量有限制，选择分区键时应避免超过限制。</p>
<ul>
<li><strong>示例</strong>：在 Oracle 中，每个表的分区或子分区总数不能超过 1023 个，选择高基数列作为分区键可能导致分区数量超过限制。</li>
</ul>
<hr>
<h3 id="10-选择分区键时忽略维护成本">10. <strong>选择分区键时忽略维护成本</strong><a class="anchor" href="#10-%e9%80%89%e6%8b%a9%e5%88%86%e5%8c%ba%e9%94%ae%e6%97%b6%e5%bf%bd%e7%95%a5%e7%bb%b4%e6%8a%a4%e6%88%90%e6%9c%ac">#</a></h3>
<p>分区表的维护需要额外的工作，选择分区键时应考虑未来的维护成本。</p>
<ul>
<li><strong>示例</strong>：使用 <code>order_date</code> 作为分区键，但需要定期删除旧分区，增加维护成本。</li>
</ul>
<hr>
<h3 id="总结-9">总结<a class="anchor" href="#%e6%80%bb%e7%bb%93-9">#</a></h3>
<p>在选择分区键时，应避免选择低基数列、数据分布不均的列、频繁更新的列、与查询条件无关的列、表达式或函数作为分区键，同时应考虑业务需求、数据增长模式、存储引擎限制和分区数量限制等因素，以确保分区表能够有效提升性能并简化管理。</p>
<h2 id="如何评估分区键的选择是否会对查询性能产生显著影响">如何评估分区键的选择是否会对查询性能产生显著影响？<a class="anchor" href="#%e5%a6%82%e4%bd%95%e8%af%84%e4%bc%b0%e5%88%86%e5%8c%ba%e9%94%ae%e7%9a%84%e9%80%89%e6%8b%a9%e6%98%af%e5%90%a6%e4%bc%9a%e5%af%b9%e6%9f%a5%e8%af%a2%e6%80%a7%e8%83%bd%e4%ba%a7%e7%94%9f%e6%98%be%e8%91%97%e5%bd%b1%e5%93%8d">#</a></h2>
<h1 id="备份">备份<a class="anchor" href="#%e5%a4%87%e4%bb%bd">#</a></h1>
<h2 id="how-to-back-up-and-restore-a-database-in-mysql">How to Back Up and Restore a Database in MySQL<a class="anchor" href="#how-to-back-up-and-restore-a-database-in-mysql">#</a></h2>
<ul>
<li>To back up a database on the MySQL server, you use the <code>mysqldump</code> program that comes by default with the MySQL client installation.</li>
<li>To restore a backup created by the mysqldump program, you use the <code>mysql</code> command-line program.</li>
</ul>
<pre tabindex="0"><code>mysqldump -h localhost -u root -p hr &gt; D:\backup\hr.sql</code></pre><ul>
<li>
<p><code>mysqldump</code>: This is the <strong>command-line utility</strong> for MySQL that allows you to <strong>dump</strong> the contents of a database into a file.</p>
</li>
<li>
<p>hr: <strong>This is the name of the MySQL database that you want to back up</strong>. Replace “hr” with the actual name of the database you want to back up.</p>
</li>
<li>
<p>备份全库 <code>mysqldump -u root -p --all-databases &gt; all_databases_backup.sql</code></p>
</li>
<li>
<p>备份单个数据库 <code>mysqldump -u root -p database_name &gt; database_backup.sql</code></p>
</li>
<li>
<p>备份特定表 <code>mysqldump -u root -p database_name table_name &gt; table_backup.sql</code></p>
</li>
<li>
<p>备份时增加压缩 <code>mysqldump -u root -p database_name | gzip &gt; database_backup.sql.gz</code></p>
</li>
<li>
<p>reference</p>
<ul>
<li><a href="https://www.mysqltutorial.org/mysql-administration/mysql-backup-a-database/">How to Back Up and Restore a Database in MySQL</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/8544684157">MySQL数据库备份与恢复：全面指南</a></li>
</ul>
</li>
</ul>
<h2 id="mysqldump-官方文档">mysqldump 官方文档<a class="anchor" href="#mysqldump-%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3">#</a></h2>
<h3 id="performance-and-scalability-considerations">Performance and Scalability Considerations<a class="anchor" href="#performance-and-scalability-considerations">#</a></h3>
<ul>
<li>
<p>mysqldump advantages include the convenience and flexibility of viewing or even editing the output before restoring. You can clone databases for development and DBA work, or produce slight variations of an existing database for testing.</p>
<ul>
<li>可以进行修改</li>
</ul>
</li>
<li>
<p>It is not intended as a fast or scalable solution for backing up substantial amounts of data. With large data sizes, even if the backup step takes a reasonable time, restoring the data can be very slow because replaying the SQL statements involves disk I/O for insertion, index creation, and so on.</p>
<ul>
<li>恢复需要时间，占用 I/O 资源</li>
</ul>
</li>
<li>
<p>For large-scale backup and restore, a physical backup is more appropriate, to copy the data files in their original format so that they can be restored quickly.</p>
<ul>
<li>如果数据量很大，建议使用物理备份</li>
</ul>
</li>
<li>
<p>If your tables are primarily InnoDB tables, or if you have a mix of InnoDB and MyISAM tables, consider using mysqlbackup, which is available as part of MySQL Enterprise. This tool provides high performance for InnoDB backups with minimal disruption; it can also back up tables from MyISAM and other storage engines; it also provides a number of convenient options to accommodate different backup scenarios.</p>
<ul>
<li>企业版备份工具</li>
</ul>
</li>
<li>
<p>reference</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html">6.5.4 mysqldump — A Database Backup Program</a></li>
</ul>
</li>
</ul>
<h2 id="logic-backup-逻辑备份">logic backup 逻辑备份<a class="anchor" href="#logic-backup-%e9%80%bb%e8%be%91%e5%a4%87%e4%bb%bd">#</a></h2>
<ul>
<li>
<p>A backup that reproduces table structure and data, <strong>without copying the actual data files</strong>. For example, the mysqldump command produces a logical backup, because its output contains statements such as CREATE TABLE and INSERT that can re-create the data. Contrast with physical backup. A logical backup offers <strong>flexibility</strong> (for example, you could edit table definitions or insert statements before restoring), but can take substantially longer to restore than a physical backup.</p>
</li>
<li>
<p><a href="https://dev.mysql.com/doc/refman/8.4/en/glossary.html#glos_logical_backup">logic backup</a></p>
</li>
</ul>
<h2 id="mysql-shell-dump-utilities">MySQL Shell dump utilities<a class="anchor" href="#mysql-shell-dump-utilities">#</a></h2>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html">6.5.4 mysqldump — A Database Backup Program</a></li>
</ul>
<h2 id="backing-up-mysql-part-6-physical-vs-logical-backups">Backing Up MySQL Part 6: Physical vs. Logical Backups<a class="anchor" href="#backing-up-mysql-part-6-physical-vs-logical-backups">#</a></h2>
<ul>
<li>reference
<ul>
<li><a href="https://www.red-gate.com/simple-talk/blogs/backing-up-mysql-part-6-physical-vs-logical-backups/">Backing Up MySQL Part 6: Physical vs. Logical Backups</a></li>
</ul>
</li>
</ul>
<h2 id="可以在mysql还在运行时执行-mysqldump-吗">可以在mysql还在运行时执行 mysqldump 吗？<a class="anchor" href="#%e5%8f%af%e4%bb%a5%e5%9c%a8mysql%e8%bf%98%e5%9c%a8%e8%bf%90%e8%a1%8c%e6%97%b6%e6%89%a7%e8%a1%8c-mysqldump-%e5%90%97">#</a></h2>
<ul>
<li>为了在备份期间保证数据的一致性（即备份出来的数据在某个时间点是一致的，不会出现半截事务），mysqldump 主要使用两种策略
<ul>
<li><strong>使用 &ndash;single-transaction 选项（推荐用于 InnoDB）</strong>
<ul>
<li>工作原理：它通过启动一个单独的长事务来工作。在这个事务中，它利用 InnoDB 的 多版本并发控制（MVCC） 特性。当您启动 mysqldump &ndash;single-transaction 时，它会向 InnoDB 请求一个在备份开始时的一致性数据快照。之后，即使其他客户端在修改数据，mysqldump 读取的也始终是备份开始那个时间点的数据。</li>
<li>优点
<ul>
<li>非阻塞：在备份过程中，不会锁定正在备份的表，因此应用程序的 读写操作可以正常进行，几乎不会感到任何阻塞。</li>
<li>保证一致性：备份的数据是某个时间点的一致快照。</li>
</ul>
</li>
<li>要求：仅适用于支持事务的存储引擎，如 InnoDB。对于 MyISAM 等非事务引擎，此选项无效。</li>
</ul>
</li>
<li><strong>使用 &ndash;lock-tables 选项</strong>
<ul>
<li><strong>工作原理</strong>：在备份某个数据库的每个表之前，会对该表执行 LOCK TABLES &hellip; READ（读锁）。这意味着在备份这个表时，其他会话可以读，但不能写。</li>
<li><strong>缺点</strong>
<ul>
<li>阻塞写入：在备份期间，被锁定的表无法被更新，这会导致应用程序的写操作被阻塞，如果备份很大，可能会造成严重的服务中断。</li>
</ul>
</li>
<li><strong>适用场景</strong>：通常只在需要备份 MyISAM 表，或者 MySQL 版本太老不支持 &ndash;single-transaction 时才考虑使用。</li>
</ul>
</li>
</ul>
</li>
<li><code>mysqldump</code> 的默认行为
<ul>
<li>对于非事务性表（如 MyISAM），mysqldump 会自动使用 &ndash;lock-tables 来保证一致性。所以如果你混用了 InnoDB 和 MyISAM 表，最好明确指定你的选项。</li>
</ul>
</li>
<li>最佳实践和建议
<ul>
<li>对于 InnoDB 表，始终使用 <code>--single-transaction</code>：这是在线备份的黄金标准，它能在保证一致性的前提下，最大限度地减少对业务的影响</li>
<li>考虑备份期间的服务器负载
<ul>
<li>虽然 <code>--single-transaction</code> 不锁表，但它仍然会从服务器读取大量数据，这会产生 I/O 和 CPU 负载。建议在业务低峰期执行备份操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="脚本中如何输入密码">脚本中如何输入密码<a class="anchor" href="#%e8%84%9a%e6%9c%ac%e4%b8%ad%e5%a6%82%e4%bd%95%e8%be%93%e5%85%a5%e5%af%86%e7%a0%81">#</a></h2>
<pre tabindex="0"><code># 设置登录路径
mysql_config_editor set --login-path=backup_user --host=localhost --user=username --password

# 执行时会提示输入密码，密码被加密存储

# 在脚本中使用

#!/bin/bash
mysqldump --login-path=backup_user --single-transaction --databases your_database &gt; backup_$(date +%Y%m%d).sql</code></pre><h2 id="reference">reference<a class="anchor" href="#reference">#</a></h2>
<ul>
<li><a href="https://www.red-gate.com/simple-talk/databases/mysql/backing-up-mysql-part-1-mysqldump/">Backing up MySQL Part 1: mysqldump</a></li>
</ul>
<h1 id="reference-1">Reference<a class="anchor" href="#reference-1">#</a></h1>
<ul>
<li><a href="https://geekdaxue.co/books/zhangnio@or5bz8">MySQL 架构原理</a></li>
<li><a href="https://www.mysqltutorial.org/">MySQL Tutorial</a></li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">

<div>

</div>

<div>

</div>

</div>





  
  
  
  <div class="flex flex-wrap justify-between">
    <span>
    
      <a href="/post/computer-science/database/mycat/" class="flex align-center">
        <img src="/icons/backward.svg" class="book-icon" alt="Backward" />
        <span>mycat</span>
      </a>
    
    </span>
    <span>
    
      <a href="/post/computer-science/database/postgresql/" class="flex align-center">
        <span>postgresql</span>
        <img src="/icons/forward.svg" class="book-icon" alt="Forward" />
      </a>
    
    </span>
  </div>
  


 
        
  
  <div class="book-comments">

</div>
  
 
        
        
  
  <div class="book-copyright flex justify-center">
    <small>Penruins - <a href="/">Main Page</a></small>
  </div>
  
 
        
  
  
    <script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script>
  

      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  
  <aside class="book-toc">
    <div class="book-toc-content">
      
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#mysql">mysql</a>
      <ul>
        <li><a href="#binlog">binlog</a>
          <ul>
            <li><a href="#redo-log-和-binlog日志">redo log 和 binlog日志</a></li>
          </ul>
        </li>
        <li><a href="#读写分离">读写分离</a></li>
        <li><a href="#repeatable-read级别中的幻读问题如何通过间隙锁解决">Repeatable Read级别中的幻读问题如何通过间隙锁解决？</a>
          <ul>
            <li><a href="#1-幻读的定义">1. <strong>幻读的定义</strong></a></li>
            <li><a href="#2-间隙锁gap-lock">2. <strong>间隙锁（Gap Lock）</strong></a></li>
            <li><a href="#3-next-key-lock">3. <strong>Next-Key Lock</strong></a></li>
            <li><a href="#4-间隙锁的适用场景">4. <strong>间隙锁的适用场景</strong></a></li>
            <li><a href="#5-间隙锁的注意事项">5. <strong>间隙锁的注意事项</strong></a></li>
            <li><a href="#6-示例">6. <strong>示例</strong></a></li>
            <li><a href="#总结">总结</a></li>
          </ul>
        </li>
        <li><a href="#mysql-有哪些索引类型">mysql 有哪些索引类型</a>
          <ul>
            <li><a href="#1-b树索引">1. <strong>B+树索引</strong></a></li>
            <li><a href="#2-哈希索引">2. <strong>哈希索引</strong></a></li>
            <li><a href="#3-全文索引fulltext">3. <strong>全文索引（FULLTEXT）</strong></a></li>
            <li><a href="#4-空间索引spatial">4. <strong>空间索引（SPATIAL）</strong></a></li>
            <li><a href="#5-主键索引">5. <strong>主键索引</strong></a></li>
            <li><a href="#6-唯一索引">6. <strong>唯一索引</strong></a></li>
            <li><a href="#7-普通索引">7. <strong>普通索引</strong></a></li>
            <li><a href="#8-组合索引">8. <strong>组合索引</strong></a></li>
            <li><a href="#9-前缀索引">9. <strong>前缀索引</strong></a></li>
            <li><a href="#10-覆盖索引">10. <strong>覆盖索引</strong></a></li>
            <li><a href="#总结-1"><strong>总结</strong></a></li>
          </ul>
        </li>
        <li><a href="#repeatable-read级别中的幻读问题如何通过间隙锁解决-1">Repeatable Read级别中的幻读问题如何通过间隙锁解决？</a>
          <ul>
            <li><a href="#1-幻读的定义-1">1. <strong>幻读的定义</strong></a></li>
            <li><a href="#2-间隙锁gap-lock-1">2. <strong>间隙锁（Gap Lock）</strong></a></li>
            <li><a href="#3-next-key-lock-1">3. <strong>Next-Key Lock</strong></a></li>
            <li><a href="#4-间隙锁的适用场景-1">4. <strong>间隙锁的适用场景</strong></a></li>
            <li><a href="#5-间隙锁的注意事项-1">5. <strong>间隙锁的注意事项</strong></a></li>
            <li><a href="#6-示例-1">6. <strong>示例</strong></a></li>
            <li><a href="#总结-2">总结</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#分区">分区</a>
      <ul>
        <li><a href="#mysql-可以做分区吗">mysql 可以做分区吗</a>
          <ul>
            <li><a href="#1-mysql-分区的版本支持">1. <strong>MySQL 分区的版本支持</strong></a></li>
            <li><a href="#2-分区的实现方式">2. <strong>分区的实现方式</strong></a></li>
            <li><a href="#3-分区的适用场景">3. <strong>分区的适用场景</strong></a></li>
            <li><a href="#4-分区的优点">4. <strong>分区的优点</strong></a></li>
            <li><a href="#5-分区的限制">5. <strong>分区的限制</strong></a></li>
            <li><a href="#6-分区示例">6. <strong>分区示例</strong></a></li>
            <li><a href="#总结-3">总结</a></li>
          </ul>
        </li>
        <li><a href="#提供一个按日期月份进行分区的例子">提供一个按日期月份进行分区的例子</a>
          <ul>
            <li><a href="#1-创建表并按月份分区">1. <strong>创建表并按月份分区</strong></a></li>
            <li><a href="#2-插入数据">2. <strong>插入数据</strong></a></li>
            <li><a href="#3-查询分区数据">3. <strong>查询分区数据</strong></a></li>
            <li><a href="#4-动态添加分区">4. <strong>动态添加分区</strong></a></li>
            <li><a href="#5-删除旧分区">5. <strong>删除旧分区</strong></a></li>
            <li><a href="#6-总结">6. <strong>总结</strong></a></li>
          </ul>
        </li>
        <li><a href="#在mysql中分区可以在之后动态新增吗">在mysql中分区可以在之后动态新增吗</a>
          <ul>
            <li><a href="#1-手动添加分区">1. <strong>手动添加分区</strong></a></li>
            <li><a href="#2-使用存储过程自动添加分区">2. <strong>使用存储过程自动添加分区</strong></a></li>
            <li><a href="#3-使用定时任务自动添加分区">3. <strong>使用定时任务自动添加分区</strong></a></li>
            <li><a href="#4-注意事项">4. <strong>注意事项</strong></a></li>
            <li><a href="#总结-4">总结</a></li>
          </ul>
        </li>
        <li><a href="#过多的分区可能导致性能下降这个问题该如何处理">过多的分区可能导致性能下降，这个问题该如何处理</a>
          <ul>
            <li><a href="#1-合理设计分区策略">1. <strong>合理设计分区策略</strong></a></li>
            <li><a href="#2-合并小分区">2. <strong>合并小分区</strong></a></li>
            <li><a href="#3-使用子分区">3. <strong>使用子分区</strong></a></li>
            <li><a href="#4-定期清理和归档数据">4. <strong>定期清理和归档数据</strong></a></li>
            <li><a href="#5-优化查询和索引">5. <strong>优化查询和索引</strong></a></li>
            <li><a href="#6-监控和调整">6. <strong>监控和调整</strong></a></li>
            <li><a href="#7-避免过度分区">7. <strong>避免过度分区</strong></a></li>
          </ul>
        </li>
        <li><a href="#如何评估一个表是否需要进行分区">如何评估一个表是否需要进行分区</a>
          <ul>
            <li><a href="#1-数据量大小">1. <strong>数据量大小</strong></a></li>
            <li><a href="#2-查询模式">2. <strong>查询模式</strong></a></li>
            <li><a href="#3-数据管理需求">3. <strong>数据管理需求</strong></a></li>
            <li><a href="#4-硬件资源">4. <strong>硬件资源</strong></a></li>
            <li><a href="#5-业务需求">5. <strong>业务需求</strong></a></li>
            <li><a href="#6-分区键选择">6. <strong>分区键选择</strong></a></li>
            <li><a href="#7-分区的优缺点权衡">7. <strong>分区的优缺点权衡</strong></a></li>
            <li><a href="#总结-5">总结</a></li>
          </ul>
        </li>
        <li><a href="#分区表和非分区表在性能上有什么具体区别">分区表和非分区表在性能上有什么具体区别</a>
          <ul>
            <li><a href="#1-查询性能">1. <strong>查询性能</strong></a></li>
            <li><a href="#2-插入性能">2. <strong>插入性能</strong></a></li>
            <li><a href="#3-删除性能">3. <strong>删除性能</strong></a></li>
            <li><a href="#4-维护性能">4. <strong>维护性能</strong></a></li>
            <li><a href="#5-索引性能">5. <strong>索引性能</strong></a></li>
            <li><a href="#6-存储性能">6. <strong>存储性能</strong></a></li>
            <li><a href="#总结-6">总结</a></li>
          </ul>
        </li>
        <li><a href="#分区表在不同数据库系统中有什么区别">分区表在不同数据库系统中有什么区别</a>
          <ul>
            <li><a href="#1-mysql-分区表">1. <strong>MySQL 分区表</strong></a></li>
            <li><a href="#2-oracle-分区表">2. <strong>Oracle 分区表</strong></a></li>
            <li><a href="#3-postgresql-分区表">3. <strong>PostgreSQL 分区表</strong></a></li>
            <li><a href="#4-主要区别">4. <strong>主要区别</strong></a></li>
            <li><a href="#总结-7">总结</a></li>
          </ul>
        </li>
        <li><a href="#如何选择合适的分区键">如何选择合适的分区键</a>
          <ul>
            <li><a href="#1-频繁查询的列">1. <strong>频繁查询的列</strong></a></li>
            <li><a href="#2-数据分布性">2. <strong>数据分布性</strong></a></li>
            <li><a href="#3-单一列或多列组合">3. <strong>单一列或多列组合</strong></a></li>
            <li><a href="#4-避免过度分区">4. <strong>避免过度分区</strong></a></li>
            <li><a href="#5-考虑分区类型">5. <strong>考虑分区类型</strong></a></li>
            <li><a href="#6-维护和管理">6. <strong>维护和管理</strong></a></li>
            <li><a href="#7-测试和调整">7. <strong>测试和调整</strong></a></li>
            <li><a href="#8-业务需求">8. <strong>业务需求</strong></a></li>
            <li><a href="#9-数据量和查询模式">9. <strong>数据量和查询模式</strong></a></li>
            <li><a href="#10-事务处理模式">10. <strong>事务处理模式</strong></a></li>
            <li><a href="#总结-8">总结</a></li>
          </ul>
        </li>
        <li><a href="#分区对数据库的水平扩展有什么影响">分区对数据库的水平扩展有什么影响</a></li>
        <li><a href="#有哪些常见的错误分区键选择案例">有哪些常见的错误分区键选择案例？</a>
          <ul>
            <li><a href="#1-选择低基数列作为分区键">1. <strong>选择低基数列作为分区键</strong></a></li>
            <li><a href="#2-选择高基数列但数据分布不均的列">2. <strong>选择高基数列但数据分布不均的列</strong></a></li>
            <li><a href="#3-选择频繁更新的列作为分区键">3. <strong>选择频繁更新的列作为分区键</strong></a></li>
            <li><a href="#4-选择与查询条件无关的列作为分区键">4. <strong>选择与查询条件无关的列作为分区键</strong></a></li>
            <li><a href="#5-选择表达式或函数作为分区键">5. <strong>选择表达式或函数作为分区键</strong></a></li>
            <li><a href="#6-选择分区键时忽略业务需求">6. <strong>选择分区键时忽略业务需求</strong></a></li>
            <li><a href="#7-选择分区键时忽略数据增长模式">7. <strong>选择分区键时忽略数据增长模式</strong></a></li>
            <li><a href="#8-选择分区键时忽略存储引擎限制">8. <strong>选择分区键时忽略存储引擎限制</strong></a></li>
            <li><a href="#9-选择分区键时忽略分区数量限制">9. <strong>选择分区键时忽略分区数量限制</strong></a></li>
            <li><a href="#10-选择分区键时忽略维护成本">10. <strong>选择分区键时忽略维护成本</strong></a></li>
            <li><a href="#总结-9">总结</a></li>
          </ul>
        </li>
        <li><a href="#如何评估分区键的选择是否会对查询性能产生显著影响">如何评估分区键的选择是否会对查询性能产生显著影响？</a></li>
      </ul>
    </li>
    <li><a href="#备份">备份</a>
      <ul>
        <li><a href="#how-to-back-up-and-restore-a-database-in-mysql">How to Back Up and Restore a Database in MySQL</a></li>
        <li><a href="#mysqldump-官方文档">mysqldump 官方文档</a>
          <ul>
            <li><a href="#performance-and-scalability-considerations">Performance and Scalability Considerations</a></li>
          </ul>
        </li>
        <li><a href="#logic-backup-逻辑备份">logic backup 逻辑备份</a></li>
        <li><a href="#mysql-shell-dump-utilities">MySQL Shell dump utilities</a></li>
        <li><a href="#backing-up-mysql-part-6-physical-vs-logical-backups">Backing Up MySQL Part 6: Physical vs. Logical Backups</a></li>
        <li><a href="#可以在mysql还在运行时执行-mysqldump-吗">可以在mysql还在运行时执行 mysqldump 吗？</a></li>
        <li><a href="#脚本中如何输入密码">脚本中如何输入密码</a></li>
        <li><a href="#reference">reference</a></li>
      </ul>
    </li>
    <li><a href="#reference-1">Reference</a></li>
  </ul>
</nav>



    </div>
  </aside>
  
 
  </main>

  
</body>
</html>




















