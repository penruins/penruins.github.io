[{"id":0,"href":"/zh/post/others/about-me/","title":"about me","section":"Others","content":" about me # 家乡 云南昆明 骑行 Strava 电影 douban 观影记录 研究各种提升效率的小工具 vim 双拼 raspberry pi ios shortcut "},{"id":1,"href":"/zh/zh/post/others/about-me/","title":"about me","section":"Others","content":" about me # 家乡 云南昆明 骑行 Strava 电影 douban 观影记录 研究各种提升效率的小工具 vim 双拼 raspberry pi ios shortcut "},{"id":2,"href":"/zh/post/computer-science/java/java/","title":"java","section":"Java","content":" java # 学习资料 # CS-Notes面试笔记 mall-swarm视频教程 basic # java array 转 list # 在Java中，你可以使用Arrays.asList()方法将数组转换为列表。这是一个简单的方法来创建一个固定大小的List。如果你需要一个能够改变大小的List，你需要使用new ArrayList\u0026lt;\u0026gt;(Arrays.asList(array))来创建一个新的ArrayList实例。\n以下是两种情况的代码示例：\n创建一个固定大小的列表 # import java.util.Arrays; import java.util.List; public class ArrayToListExample { public static void main(String[] args) { String[] array = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; List\u0026lt;String\u0026gt; list = Arrays.asList(array); System.out.println(list); // 输出: [a, b, c] } } 创建一个可变大小的列表 # import java.util.ArrayList; import java.util.Arrays; import java.util.List; public class ArrayToArrayListExample { public static void main(String[] args) { String[] array = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(array)); // 现在可以添加或删除元素了 arrayList.add(\u0026#34;d\u0026#34;); System.out.println(arrayList); // 输出: [a, b, c, d] } } 请注意，当你使用Arrays.asList()时，它返回的是一个受数组支持的固定大小的列表。这意味着你不能添加或移除元素（除非你将其转换为像ArrayList这样的可调整大小的列表），但是你可以修改已经存在的元素。如果你尝试对固定大小的列表执行添加或移除操作，将会抛出UnsupportedOperationException异常。\njava， 怎么用二进制打印int # 在Java中，可以使用Integer.toBinaryString()方法来将一个int类型的数值转换为二进制字符串表示。此方法返回的是一个不带前导零的字符串，也就是说它不会打印出完整的32位（对于int类型），如果需要显示所有位，包括前导零，则需要额外处理。\n以下是一些例子：\n使用 Integer.toBinaryString() # public class BinaryPrintExample { public static void main(String[] args) { int number = 42; String binaryString = Integer.toBinaryString(number); System.out.println(\u0026#34;The binary representation of \u0026#34; + number + \u0026#34; is: \u0026#34; + binaryString); } } 打印包含前导零的完整32位 # 如果你想要打印出完整的32位二进制数，包括前导的0，你可以使用String.format()或者BitSet，但最简单的方法是用String.format()配合循环补足前导零：\npublic class FullBinaryPrintExample { public static void main(String[] args) { int number = 42; // Convert to binary string and ensure it\u0026#39;s 32 bits long with leading zeros String binaryString = String.format(\u0026#34;%32s\u0026#34;, Integer.toBinaryString(number)).replace(\u0026#39; \u0026#39;, \u0026#39;0\u0026#39;); System.out.println(\u0026#34;The full 32-bit binary representation of \u0026#34; + number + \u0026#34; is: \u0026#34; + binaryString); } } 上面的代码中，%32s指定了格式化后的字符串总长度为32，不足的部分用空格填充，然后我们用replace(' ', '0')把所有的空格替换成'0\u0026rsquo;。\n使用位运算手动构建二进制字符串 # 如果你想自己实现这个功能，你也可以使用位运算来构建二进制字符串：\npublic class ManualBinaryPrintExample { public static void main(String[] args) { int number = 42; StringBuilder binaryString = new StringBuilder(); for (int i = 31; i \u0026gt;= 0; i--) { int k = number \u0026gt;\u0026gt; i; if ((k \u0026amp; 1) \u0026gt; 0) { binaryString.append(\u0026#34;1\u0026#34;); } else { binaryString.append(\u0026#34;0\u0026#34;); } } System.out.println(\u0026#34;The manually constructed 32-bit binary representation of \u0026#34; + number + \u0026#34; is: \u0026#34; + binaryString.toString()); } } 这段代码通过逐位检查整数的每一位是否为1，并相应地添加\u0026quot;1\u0026quot;或\u0026quot;0\u0026quot;到StringBuilder对象中，最终构建出完整的32位二进制字符串。\nconcurrent # "},{"id":3,"href":"/zh/zh/post/computer-science/java/java/","title":"java","section":"Java","content":" java # 学习资料 # CS-Notes面试笔记 mall-swarm视频教程 basic # java array 转 list # 在Java中，你可以使用Arrays.asList()方法将数组转换为列表。这是一个简单的方法来创建一个固定大小的List。如果你需要一个能够改变大小的List，你需要使用new ArrayList\u0026lt;\u0026gt;(Arrays.asList(array))来创建一个新的ArrayList实例。\n以下是两种情况的代码示例：\n创建一个固定大小的列表 # import java.util.Arrays; import java.util.List; public class ArrayToListExample { public static void main(String[] args) { String[] array = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; List\u0026lt;String\u0026gt; list = Arrays.asList(array); System.out.println(list); // 输出: [a, b, c] } } 创建一个可变大小的列表 # import java.util.ArrayList; import java.util.Arrays; import java.util.List; public class ArrayToArrayListExample { public static void main(String[] args) { String[] array = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(array)); // 现在可以添加或删除元素了 arrayList.add(\u0026#34;d\u0026#34;); System.out.println(arrayList); // 输出: [a, b, c, d] } } 请注意，当你使用Arrays.asList()时，它返回的是一个受数组支持的固定大小的列表。这意味着你不能添加或移除元素（除非你将其转换为像ArrayList这样的可调整大小的列表），但是你可以修改已经存在的元素。如果你尝试对固定大小的列表执行添加或移除操作，将会抛出UnsupportedOperationException异常。\njava， 怎么用二进制打印int # 在Java中，可以使用Integer.toBinaryString()方法来将一个int类型的数值转换为二进制字符串表示。此方法返回的是一个不带前导零的字符串，也就是说它不会打印出完整的32位（对于int类型），如果需要显示所有位，包括前导零，则需要额外处理。\n以下是一些例子：\n使用 Integer.toBinaryString() # public class BinaryPrintExample { public static void main(String[] args) { int number = 42; String binaryString = Integer.toBinaryString(number); System.out.println(\u0026#34;The binary representation of \u0026#34; + number + \u0026#34; is: \u0026#34; + binaryString); } } 打印包含前导零的完整32位 # 如果你想要打印出完整的32位二进制数，包括前导的0，你可以使用String.format()或者BitSet，但最简单的方法是用String.format()配合循环补足前导零：\npublic class FullBinaryPrintExample { public static void main(String[] args) { int number = 42; // Convert to binary string and ensure it\u0026#39;s 32 bits long with leading zeros String binaryString = String.format(\u0026#34;%32s\u0026#34;, Integer.toBinaryString(number)).replace(\u0026#39; \u0026#39;, \u0026#39;0\u0026#39;); System.out.println(\u0026#34;The full 32-bit binary representation of \u0026#34; + number + \u0026#34; is: \u0026#34; + binaryString); } } 上面的代码中，%32s指定了格式化后的字符串总长度为32，不足的部分用空格填充，然后我们用replace(' ', '0')把所有的空格替换成'0\u0026rsquo;。\n使用位运算手动构建二进制字符串 # 如果你想自己实现这个功能，你也可以使用位运算来构建二进制字符串：\npublic class ManualBinaryPrintExample { public static void main(String[] args) { int number = 42; StringBuilder binaryString = new StringBuilder(); for (int i = 31; i \u0026gt;= 0; i--) { int k = number \u0026gt;\u0026gt; i; if ((k \u0026amp; 1) \u0026gt; 0) { binaryString.append(\u0026#34;1\u0026#34;); } else { binaryString.append(\u0026#34;0\u0026#34;); } } System.out.println(\u0026#34;The manually constructed 32-bit binary representation of \u0026#34; + number + \u0026#34; is: \u0026#34; + binaryString.toString()); } } 这段代码通过逐位检查整数的每一位是否为1，并相应地添加\u0026quot;1\u0026quot;或\u0026quot;0\u0026quot;到StringBuilder对象中，最终构建出完整的32位二进制字符串。\nconcurrent # "},{"id":4,"href":"/zh/post/computer-science/java/mybatis/","title":"Mybatis","section":"Java","content":" mybatis是怎么进行事务管理的 2025-02-08 # MyBatis 通过集成外部事务管理器（如 Spring 或 Java EE 容器）或使用内置的 JDBC 事务管理机制来管理事务。以下是 MyBatis 事务管理的主要方式：\n1. 使用 JDBC 事务管理 # MyBatis 默认使用 JDBC 的事务管理，通过 java.sql.Connection 实现。具体步骤如下：\n开启事务：调用 Connection.setAutoCommit(false) 关闭自动提交。 提交事务：调用 Connection.commit() 提交事务。 回滚事务：调用 Connection.rollback() 回滚事务。 示例代码：\nSqlSession sqlSession = sqlSessionFactory.openSession(); try{ // 执行数据库操作 sqlSession. insert(\u0026#34;insertUser\u0026#34;,user); sqlSession. update(\u0026#34;updateUser\u0026#34;,user); // 提交事务 sqlSession. commit(); }catch( Exception e){ // 回滚事务 sqlSession. rollback(); }finally{ // 关闭 SqlSession sqlSession. close(); } 2. 集成 Spring 事务管理 # MyBatis 通常与 Spring 集成，利用 Spring 的事务管理功能。Spring 提供了声明式和编程式事务管理。\n2.1 声明式事务管理 # 通过 @Transactional 注解或 XML 配置实现事务管理。\n示例代码：\n@Service public class UserService { @Autowired private UserMapper userMapper; @Transactional public void addUser(User user) { userMapper.insertUser(user); userMapper.updateUser(user); } } 2.2 编程式事务管理 # 通过 TransactionTemplate 或 PlatformTransactionManager 手动管理事务。\n示例代码：\n@Service public class UserService { @Autowired private UserMapper userMapper; @Autowired private PlatformTransactionManager transactionManager; public void addUser(User user) { TransactionDefinition def = new DefaultTransactionDefinition(); TransactionStatus status = transactionManager.getTransaction(def); try { userMapper.insertUser(user); userMapper.updateUser(user); transactionManager.commit(status); } catch (Exception e) { transactionManager.rollback(status); throw e; } } } 3. 使用 Java EE 容器的事务管理 # 在 Java EE 环境中，MyBatis 可以通过 JTA（Java Transaction API）与容器的事务管理器集成，通常通过 UserTransaction 或容器提供的其他机制管理事务。\n总结 # JDBC 事务管理：MyBatis 默认使用 JDBC 事务管理，手动控制事务。 Spring 事务管理：与 Spring 集成时，推荐使用 Spring 的事务管理，支持声明式和编程式事务。 Java EE 事务管理：在 Java EE 环境中，可通过 JTA 与容器的事务管理器集成。 选择合适的事务管理方式取决于应用场景和框架集成需求。\n我使用springboot框架，我在一个方法中使用mybatis提供的mapper方法插入了一条数据，但是我没有在方法上使用@Transactional注解，这种情况下有事务吗 2025-02-08 # 在 Spring Boot 中使用 MyBatis 时，如果你在一个方法中调用了 MyBatis 的 Mapper 方法插入数据，但没有在方法上使用 @Transactional 注解，那么默认情况下是没有事务管理的。具体表现如下：\n1. 没有事务的情况 # 如果没有 @Transactional 注解，Spring 不会为该方法开启事务。 每次调用 MyBatis 的 Mapper 方法时，MyBatis 会使用默认的 JDBC 行为，即自动提交（auto-commit）。 这意味着每次执行 SQL 语句（如插入、更新、删除）后，数据库会立即提交该操作，无法回滚。 2. 可能的风险 # 数据不一致：如果方法中有多个数据库操作（例如插入多条数据），其中一个操作失败，前面的操作已经提交，无法回滚，可能导致数据不一致。 缺乏事务控制：无法保证操作的原子性。 3. 如何验证没有事务 # 你可以通过以下方式验证：\n在方法中故意抛出异常，观察数据是否被插入。 如果没有事务，即使抛出异常，已经插入的数据也会被提交到数据库。 示例代码：\n@Service public class UserService { @Autowired private UserMapper userMapper; public void addUser(User user) { userMapper.insertUser(user); // 插入数据 throw new RuntimeException(\u0026#34;模拟异常\u0026#34;); // 抛出异常 } } 运行后，检查数据库，会发现 user 数据已经被插入，即使抛出了异常。\n4. 如何启用事务 # 如果你希望方法中的操作在一个事务中执行，可以通过以下方式启用事务管理：\n4.1 使用 @Transactional 注解 # 在方法上添加 @Transactional 注解，Spring 会为该方法开启事务。\n示例代码：\n@Service public class UserService { @Autowired private UserMapper userMapper; @Transactional public void addUser(User user) { userMapper.insertUser(user); // 插入数据 throw new RuntimeException(\u0026#34;模拟异常\u0026#34;); // 抛出异常 } } 运行后，检查数据库，会发现 user 数据没有被插入，因为事务回滚了。\n4.2 配置事务管理器 # 确保 Spring Boot 项目中已经配置了事务管理器（通常使用 DataSourceTransactionManager）。Spring Boot 会自动配置事务管理器，只要你引入了相关依赖（如 spring-boot-starter-data-jpa 或 mybatis-spring-boot-starter）。\n5. 总结 # 没有 @Transactional 注解：默认没有事务，每次 SQL 操作会立即提交。 需要事务：在方法上添加 @Transactional 注解，确保方法中的多个操作在同一个事务中执行，保证原子性。 验证事务：通过抛出异常的方式验证事务是否生效。 如果你希望方法中的操作具有事务性，务必使用 @Transactional 注解。\n什么是乐观锁、悲观锁 2025-02-08 # 乐观锁和悲观锁是并发控制中常用的两种策略，用于解决多个事务或线程同时访问和修改同一数据时可能引发的数据不一致问题。它们的核心区别在于对并发冲突的处理方式。\n1. 悲观锁（Pessimistic Locking） # 悲观锁假设并发冲突很可能发生，因此在访问数据时直接加锁，确保其他事务或线程无法修改数据，直到当前操作完成。\n实现方式 # 在数据库中，通常通过 SELECT ... FOR UPDATE 或 SELECT ... LOCK IN SHARE MODE 实现。 在代码中，可以通过 synchronized 关键字或 ReentrantLock 实现。 特点 # 优点：保证数据强一致性，适合写操作多的场景。 缺点：加锁会降低并发性能，可能导致死锁。 适用场景 # 写操作频繁，且并发冲突概率高的场景。 例如：银行转账、库存扣减等。 示例 # -- 数据库中使用悲观锁 BEGIN; SELECT * FROM account WHERE id = 1 FOR UPDATE; -- 加锁 UPDATE account SET balance = balance - 100 WHERE id = 1; COMMIT; 2. 乐观锁（Optimistic Locking） # 乐观锁假设并发冲突很少发生，因此在访问数据时不会加锁，而是在提交时检查数据是否被其他事务修改过。如果发现冲突，则回滚或重试。\n实现方式 # 通常通过版本号（Version）或时间戳（Timestamp）实现。 在数据库中，可以为表添加一个 version 字段，每次更新时检查版本号是否一致。 特点 # 优点：不加锁，提高并发性能，适合读操作多的场景。 缺点：冲突时需要回滚或重试，可能增加业务逻辑复杂度。 适用场景 # 读操作频繁，写操作较少的场景。 例如：电商库存、评论系统等。 示例 # -- 数据库中使用乐观锁 -- 表结构 CREATE TABLE product ( id INT PRIMARY KEY, name VARCHAR(50), stock INT, version INT -- 版本号字段 ); -- 更新操作 UPDATE product SET stock = stock - 1, version = version + 1 WHERE id = 1 AND version = 5; -- 检查版本号 在代码中，可以通过以下方式实现乐观锁：\npublic boolean updateProduct(Product product) { int rows = productMapper.updateProduct( product.getId(), product.getStock(), product.getVersion() ); if (rows == 0) { throw new OptimisticLockException(\u0026#34;数据已被修改，请重试\u0026#34;); } return true; } 3. 对比总结 # 特性 悲观锁 乐观锁 加锁时机 访问数据时立即加锁 提交时检查冲突 性能 低（加锁影响并发） 高（不加锁，冲突时回滚） 适用场景 写操作多，冲突概率高 读操作多，冲突概率低 实现复杂度 简单 较复杂（需处理冲突） 数据一致性 强一致性 最终一致性 4. 如何选择 # 如果业务场景中写操作频繁，且对数据一致性要求高，选择悲观锁。 如果业务场景中读操作频繁，且冲突概率低，选择乐观锁。 5. 实际应用中的注意事项 # 悲观锁：注意死锁问题，避免长时间持有锁。 乐观锁：需要设计重试机制，处理冲突时的回滚或重试逻辑。 通过合理选择锁机制，可以在保证数据一致性的同时，最大化系统的并发性能。\n"},{"id":5,"href":"/zh/zh/post/computer-science/java/mybatis/","title":"Mybatis","section":"Java","content":" mybatis是怎么进行事务管理的 2025-02-08 # MyBatis 通过集成外部事务管理器（如 Spring 或 Java EE 容器）或使用内置的 JDBC 事务管理机制来管理事务。以下是 MyBatis 事务管理的主要方式：\n1. 使用 JDBC 事务管理 # MyBatis 默认使用 JDBC 的事务管理，通过 java.sql.Connection 实现。具体步骤如下：\n开启事务：调用 Connection.setAutoCommit(false) 关闭自动提交。 提交事务：调用 Connection.commit() 提交事务。 回滚事务：调用 Connection.rollback() 回滚事务。 示例代码：\nSqlSession sqlSession = sqlSessionFactory.openSession(); try{ // 执行数据库操作 sqlSession. insert(\u0026#34;insertUser\u0026#34;,user); sqlSession. update(\u0026#34;updateUser\u0026#34;,user); // 提交事务 sqlSession. commit(); }catch( Exception e){ // 回滚事务 sqlSession. rollback(); }finally{ // 关闭 SqlSession sqlSession. close(); } 2. 集成 Spring 事务管理 # MyBatis 通常与 Spring 集成，利用 Spring 的事务管理功能。Spring 提供了声明式和编程式事务管理。\n2.1 声明式事务管理 # 通过 @Transactional 注解或 XML 配置实现事务管理。\n示例代码：\n@Service public class UserService { @Autowired private UserMapper userMapper; @Transactional public void addUser(User user) { userMapper.insertUser(user); userMapper.updateUser(user); } } 2.2 编程式事务管理 # 通过 TransactionTemplate 或 PlatformTransactionManager 手动管理事务。\n示例代码：\n@Service public class UserService { @Autowired private UserMapper userMapper; @Autowired private PlatformTransactionManager transactionManager; public void addUser(User user) { TransactionDefinition def = new DefaultTransactionDefinition(); TransactionStatus status = transactionManager.getTransaction(def); try { userMapper.insertUser(user); userMapper.updateUser(user); transactionManager.commit(status); } catch (Exception e) { transactionManager.rollback(status); throw e; } } } 3. 使用 Java EE 容器的事务管理 # 在 Java EE 环境中，MyBatis 可以通过 JTA（Java Transaction API）与容器的事务管理器集成，通常通过 UserTransaction 或容器提供的其他机制管理事务。\n总结 # JDBC 事务管理：MyBatis 默认使用 JDBC 事务管理，手动控制事务。 Spring 事务管理：与 Spring 集成时，推荐使用 Spring 的事务管理，支持声明式和编程式事务。 Java EE 事务管理：在 Java EE 环境中，可通过 JTA 与容器的事务管理器集成。 选择合适的事务管理方式取决于应用场景和框架集成需求。\n我使用springboot框架，我在一个方法中使用mybatis提供的mapper方法插入了一条数据，但是我没有在方法上使用@Transactional注解，这种情况下有事务吗 2025-02-08 # 在 Spring Boot 中使用 MyBatis 时，如果你在一个方法中调用了 MyBatis 的 Mapper 方法插入数据，但没有在方法上使用 @Transactional 注解，那么默认情况下是没有事务管理的。具体表现如下：\n1. 没有事务的情况 # 如果没有 @Transactional 注解，Spring 不会为该方法开启事务。 每次调用 MyBatis 的 Mapper 方法时，MyBatis 会使用默认的 JDBC 行为，即自动提交（auto-commit）。 这意味着每次执行 SQL 语句（如插入、更新、删除）后，数据库会立即提交该操作，无法回滚。 2. 可能的风险 # 数据不一致：如果方法中有多个数据库操作（例如插入多条数据），其中一个操作失败，前面的操作已经提交，无法回滚，可能导致数据不一致。 缺乏事务控制：无法保证操作的原子性。 3. 如何验证没有事务 # 你可以通过以下方式验证：\n在方法中故意抛出异常，观察数据是否被插入。 如果没有事务，即使抛出异常，已经插入的数据也会被提交到数据库。 示例代码：\n@Service public class UserService { @Autowired private UserMapper userMapper; public void addUser(User user) { userMapper.insertUser(user); // 插入数据 throw new RuntimeException(\u0026#34;模拟异常\u0026#34;); // 抛出异常 } } 运行后，检查数据库，会发现 user 数据已经被插入，即使抛出了异常。\n4. 如何启用事务 # 如果你希望方法中的操作在一个事务中执行，可以通过以下方式启用事务管理：\n4.1 使用 @Transactional 注解 # 在方法上添加 @Transactional 注解，Spring 会为该方法开启事务。\n示例代码：\n@Service public class UserService { @Autowired private UserMapper userMapper; @Transactional public void addUser(User user) { userMapper.insertUser(user); // 插入数据 throw new RuntimeException(\u0026#34;模拟异常\u0026#34;); // 抛出异常 } } 运行后，检查数据库，会发现 user 数据没有被插入，因为事务回滚了。\n4.2 配置事务管理器 # 确保 Spring Boot 项目中已经配置了事务管理器（通常使用 DataSourceTransactionManager）。Spring Boot 会自动配置事务管理器，只要你引入了相关依赖（如 spring-boot-starter-data-jpa 或 mybatis-spring-boot-starter）。\n5. 总结 # 没有 @Transactional 注解：默认没有事务，每次 SQL 操作会立即提交。 需要事务：在方法上添加 @Transactional 注解，确保方法中的多个操作在同一个事务中执行，保证原子性。 验证事务：通过抛出异常的方式验证事务是否生效。 如果你希望方法中的操作具有事务性，务必使用 @Transactional 注解。\n什么是乐观锁、悲观锁 2025-02-08 # 乐观锁和悲观锁是并发控制中常用的两种策略，用于解决多个事务或线程同时访问和修改同一数据时可能引发的数据不一致问题。它们的核心区别在于对并发冲突的处理方式。\n1. 悲观锁（Pessimistic Locking） # 悲观锁假设并发冲突很可能发生，因此在访问数据时直接加锁，确保其他事务或线程无法修改数据，直到当前操作完成。\n实现方式 # 在数据库中，通常通过 SELECT ... FOR UPDATE 或 SELECT ... LOCK IN SHARE MODE 实现。 在代码中，可以通过 synchronized 关键字或 ReentrantLock 实现。 特点 # 优点：保证数据强一致性，适合写操作多的场景。 缺点：加锁会降低并发性能，可能导致死锁。 适用场景 # 写操作频繁，且并发冲突概率高的场景。 例如：银行转账、库存扣减等。 示例 # -- 数据库中使用悲观锁 BEGIN; SELECT * FROM account WHERE id = 1 FOR UPDATE; -- 加锁 UPDATE account SET balance = balance - 100 WHERE id = 1; COMMIT; 2. 乐观锁（Optimistic Locking） # 乐观锁假设并发冲突很少发生，因此在访问数据时不会加锁，而是在提交时检查数据是否被其他事务修改过。如果发现冲突，则回滚或重试。\n实现方式 # 通常通过版本号（Version）或时间戳（Timestamp）实现。 在数据库中，可以为表添加一个 version 字段，每次更新时检查版本号是否一致。 特点 # 优点：不加锁，提高并发性能，适合读操作多的场景。 缺点：冲突时需要回滚或重试，可能增加业务逻辑复杂度。 适用场景 # 读操作频繁，写操作较少的场景。 例如：电商库存、评论系统等。 示例 # -- 数据库中使用乐观锁 -- 表结构 CREATE TABLE product ( id INT PRIMARY KEY, name VARCHAR(50), stock INT, version INT -- 版本号字段 ); -- 更新操作 UPDATE product SET stock = stock - 1, version = version + 1 WHERE id = 1 AND version = 5; -- 检查版本号 在代码中，可以通过以下方式实现乐观锁：\npublic boolean updateProduct(Product product) { int rows = productMapper.updateProduct( product.getId(), product.getStock(), product.getVersion() ); if (rows == 0) { throw new OptimisticLockException(\u0026#34;数据已被修改，请重试\u0026#34;); } return true; } 3. 对比总结 # 特性 悲观锁 乐观锁 加锁时机 访问数据时立即加锁 提交时检查冲突 性能 低（加锁影响并发） 高（不加锁，冲突时回滚） 适用场景 写操作多，冲突概率高 读操作多，冲突概率低 实现复杂度 简单 较复杂（需处理冲突） 数据一致性 强一致性 最终一致性 4. 如何选择 # 如果业务场景中写操作频繁，且对数据一致性要求高，选择悲观锁。 如果业务场景中读操作频繁，且冲突概率低，选择乐观锁。 5. 实际应用中的注意事项 # 悲观锁：注意死锁问题，避免长时间持有锁。 乐观锁：需要设计重试机制，处理冲突时的回滚或重试逻辑。 通过合理选择锁机制，可以在保证数据一致性的同时，最大化系统的并发性能。\n"},{"id":6,"href":"/zh/post/computer-science/computer-science-recommend/","title":"推荐","section":"Computer Science","content":" 推荐 # github alex-shpak/hugo-book 这个博客就是用这个项目搭建的 hacker news 有很多关于计算机相关的文章，每天都会更新 资源下载相关 pingf/annie 可以用来下载B站视频 yt-dlp/yt-dlp 下载 youtube 视频 yutto-dev/bilili 下载 bilibili 视频(项目已经归档不再维护,目前还能用，可以使用yutto) yutto-dev/yutto 卡码笔记 代码随想录的网站，里面整理了一些计算机相关的知识点（非算法相关） segment fault blog # 阮一峰的网络日志 王垠 github # yihong0618 Large Language Model(LLM) # 通义千问 "},{"id":7,"href":"/zh/zh/post/computer-science/computer-science-recommend/","title":"推荐","section":"Computer Science","content":" 推荐 # github alex-shpak/hugo-book 这个博客就是用这个项目搭建的 hacker news 有很多关于计算机相关的文章，每天都会更新 资源下载相关 pingf/annie 可以用来下载B站视频 yt-dlp/yt-dlp 下载 youtube 视频 yutto-dev/bilili 下载 bilibili 视频(项目已经归档不再维护,目前还能用，可以使用yutto) yutto-dev/yutto 卡码笔记 代码随想录的网站，里面整理了一些计算机相关的知识点（非算法相关） segment fault blog # 阮一峰的网络日志 王垠 github # yihong0618 Large Language Model(LLM) # 通义千问 "},{"id":8,"href":"/zh/post/life/movies-log/","title":"观影记录","section":"Life","content":" 观影记录 # 2025 # 2025-01-12 敦煌 1 2025-01-12 2 2025-01-15 3 2025-01-16 4 2025-01-18 5 2025-01-20 6 `` 7 `` 8 `` 9 `` 10 `` 2025-01-11 如果国宝会说话 第四季 东京爱情故事 1 2025-01-11 2 2025-01-12 3 2025-01-13 4 2025-01-15 5 2025-01-16 6 2025-01-17 7 2025-01-18 8 2025-01-19 9 2025-01-20 10 2025-01-22 11 `` 2025-01-10 飞屋环游记 2025-01-07 如果国宝会说话 第三季 2025-01-04 如果国宝会说话 第二季 2025-01-03 辛德勒的名单（2） 2025-01-02 四重奏 1 2025-01-02 2 2025-01-03 3 2025-01-04 4 2025-01-05 5 2025-01-06 6 2025-01-07 7 2025-01-08 8 2025-01-09 9 2025-01-10 10 2025-01-10 2025-01-01 如果国宝会说话 第一季 2024 # 2024-12-01 金色梦乡 2024-11-30 Better Call Saul S04E07 2024-11-29 Better Call Saul S04E06 2024-11-28 Better Call Saul S04E05 2024-11-27 Better Call Saul S04E03-04 2024-11-26 Better Call Saul S04E01-02 2024-11-25 Better Call Saul S03E09-10 2024-11-23 热血警探 铁雨 ⭐⭐⭐⭐ 2024-11-18 东邪西毒 终极版 2024-11-17 甲方乙方 2024-11-16 正义回廊 ⭐⭐⭐⭐ 有话好好说 ⭐⭐⭐⭐ 2024-11-15 Better Call Saul S03E07 Better Call Saul S03E08 2024-11-14 Better Call Saul S03E06 2024-11-13 Better Call Saul S03E05 2024-11-12 Better Call Saul S03E04 2024-11-12 Better Call Saul S03E02 Better Call Saul S03E03 2024-10-24 哈利波特与死亡圣器 下 2024-10-23 哈利波特与死亡圣器 上 2024-10-22 哈利波特与混血王子 2024-10-20 哈利波特与凤凰社 哈利波特与火焰杯 哈利波特与阿兹卡班的囚徒 2024-10-19 哈利波特与密室 哈利波特与魔法石 2024-10-07 燃情岁月 ⭐⭐⭐⭐ 抓娃娃 2024-10-06 赛德克巴莱 2024-10-05 名侦探柯南：百万美元的五棱星 2024-10-04 年会不能停 2024-09-17 市场法则 过季 ⭐⭐⭐⭐ 完美的日子 ⭐⭐⭐⭐⭐ 2024-09-15 幽灵公主 鬼灭之刃 那田蜘蛛山篇 鬼灭之刃 柱训练篇 鬼灭之刃 锻刀村篇 2024-09-08 不要抬头 2024-08-18 一部关于咖啡的电影 2024-07-14 鬼灭之刃 游郭篇 鬼灭之刃 无限列车篇 2024-07-07 朗读者 2024-06-15 环法自行车赛：逆风飞驰 第二季 2024-06-09 江湖儿女 2024-05-19 红猪 2024-05-12 繁花 2024-05-04 极速车王 2024-05-03 大佛普拉斯 芝加哥七君子审判 2024-04-22 寻梦环游记 2024-04-21 你想活出怎样的人生 2024-04-06 黄海 逃离乌托邦 2024-04-04 坠落的审判 2024-03-15 周处除三害 2024-03-13 巾帼枭雄之义海豪情 2024-02-20 新闻女王 2024-02-18 飞驰人生2 2024-02-09 阿尔法围棋 哈利波特20周年：回到霍格沃茨 2024-02-08 三大队 2024-01-20 土拨鼠之日 2024-01-10 请回答1988 2023 # 2023年5月2日 婚姻生活 2023年4月29日 惠子，凝视 ⭐⭐⭐⭐ 2023年3月18日 黑暗荣耀 第二季 2023年3月05日 乒乓 2023年2月12日 健听女孩 2023年1月30日 黑匣子 2023年1月29日 巴斯克·斯克鲁格斯的歌谣 2023年1月27日 马拉多纳2019 2023年1月26日 马拉多纳之死 2023年1月26日 打扰伯格曼 2023年1月26日 误杀瞒天记 2023年1月26日 我即闪电 2023年1月25日 风骚律师 第六季 ⭐⭐⭐⭐⭐ 2023年1月25日 宿敌 2023年1月24日 互联网之子 2023年1月22日 互联网之子 2023年1月22日 万圣节的新娘 2023年1月22日 伊卡洛斯 2023年1月22日 老师，您能坐我旁边吗？ 2022 # 2022年10月07日 真相捕捉 第二季 2022年10月03日 黑洞 2022年09月10日 六号车厢 ⭐⭐⭐⭐ 2022年08月10日 我的天才女友 第三季 2022年07月31日 命运喜欢恶作剧 2022年07月30日 人生大事 2022年07月26日 渔业阴谋 2022年02月08日 Tinder诈骗王 2022年02月07日 亢奋 第一季 2022年02月03日 情事 2022年02月03日 火口的两人 2022年02月03日 激情 2022年02月02日 偶然与想象 2022年02月02日 东城梦魇 2022年02月01日 2020去死 2022年01月31日 瀑布 2022年01月31日 天注定 2022年01月30日 T省的 84·85年 2022年01月30日 天道 2022年01月20日 405谋杀案 2022年01月19日 背靠背，脸对脸 2022年01月18日 黑炮事件 2022年01月17日 成瘾剂量 2022年01月09日 驾驶我的车 ⭐⭐⭐⭐ 2022年01月01日 踏雪寻梅 2021 # 2021年12月26日 困在时间里的父亲 2021年11月19日 扬名立万 2021年11月13日 不老奇事 2021年10月31日 沙丘 2021年10月31日 007:无暇赴死 2021年10月16日 长津湖 2021年10月10日 吗啡 2021年09月25日 峰爆 2021年09月22日 教室里的一头牦牛 2021年09月20日 无依之地 2021年09月03日 失控玩家 2021年08月29日 让子弹飞 2021年08月15日 心灵奇旅 2021年08月10日 脸庞，村庄 2021年08月07日 沉默的真相 2021年08月02日 隐秘的角落 2021年07月31日 花束般的恋爱 2021年07月30日 热带往事 2021年07月30日 大阪直美 2021年07月26日 俗女养成记 2021年07月07日 巴萨提的颜色 2021年07月04日 真心半解 2021年06月11日 过把瘾 2021年06月08日 射雕英雄传 2021年05月27日 茶馆 2021年05月16日 人间的条件 5,6 2021年05月15日 人间的条件 3,4 2021年05月14日 热带雨 人间的条件 1,2 2021年05月13日 南海十三郎 2021年05月11日 笨鸟 2021年05月10日 无言的山丘 2021年05月09日 恐怖分子 2021年05月08日 海滩的一日 2021年05月08日 麻将 2021年05月07日 青梅竹马 盲山 万箭穿心 2021年05月06日 倒霉性爱，发狂黄片 2021年05月05日 龙争虎斗 零水日 2021年05月04日 若水 2021年05月04日 剩女 2021-04-13 盗火者：中国教育改革调查 others # 【风骚律师杂谈】我爱你——86年 "},{"id":9,"href":"/zh/zh/post/life/movies-log/","title":"观影记录","section":"Life","content":" 观影记录 # 2025 # 2025-01-12 敦煌 1 2025-01-12 2 2025-01-15 3 2025-01-16 4 2025-01-18 5 2025-01-20 6 `` 7 `` 8 `` 9 `` 10 `` 2025-01-11 如果国宝会说话 第四季 东京爱情故事 1 2025-01-11 2 2025-01-12 3 2025-01-13 4 2025-01-15 5 2025-01-16 6 2025-01-17 7 2025-01-18 8 2025-01-19 9 2025-01-20 10 2025-01-22 11 `` 2025-01-10 飞屋环游记 2025-01-07 如果国宝会说话 第三季 2025-01-04 如果国宝会说话 第二季 2025-01-03 辛德勒的名单（2） 2025-01-02 四重奏 1 2025-01-02 2 2025-01-03 3 2025-01-04 4 2025-01-05 5 2025-01-06 6 2025-01-07 7 2025-01-08 8 2025-01-09 9 2025-01-10 10 2025-01-10 2025-01-01 如果国宝会说话 第一季 2024 # 2024-12-01 金色梦乡 2024-11-30 Better Call Saul S04E07 2024-11-29 Better Call Saul S04E06 2024-11-28 Better Call Saul S04E05 2024-11-27 Better Call Saul S04E03-04 2024-11-26 Better Call Saul S04E01-02 2024-11-25 Better Call Saul S03E09-10 2024-11-23 热血警探 铁雨 ⭐⭐⭐⭐ 2024-11-18 东邪西毒 终极版 2024-11-17 甲方乙方 2024-11-16 正义回廊 ⭐⭐⭐⭐ 有话好好说 ⭐⭐⭐⭐ 2024-11-15 Better Call Saul S03E07 Better Call Saul S03E08 2024-11-14 Better Call Saul S03E06 2024-11-13 Better Call Saul S03E05 2024-11-12 Better Call Saul S03E04 2024-11-12 Better Call Saul S03E02 Better Call Saul S03E03 2024-10-24 哈利波特与死亡圣器 下 2024-10-23 哈利波特与死亡圣器 上 2024-10-22 哈利波特与混血王子 2024-10-20 哈利波特与凤凰社 哈利波特与火焰杯 哈利波特与阿兹卡班的囚徒 2024-10-19 哈利波特与密室 哈利波特与魔法石 2024-10-07 燃情岁月 ⭐⭐⭐⭐ 抓娃娃 2024-10-06 赛德克巴莱 2024-10-05 名侦探柯南：百万美元的五棱星 2024-10-04 年会不能停 2024-09-17 市场法则 过季 ⭐⭐⭐⭐ 完美的日子 ⭐⭐⭐⭐⭐ 2024-09-15 幽灵公主 鬼灭之刃 那田蜘蛛山篇 鬼灭之刃 柱训练篇 鬼灭之刃 锻刀村篇 2024-09-08 不要抬头 2024-08-18 一部关于咖啡的电影 2024-07-14 鬼灭之刃 游郭篇 鬼灭之刃 无限列车篇 2024-07-07 朗读者 2024-06-15 环法自行车赛：逆风飞驰 第二季 2024-06-09 江湖儿女 2024-05-19 红猪 2024-05-12 繁花 2024-05-04 极速车王 2024-05-03 大佛普拉斯 芝加哥七君子审判 2024-04-22 寻梦环游记 2024-04-21 你想活出怎样的人生 2024-04-06 黄海 逃离乌托邦 2024-04-04 坠落的审判 2024-03-15 周处除三害 2024-03-13 巾帼枭雄之义海豪情 2024-02-20 新闻女王 2024-02-18 飞驰人生2 2024-02-09 阿尔法围棋 哈利波特20周年：回到霍格沃茨 2024-02-08 三大队 2024-01-20 土拨鼠之日 2024-01-10 请回答1988 2023 # 2023年5月2日 婚姻生活 2023年4月29日 惠子，凝视 ⭐⭐⭐⭐ 2023年3月18日 黑暗荣耀 第二季 2023年3月05日 乒乓 2023年2月12日 健听女孩 2023年1月30日 黑匣子 2023年1月29日 巴斯克·斯克鲁格斯的歌谣 2023年1月27日 马拉多纳2019 2023年1月26日 马拉多纳之死 2023年1月26日 打扰伯格曼 2023年1月26日 误杀瞒天记 2023年1月26日 我即闪电 2023年1月25日 风骚律师 第六季 ⭐⭐⭐⭐⭐ 2023年1月25日 宿敌 2023年1月24日 互联网之子 2023年1月22日 互联网之子 2023年1月22日 万圣节的新娘 2023年1月22日 伊卡洛斯 2023年1月22日 老师，您能坐我旁边吗？ 2022 # 2022年10月07日 真相捕捉 第二季 2022年10月03日 黑洞 2022年09月10日 六号车厢 ⭐⭐⭐⭐ 2022年08月10日 我的天才女友 第三季 2022年07月31日 命运喜欢恶作剧 2022年07月30日 人生大事 2022年07月26日 渔业阴谋 2022年02月08日 Tinder诈骗王 2022年02月07日 亢奋 第一季 2022年02月03日 情事 2022年02月03日 火口的两人 2022年02月03日 激情 2022年02月02日 偶然与想象 2022年02月02日 东城梦魇 2022年02月01日 2020去死 2022年01月31日 瀑布 2022年01月31日 天注定 2022年01月30日 T省的 84·85年 2022年01月30日 天道 2022年01月20日 405谋杀案 2022年01月19日 背靠背，脸对脸 2022年01月18日 黑炮事件 2022年01月17日 成瘾剂量 2022年01月09日 驾驶我的车 ⭐⭐⭐⭐ 2022年01月01日 踏雪寻梅 2021 # 2021年12月26日 困在时间里的父亲 2021年11月19日 扬名立万 2021年11月13日 不老奇事 2021年10月31日 沙丘 2021年10月31日 007:无暇赴死 2021年10月16日 长津湖 2021年10月10日 吗啡 2021年09月25日 峰爆 2021年09月22日 教室里的一头牦牛 2021年09月20日 无依之地 2021年09月03日 失控玩家 2021年08月29日 让子弹飞 2021年08月15日 心灵奇旅 2021年08月10日 脸庞，村庄 2021年08月07日 沉默的真相 2021年08月02日 隐秘的角落 2021年07月31日 花束般的恋爱 2021年07月30日 热带往事 2021年07月30日 大阪直美 2021年07月26日 俗女养成记 2021年07月07日 巴萨提的颜色 2021年07月04日 真心半解 2021年06月11日 过把瘾 2021年06月08日 射雕英雄传 2021年05月27日 茶馆 2021年05月16日 人间的条件 5,6 2021年05月15日 人间的条件 3,4 2021年05月14日 热带雨 人间的条件 1,2 2021年05月13日 南海十三郎 2021年05月11日 笨鸟 2021年05月10日 无言的山丘 2021年05月09日 恐怖分子 2021年05月08日 海滩的一日 2021年05月08日 麻将 2021年05月07日 青梅竹马 盲山 万箭穿心 2021年05月06日 倒霉性爱，发狂黄片 2021年05月05日 龙争虎斗 零水日 2021年05月04日 若水 2021年05月04日 剩女 2021-04-13 盗火者：中国教育改革调查 others # 【风骚律师杂谈】我爱你——86年 "},{"id":10,"href":"/zh/post/computer-science/computer-science-learning-log/","title":"学习记录","section":"Computer Science","content":" 学习记录 # 2025-01-17 # 剑指Offer Book # 剑指Offer 第1章 面试的流程 1 # 1.1 面试官谈面试 1 1.2 面试的三种形式 2 1.2.1 电话面试 2 1.2.2 共享桌面远程面试 3 1.2.3 现场面试 4 1.3 面试的三个环节 5 1.3.1 行为面试环节 5 应聘者的项目经验 6 应聘者掌握的技能 7 回答“为什么跳槽” 8 1.3.2 技术面试环节 10 扎实的基础知识 10 高质量的代码 11 清晰的思路 14 优化效率的能力 15 优秀的综合能力 16 1.3.3 应聘者提问环节 17 1.4 本章小结 18 第2章 面试需要的基础知识 20 # 2.1 面试官谈基础知识 20 2.2 编程语言 22 2.2.1 C++ 22 面试题1：赋值运算符函数 24 经典的解法，适用于初级程序员 25 考虑异常安全性的解法，高级程序员必备 26 2.2.2 C# 27 面试题2：实现Singleton模式 31 不好的解法一：只适用于单线程 31 不好的解法二：可用于多线程但效率不高 32 可行的解法：同步锁前后两次判断 33 推荐的解法一：利用静态构造函数 34 推荐的解法二：按需创建实例 34 解法比较 35 2.3 数据结构 36 2.3.1 数组 36 面试题3：二维数组中的查找 38 2.3.2 字符串 42 面试题4：替换空格 44 O(n2)的解法，不足以拿到Offer 45 O(n)的解法，搞定Offer就靠它 46 2.3.3 链表 49 面试题5：从尾到头打印链表 51 2.3.4 树 53 面试题6：重建二叉树 55 2.3.5 栈和队列 58 面试题7：用两个栈实现队列 59 2.4 算法和数据操作 62 2.4.1 查找和排序 63 面试题8：旋转数组的最小数字 66 2.4.2 递归和循环 71 面试题9：斐波那契数列 73 效率很低的解法，面试官不会喜欢 73 面试官期待的实用解法 74 O(logn)但不够实用的解法 74 解法比较 75 2.4.3 位运算 77 面试题10：二进制中1的个数 78 可能引起死循环的解法 79 常规解法 79 能给面试官带来惊喜的解法 80 2.5 本章小结 82 第3章 高质量的代码 84 # 3.1 面试官谈代码质量 84 3.2 代码的规范性 86 3.3 代码的完整性 87 从3方面确保代码的完整性 87 3种错误处理的方法 88 面试题11：数值的整数次方 90 自以为题目简单的解法 90 全面但不够高效的解法，离Offer已经很近了 90 全面又高效的解法，确保能拿到Offer 92 面试题12：打印1到最大的n位数 94 跳进面试官陷阱 94 在字符串上模拟数字加法 94 把问题转换成数字排列 97 面试题13：在O(1)时间删除链表结点 99 面试题14：调整数组顺序使奇数位于偶数前面 102 只完成基本功能的解法，仅适用于初级程序员 102 考虑可扩展性的解法，能秒杀Offer 104 3.4 代码的鲁棒性 106 面试题15：链表中倒数第k个结点 107 面试题16：反转链表 112 面试题17：合并两个排序的链表 114 面试题18：树的子结构 117 3.5 本章小结 121 第4章 解决面试题的思路 123 # 4.1 面试官谈面试思路 123 面试题19：二叉树的镜像 125 4.2 画图让抽象问题形象化 125 面试题20：顺时针打印矩阵 127 4.3 举例让抽象问题具体化 131 面试题21：包含min函数的栈 132 面试题22：栈的压入、弹出序列 134 面试题23：从上往下打印二叉树 137 面试题24：二叉搜索树的后序遍历序列 140 面试题25：二叉树中和为某一值的路径 143 4.4 分解让复杂问题简单化 146 面试题26：复杂链表的复制 147 面试题27：二叉搜索树与双向链表 151 面试题28：字符串的排列 154 4.5 本章小结 158 第5章 优化时间和空间效率 160 # 5.1 面试官谈效率 160 5.2 时间效率 162 面试题29：数组中出现次数超过一半的数字 163 基于Partition函数的O(n)算法 163 利用数组特点的O(n)算法 165 解法比较 166 面试题30：最小的k个数 167 O(n)的算法，只当可以修改输入数组时可用 167 O(nlogk)的算法，适合处理海量数据 168 解法比较 169 面试题31：连续子数组的最大和 171 举例分析数组的规律 171 应用动态规划法 173 面试题32：从1到n整数中1出现的次数 174 不考虑效率的解法，想拿Offer有点难 174 明显提高效率的解法，让面试官耳目一新 175 面试题33：把数组排成最小的数 177 5.3 时间效率与空间效率的平衡 181 面试题34：丑数 182 逐个判断整数是不是丑数的解法 182 创建数组保存已经找到的丑数的解法 183 面试题35：第一个只出现一次的字符 186 面试题36：数组中的逆序对 189 面试题37：两个链表的第一个公共结点 193 5.4 本章小结 196 第6章 面试中的各项能力 198 # 6.1 面试官谈能力 198 6.2 沟通能力和学习能力 200 沟通能力 200 学习能力 200 善于学习、沟通的人也善于提问 201 6.3 知识迁移能力 203 面试题38：数字在排序数组中出现的次数 204 面试题39：二叉树的深度 207 重复遍历结点的解法，不足以打动面试官 209 只遍历结点一次的解法，正是面试官喜欢的 209 面试题40：数组中只出现一次的数字 211 面试题41：和为s的两个数字VS和为s的连续正数序列 214 面试题42：翻转单词顺序 VS左旋转字符串 218 6.4 抽象建模能力 222 面试题43：n个骰子的点数 223 基于递归求骰子点数，时间效率不够高 223 基于循环求骰子点数，时间性能好 224 面试题44：扑克牌的顺子 226 面试题45：圆圈中最后剩下的数字 228 经典的解法，用循环链表模拟圆圈 229 创新的解法，拿到Offer不在话下 230 6.5 发散思维能力 232 面试题46：求1+2+…+n 233 利用构造函数求解 234 利用虚函数求解 234 利用函数指针求解 235 利用模板类型求解 236 面试题47：不用加减乘除做加法 237 面试题48：不能被继承的类 239 常规的解法：把构造函数设为私有函数 239 新奇的解法：利用虚拟继承 240 6.6 本章小结 241 第7章 两个面试案例 243 # 7.1 案例一：（面试题49）把字符串转换成整数 244 7.2 案例二：（面试题50）树中两个结点的最低公共祖先 252 第8章 英文版新增面试题 261 # 8.1 数组 261 面试题51：数组中重复的数字 261 面试题52：构建乘积数组 263 8.2 字符串 265 面试题53：正则表达式匹配 265 面试题54：表示数值的字符串 267 面试题55：字符流中第一个不重复的字符 269 8.3 链表 270 面试题56：链表中环的入口结点 270 面试题57：删除链表中重复的结点 273 8.4 树 275 面试题58：二叉树的下一个结点 275 面试题59：对称的二叉树 277 面试题60：把二叉树打印成多行 278 面试题61：按之字形顺序打印二叉树 280 面试题62：序列化二叉树 283 面试题63：二叉搜索树的第k个结点 285 面试题64：数据流中的中位数 286 8.5 栈和队列 290 面试题65：滑动窗口的最大值 290 8.6 回溯法 294 面试题66：矩阵中的路径 294 面试题67：机器人的运动范围 296 2025-01-11 # leetcode 刷题 # 面试经典150题 # 面试经典150题 数组/字符串 # 合并两个有序数组 2025-01-12 移除元素 2025-01-11 删除有序数组中的重复项 2025-01-11 没有做出来，看的官方题解 2025-01-11 做完删除有序数组中的重复项 II之后再尝试重新解题完成 删除有序数组中的重复项 II 2025-01-11 多数元素 2025-01-12 轮转数组 2025-01-18 进阶 尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 买卖股票的最佳时机 2025-01-11 看官方题解做出来的 2025-01-17 review 买卖股票的最佳时机 II 官方题解 理解 2025-01-17 方法一：动态规划 方法二：贪心 跳跃游戏 2025-01-17 官方题解理解 贪心 2025-01-18 跳跃游戏 II 2025-01-18 算法超时了 理解官方题解 2025-01-18 方法一：反向查找出发位置 Solution45.jump2 2025-01-18 方法二：正向查找可达到的最大位置 Solution45.jump3 H 指数 2025-01-18 Tips An easy approach is to sort the array first. What are the possible values of h-index? A faster approach is to use extra space. O(1) 时间插入、删除和获取随机元素 除自身以外数组的乘积 加油站 分发糖果 接雨水 罗马数字转整数 2025-01-12 整数转罗马数字 最后一个单词的长度 2025-01-12 最长公共前缀 2025-01-12 反转字符串中的单词 2025-01-18 进阶 如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。 Z 字形变换 找出字符串中第一个匹配项的下标 2025-01-12 文本左右对齐 双指针 # 验证回文串 2025-01-13 判断子序列 2025-01-13 两数之和 II - 输入有序数组 2025-01-13 运行有时候会超过时间限制 盛最多水的容器 三数之和 滑动窗口 # 长度最小的子数组 2025-01-22 无重复字符的最长子串 2025-01-22 串联所有单词的子串 2025-01-22 最小覆盖子串 矩阵 # 有效的数独 2025-01-18 螺旋矩阵 2025-01-18 旋转图像 理解官方题解 2025-01-18 方法一：使用辅助数组 2025-01-18 方法二：原地旋转 有数学公式的推导，需要自己推导一次 2025-01-18 方法三：用翻转代替旋转 有数学公式的推导，需要自己推导一次 矩阵置零 2025-01-18 生命游戏 2025-01-18 进阶 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？ ✅ 哈希表 # 赎金信 2025-01-13 同构字符串 2025-01-13 单词规律 2025-01-13 有效的字母异位词 2025-01-13 字母异位词分组 2025-01-16 第一遍算法超时，看了官方题解思路后实现通过 两数之和 2025-01-13 快乐数 2025-01-13 存在重复元素 II 2025-01-13 最长连续序列 2025-01-16 看了官方题解后完成 区间 # 栈 # 有效的括号 2025-01-22 简化路径 2025-01-22 最小栈 2025-01-22 理解官方题解 文字描述后完成 2025-01-22 理解官方题解 逆波兰表达式求值 2025-01-22 基本计算器 链表 # 环形链表 2025-01-20 理解官方题解 2025-01-20 方法一：哈希表 方法二：快慢指针 两数相加 2025-01-20 合并两个有序链表 2025-01-20 随机链表的复制 2025-01-20 反转链表 II 2025-01-20 K 个一组翻转链表 删除链表的倒数第 N 个结点 2025-01-20 进阶 2025-01-20 你能尝试使用一趟扫描实现吗？ 删除排序链表中的重复元素 II 2025-01-21 旋转链表 2025-01-20 分隔链表 2025-01-21 LRU 缓存 2025-01-22 理解官方题解 二叉树 # 二叉树的最大深度 2025-01-15 相同的树 2025-01-15 翻转二叉树 2025-01-15 对称二叉树 没做出来，看的官方题解 从前序与中序遍历序列构造二叉树 从中序与后序遍历序列构造二叉树 填充每个节点的下一个右侧节点指针 II 二叉树展开为链表 路径总和 求根节点到叶节点数字之和 二叉树中的最大路径和 二叉搜索树迭代器 完全二叉树的节点个数 二叉树的最近公共祖先 二叉树层次遍历 # 二叉搜索树 # 图 # 图的广度优先搜索 # 字典树 # ✅ 回溯 # 电话号码的字母组合 2025-01-15 组合 2025-01-15 全排列 2025-01-15 组合总和 2025-01-15 N 皇后 II 2025-01-15 括号生成 2025-01-15 单词搜索 2025-01-15 分治 # kadane算法 # 二分查找 # 堆 # 位运算 # 二进制求和 2025-01-16 颠倒二进制位 2025-01-16 没做出来, 参考这篇文章LeetCode 190. 颠倒二进制位 （位运算 分治） 2025-01-17 复习了一遍 2025-01-17 新增了中间值打印的代码在算法中 位1的个数 2025-01-17 只出现一次的数字 2025-01-17 只出现一次的数字 II 2025-01-17 理解了官方题解 方法2 数字范围按位与 2025-01-17 理解了官方题解 方法2 数学 # 回文数 2025-01-17 不将整数转为字符串来解决这个问题 加一 2025-01-17 阶乘后的零 2025-01-17 x 的平方根 2025-01-17 Pow(x, n) 2025-01-17 超时了 2025-01-17 看懂了官方题解 直线上最多的点数 2025-01-17 看了官方题解，但还是不太理解 一维动态规划 # 爬楼梯 2025-01-11 通过 多维动态规划 # 2025-01-09 # ✅ Spring实战 第6版 Book # 第1章 Spring 起步 1.1 什么是Spring 2025-01-09 1.2 初始化 spring 应用 2025-01-09 1.3 编写 Spring 应用 2025-01-09 1.4 俯瞰 Spring 风景线 2025-01-09 第2章 2.1 展现信息 2025-01-09 2.2 处理表单提交 2025-01-09 2.3 校验表单输入 2025-01-09 2.4 使用视图控制器 2025-01-09 2.5 选择视图模板库 2025-01-09 第3章 使用数据 3.1 2025-01-09 3.2 2025-01-11 3.3 2025-01-11 第4章 使用非关系型数据 4.1 2025-01-11 4.2 2025-01-11 第5章 保护Spring 5.1 2025-01-11 5.2 2025-01-11 5.3 2025-01-11 5.4 2025-01-11 5.5 2025-01-12 第6章 使用配置属性 6.1 2025-01-12 6.2 2025-01-12 6.3 2025-01-12 第7章 创建REST服务 7.1 2025-01-12 7.2 2025-01-12 7.3 2025-01-12 第8章 保护REST 8.1 2025-01-12 8.2 2025-01-12 8.3 2025-01-12 8.4 2025-01-12 第9章 发送异步消息 9.1 2025-01-13 9.2 2025-01-13 9.3 2025-01-13 第10章 Spring集成 10.1 2025-01-13 10.2 2025-01-13 10.3 2025-01-13 第11章 理解反应式编程 11.1 2025-01-13 11.2 2025-01-13 11.3 2025-01-13 第12章 开发反应式API 12.1 2025-01-13 12.2 2025-01-13 12.3 2025-01-13 12.4 2025-01-13 12.5 2025-01-13 第13章 反应式持久化数据 13.1 2025-01-14 13.2 2025-01-14 13.3 2025-01-14 第14章 使用RSocket 14.1 2025-01-14 14.2 2025-01-15 14.3 2025-01-15 第15章 部署Spring 15.1 2025-01-15 15.2 2025-01-15 15.3 2025-01-15 15.4 2025-01-15 第16章 管理Spring 16.1 2025-01-15 16.2 2025-01-15 16.3 2025-01-15 第17章 使用JMX监控Spring 17.1 2025-01-15 17.2 2025-01-15 17.3 2025-01-15 第18章 部署Spring 18.1 2025-01-15 18.2 2025-01-15 18.3 2025-01-15 18.4 2025-01-15 18.5 2025-01-15 JavaGuide 文档阅读 # JavaGuide 必看 面试准备 Java 计算机基础 数据库 开发工具 常用框架 Spring\u0026amp;Spring Boot MyBatis常见面试题总结 2025-01-09 太过总结性，需要看一些更基础的文章 Netty常见面试题总结 系统设计 分布式 高性能 高可用 2025-01-08 # 计算机教育中缺失的学期 # 计算机教育中缺失的学期 阮一峰博客阅读 # 阮一峰的网络日志 散文 观点与感想 算法与数学 开发者手册 理解计算机 JavaScript 计算机行业历史 周刊 创业 译文集 2025-01-05 # spring 基础知识点 视频 # B站大学终于把Spring做成动画片了，一周刷爆，2024最新版，学完即可面试，拿走不谢，学不会我退出IT圈！ 1 2025-01-05 Spring 是如何整合MyBatis管理Mapper接口的 2025-01-05 2 2025-01-06 3 2025-01-06 4 2025-01-06 5 2025-01-06 6 2025-01-06 7 2025-01-06 8 2025-01-06 9 2025-01-06 10 2025-01-06 11 (January 6, 2025 at 18:43:04 GMT+8) 12 (January 6, 2025 at 18:50:57 GMT+8) 13 (January 6, 2025 at 18:57:05 GMT+8) 14 (January 6, 2025 at 18:59:15 GMT+8) 15 2025-01-07 16 2025-01-07 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 100 2025-01-03 # 代码随想录 视频 # 代码随想录 数组 # 链表 # 哈希表 # 字符串 # 栈与队列 # 二叉树 # 1 理论基础 2025-01-09 2 递归遍历 (Leetcode 144, 145, 94) 2025-01-09 3 非递归遍历 2025-01-09 4 非递归遍历-中序 2025-01-11 5 层序遍历（广度优先搜索） 6 翻转二叉树 7 对称二叉树 8 二叉树的最大深度 9 二叉树的最小深度 10 完全二叉树节点的数量 11 平衡二叉树 12 二叉树的所有路径 13 左叶子之和 14 找左下角的值 15 路径总和 16 从中序和后序遍历序列构造二叉树 17 最大二叉树 18 合并二叉树 19 二叉搜索树中的搜索 (Leetcode 700) 2025-01-08 20 验证二叉搜索树 (Leetcode 98) 2025-01-08 21 二叉搜索树的最小绝对差 (Leetcode 530) 2025-01-08 22 二叉搜索树中的众数(Leetcode 501) 2025-01-09 23 二叉树的最近公共祖先(Leetcode 236) 2025-01-09 24 二叉搜索树的最近公共祖先 2025-01-09 25 二叉搜索树中的插入操作(Leetcode 701) 2025-01-09 26 删除二叉搜索树中的节点(Leetcode 450) 2025-01-09 27 修剪二叉搜索树 (Leetcode 669) 2025-01-09 28 将有序数组转换为二叉搜索树 (Leetcode 108) 2025-01-09 29 把二叉搜索树转换为累加树(Leetcode 538) 2025-01-09 ✅ 回溯法 # 1 理论篇 2025-01-03 2 组合问题（对应力扣题目：77.组合） 2025-01-03 3 组合问题的剪枝操作（对应力扣题目：77.组合）2025-01-03 4 回溯算法如何剪枝？| LeetCode：216.组合总和III 2025-01-03 5 LeetCode：17.电话号码的字母组合 2025-01-03 6 组合总和（对应「leetcode」力扣题目：39.组合总和） 2025-01-03 7 LeetCode:40.组合总和II 2025-01-03 8 分割回文串 2025-01-04 9 复原IP地址 2025-01-04 10 子集 （Leetcode 78） 2025-01-04 11 子集2（Leetcode 90） 2025-01-04 12 递增子序列（Leetcode 491） 2025-01-04 13 全排列（Leetcode 46） 2025-01-04 14 全排列2（Leetcode 47）2025-01-04 15 N皇后（Leetcode 51） 2025-01-05 16 解数独（Leetcode 37） 2025-01-05 ✅ 贪心算法 # 理论基础 2025-01-05 1 分发饼干 leetcode 455 2025-01-05 2 摆动序列 Leetcode 376 2025-01-05 3 最大子序和 2025-01-06 4 买卖股票最佳时机2 2025-01-06 5 跳跃游戏（Leetcode 55） 2025-01-06 6 跳跃游戏2 （Leetcode 45） 2025-01-06 这道题没听懂 7 K次取反后最大化的数组和 （Leetcode 1005） 2025-01-06 8 加油站（Leetcode 134） 2025-01-06 9 分发糖果（Leetcode 135） 2025-01-06 10 柠檬水找零（Leetcode 860） 2025-01-06 11 根据身高重建队列（Leetcode 406） 2025-01-06 12 用最少数量的箭引爆气球(Leetcode 452) 2025-01-06 13 无重叠区间(Leetcode 435) 2025-01-06 14 划分字母区间 (Leetcode 763) 2025-01-06 15 合并区间 （Leetcode 56） (January 7, 2025 at 15:18:40 GMT+8) 16 单调自增的数字（Leetcode 738）(January 7, 2025 at 15:41:59 GMT+8) 17 监督二叉树（Leetcode 968） (January 7, 2025 at 16:11:51 GMT+8) 动态规划 # 1 理论基础 (January 7, 2025 at 16:34:49 GMT+8) 2 斐波那契数列 （Leetcode 509） (January 7, 2025 at 16:46:54 GMT+8) 3 爬楼梯（Leetcode 70） (January 7, 2025 at 16:57:46 GMT+8) 4 使用最小花费爬楼梯 (Leetcode 746) 2025-01-08 5 不同路径 2025-01-08 6 不同路径2 (Leetcode 63) 2025-01-08 7 整数拆分 (Leetcode 343) 2025-01-08 这道题没太听懂 8 不同的二叉搜索树（Leetcode 96） 9 0-1背包问题理论基础 10 0-1背包问题之滚动数组 11 分割等和子集 12 最后一块石头的重量2 13 目标和 14 一和零 15 完全背包理论基础 16 零钱兑换2 17 组合综合4 18 零钱兑换 19 完全平方数 20 单词拆分 21 打家劫舍 22 打家劫舍2 23 打家劫舍3 24 买卖股票的最佳时机1 25 买卖股票的最佳时机2 26 买卖股票的最佳时机3 27 买卖股票的最佳时机4 28 买卖股票的最佳时机含冷冻期 29 买卖股票的最佳时机含手续费 30 最长递增子序列 31 最长连续递增序列 32 最长重复子数组 33 最长公共子序列 34 不相交的线 35 最大子序和 36 判断子序列 37 不同的子序列 38 两个字符串的删除操作 39 编辑距离 40 回文子串 42 最长回文子序列 单调栈 # 2024-11-14 # What I Wish Someone Told Me About Postgres 介绍了 postgresql 相关的一些知识点，可以看一看 The WIRED Guide to Protecting Yourself From Government Surveillance How a stubborn computer scientist accidentally launched the deep learning boom 可以了解到 辛顿、黄仁勋、李飞飞 的工作是如何推动神经网络的发展的 "},{"id":11,"href":"/zh/zh/post/computer-science/computer-science-learning-log/","title":"学习记录","section":"Computer Science","content":" 学习记录 # 2025-01-17 # 剑指Offer Book # 剑指Offer 第1章 面试的流程 1 # 1.1 面试官谈面试 1 1.2 面试的三种形式 2 1.2.1 电话面试 2 1.2.2 共享桌面远程面试 3 1.2.3 现场面试 4 1.3 面试的三个环节 5 1.3.1 行为面试环节 5 应聘者的项目经验 6 应聘者掌握的技能 7 回答“为什么跳槽” 8 1.3.2 技术面试环节 10 扎实的基础知识 10 高质量的代码 11 清晰的思路 14 优化效率的能力 15 优秀的综合能力 16 1.3.3 应聘者提问环节 17 1.4 本章小结 18 第2章 面试需要的基础知识 20 # 2.1 面试官谈基础知识 20 2.2 编程语言 22 2.2.1 C++ 22 面试题1：赋值运算符函数 24 经典的解法，适用于初级程序员 25 考虑异常安全性的解法，高级程序员必备 26 2.2.2 C# 27 面试题2：实现Singleton模式 31 不好的解法一：只适用于单线程 31 不好的解法二：可用于多线程但效率不高 32 可行的解法：同步锁前后两次判断 33 推荐的解法一：利用静态构造函数 34 推荐的解法二：按需创建实例 34 解法比较 35 2.3 数据结构 36 2.3.1 数组 36 面试题3：二维数组中的查找 38 2.3.2 字符串 42 面试题4：替换空格 44 O(n2)的解法，不足以拿到Offer 45 O(n)的解法，搞定Offer就靠它 46 2.3.3 链表 49 面试题5：从尾到头打印链表 51 2.3.4 树 53 面试题6：重建二叉树 55 2.3.5 栈和队列 58 面试题7：用两个栈实现队列 59 2.4 算法和数据操作 62 2.4.1 查找和排序 63 面试题8：旋转数组的最小数字 66 2.4.2 递归和循环 71 面试题9：斐波那契数列 73 效率很低的解法，面试官不会喜欢 73 面试官期待的实用解法 74 O(logn)但不够实用的解法 74 解法比较 75 2.4.3 位运算 77 面试题10：二进制中1的个数 78 可能引起死循环的解法 79 常规解法 79 能给面试官带来惊喜的解法 80 2.5 本章小结 82 第3章 高质量的代码 84 # 3.1 面试官谈代码质量 84 3.2 代码的规范性 86 3.3 代码的完整性 87 从3方面确保代码的完整性 87 3种错误处理的方法 88 面试题11：数值的整数次方 90 自以为题目简单的解法 90 全面但不够高效的解法，离Offer已经很近了 90 全面又高效的解法，确保能拿到Offer 92 面试题12：打印1到最大的n位数 94 跳进面试官陷阱 94 在字符串上模拟数字加法 94 把问题转换成数字排列 97 面试题13：在O(1)时间删除链表结点 99 面试题14：调整数组顺序使奇数位于偶数前面 102 只完成基本功能的解法，仅适用于初级程序员 102 考虑可扩展性的解法，能秒杀Offer 104 3.4 代码的鲁棒性 106 面试题15：链表中倒数第k个结点 107 面试题16：反转链表 112 面试题17：合并两个排序的链表 114 面试题18：树的子结构 117 3.5 本章小结 121 第4章 解决面试题的思路 123 # 4.1 面试官谈面试思路 123 面试题19：二叉树的镜像 125 4.2 画图让抽象问题形象化 125 面试题20：顺时针打印矩阵 127 4.3 举例让抽象问题具体化 131 面试题21：包含min函数的栈 132 面试题22：栈的压入、弹出序列 134 面试题23：从上往下打印二叉树 137 面试题24：二叉搜索树的后序遍历序列 140 面试题25：二叉树中和为某一值的路径 143 4.4 分解让复杂问题简单化 146 面试题26：复杂链表的复制 147 面试题27：二叉搜索树与双向链表 151 面试题28：字符串的排列 154 4.5 本章小结 158 第5章 优化时间和空间效率 160 # 5.1 面试官谈效率 160 5.2 时间效率 162 面试题29：数组中出现次数超过一半的数字 163 基于Partition函数的O(n)算法 163 利用数组特点的O(n)算法 165 解法比较 166 面试题30：最小的k个数 167 O(n)的算法，只当可以修改输入数组时可用 167 O(nlogk)的算法，适合处理海量数据 168 解法比较 169 面试题31：连续子数组的最大和 171 举例分析数组的规律 171 应用动态规划法 173 面试题32：从1到n整数中1出现的次数 174 不考虑效率的解法，想拿Offer有点难 174 明显提高效率的解法，让面试官耳目一新 175 面试题33：把数组排成最小的数 177 5.3 时间效率与空间效率的平衡 181 面试题34：丑数 182 逐个判断整数是不是丑数的解法 182 创建数组保存已经找到的丑数的解法 183 面试题35：第一个只出现一次的字符 186 面试题36：数组中的逆序对 189 面试题37：两个链表的第一个公共结点 193 5.4 本章小结 196 第6章 面试中的各项能力 198 # 6.1 面试官谈能力 198 6.2 沟通能力和学习能力 200 沟通能力 200 学习能力 200 善于学习、沟通的人也善于提问 201 6.3 知识迁移能力 203 面试题38：数字在排序数组中出现的次数 204 面试题39：二叉树的深度 207 重复遍历结点的解法，不足以打动面试官 209 只遍历结点一次的解法，正是面试官喜欢的 209 面试题40：数组中只出现一次的数字 211 面试题41：和为s的两个数字VS和为s的连续正数序列 214 面试题42：翻转单词顺序 VS左旋转字符串 218 6.4 抽象建模能力 222 面试题43：n个骰子的点数 223 基于递归求骰子点数，时间效率不够高 223 基于循环求骰子点数，时间性能好 224 面试题44：扑克牌的顺子 226 面试题45：圆圈中最后剩下的数字 228 经典的解法，用循环链表模拟圆圈 229 创新的解法，拿到Offer不在话下 230 6.5 发散思维能力 232 面试题46：求1+2+…+n 233 利用构造函数求解 234 利用虚函数求解 234 利用函数指针求解 235 利用模板类型求解 236 面试题47：不用加减乘除做加法 237 面试题48：不能被继承的类 239 常规的解法：把构造函数设为私有函数 239 新奇的解法：利用虚拟继承 240 6.6 本章小结 241 第7章 两个面试案例 243 # 7.1 案例一：（面试题49）把字符串转换成整数 244 7.2 案例二：（面试题50）树中两个结点的最低公共祖先 252 第8章 英文版新增面试题 261 # 8.1 数组 261 面试题51：数组中重复的数字 261 面试题52：构建乘积数组 263 8.2 字符串 265 面试题53：正则表达式匹配 265 面试题54：表示数值的字符串 267 面试题55：字符流中第一个不重复的字符 269 8.3 链表 270 面试题56：链表中环的入口结点 270 面试题57：删除链表中重复的结点 273 8.4 树 275 面试题58：二叉树的下一个结点 275 面试题59：对称的二叉树 277 面试题60：把二叉树打印成多行 278 面试题61：按之字形顺序打印二叉树 280 面试题62：序列化二叉树 283 面试题63：二叉搜索树的第k个结点 285 面试题64：数据流中的中位数 286 8.5 栈和队列 290 面试题65：滑动窗口的最大值 290 8.6 回溯法 294 面试题66：矩阵中的路径 294 面试题67：机器人的运动范围 296 2025-01-11 # leetcode 刷题 # 面试经典150题 # 面试经典150题 数组/字符串 # 合并两个有序数组 2025-01-12 移除元素 2025-01-11 删除有序数组中的重复项 2025-01-11 没有做出来，看的官方题解 2025-01-11 做完删除有序数组中的重复项 II之后再尝试重新解题完成 删除有序数组中的重复项 II 2025-01-11 多数元素 2025-01-12 轮转数组 2025-01-18 进阶 尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 买卖股票的最佳时机 2025-01-11 看官方题解做出来的 2025-01-17 review 买卖股票的最佳时机 II 官方题解 理解 2025-01-17 方法一：动态规划 方法二：贪心 跳跃游戏 2025-01-17 官方题解理解 贪心 2025-01-18 跳跃游戏 II 2025-01-18 算法超时了 理解官方题解 2025-01-18 方法一：反向查找出发位置 Solution45.jump2 2025-01-18 方法二：正向查找可达到的最大位置 Solution45.jump3 H 指数 2025-01-18 Tips An easy approach is to sort the array first. What are the possible values of h-index? A faster approach is to use extra space. O(1) 时间插入、删除和获取随机元素 除自身以外数组的乘积 加油站 分发糖果 接雨水 罗马数字转整数 2025-01-12 整数转罗马数字 最后一个单词的长度 2025-01-12 最长公共前缀 2025-01-12 反转字符串中的单词 2025-01-18 进阶 如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。 Z 字形变换 找出字符串中第一个匹配项的下标 2025-01-12 文本左右对齐 双指针 # 验证回文串 2025-01-13 判断子序列 2025-01-13 两数之和 II - 输入有序数组 2025-01-13 运行有时候会超过时间限制 盛最多水的容器 三数之和 滑动窗口 # 长度最小的子数组 2025-01-22 无重复字符的最长子串 2025-01-22 串联所有单词的子串 2025-01-22 最小覆盖子串 矩阵 # 有效的数独 2025-01-18 螺旋矩阵 2025-01-18 旋转图像 理解官方题解 2025-01-18 方法一：使用辅助数组 2025-01-18 方法二：原地旋转 有数学公式的推导，需要自己推导一次 2025-01-18 方法三：用翻转代替旋转 有数学公式的推导，需要自己推导一次 矩阵置零 2025-01-18 生命游戏 2025-01-18 进阶 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？ ✅ 哈希表 # 赎金信 2025-01-13 同构字符串 2025-01-13 单词规律 2025-01-13 有效的字母异位词 2025-01-13 字母异位词分组 2025-01-16 第一遍算法超时，看了官方题解思路后实现通过 两数之和 2025-01-13 快乐数 2025-01-13 存在重复元素 II 2025-01-13 最长连续序列 2025-01-16 看了官方题解后完成 区间 # 栈 # 有效的括号 2025-01-22 简化路径 2025-01-22 最小栈 2025-01-22 理解官方题解 文字描述后完成 2025-01-22 理解官方题解 逆波兰表达式求值 2025-01-22 基本计算器 链表 # 环形链表 2025-01-20 理解官方题解 2025-01-20 方法一：哈希表 方法二：快慢指针 两数相加 2025-01-20 合并两个有序链表 2025-01-20 随机链表的复制 2025-01-20 反转链表 II 2025-01-20 K 个一组翻转链表 删除链表的倒数第 N 个结点 2025-01-20 进阶 2025-01-20 你能尝试使用一趟扫描实现吗？ 删除排序链表中的重复元素 II 2025-01-21 旋转链表 2025-01-20 分隔链表 2025-01-21 LRU 缓存 2025-01-22 理解官方题解 二叉树 # 二叉树的最大深度 2025-01-15 相同的树 2025-01-15 翻转二叉树 2025-01-15 对称二叉树 没做出来，看的官方题解 从前序与中序遍历序列构造二叉树 从中序与后序遍历序列构造二叉树 填充每个节点的下一个右侧节点指针 II 二叉树展开为链表 路径总和 求根节点到叶节点数字之和 二叉树中的最大路径和 二叉搜索树迭代器 完全二叉树的节点个数 二叉树的最近公共祖先 二叉树层次遍历 # 二叉搜索树 # 图 # 图的广度优先搜索 # 字典树 # ✅ 回溯 # 电话号码的字母组合 2025-01-15 组合 2025-01-15 全排列 2025-01-15 组合总和 2025-01-15 N 皇后 II 2025-01-15 括号生成 2025-01-15 单词搜索 2025-01-15 分治 # kadane算法 # 二分查找 # 堆 # 位运算 # 二进制求和 2025-01-16 颠倒二进制位 2025-01-16 没做出来, 参考这篇文章LeetCode 190. 颠倒二进制位 （位运算 分治） 2025-01-17 复习了一遍 2025-01-17 新增了中间值打印的代码在算法中 位1的个数 2025-01-17 只出现一次的数字 2025-01-17 只出现一次的数字 II 2025-01-17 理解了官方题解 方法2 数字范围按位与 2025-01-17 理解了官方题解 方法2 数学 # 回文数 2025-01-17 不将整数转为字符串来解决这个问题 加一 2025-01-17 阶乘后的零 2025-01-17 x 的平方根 2025-01-17 Pow(x, n) 2025-01-17 超时了 2025-01-17 看懂了官方题解 直线上最多的点数 2025-01-17 看了官方题解，但还是不太理解 一维动态规划 # 爬楼梯 2025-01-11 通过 多维动态规划 # 2025-01-09 # ✅ Spring实战 第6版 Book # 第1章 Spring 起步 1.1 什么是Spring 2025-01-09 1.2 初始化 spring 应用 2025-01-09 1.3 编写 Spring 应用 2025-01-09 1.4 俯瞰 Spring 风景线 2025-01-09 第2章 2.1 展现信息 2025-01-09 2.2 处理表单提交 2025-01-09 2.3 校验表单输入 2025-01-09 2.4 使用视图控制器 2025-01-09 2.5 选择视图模板库 2025-01-09 第3章 使用数据 3.1 2025-01-09 3.2 2025-01-11 3.3 2025-01-11 第4章 使用非关系型数据 4.1 2025-01-11 4.2 2025-01-11 第5章 保护Spring 5.1 2025-01-11 5.2 2025-01-11 5.3 2025-01-11 5.4 2025-01-11 5.5 2025-01-12 第6章 使用配置属性 6.1 2025-01-12 6.2 2025-01-12 6.3 2025-01-12 第7章 创建REST服务 7.1 2025-01-12 7.2 2025-01-12 7.3 2025-01-12 第8章 保护REST 8.1 2025-01-12 8.2 2025-01-12 8.3 2025-01-12 8.4 2025-01-12 第9章 发送异步消息 9.1 2025-01-13 9.2 2025-01-13 9.3 2025-01-13 第10章 Spring集成 10.1 2025-01-13 10.2 2025-01-13 10.3 2025-01-13 第11章 理解反应式编程 11.1 2025-01-13 11.2 2025-01-13 11.3 2025-01-13 第12章 开发反应式API 12.1 2025-01-13 12.2 2025-01-13 12.3 2025-01-13 12.4 2025-01-13 12.5 2025-01-13 第13章 反应式持久化数据 13.1 2025-01-14 13.2 2025-01-14 13.3 2025-01-14 第14章 使用RSocket 14.1 2025-01-14 14.2 2025-01-15 14.3 2025-01-15 第15章 部署Spring 15.1 2025-01-15 15.2 2025-01-15 15.3 2025-01-15 15.4 2025-01-15 第16章 管理Spring 16.1 2025-01-15 16.2 2025-01-15 16.3 2025-01-15 第17章 使用JMX监控Spring 17.1 2025-01-15 17.2 2025-01-15 17.3 2025-01-15 第18章 部署Spring 18.1 2025-01-15 18.2 2025-01-15 18.3 2025-01-15 18.4 2025-01-15 18.5 2025-01-15 JavaGuide 文档阅读 # JavaGuide 必看 面试准备 Java 计算机基础 数据库 开发工具 常用框架 Spring\u0026amp;Spring Boot MyBatis常见面试题总结 2025-01-09 太过总结性，需要看一些更基础的文章 Netty常见面试题总结 系统设计 分布式 高性能 高可用 2025-01-08 # 计算机教育中缺失的学期 # 计算机教育中缺失的学期 阮一峰博客阅读 # 阮一峰的网络日志 散文 观点与感想 算法与数学 开发者手册 理解计算机 JavaScript 计算机行业历史 周刊 创业 译文集 2025-01-05 # spring 基础知识点 视频 # B站大学终于把Spring做成动画片了，一周刷爆，2024最新版，学完即可面试，拿走不谢，学不会我退出IT圈！ 1 2025-01-05 Spring 是如何整合MyBatis管理Mapper接口的 2025-01-05 2 2025-01-06 3 2025-01-06 4 2025-01-06 5 2025-01-06 6 2025-01-06 7 2025-01-06 8 2025-01-06 9 2025-01-06 10 2025-01-06 11 (January 6, 2025 at 18:43:04 GMT+8) 12 (January 6, 2025 at 18:50:57 GMT+8) 13 (January 6, 2025 at 18:57:05 GMT+8) 14 (January 6, 2025 at 18:59:15 GMT+8) 15 2025-01-07 16 2025-01-07 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 100 2025-01-03 # 代码随想录 视频 # 代码随想录 数组 # 链表 # 哈希表 # 字符串 # 栈与队列 # 二叉树 # 1 理论基础 2025-01-09 2 递归遍历 (Leetcode 144, 145, 94) 2025-01-09 3 非递归遍历 2025-01-09 4 非递归遍历-中序 2025-01-11 5 层序遍历（广度优先搜索） 6 翻转二叉树 7 对称二叉树 8 二叉树的最大深度 9 二叉树的最小深度 10 完全二叉树节点的数量 11 平衡二叉树 12 二叉树的所有路径 13 左叶子之和 14 找左下角的值 15 路径总和 16 从中序和后序遍历序列构造二叉树 17 最大二叉树 18 合并二叉树 19 二叉搜索树中的搜索 (Leetcode 700) 2025-01-08 20 验证二叉搜索树 (Leetcode 98) 2025-01-08 21 二叉搜索树的最小绝对差 (Leetcode 530) 2025-01-08 22 二叉搜索树中的众数(Leetcode 501) 2025-01-09 23 二叉树的最近公共祖先(Leetcode 236) 2025-01-09 24 二叉搜索树的最近公共祖先 2025-01-09 25 二叉搜索树中的插入操作(Leetcode 701) 2025-01-09 26 删除二叉搜索树中的节点(Leetcode 450) 2025-01-09 27 修剪二叉搜索树 (Leetcode 669) 2025-01-09 28 将有序数组转换为二叉搜索树 (Leetcode 108) 2025-01-09 29 把二叉搜索树转换为累加树(Leetcode 538) 2025-01-09 ✅ 回溯法 # 1 理论篇 2025-01-03 2 组合问题（对应力扣题目：77.组合） 2025-01-03 3 组合问题的剪枝操作（对应力扣题目：77.组合）2025-01-03 4 回溯算法如何剪枝？| LeetCode：216.组合总和III 2025-01-03 5 LeetCode：17.电话号码的字母组合 2025-01-03 6 组合总和（对应「leetcode」力扣题目：39.组合总和） 2025-01-03 7 LeetCode:40.组合总和II 2025-01-03 8 分割回文串 2025-01-04 9 复原IP地址 2025-01-04 10 子集 （Leetcode 78） 2025-01-04 11 子集2（Leetcode 90） 2025-01-04 12 递增子序列（Leetcode 491） 2025-01-04 13 全排列（Leetcode 46） 2025-01-04 14 全排列2（Leetcode 47）2025-01-04 15 N皇后（Leetcode 51） 2025-01-05 16 解数独（Leetcode 37） 2025-01-05 ✅ 贪心算法 # 理论基础 2025-01-05 1 分发饼干 leetcode 455 2025-01-05 2 摆动序列 Leetcode 376 2025-01-05 3 最大子序和 2025-01-06 4 买卖股票最佳时机2 2025-01-06 5 跳跃游戏（Leetcode 55） 2025-01-06 6 跳跃游戏2 （Leetcode 45） 2025-01-06 这道题没听懂 7 K次取反后最大化的数组和 （Leetcode 1005） 2025-01-06 8 加油站（Leetcode 134） 2025-01-06 9 分发糖果（Leetcode 135） 2025-01-06 10 柠檬水找零（Leetcode 860） 2025-01-06 11 根据身高重建队列（Leetcode 406） 2025-01-06 12 用最少数量的箭引爆气球(Leetcode 452) 2025-01-06 13 无重叠区间(Leetcode 435) 2025-01-06 14 划分字母区间 (Leetcode 763) 2025-01-06 15 合并区间 （Leetcode 56） (January 7, 2025 at 15:18:40 GMT+8) 16 单调自增的数字（Leetcode 738）(January 7, 2025 at 15:41:59 GMT+8) 17 监督二叉树（Leetcode 968） (January 7, 2025 at 16:11:51 GMT+8) 动态规划 # 1 理论基础 (January 7, 2025 at 16:34:49 GMT+8) 2 斐波那契数列 （Leetcode 509） (January 7, 2025 at 16:46:54 GMT+8) 3 爬楼梯（Leetcode 70） (January 7, 2025 at 16:57:46 GMT+8) 4 使用最小花费爬楼梯 (Leetcode 746) 2025-01-08 5 不同路径 2025-01-08 6 不同路径2 (Leetcode 63) 2025-01-08 7 整数拆分 (Leetcode 343) 2025-01-08 这道题没太听懂 8 不同的二叉搜索树（Leetcode 96） 9 0-1背包问题理论基础 10 0-1背包问题之滚动数组 11 分割等和子集 12 最后一块石头的重量2 13 目标和 14 一和零 15 完全背包理论基础 16 零钱兑换2 17 组合综合4 18 零钱兑换 19 完全平方数 20 单词拆分 21 打家劫舍 22 打家劫舍2 23 打家劫舍3 24 买卖股票的最佳时机1 25 买卖股票的最佳时机2 26 买卖股票的最佳时机3 27 买卖股票的最佳时机4 28 买卖股票的最佳时机含冷冻期 29 买卖股票的最佳时机含手续费 30 最长递增子序列 31 最长连续递增序列 32 最长重复子数组 33 最长公共子序列 34 不相交的线 35 最大子序和 36 判断子序列 37 不同的子序列 38 两个字符串的删除操作 39 编辑距离 40 回文子串 42 最长回文子序列 单调栈 # 2024-11-14 # What I Wish Someone Told Me About Postgres 介绍了 postgresql 相关的一些知识点，可以看一看 The WIRED Guide to Protecting Yourself From Government Surveillance How a stubborn computer scientist accidentally launched the deep learning boom 可以了解到 辛顿、黄仁勋、李飞飞 的工作是如何推动神经网络的发展的 "},{"id":12,"href":"/zh/post/others/english-learning/","title":"English Learning","section":"Others","content":" English Learning # lite cnn 纯文字版的cnn，没有图片 lite cnn China China Daily 中国官方最大的英语新闻网站？ voa special English 这个网站听 voa special 不用翻墙 rest of world 这个网站很有设计感 China verge Hacker News 技术文章也能学习英语 南华早报 bbc China quora 国外的知乎 log # 2025-01-07 2024-12-14 “羽绒服”英语怎么说？你绝对想不到！ 2025-01-07 2025-01-06 “年会”英文怎么说？“Year Meeting”还是“Annual Party？” 都错啦！ voa special English # voa special English others # 如何利用 AI 更好地学外语 A List Of Text-Only \u0026amp; Minimalist News Sites 2022 # Monkeypox outbreak 猴痘病毒爆发 Russia-Ukraine War November A projected \u0026ldquo;red wave\u0026rdquo; fizzled, as Republicans won a slim majority in the House, and Democrats held control of the United States Senate 随着共和党在众议院赢得微弱多数，民主党控制了美国参议院，预计中的“红色浪潮”落空了 2022-11-09 Why is Apple Rosetta 2 fast? 为什么 Apple Rosetta 2 速度很快？ October Elon Musk took control of Twitter, bringing to the social media giant a brash leadership style – along with thousands of layoffs 埃隆·马斯克 （Elon Musk） 控制了 Twitter，为这家社交媒体巨头带来了傲慢的领导风格——以及数千人的裁员 September Britain\u0026rsquo;s Queen Elizabeth II died in Scotland, at the age of 96. Her son Charles succeeded her as king 英国女王伊丽莎白二世在苏格兰去世，享年 96 岁。她的儿子查理继承了她的国王之位 August The FBI conducted a search of Mar-a-Lago, the home of former president Donald Trump, and found classified materials, including documents labeled \u0026ldquo;top secret.\u0026rdquo; 联邦调查局对前总统唐纳德·特朗普的家马阿拉歌庄园进行了搜查，发现了机密材料，包括标记为“绝密”的文件。 July Former Japanese prime minister Shinzo Abe was assassinated, just two days before that country\u0026rsquo;s parliamentary elections 日本前首相安倍晋三在该国议会选举前两天被暗杀 June The Supreme Court overturned Roe v. Wade, effectively criminalizing abortion in much of the nation 最高法院推翻了罗伊诉韦德案（Roe v. Wade），实际上在全国大部分地区将堕胎定为刑事犯罪。 May A gunman in Uvalde, Texas killed 19 students and two teachers at Robb Elementary School. It was the third-deadliest school shooting in U.S. history 德克萨斯州尤瓦尔迪的一名枪手在罗布小学杀死了 19 名学生和两名教师。这是美国历史上第三致命的校园枪击事件 2021 # December In December, tornadoes ripped through the South and Midwest, killing at least 91 people \u0026hellip; 12 月，龙卷风席卷南部和中西部，造成至少 91 人死亡\u0026hellip;\u0026hellip; October October brought the welcome news that the World Health Organization had endorsed the world\u0026rsquo;s first vaccine against malaria. 10 月带来了一个可喜的消息，即世界卫生组织批准了世界上第一种疟疾疫苗 September September saw the implementation of the Texas Heartbeat Act, which bans abortions after roughly six weeks. The Supreme Court has declined to block the law, saying it\u0026rsquo;s a question for lower courts. 9 月，德克萨斯州心跳法案 （Texas Heartbeat Act） 实施，该法案禁止在大约六周后堕胎。最高法院拒绝阻止这项法律，称这是下级法院的问题 August August saw the withdrawal of American troops from Afghanistan after a two-decade war that took the lives of over 2,400 U.S. service personnel. 8 月，美国军队在经历了二十年的战争后从阿富汗撤军，这场战争夺走了 2,400 多名美国军人的生命 July July brought the 32nd Summer Olympic games to Tokyo, a year after being postponed. The U.S. topped the medal count with 113. 第 32 届夏季奥运会在推迟一年后于 7 月在东京举行。美国以 113 枚奖牌位居榜首 June June saw the partial collapse of a 12-story condominium in Surfside, Florida, killing 98 residents. 6 月，佛罗里达州瑟夫赛德 （Surfside） 的一栋 12 层公寓部分倒塌，造成 98 名居民死亡 March The container ship Ever Given ran aground in the Suez Canal in March, holding up billions in trade. The ship was freed six days later. 3 月，集装箱船 Ever Given 在苏伊士运河搁浅，阻碍了数十亿美元的贸易。六天后，这艘船被释放 February In February, the United States formally re-joined the Paris Climate Agreement, an international treaty aimed at limiting global warming. 今年 2 月，美国正式重新加入旨在限制全球变暖的国际条约《巴黎气候协定》。 Janurary In January Joe Biden was inaugurated as our 46th president … 1 月，乔·拜登就任我们的第 46 任总统\u0026hellip;\u0026hellip; 2020 # The United Kingdom left the European Union; Brexit 2019 # Global SARS-Cov-2 (COVID-19) Pandemic Hong Kong Protests in 2019. 2019 年香港抗议活动 2018 # The Yellow Vests Movement in France 法国巴黎黄背心运动 World\u0026rsquo;s longest sea-crossing bridge: Hong Kong-Zhuhai-Macao Bridge The China-US trade War Started in 2018. 2018 年开始的中美贸易战 2015 # The Legalization of Same-Sex Marriage in the United States 美国同性婚姻合法化 2014 # Catastrophic Aviation Disasters of 2014. 2014 年的灾难性航空灾难 The Annexation of Crimea by Russia 俄罗斯吞并克里米亚 2012 # The “God Particle” Is (Probably) Discovered “上帝粒子”被发现 2011 # Japan’s 2011 Tōhoku Earthquake and Tsunami 日本 2011 年东北地震和海啸 Bin Laden Killed 本·拉登被击毙 2010 # Instagram was launched Apple Inc. releasd the first tablet touch screen computer iPad 2009-2017 # Barack Obama, the 44th U.S. President. The 1st African American President of the United States 2009 # Bitcoin 比特币\n2008 # **The credit and property value bubble collapses, Wall Street and other equities markets crash, demand evaporates, and a global economic recession ensues** 信用和财产价值泡沫破灭，华尔街和其他产权投资金融市场崩盘，因市场需求蒸发，导致全球性的经济衰退 2006 # The International Astronomical Union decides to remove Pluto from the list planets of the solar system 国际天文联会决定将冥王星从太阳系中除名 Twitter was launched 2005 # Facebook Youtube 2003 # USA invades Iraq 2002 # Latin no longer used in UK legal documents USA invades Afghanistan 2001 # Sep. 11 2001 New York City World Trade Center attacked fomer # 2000 International space station 1999 Alibaba 1998 Google 1996 clone 1994 Yahoo European Union 1991 1st web page From 1991 until now. The Information Revolution An era marked by the spread of telecommunications technology, especially with personal computers, the internet, the web-based economy, social media, smart phones, and greater cross-cultural mixing. Late-stage capitalism as inequalities increased. The rise of China. Death cults terrorize the world early in this era, and extremism poses a threat to global security. The threat of global conflict remains as leadership in North Korea, China, and Russia use outdated paradigms to justify policies that prepare their nations for military conflict with neighbors ( Ukraine, Georgia, Taiwan). Anti-democratic nationalist tendencies manifest in the United States (Trump), Brazil, Hungary, Poland, Turkey, the Philippines, China, Russia, Egypt, and elsewhere. But popular people’s movements for the environment, peace, and democracy (e.g., the Arab Spring, anti-global-warming activism, Black Lives Matter, Occupy Wall Street, Anti-Iraq-War) also manifest, and win some victories. Anthropocene global climate catastrophe threatens humanity. Mass extinctions begin. 这个时代代表着电信技术的普及，特别是在个人电脑、网路、电商经济、社交媒体、智能手机、以及更广泛的跨文化融合。晚期资本主义，不平等情况增加。中国的崛起，死亡邪教在这个世界造成。恐惧，极端主义也对全球的安全构成威胁。全球性的威胁冲突仍然存在北韩、中国和俄罗斯的领导阶层，他们使用不符合时代的政策，来证明准备与邻国之间（乌克兰、乔治亚、台湾）所发生的军事冲突的正当性。反民主之民族主义者倾向表现在美国（川普）、巴西、匈牙利、波兰、土耳其、菲律宾、中国、俄罗斯、埃及和其他地方。而民众为了保护环境、和平与民主而开展的运动（例如，阿拉伯之春、反全球暖化的激进主义、黑人的生命问题、占领华尔街和伊拉克战争）也得以体现，并赢得了一些胜利。在人类世，人们正面临着全球性气候灾难的威胁，这也是大灭绝的开始。 1991 1st Gulf War, USA invades Iraq following invasion of Kuwait 第一次波斯湾战争，美国攻击伊拉克接著入侵科威特 USSR collapse 苏联体制崩溃解体 Union of Soviet Socialist Republics 苏维埃社会主义共和国联盟 1990 Hubble space telescope 哈伯太空望远镜 1989 USSR quits Eastern Europe 苏联撤离东欧 Berlin wall falls 1988 USSR quits Afghanistan 1987 DNA convicts criminals 用DNA检测方式证明罪犯的罪行 1986 Shuttle Tragedy 航天飞机悲剧 1985 Ozone layer \u0026ldquo;hole\u0026rdquo; discovered 发现臭氧层破洞 1984 String Theory accepted as a possible unifying theory in physics 弦理论被接受的原因在于它有可能会成为物理中的大统一理论 1983 The Internet is Born 互联网诞生 1981 AIDS identified 辨认出爱滋病 Acquired Immunodeficiency Syndrome 获得性免疫缺陷综合征 1979 USSR invades Afghanistan China attacks Vietnam, but is repelled 1977 MRI 核磁共振摄影 Magnetic Resonance Imaging 1973 Roe v. Wade 罗诉韦德案 1972 Nixon Goes To China 尼克松访问中国 1970 String Theory \u0026ldquo;born\u0026rdquo; 1969 1st moon walk 人类首次登陆月球 1968 King Assassinated 马丁·路德·金遇刺 1967 Arab-Israeli \u0026ldquo;6-day war\u0026rdquo; 阿拉伯和以色列之间的“六日战争\u0026quot; 1966 Martin Luther King assassination 1963 John F. Kennedy Assassinated 肯尼迪遇刺 1962 Cuban Missile Crisis 古巴导弹危机 1961 Berlin Wall Built 柏林墙建成 1958 US Launches First Satellite 美国发射第一颗卫星 1953 The Dawn of DNA 1950 Credit cards 1949 Germany divided into East \u0026amp; West 1948 State of Israel founded First transistor 晶体管 1945 USA bombs Japan with two Atomic bombs UN founded 1939-1945 World War II 1935 Spanish Civil War 西班牙内战 Mao\u0026rsquo;s long march 长征 1932 Von Neumann develops foundation for Quantum Mechanics 冯・诺伊曼建立了量子力学的基础 1931 Empire State Building Completed 帝国大厦竣工 1927 Heisenberg, Uncertainty Principle 海森堡的不确定性原理 1920-1933 U.S. Prohibition 美国禁酒时期 1920 Schrödinger Equation, Quantum Theory emerges in modern form 薛定谔方程式，为现在量子力学中的基本方程式 1914-1918 World War I From 1912 end of Imperial China and start of Balkan wars to 1991, the end of the Cold War. The Age of Conflict 冲突时代 从西元1912年中国大情帝国衰亡和巴尔干战争开始，到西元1991年的冷战结束。 An era marked by the Mexican Revolution, the Russian Revolution, the Great War (1914-1918), the Great Influenza Pandemic, the Warlord Era in China, The War of Japanese Imperial Conquest, the Second World War, the Maoist Revolution in China, various anti-colonial wars, the Cold War, and all this while technology leaped ahead with computer-controlled machine tools carrying automation to new levels. Rudimentary automobiles and aircraft of the previous era transformed to a point where humans went to the moon. Air conditioning and television and radio changed culture as people spent more time indoors. Urbanization transformed society as fewer people lived on farms in rural areas. Electrification and the demand for power created a surge in the construction of power plants and infrastructure to extract fossil fuels and Uranium ores from the earth. 这个时代看到了墨西哥革命、俄罗斯革命、第一次世界大战（西元1914-1918年）、流感大流行、中国的军阀时代、日本的帝国战争、第二次世界大战、中国的毛派革命、 各种反殖民战争、冷战，在同时科技飞速的发展，提升到用电脑控制的自动化机器的新的水平。上一个时代，基本生活里的汽车和飞机，已转变为人类有能力登陆月球。随着冷气机、电视机和广播的普及，人们花费更多的时间待在室内。城市化改变了社会，因为在农村地区居住的人口减少了。电气化和对电力的需求，掀起一股建设发电厂的热潮，和从地球上开采化石燃料和铀矿石的基础设施。 "},{"id":13,"href":"/zh/zh/post/others/english-learning/","title":"English Learning","section":"Others","content":" English Learning # lite cnn 纯文字版的cnn，没有图片 lite cnn China China Daily 中国官方最大的英语新闻网站？ voa special English 这个网站听 voa special 不用翻墙 rest of world 这个网站很有设计感 China verge Hacker News 技术文章也能学习英语 南华早报 bbc China quora 国外的知乎 log # 2025-01-07 2024-12-14 “羽绒服”英语怎么说？你绝对想不到！ 2025-01-07 2025-01-06 “年会”英文怎么说？“Year Meeting”还是“Annual Party？” 都错啦！ voa special English # voa special English others # 如何利用 AI 更好地学外语 A List Of Text-Only \u0026amp; Minimalist News Sites 2022 # Monkeypox outbreak 猴痘病毒爆发 Russia-Ukraine War November A projected \u0026ldquo;red wave\u0026rdquo; fizzled, as Republicans won a slim majority in the House, and Democrats held control of the United States Senate 随着共和党在众议院赢得微弱多数，民主党控制了美国参议院，预计中的“红色浪潮”落空了 2022-11-09 Why is Apple Rosetta 2 fast? 为什么 Apple Rosetta 2 速度很快？ October Elon Musk took control of Twitter, bringing to the social media giant a brash leadership style – along with thousands of layoffs 埃隆·马斯克 （Elon Musk） 控制了 Twitter，为这家社交媒体巨头带来了傲慢的领导风格——以及数千人的裁员 September Britain\u0026rsquo;s Queen Elizabeth II died in Scotland, at the age of 96. Her son Charles succeeded her as king 英国女王伊丽莎白二世在苏格兰去世，享年 96 岁。她的儿子查理继承了她的国王之位 August The FBI conducted a search of Mar-a-Lago, the home of former president Donald Trump, and found classified materials, including documents labeled \u0026ldquo;top secret.\u0026rdquo; 联邦调查局对前总统唐纳德·特朗普的家马阿拉歌庄园进行了搜查，发现了机密材料，包括标记为“绝密”的文件。 July Former Japanese prime minister Shinzo Abe was assassinated, just two days before that country\u0026rsquo;s parliamentary elections 日本前首相安倍晋三在该国议会选举前两天被暗杀 June The Supreme Court overturned Roe v. Wade, effectively criminalizing abortion in much of the nation 最高法院推翻了罗伊诉韦德案（Roe v. Wade），实际上在全国大部分地区将堕胎定为刑事犯罪。 May A gunman in Uvalde, Texas killed 19 students and two teachers at Robb Elementary School. It was the third-deadliest school shooting in U.S. history 德克萨斯州尤瓦尔迪的一名枪手在罗布小学杀死了 19 名学生和两名教师。这是美国历史上第三致命的校园枪击事件 2021 # December In December, tornadoes ripped through the South and Midwest, killing at least 91 people \u0026hellip; 12 月，龙卷风席卷南部和中西部，造成至少 91 人死亡\u0026hellip;\u0026hellip; October October brought the welcome news that the World Health Organization had endorsed the world\u0026rsquo;s first vaccine against malaria. 10 月带来了一个可喜的消息，即世界卫生组织批准了世界上第一种疟疾疫苗 September September saw the implementation of the Texas Heartbeat Act, which bans abortions after roughly six weeks. The Supreme Court has declined to block the law, saying it\u0026rsquo;s a question for lower courts. 9 月，德克萨斯州心跳法案 （Texas Heartbeat Act） 实施，该法案禁止在大约六周后堕胎。最高法院拒绝阻止这项法律，称这是下级法院的问题 August August saw the withdrawal of American troops from Afghanistan after a two-decade war that took the lives of over 2,400 U.S. service personnel. 8 月，美国军队在经历了二十年的战争后从阿富汗撤军，这场战争夺走了 2,400 多名美国军人的生命 July July brought the 32nd Summer Olympic games to Tokyo, a year after being postponed. The U.S. topped the medal count with 113. 第 32 届夏季奥运会在推迟一年后于 7 月在东京举行。美国以 113 枚奖牌位居榜首 June June saw the partial collapse of a 12-story condominium in Surfside, Florida, killing 98 residents. 6 月，佛罗里达州瑟夫赛德 （Surfside） 的一栋 12 层公寓部分倒塌，造成 98 名居民死亡 March The container ship Ever Given ran aground in the Suez Canal in March, holding up billions in trade. The ship was freed six days later. 3 月，集装箱船 Ever Given 在苏伊士运河搁浅，阻碍了数十亿美元的贸易。六天后，这艘船被释放 February In February, the United States formally re-joined the Paris Climate Agreement, an international treaty aimed at limiting global warming. 今年 2 月，美国正式重新加入旨在限制全球变暖的国际条约《巴黎气候协定》。 Janurary In January Joe Biden was inaugurated as our 46th president … 1 月，乔·拜登就任我们的第 46 任总统\u0026hellip;\u0026hellip; 2020 # The United Kingdom left the European Union; Brexit 2019 # Global SARS-Cov-2 (COVID-19) Pandemic Hong Kong Protests in 2019. 2019 年香港抗议活动 2018 # The Yellow Vests Movement in France 法国巴黎黄背心运动 World\u0026rsquo;s longest sea-crossing bridge: Hong Kong-Zhuhai-Macao Bridge The China-US trade War Started in 2018. 2018 年开始的中美贸易战 2015 # The Legalization of Same-Sex Marriage in the United States 美国同性婚姻合法化 2014 # Catastrophic Aviation Disasters of 2014. 2014 年的灾难性航空灾难 The Annexation of Crimea by Russia 俄罗斯吞并克里米亚 2012 # The “God Particle” Is (Probably) Discovered “上帝粒子”被发现 2011 # Japan’s 2011 Tōhoku Earthquake and Tsunami 日本 2011 年东北地震和海啸 Bin Laden Killed 本·拉登被击毙 2010 # Instagram was launched Apple Inc. releasd the first tablet touch screen computer iPad 2009-2017 # Barack Obama, the 44th U.S. President. The 1st African American President of the United States 2009 # Bitcoin 比特币\n2008 # **The credit and property value bubble collapses, Wall Street and other equities markets crash, demand evaporates, and a global economic recession ensues** 信用和财产价值泡沫破灭，华尔街和其他产权投资金融市场崩盘，因市场需求蒸发，导致全球性的经济衰退 2006 # The International Astronomical Union decides to remove Pluto from the list planets of the solar system 国际天文联会决定将冥王星从太阳系中除名 Twitter was launched 2005 # Facebook Youtube 2003 # USA invades Iraq 2002 # Latin no longer used in UK legal documents USA invades Afghanistan 2001 # Sep. 11 2001 New York City World Trade Center attacked fomer # 2000 International space station 1999 Alibaba 1998 Google 1996 clone 1994 Yahoo European Union 1991 1st web page From 1991 until now. The Information Revolution An era marked by the spread of telecommunications technology, especially with personal computers, the internet, the web-based economy, social media, smart phones, and greater cross-cultural mixing. Late-stage capitalism as inequalities increased. The rise of China. Death cults terrorize the world early in this era, and extremism poses a threat to global security. The threat of global conflict remains as leadership in North Korea, China, and Russia use outdated paradigms to justify policies that prepare their nations for military conflict with neighbors ( Ukraine, Georgia, Taiwan). Anti-democratic nationalist tendencies manifest in the United States (Trump), Brazil, Hungary, Poland, Turkey, the Philippines, China, Russia, Egypt, and elsewhere. But popular people’s movements for the environment, peace, and democracy (e.g., the Arab Spring, anti-global-warming activism, Black Lives Matter, Occupy Wall Street, Anti-Iraq-War) also manifest, and win some victories. Anthropocene global climate catastrophe threatens humanity. Mass extinctions begin. 这个时代代表着电信技术的普及，特别是在个人电脑、网路、电商经济、社交媒体、智能手机、以及更广泛的跨文化融合。晚期资本主义，不平等情况增加。中国的崛起，死亡邪教在这个世界造成。恐惧，极端主义也对全球的安全构成威胁。全球性的威胁冲突仍然存在北韩、中国和俄罗斯的领导阶层，他们使用不符合时代的政策，来证明准备与邻国之间（乌克兰、乔治亚、台湾）所发生的军事冲突的正当性。反民主之民族主义者倾向表现在美国（川普）、巴西、匈牙利、波兰、土耳其、菲律宾、中国、俄罗斯、埃及和其他地方。而民众为了保护环境、和平与民主而开展的运动（例如，阿拉伯之春、反全球暖化的激进主义、黑人的生命问题、占领华尔街和伊拉克战争）也得以体现，并赢得了一些胜利。在人类世，人们正面临着全球性气候灾难的威胁，这也是大灭绝的开始。 1991 1st Gulf War, USA invades Iraq following invasion of Kuwait 第一次波斯湾战争，美国攻击伊拉克接著入侵科威特 USSR collapse 苏联体制崩溃解体 Union of Soviet Socialist Republics 苏维埃社会主义共和国联盟 1990 Hubble space telescope 哈伯太空望远镜 1989 USSR quits Eastern Europe 苏联撤离东欧 Berlin wall falls 1988 USSR quits Afghanistan 1987 DNA convicts criminals 用DNA检测方式证明罪犯的罪行 1986 Shuttle Tragedy 航天飞机悲剧 1985 Ozone layer \u0026ldquo;hole\u0026rdquo; discovered 发现臭氧层破洞 1984 String Theory accepted as a possible unifying theory in physics 弦理论被接受的原因在于它有可能会成为物理中的大统一理论 1983 The Internet is Born 互联网诞生 1981 AIDS identified 辨认出爱滋病 Acquired Immunodeficiency Syndrome 获得性免疫缺陷综合征 1979 USSR invades Afghanistan China attacks Vietnam, but is repelled 1977 MRI 核磁共振摄影 Magnetic Resonance Imaging 1973 Roe v. Wade 罗诉韦德案 1972 Nixon Goes To China 尼克松访问中国 1970 String Theory \u0026ldquo;born\u0026rdquo; 1969 1st moon walk 人类首次登陆月球 1968 King Assassinated 马丁·路德·金遇刺 1967 Arab-Israeli \u0026ldquo;6-day war\u0026rdquo; 阿拉伯和以色列之间的“六日战争\u0026quot; 1966 Martin Luther King assassination 1963 John F. Kennedy Assassinated 肯尼迪遇刺 1962 Cuban Missile Crisis 古巴导弹危机 1961 Berlin Wall Built 柏林墙建成 1958 US Launches First Satellite 美国发射第一颗卫星 1953 The Dawn of DNA 1950 Credit cards 1949 Germany divided into East \u0026amp; West 1948 State of Israel founded First transistor 晶体管 1945 USA bombs Japan with two Atomic bombs UN founded 1939-1945 World War II 1935 Spanish Civil War 西班牙内战 Mao\u0026rsquo;s long march 长征 1932 Von Neumann develops foundation for Quantum Mechanics 冯・诺伊曼建立了量子力学的基础 1931 Empire State Building Completed 帝国大厦竣工 1927 Heisenberg, Uncertainty Principle 海森堡的不确定性原理 1920-1933 U.S. Prohibition 美国禁酒时期 1920 Schrödinger Equation, Quantum Theory emerges in modern form 薛定谔方程式，为现在量子力学中的基本方程式 1914-1918 World War I From 1912 end of Imperial China and start of Balkan wars to 1991, the end of the Cold War. The Age of Conflict 冲突时代 从西元1912年中国大情帝国衰亡和巴尔干战争开始，到西元1991年的冷战结束。 An era marked by the Mexican Revolution, the Russian Revolution, the Great War (1914-1918), the Great Influenza Pandemic, the Warlord Era in China, The War of Japanese Imperial Conquest, the Second World War, the Maoist Revolution in China, various anti-colonial wars, the Cold War, and all this while technology leaped ahead with computer-controlled machine tools carrying automation to new levels. Rudimentary automobiles and aircraft of the previous era transformed to a point where humans went to the moon. Air conditioning and television and radio changed culture as people spent more time indoors. Urbanization transformed society as fewer people lived on farms in rural areas. Electrification and the demand for power created a surge in the construction of power plants and infrastructure to extract fossil fuels and Uranium ores from the earth. 这个时代看到了墨西哥革命、俄罗斯革命、第一次世界大战（西元1914-1918年）、流感大流行、中国的军阀时代、日本的帝国战争、第二次世界大战、中国的毛派革命、 各种反殖民战争、冷战，在同时科技飞速的发展，提升到用电脑控制的自动化机器的新的水平。上一个时代，基本生活里的汽车和飞机，已转变为人类有能力登陆月球。随着冷气机、电视机和广播的普及，人们花费更多的时间待在室内。城市化改变了社会，因为在农村地区居住的人口减少了。电气化和对电力的需求，掀起一股建设发电厂的热潮，和从地球上开采化石燃料和铀矿石的基础设施。 "},{"id":14,"href":"/zh/post/life/bilibili/","title":"bilibili","section":"Life","content":" bilibili # movies # 木鱼水心 电影广角镜 world # Yooupi食途 星球研究所 世茹很如意 digital # 那岩KJMX TESTV官方频道 黄杨ME cycling # Contayu_Cycling 道长说车 club100 周四青年 艾慕葡萄 table tennis # -我是派派- computer science # TheCW PegasusWang 神州数码云基地 Koala聊开源 JavaEE之Spring框架 开源社KAIYUANSHE 美团技术团队 技术胖 代码随想录 张老师和杜老师编程课 photography # 影视飓风 music # 94不曈 bilibili-knowledge # 量子位 柴知道 other # M2档案 "},{"id":15,"href":"/zh/zh/post/life/bilibili/","title":"bilibili","section":"Life","content":" bilibili # movies # 木鱼水心 电影广角镜 world # Yooupi食途 星球研究所 世茹很如意 digital # 那岩KJMX TESTV官方频道 黄杨ME cycling # Contayu_Cycling 道长说车 club100 周四青年 艾慕葡萄 table tennis # -我是派派- computer science # TheCW PegasusWang 神州数码云基地 Koala聊开源 JavaEE之Spring框架 开源社KAIYUANSHE 美团技术团队 技术胖 代码随想录 张老师和杜老师编程课 photography # 影视飓风 music # 94不曈 bilibili-knowledge # 量子位 柴知道 other # M2档案 "},{"id":16,"href":"/zh/post/life/books/","title":"books","section":"Life","content":" books # mathematics # 组合数学 原书第5版 computer science # 软件体系结构原理、方法与实践 algorithms # 算法 第四版 剑指Offer：名企面试官精讲典型编程题 java # Head First Java Java实战（第2版） java 核心技术 java 编程的逻辑 Maven 实战 java8 实战 深入理解java虚拟机 第一行代码：Android Spring实战（第6版） spring 微服务实战 第2版 书单 Modern Java(8+)下的技术/技能升级 Java 图灵程序设计丛书·Java系列 security # 白帽子讲 web 安全 networking # http 权威指南 深入浅出https 网络是怎样连接的 cloud # 云计算通俗讲义 kubernates in action database # SQL优化最佳实践 SQL查询的艺术 artificial intelligence # 人工智能入行实战：从校园到职场 深度学习入门 Python 神经网络编程 others # 大象：Thinking in UML Redis 设计与实现 人人都懂设计模式 编程之美 ffmpeg音视频开发基础与实战 黑客与画家 economy # 股票投资入门，进阶，与实战 经济学：第18版 politics # 美国困局 history # 邓小平时代 美国十讲 资中筠 明朝那些事1 文明的进程：文明的社会发生和心理发生的研究 law # 法理学（第4版） 刑法学讲义 罗翔 health # 我们为什么睡觉 philosophy # 西方哲学史讲演录 伦理学的两个基本问题 哲学 科学 常识 古希腊文明的光芒 赵林 大问题：简明哲学导论 人类理智研究 自识与反思：近现代西方哲学的基本问题 谈谈方法 笛卡尔 第一哲学沉思集：反驳与答辩 给无神论者：宗教对世俗生活的意义 psychology # 社会心理学 戴维迈尔斯 认知心理学及其启示 自控力：斯坦福大学最受欢迎心理学课程 习惯的力量 发展心理学 精神焦虑症的自救（病理分析卷） learning science # 学习之道 练习的心态：如何培养耐心、专注和自律 为什么学生不喜欢上学 暗时间 thinking # 送你一颗子弹 2019-08-05 枪炮、病菌与钢铁：人类社会的命运 literature # 恶意 嫌疑人X的献身 伽利略的苦恼 斯通纳 少年的你，如此美丽 杀死一只知更鸟 许三观卖血记 月光落在左手上 虚无的十字架 放学后 mess # 查令十字街84号 2019-08-05 跑步圣经：我跑故我在 当我谈跑步时我在谈些什么 囚徒健身：用失传的技艺练就强大的生存实力 "},{"id":17,"href":"/zh/zh/post/life/books/","title":"books","section":"Life","content":" books # mathematics # 组合数学 原书第5版 computer science # 软件体系结构原理、方法与实践 algorithms # 算法 第四版 剑指Offer：名企面试官精讲典型编程题 java # Head First Java Java实战（第2版） java 核心技术 java 编程的逻辑 Maven 实战 java8 实战 深入理解java虚拟机 第一行代码：Android Spring实战（第6版） spring 微服务实战 第2版 书单 Modern Java(8+)下的技术/技能升级 Java 图灵程序设计丛书·Java系列 security # 白帽子讲 web 安全 networking # http 权威指南 深入浅出https 网络是怎样连接的 cloud # 云计算通俗讲义 kubernates in action database # SQL优化最佳实践 SQL查询的艺术 artificial intelligence # 人工智能入行实战：从校园到职场 深度学习入门 Python 神经网络编程 others # 大象：Thinking in UML Redis 设计与实现 人人都懂设计模式 编程之美 ffmpeg音视频开发基础与实战 黑客与画家 economy # 股票投资入门，进阶，与实战 经济学：第18版 politics # 美国困局 history # 邓小平时代 美国十讲 资中筠 明朝那些事1 文明的进程：文明的社会发生和心理发生的研究 law # 法理学（第4版） 刑法学讲义 罗翔 health # 我们为什么睡觉 philosophy # 西方哲学史讲演录 伦理学的两个基本问题 哲学 科学 常识 古希腊文明的光芒 赵林 大问题：简明哲学导论 人类理智研究 自识与反思：近现代西方哲学的基本问题 谈谈方法 笛卡尔 第一哲学沉思集：反驳与答辩 给无神论者：宗教对世俗生活的意义 psychology # 社会心理学 戴维迈尔斯 认知心理学及其启示 自控力：斯坦福大学最受欢迎心理学课程 习惯的力量 发展心理学 精神焦虑症的自救（病理分析卷） learning science # 学习之道 练习的心态：如何培养耐心、专注和自律 为什么学生不喜欢上学 暗时间 thinking # 送你一颗子弹 2019-08-05 枪炮、病菌与钢铁：人类社会的命运 literature # 恶意 嫌疑人X的献身 伽利略的苦恼 斯通纳 少年的你，如此美丽 杀死一只知更鸟 许三观卖血记 月光落在左手上 虚无的十字架 放学后 mess # 查令十字街84号 2019-08-05 跑步圣经：我跑故我在 当我谈跑步时我在谈些什么 囚徒健身：用失传的技艺练就强大的生存实力 "},{"id":18,"href":"/zh/post/life/cycling/","title":"cycling","section":"Life","content":" cycling # my log # 环滇池 # 9 2024-09-15 8 2023-11-11 7 2023-10-28 6 2023-10-22 5 2023-05-21 4 2022-12-31 3 2022-06-05 2 2022-03-20 1 2021-11-27 昆洛路-\u0026gt;彩云中路爬坡-\u0026gt;彩云北路 # 8 2025-01-07 7 2024-12-19 6 2024-12-18 5 2024-12-17 4 2024-12-13 3 2024-12-10 2 2024-12-06 1 2024-11-29 2024 # 2024-05-01 149.44km 阳宗海 2024-03-16 169.81km 环两湖失败 2023 # 2023-07-15 136.21km 梁王山 2023-04-30 150.06km 抚仙湖折返 2022 # 2022-05-28 131.56km 梁王山 2022-04-30 202.94km 抚仙湖 骑行路线 # 昆明 # 环滇池 宝花路 爬至小亭子 梁王山上坡 西山后山爬坡 松花坝水库爬坡 昭通 # 凤凰山 athlete # Tadej Pogacar # strava 2024-09-29 世锦赛冠军 2024-07-21 环法 stage 21 赛段冠军 2024-07-20 stage 20 赛段冠军 reference # pro cycling stats 自行车职业赛数据及积分排行查询 strava my_strava veloviewer "},{"id":19,"href":"/zh/zh/post/life/cycling/","title":"cycling","section":"Life","content":" cycling # my log # 环滇池 # 9 2024-09-15 8 2023-11-11 7 2023-10-28 6 2023-10-22 5 2023-05-21 4 2022-12-31 3 2022-06-05 2 2022-03-20 1 2021-11-27 昆洛路-\u0026gt;彩云中路爬坡-\u0026gt;彩云北路 # 8 2025-01-07 7 2024-12-19 6 2024-12-18 5 2024-12-17 4 2024-12-13 3 2024-12-10 2 2024-12-06 1 2024-11-29 2024 # 2024-05-01 149.44km 阳宗海 2024-03-16 169.81km 环两湖失败 2023 # 2023-07-15 136.21km 梁王山 2023-04-30 150.06km 抚仙湖折返 2022 # 2022-05-28 131.56km 梁王山 2022-04-30 202.94km 抚仙湖 骑行路线 # 昆明 # 环滇池 宝花路 爬至小亭子 梁王山上坡 西山后山爬坡 松花坝水库爬坡 昭通 # 凤凰山 athlete # Tadej Pogacar # strava 2024-09-29 世锦赛冠军 2024-07-21 环法 stage 21 赛段冠军 2024-07-20 stage 20 赛段冠军 reference # pro cycling stats 自行车职业赛数据及积分排行查询 strava my_strava veloviewer "},{"id":20,"href":"/zh/post/computer-science/database/","title":"database","section":"Computer Science","content":" database # sql # 175 组合两个表 # 175. 组合两个表 select FirstName, LastName, City, State from Person left join on Person.PersonId = Address.PersonId; 176 第二高的薪水 # 176. 第二高的薪水 select distinct Salary as SecondHighestSalary from Employee order by Salary desc limit 1 offset 1 然而，如果没有第 2 高的薪资，即表里可能只有一条记录，这个解答会被评测为 \u0026lsquo;Wrong Answer\u0026rsquo; 。为了克服这个问题，我们可以将其作为临时表。\nSELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary ; "},{"id":21,"href":"/zh/zh/post/computer-science/database/","title":"database","section":"Computer Science","content":" database # sql # 175 组合两个表 # 175. 组合两个表 select FirstName, LastName, City, State from Person left join on Person.PersonId = Address.PersonId; 176 第二高的薪水 # 176. 第二高的薪水 select distinct Salary as SecondHighestSalary from Employee order by Salary desc limit 1 offset 1 然而，如果没有第 2 高的薪资，即表里可能只有一条记录，这个解答会被评测为 \u0026lsquo;Wrong Answer\u0026rsquo; 。为了克服这个问题，我们可以将其作为临时表。\nSELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary ; "},{"id":22,"href":"/zh/post/computer-science/echarts/","title":"echarts","section":"Computer Science","content":" echarts # PPChart "},{"id":23,"href":"/zh/zh/post/computer-science/echarts/","title":"echarts","section":"Computer Science","content":" echarts # PPChart "},{"id":24,"href":"/zh/post/computer-science/github/","title":"github","section":"Computer Science","content":" github # Github Action # GitHub Actions 入门教程 repository # torvalds/linux CesiumGS/cesium CesiumJS is a JavaScript library for creating 3D globes and 2D maps in a web browser without a plugin. It uses WebGL for hardware-accelerated graphics, and is cross-platform, cross-browser, and tuned for dynamic-data visualization. ohmyzsh/ohmyzsh Oh My Zsh is an open source, community-driven framework for managing your zsh configuration. follow # oldratlee "},{"id":25,"href":"/zh/zh/post/computer-science/github/","title":"github","section":"Computer Science","content":" github # Github Action # GitHub Actions 入门教程 repository # torvalds/linux CesiumGS/cesium CesiumJS is a JavaScript library for creating 3D globes and 2D maps in a web browser without a plugin. It uses WebGL for hardware-accelerated graphics, and is cross-platform, cross-browser, and tuned for dynamic-data visualization. ohmyzsh/ohmyzsh Oh My Zsh is an open source, community-driven framework for managing your zsh configuration. follow # oldratlee "},{"id":26,"href":"/zh/post/life/hiking/","title":"hiking","section":"Life","content":" hiking # 2024-10-13 金铜盆 "},{"id":27,"href":"/zh/zh/post/life/hiking/","title":"hiking","section":"Life","content":" hiking # 2024-10-13 金铜盆 "},{"id":28,"href":"/zh/post/computer-science/ios/","title":"ios","section":"Computer Science","content":" ios # 一日一技：iOS抓包最简单方案 bark # Finb/Bark Bark is a push notification tool app. It\u0026rsquo;s free, simple, and secure, leveraging APNs without draining device battery. document Bark-Java-SDK Day One # Obsidian # IFTTT # 3 个非常规 Day One 使用场景 触发你的智能生活：IFTTT 入门 RSS # Inoreader Feedly "},{"id":29,"href":"/zh/zh/post/computer-science/ios/","title":"ios","section":"Computer Science","content":" ios # 一日一技：iOS抓包最简单方案 bark # Finb/Bark Bark is a push notification tool app. It\u0026rsquo;s free, simple, and secure, leveraging APNs without draining device battery. document Bark-Java-SDK Day One # Obsidian # IFTTT # 3 个非常规 Day One 使用场景 触发你的智能生活：IFTTT 入门 RSS # Inoreader Feedly "},{"id":30,"href":"/zh/post/computer-science/job/","title":"job","section":"Computer Science","content":" job # 应届生的简历 "},{"id":31,"href":"/zh/zh/post/computer-science/job/","title":"job","section":"Computer Science","content":" job # 应届生的简历 "},{"id":32,"href":"/zh/post/computer-science/java/jvm/","title":"jvm","section":"Java","content":" jvm # "},{"id":33,"href":"/zh/zh/post/computer-science/java/jvm/","title":"jvm","section":"Java","content":" jvm # "},{"id":34,"href":"/zh/post/life/life-recommend/","title":"life recommand","section":"Life","content":" life recommend # sspai 数码相关内容，还有一些偏硬核的科普，技术文章 movies # 绝命毒师 Breaking Bad 风骚律师 Better Call Saul 权力的游戏 灿烂人生 无言的山丘 人间的条件 赤足小子 婚姻生活 article # 互联网是人类历史的一段弯路吗 每天通勤骑车60公里身体会不会累垮？ books # 社会心理学 戴维迈尔斯 西方哲学史讲演录 赵林 为什么学生不喜欢上学 送你一颗子弹 刘瑜 bilibili # movies 木鱼水心 质量很高，第一个关注的电影解说up 电影广角镜 绝命毒师和风骚律师 解说的很棒 digital 那岩KJMX 科技美学 cycling 道长说车 CLUB100 Contayu_Cycling world Yooupi食途 星球研究所 economy 小Lin说 software # ios # a-Shell working copy Documents Shadowrocket Obsidian ServerCat Github 搜狗输入法 彩云天气 Actions DataJar ShellFish nPlayer HashPhotos Soor Shortcuts 小宇宙 让听播客回归简单——即刻团队新作「小宇宙」体验报告 mac # windows # wallpaper # 4k wallpapers philosophy # Philosophia 哲学社 2020-03-16 种族歧视错在哪儿 F1 # 指北集EP.01——简明Formula One观赛指北 motto # you don\u0026rsquo;t give up, then there\u0026rsquo;s no limitation.\n真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。\n梦里不知身是客，一晌贪欢\n夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？此余之所得也！\n2024-06-12\n艾柯：將來，教育目的是教人“篩選”這種藝術。再沒必要教加德滿都在哪裏，或者查理大帝之後誰是第一個法蘭西國王，因為我們隨處找到答案。不過，我們應該叫學生考查十五個網絡頁面，讓他們自己判斷哪個最差。需要教會他們“比較”這種技巧。\n2023-10-24\n"},{"id":35,"href":"/zh/zh/post/life/life-recommend/","title":"life recommand","section":"Life","content":" life recommend # sspai 数码相关内容，还有一些偏硬核的科普，技术文章 movies # 绝命毒师 Breaking Bad 风骚律师 Better Call Saul 权力的游戏 灿烂人生 无言的山丘 人间的条件 赤足小子 婚姻生活 article # 互联网是人类历史的一段弯路吗 每天通勤骑车60公里身体会不会累垮？ books # 社会心理学 戴维迈尔斯 西方哲学史讲演录 赵林 为什么学生不喜欢上学 送你一颗子弹 刘瑜 bilibili # movies 木鱼水心 质量很高，第一个关注的电影解说up 电影广角镜 绝命毒师和风骚律师 解说的很棒 digital 那岩KJMX 科技美学 cycling 道长说车 CLUB100 Contayu_Cycling world Yooupi食途 星球研究所 economy 小Lin说 software # ios # a-Shell working copy Documents Shadowrocket Obsidian ServerCat Github 搜狗输入法 彩云天气 Actions DataJar ShellFish nPlayer HashPhotos Soor Shortcuts 小宇宙 让听播客回归简单——即刻团队新作「小宇宙」体验报告 mac # windows # wallpaper # 4k wallpapers philosophy # Philosophia 哲学社 2020-03-16 种族歧视错在哪儿 F1 # 指北集EP.01——简明Formula One观赛指北 motto # you don\u0026rsquo;t give up, then there\u0026rsquo;s no limitation.\n真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。\n梦里不知身是客，一晌贪欢\n夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？此余之所得也！\n2024-06-12\n艾柯：將來，教育目的是教人“篩選”這種藝術。再沒必要教加德滿都在哪裏，或者查理大帝之後誰是第一個法蘭西國王，因為我們隨處找到答案。不過，我們應該叫學生考查十五個網絡頁面，讓他們自己判斷哪個最差。需要教會他們“比較”這種技巧。\n2023-10-24\n"},{"id":36,"href":"/zh/post/computer-science/mac/","title":"mac","section":"Computer Science","content":" mac # brew # 查看 brew 服务运行状态 brew services list mysql # 启动 brew services start mysql@8.0 使用命令行连接 mysql mysql -u root reference Macbook通过brew安装mysql8.0 mongodb # mongodb 安装 brew tap mongodb/brew brew update brew install mongodb-community@8.0 启动 mongodb brew services start mongodb-community@8.0 停止 mongodb brew services stop mongodb-community@8.0 mongodb 配置文件位置 vim /opt/homebrew/etc/mongod.conf ffmpeg # 安装 brew install ffmpeg postgresql # Homebrew 安装 postgresql yt-dlp # yt-dlp/yt-dlp 安装 brew install yt-dlp output-template yt-dlp -N 20 https://www.youtube.com/@xiaodaodalang --merge-output-format mp4 # 后台下载 nohup yt-dlp -N 20 https://www.youtube.com/@xiaodaodalang --merge-output-format mp4 \u0026amp; # 加上日期前缀 yt-dlp -N 20 -o \u0026#34;%(upload_date\u0026gt;%Y-%m-%d)s-%(title)s.%(ext)s\u0026#34; https://www.youtube.com/@xiaodaodalang --merge-output-format mp4 player # Mac下最好的视频播放器 IINA disk # DaisyDisk Hidden space 隐藏空间 如何用命令弹出硬盘 查询硬盘挂载路径 df -h 取消挂载 diskutil unmount xxxxx transmit 文件传输工具 把一个java程序配置为一个服务 # 在 macOS 中将 Java 程序配置为服务，可以通过创建一个 LaunchDaemon 或 LaunchAgent 来实现。这里我们以创建一个 LaunchDaemon 为例来说明如何操作。\n准备工作\n确保你的 Java 程序可以无交互地运行：\n你的 Java 应用应该能够从命令行启动，并且不需要用户界面或用户输入。 编写启动脚本（可选）：\n如果你的 Java 程序需要复杂的启动参数或者环境变量设置，建议先编写一个 Shell 脚本来处理这些细节。例如，你可以创建一个名为 start-myapp.sh 的脚本文件，内容如下： #!/bin/bash cd /path/to/your/app export JAVA_OPTS=\u0026#34;-Xms512m -Xmx1024m\u0026#34; exec java $JAVA_OPTS -jar your-application.jar 记得给这个脚本执行权限： chmod +x start-myapp.sh 创建 LaunchDaemon 配置文件\n创建配置文件：\n在 /Library/LaunchDaemons/ 目录下创建一个新的 .plist 文件。文件名应该包含反向域名格式的唯一标识符，例如 com.yourdomain.yourapp.plist。 使用文本编辑器创建并编辑这个文件，内容如下： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.yourdomain.yourapp\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;/path/to/start-myapp.sh\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;RunAtLoad\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;KeepAlive\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;StandardOutPath\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;/path/to/yourapp.log\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;StandardErrorPath\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;/path/to/yourapp.err\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; 解释： Label 是服务的唯一标识符。 ProgramArguments 指定了启动程序的命令及其参数。 RunAtLoad 设置为 true 表示系统启动时自动启动该服务。 KeepAlive 设置为 true 表示如果服务停止，则系统会自动重启它。 StandardOutPath 和 StandardErrorPath 分别指定了标准输出和错误输出的日志文件路径。 加载服务：\n将配置文件保存后，使用以下命令加载服务： sudo launchctl load /Library/LaunchDaemons/com.yourdomain.yourapp.plist 启动服务： sudo launchctl start com.yourdomain.yourapp 停止和卸载服务\n停止服务： sudo launchctl stop com.yourdomain.yourapp 卸载服务： sudo launchctl unload /Library/LaunchDaemons/com.yourdomain.yourapp.plist 以上步骤完成后，你的 Java 应用程序就会作为一个 macOS 服务运行了。如果有任何问题，可以检查指定的日志文件以获取更多信息。\n怎么查看 launchctl 服务的状态 # 在 macOS 中，你可以使用 launchctl 命令来查看服务的状态。以下是几种常见的方法来检查 launchctl 服务的状态：\n查看所有已加载的服务 使用 list 子命令可以列出所有已加载的 launchd 服务及其状态：\nsudo launchctl list 这将显示一个列表，其中包括服务的标签（Label）、进程 ID（PID）以及退出状态（LastExitStatus）。\n查看特定服务的状态 如果你只想查看某个特定服务的状态，可以使用服务的标签（Label）来过滤输出。例如，如果你的服务标签是 com.yourdomain.yourapp，可以使用以下命令：\nsudo launchctl list com.yourdomain.yourapp 查看服务的详细信息 如果你想查看更详细的信息，可以使用 print 子命令。例如：\nsudo launchctl print system/com.yourdomain.yourapp 这将显示关于该服务的详细信息，包括其配置、状态、环境变量等。\n检查服务日志 如果服务有日志输出，可以使用 log 命令来查看日志。例如：\nsudo log show --predicate \u0026#39;process == \u0026#34;yourapp\u0026#34;\u0026#39; --info --debug --last 1h 这将显示过去一小时内与 yourapp 进程相关的所有日志信息。\n示例\n假设你有一个服务标签为 com.example.myapp 的服务，你可以按以下步骤检查其状态：\n查看所有已加载的服务：\nsudo launchctl list 查看特定服务的状态：\nsudo launchctl list com.example.myapp 查看服务的详细信息：\nsudo launchctl print system/com.example.myapp 查看服务日志：\nsudo log show --predicate \u0026#39;process == \u0026#34;myapp\u0026#34;\u0026#39; --info --debug --last 1h 通过这些命令，你可以轻松地检查和管理 launchctl 服务的状态。\n怎么查看 launchctl 中一个服务的内存使用情况 # 在 macOS 中，你可以使用多种方法来查看 launchctl 服务的内存使用情况。以下是几种常见的方法：\n使用 top 命令\ntop 命令是一个实时系统监视工具，可以显示系统的整体状态，包括 CPU 和内存使用情况。你可以通过 top 命令来查找特定服务的进程 ID（PID），然后查看其内存使用情况。\n打开 top 并查找进程：\ntop 在 top 界面中查找你的服务：\n按 P 可以按 CPU 使用率排序。 按 M 可以按内存使用率排序。 查找你的服务进程，通常可以通过进程名称或部分名称来识别。 使用 ps 命令\nps 命令可以显示当前系统中运行的进程信息。你可以结合 grep 命令来查找特定服务的进程信息。\n查找服务的 PID：\nps aux | grep com.yourdomain.yourapp 这将显示与 com.yourdomain.yourapp 相关的所有进程信息。找到你的服务进程的 PID。\n查看特定进程的内存使用情况：\nps -p \u0026lt;PID\u0026gt; -o %mem,%cpu,rss 其中 \u0026lt;PID\u0026gt; 是你在上一步中找到的进程 ID。%mem 显示内存使用百分比，%cpu 显示 CPU 使用百分比，rss 显示常驻集大小（Resident Set Size，即进程占用的实际物理内存）。\n使用 activity monitor\nmacOS 自带的“活动监视器”应用程序也可以用来查看进程的内存使用情况。\n打开“活动监视器”：\n你可以通过 Spotlight 搜索（按 Cmd + Space，然后输入“活动监视器”）来打开它。 切换到“内存”标签页：\n在“活动监视器”中，选择“内存”标签页，这里会显示所有进程的内存使用情况。 查找你的服务：\n在进程列表中查找你的服务名称，查看其内存使用情况。 使用 memory_pressure 命令\nmemory_pressure 命令可以显示系统的内存压力情况，虽然它不能直接显示单个进程的内存使用情况，但可以帮助你了解系统整体的内存状况。\nmemory_pressure 示例\n假设你的服务标签是 com.example.myapp，你可以按以下步骤查看其内存使用情况：\n查找服务的 PID：\nps aux | grep com.example.myapp 假设找到的 PID 是 12345，查看该进程的内存使用情况：\nps -p 12345 -o %mem,%cpu,rss 通过这些方法，你可以轻松地查看 launchctl 服务的内存使用情况。\nmac 上抓取应用的https的包 # 在Mac上抓取应用的HTTPS流量，你需要使用网络分析工具，如Wireshark、Charles Proxy或MITMproxy。由于HTTPS加密了数据传输，直接抓包无法查看具体内容，因此通常需要设置一个代理服务器来进行中间人攻击（Man-in-the-Middle, MITM）来解密和检查HTTPS流量。\n以下是使用Charles Proxy作为例子来说明如何进行HTTPS流量的抓取：\n安装Charles Proxy:\n下载并安装Charles Proxy应用程序到你的Mac电脑上。 配置Charles SSL代理:\n打开Charles，前往Proxy -\u0026gt; SSL Proxying Settings。 在SSL Proxying标签中点击Enable SSL Proxying。 添加你想要监控的应用程序使用的域名端口对，例如对于大多数Web流量是443端口。 安装Charles的SSL证书:\n为了让Charles能够解密HTTPS流量，你需要信任它的SSL证书。 在Charles中前往Help -\u0026gt; SSL Proxying -\u0026gt; Install Charles Root Certificate。 按照提示完成证书安装，并确保系统信任此证书。 配置设备或应用以使用Charles代理:\n如果你想抓取的是Mac本地应用的流量，你需要配置该应用使用Charles作为HTTP/HTTPS代理。 对于某些应用程序，这可能需要更改系统的网络设置，或者在应用内部设置代理服务器地址为localhost或127.0.0.1，端口号通常是8888（默认的Charles监听端口）。 如果是移动设备上的应用，你需要设置设备的Wi-Fi连接使用手动HTTP代理指向运行Charles的Mac的局域网IP地址和端口。 开始抓包:\n现在你可以启动目标应用程序并开始与它交互，所有的HTTPS流量应该会通过Charles被截获，并且如果你正确设置了SSL代理，你应该能看到解密后的流量。 过滤和分析流量:\n使用Charles提供的过滤器和搜索功能来定位你感兴趣的特定请求和响应。 请注意，抓取和解密HTTPS流量可能涉及到隐私问题以及违反服务条款的风险。务必确保你有合法的权利去监视和分析这些流量。如果你是在测试自己的应用，确保遵循公司的政策和法律要求。如果你试图分析第三方应用的流量，请确保你有权这样做。\ncharles # Mac使用Charles进行HTTPS抓包 高颜值抓包工具Charles，实现Mac和IOS端抓取https请求 Configure Charles Root certificate on Mac 需要在keychains里信任证书 Charles Proxy for Mobile apps that use SSL Pinning 8 Ways to Bypass SSL Pinning in iOS questions # 2024-11-15 指纹识别及录入问题 M1 macbookPro 指纹不是识别及其慢就是识别不了，没有反应 电脑插电会有影响，不插电指纹功能是正常的 2025-02-08 Is there a way to download Screen Time data from iPhone or other Apple devices? Timing "},{"id":37,"href":"/zh/zh/post/computer-science/mac/","title":"mac","section":"Computer Science","content":" mac # brew # 查看 brew 服务运行状态 brew services list mysql # 启动 brew services start mysql@8.0 使用命令行连接 mysql mysql -u root reference Macbook通过brew安装mysql8.0 mongodb # mongodb 安装 brew tap mongodb/brew brew update brew install mongodb-community@8.0 启动 mongodb brew services start mongodb-community@8.0 停止 mongodb brew services stop mongodb-community@8.0 mongodb 配置文件位置 vim /opt/homebrew/etc/mongod.conf ffmpeg # 安装 brew install ffmpeg postgresql # Homebrew 安装 postgresql yt-dlp # yt-dlp/yt-dlp 安装 brew install yt-dlp output-template yt-dlp -N 20 https://www.youtube.com/@xiaodaodalang --merge-output-format mp4 # 后台下载 nohup yt-dlp -N 20 https://www.youtube.com/@xiaodaodalang --merge-output-format mp4 \u0026amp; # 加上日期前缀 yt-dlp -N 20 -o \u0026#34;%(upload_date\u0026gt;%Y-%m-%d)s-%(title)s.%(ext)s\u0026#34; https://www.youtube.com/@xiaodaodalang --merge-output-format mp4 player # Mac下最好的视频播放器 IINA disk # DaisyDisk Hidden space 隐藏空间 如何用命令弹出硬盘 查询硬盘挂载路径 df -h 取消挂载 diskutil unmount xxxxx transmit 文件传输工具 把一个java程序配置为一个服务 # 在 macOS 中将 Java 程序配置为服务，可以通过创建一个 LaunchDaemon 或 LaunchAgent 来实现。这里我们以创建一个 LaunchDaemon 为例来说明如何操作。\n准备工作\n确保你的 Java 程序可以无交互地运行：\n你的 Java 应用应该能够从命令行启动，并且不需要用户界面或用户输入。 编写启动脚本（可选）：\n如果你的 Java 程序需要复杂的启动参数或者环境变量设置，建议先编写一个 Shell 脚本来处理这些细节。例如，你可以创建一个名为 start-myapp.sh 的脚本文件，内容如下： #!/bin/bash cd /path/to/your/app export JAVA_OPTS=\u0026#34;-Xms512m -Xmx1024m\u0026#34; exec java $JAVA_OPTS -jar your-application.jar 记得给这个脚本执行权限： chmod +x start-myapp.sh 创建 LaunchDaemon 配置文件\n创建配置文件：\n在 /Library/LaunchDaemons/ 目录下创建一个新的 .plist 文件。文件名应该包含反向域名格式的唯一标识符，例如 com.yourdomain.yourapp.plist。 使用文本编辑器创建并编辑这个文件，内容如下： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.yourdomain.yourapp\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;/path/to/start-myapp.sh\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;RunAtLoad\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;KeepAlive\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;StandardOutPath\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;/path/to/yourapp.log\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;StandardErrorPath\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;/path/to/yourapp.err\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; 解释： Label 是服务的唯一标识符。 ProgramArguments 指定了启动程序的命令及其参数。 RunAtLoad 设置为 true 表示系统启动时自动启动该服务。 KeepAlive 设置为 true 表示如果服务停止，则系统会自动重启它。 StandardOutPath 和 StandardErrorPath 分别指定了标准输出和错误输出的日志文件路径。 加载服务：\n将配置文件保存后，使用以下命令加载服务： sudo launchctl load /Library/LaunchDaemons/com.yourdomain.yourapp.plist 启动服务： sudo launchctl start com.yourdomain.yourapp 停止和卸载服务\n停止服务： sudo launchctl stop com.yourdomain.yourapp 卸载服务： sudo launchctl unload /Library/LaunchDaemons/com.yourdomain.yourapp.plist 以上步骤完成后，你的 Java 应用程序就会作为一个 macOS 服务运行了。如果有任何问题，可以检查指定的日志文件以获取更多信息。\n怎么查看 launchctl 服务的状态 # 在 macOS 中，你可以使用 launchctl 命令来查看服务的状态。以下是几种常见的方法来检查 launchctl 服务的状态：\n查看所有已加载的服务 使用 list 子命令可以列出所有已加载的 launchd 服务及其状态：\nsudo launchctl list 这将显示一个列表，其中包括服务的标签（Label）、进程 ID（PID）以及退出状态（LastExitStatus）。\n查看特定服务的状态 如果你只想查看某个特定服务的状态，可以使用服务的标签（Label）来过滤输出。例如，如果你的服务标签是 com.yourdomain.yourapp，可以使用以下命令：\nsudo launchctl list com.yourdomain.yourapp 查看服务的详细信息 如果你想查看更详细的信息，可以使用 print 子命令。例如：\nsudo launchctl print system/com.yourdomain.yourapp 这将显示关于该服务的详细信息，包括其配置、状态、环境变量等。\n检查服务日志 如果服务有日志输出，可以使用 log 命令来查看日志。例如：\nsudo log show --predicate \u0026#39;process == \u0026#34;yourapp\u0026#34;\u0026#39; --info --debug --last 1h 这将显示过去一小时内与 yourapp 进程相关的所有日志信息。\n示例\n假设你有一个服务标签为 com.example.myapp 的服务，你可以按以下步骤检查其状态：\n查看所有已加载的服务：\nsudo launchctl list 查看特定服务的状态：\nsudo launchctl list com.example.myapp 查看服务的详细信息：\nsudo launchctl print system/com.example.myapp 查看服务日志：\nsudo log show --predicate \u0026#39;process == \u0026#34;myapp\u0026#34;\u0026#39; --info --debug --last 1h 通过这些命令，你可以轻松地检查和管理 launchctl 服务的状态。\n怎么查看 launchctl 中一个服务的内存使用情况 # 在 macOS 中，你可以使用多种方法来查看 launchctl 服务的内存使用情况。以下是几种常见的方法：\n使用 top 命令\ntop 命令是一个实时系统监视工具，可以显示系统的整体状态，包括 CPU 和内存使用情况。你可以通过 top 命令来查找特定服务的进程 ID（PID），然后查看其内存使用情况。\n打开 top 并查找进程：\ntop 在 top 界面中查找你的服务：\n按 P 可以按 CPU 使用率排序。 按 M 可以按内存使用率排序。 查找你的服务进程，通常可以通过进程名称或部分名称来识别。 使用 ps 命令\nps 命令可以显示当前系统中运行的进程信息。你可以结合 grep 命令来查找特定服务的进程信息。\n查找服务的 PID：\nps aux | grep com.yourdomain.yourapp 这将显示与 com.yourdomain.yourapp 相关的所有进程信息。找到你的服务进程的 PID。\n查看特定进程的内存使用情况：\nps -p \u0026lt;PID\u0026gt; -o %mem,%cpu,rss 其中 \u0026lt;PID\u0026gt; 是你在上一步中找到的进程 ID。%mem 显示内存使用百分比，%cpu 显示 CPU 使用百分比，rss 显示常驻集大小（Resident Set Size，即进程占用的实际物理内存）。\n使用 activity monitor\nmacOS 自带的“活动监视器”应用程序也可以用来查看进程的内存使用情况。\n打开“活动监视器”：\n你可以通过 Spotlight 搜索（按 Cmd + Space，然后输入“活动监视器”）来打开它。 切换到“内存”标签页：\n在“活动监视器”中，选择“内存”标签页，这里会显示所有进程的内存使用情况。 查找你的服务：\n在进程列表中查找你的服务名称，查看其内存使用情况。 使用 memory_pressure 命令\nmemory_pressure 命令可以显示系统的内存压力情况，虽然它不能直接显示单个进程的内存使用情况，但可以帮助你了解系统整体的内存状况。\nmemory_pressure 示例\n假设你的服务标签是 com.example.myapp，你可以按以下步骤查看其内存使用情况：\n查找服务的 PID：\nps aux | grep com.example.myapp 假设找到的 PID 是 12345，查看该进程的内存使用情况：\nps -p 12345 -o %mem,%cpu,rss 通过这些方法，你可以轻松地查看 launchctl 服务的内存使用情况。\nmac 上抓取应用的https的包 # 在Mac上抓取应用的HTTPS流量，你需要使用网络分析工具，如Wireshark、Charles Proxy或MITMproxy。由于HTTPS加密了数据传输，直接抓包无法查看具体内容，因此通常需要设置一个代理服务器来进行中间人攻击（Man-in-the-Middle, MITM）来解密和检查HTTPS流量。\n以下是使用Charles Proxy作为例子来说明如何进行HTTPS流量的抓取：\n安装Charles Proxy:\n下载并安装Charles Proxy应用程序到你的Mac电脑上。 配置Charles SSL代理:\n打开Charles，前往Proxy -\u0026gt; SSL Proxying Settings。 在SSL Proxying标签中点击Enable SSL Proxying。 添加你想要监控的应用程序使用的域名端口对，例如对于大多数Web流量是443端口。 安装Charles的SSL证书:\n为了让Charles能够解密HTTPS流量，你需要信任它的SSL证书。 在Charles中前往Help -\u0026gt; SSL Proxying -\u0026gt; Install Charles Root Certificate。 按照提示完成证书安装，并确保系统信任此证书。 配置设备或应用以使用Charles代理:\n如果你想抓取的是Mac本地应用的流量，你需要配置该应用使用Charles作为HTTP/HTTPS代理。 对于某些应用程序，这可能需要更改系统的网络设置，或者在应用内部设置代理服务器地址为localhost或127.0.0.1，端口号通常是8888（默认的Charles监听端口）。 如果是移动设备上的应用，你需要设置设备的Wi-Fi连接使用手动HTTP代理指向运行Charles的Mac的局域网IP地址和端口。 开始抓包:\n现在你可以启动目标应用程序并开始与它交互，所有的HTTPS流量应该会通过Charles被截获，并且如果你正确设置了SSL代理，你应该能看到解密后的流量。 过滤和分析流量:\n使用Charles提供的过滤器和搜索功能来定位你感兴趣的特定请求和响应。 请注意，抓取和解密HTTPS流量可能涉及到隐私问题以及违反服务条款的风险。务必确保你有合法的权利去监视和分析这些流量。如果你是在测试自己的应用，确保遵循公司的政策和法律要求。如果你试图分析第三方应用的流量，请确保你有权这样做。\ncharles # Mac使用Charles进行HTTPS抓包 高颜值抓包工具Charles，实现Mac和IOS端抓取https请求 Configure Charles Root certificate on Mac 需要在keychains里信任证书 Charles Proxy for Mobile apps that use SSL Pinning 8 Ways to Bypass SSL Pinning in iOS questions # 2024-11-15 指纹识别及录入问题 M1 macbookPro 指纹不是识别及其慢就是识别不了，没有反应 电脑插电会有影响，不插电指纹功能是正常的 2025-02-08 Is there a way to download Screen Time data from iPhone or other Apple devices? Timing "},{"id":38,"href":"/zh/post/life/learning-others-log/","title":"other learning","section":"Life","content":" other learning # 2025-01-07 # 美国困局：“新右翼” 的兴起与挑战 # 第1章 2025-01-07 第2章 1 (2025-01-10) 2 (2025-01-10) 3 (2025-01-10) 4 (2025-01-10) 5 (2025-01-10) 第3章 1 (2025-01-11) 2 (2025-01-11) 3 (2025-01-11) 4 (2025-01-11) 5 第4章 1 2 3 4 5 第5章 1 2 3 4 5 第6章 第7章 第8章 第9章 2025-01-04 # 清华韩秀云精品课（第一季，64集） # 清华韩秀云精品课（第一季，64集） ✅ 第一期：国外宏观经济形势 # 1 美国央行大放水 2025-01-04 2 负债率的欧洲和日本 2025-01-04 3 政府发钱刺激经济 2025-01-04 ✅ 第二期：通胀来了，该如何配置资产 # 4 通胀来了怎么办 2025-01-05 5 如何配置你的资产？2025-01-05 6 投资房产考虑什么？2025-01-05 7 投资黄金有必要吗？2025-01-06 8 炒股要注意什么？2025-01-06 ✅ 第三期：我国宏观政策走向 # 9 政府救市与共同富裕 2025-01-06 10 2022年政策与行业机会 2025-01-07 ✅ 第四期：黄金 # 11 黄金的前世今生 2025-01-07 12 美元和黄金挂钩与脱钩 2025-01-07 13 黄金的避险功能 2025-01-08 14 全世界的金库在哪里 2025-01-08 15 投资黄金该注意什么 2025-01-08 ✅ 第五期：石油 # 16 石油的前世今生 2025-01-09 17 洛克菲勒与标准石油 2025-01-09 18 美国石油反垄断 2025-01-09 19 油价为何总在波动 2025-01-11 20 欧佩克的转变 2025-01-11 21 石油的用途 2025-01-11 22 油价为何是负的 2025-01-12 23 什么是石油期货的 2025-01-12 ✅ 第六期：楼市 # 24 房价的成长史的 2025-01-12 25 楼市中看不见的手的 2025-01-13 26 市场决定资源配置的 2025-01-13 27 买房要选稀缺的 2025-01-13 28 买住宅怎么选 2025-01-15 29 买商铺和写字楼 2025-01-15 30 买房看机会成本 2025-01-15 31 买房要注意几件事 2025-01-16 32 买房还是租房好 2025-01-16 33 政府何为要调控楼市 2025-01-16 34 楼市调控还会继续吗？ 2025-01-17 35 房地产税会退出吗？ 2025-01-17 36 房地产税推出后，房价会下跌吗？ 2025-01-17 37 买房防止变成资产 2025-01-19 38 警惕房地产泡沫 2025-01-19 39 全球楼市涨跌互见 2025-01-19 第七期：股市 # 40 炒股要懂经济学 2025-01-20 41 股票是如何诞生的？ 2025-01-20 42 东印度公司的第一张股票 2025-01-20 43 英美为什么发股票 2025-01-21 44 荷兰证券交易所的诞生 2025-01-21 45 纽约证券交易所的由来 2025-01-21 46 道琼斯指数的故事 2025-01-21 47 股票价格与股价指数 2025-01-21 48 股市的投资理念 2025-01-21 49 炒股应该注意什么？2025-02-09 50 参与股市的几种方式 2025-02-09 51 郁金香泡沫 2025-02-09 52 密西西比泡沫 2025-02-10 53 南海泡沫 2025-02-10 54 美国1929年股灾 2025-02-10 55 中国2007年股市暴涨 56 中国2015年股灾 57 教你判断股市趋势 第八期：汇市 # 58 汇率的基本知识 59 人民币汇率 60 美元的霸权 61 欧元的诞生 62 人民币国际化 "},{"id":39,"href":"/zh/zh/post/life/learning-others-log/","title":"other learning","section":"Life","content":" other learning # 2025-01-07 # 美国困局：“新右翼” 的兴起与挑战 # 第1章 2025-01-07 第2章 1 (2025-01-10) 2 (2025-01-10) 3 (2025-01-10) 4 (2025-01-10) 5 (2025-01-10) 第3章 1 (2025-01-11) 2 (2025-01-11) 3 (2025-01-11) 4 (2025-01-11) 5 第4章 1 2 3 4 5 第5章 1 2 3 4 5 第6章 第7章 第8章 第9章 2025-01-04 # 清华韩秀云精品课（第一季，64集） # 清华韩秀云精品课（第一季，64集） ✅ 第一期：国外宏观经济形势 # 1 美国央行大放水 2025-01-04 2 负债率的欧洲和日本 2025-01-04 3 政府发钱刺激经济 2025-01-04 ✅ 第二期：通胀来了，该如何配置资产 # 4 通胀来了怎么办 2025-01-05 5 如何配置你的资产？2025-01-05 6 投资房产考虑什么？2025-01-05 7 投资黄金有必要吗？2025-01-06 8 炒股要注意什么？2025-01-06 ✅ 第三期：我国宏观政策走向 # 9 政府救市与共同富裕 2025-01-06 10 2022年政策与行业机会 2025-01-07 ✅ 第四期：黄金 # 11 黄金的前世今生 2025-01-07 12 美元和黄金挂钩与脱钩 2025-01-07 13 黄金的避险功能 2025-01-08 14 全世界的金库在哪里 2025-01-08 15 投资黄金该注意什么 2025-01-08 ✅ 第五期：石油 # 16 石油的前世今生 2025-01-09 17 洛克菲勒与标准石油 2025-01-09 18 美国石油反垄断 2025-01-09 19 油价为何总在波动 2025-01-11 20 欧佩克的转变 2025-01-11 21 石油的用途 2025-01-11 22 油价为何是负的 2025-01-12 23 什么是石油期货的 2025-01-12 ✅ 第六期：楼市 # 24 房价的成长史的 2025-01-12 25 楼市中看不见的手的 2025-01-13 26 市场决定资源配置的 2025-01-13 27 买房要选稀缺的 2025-01-13 28 买住宅怎么选 2025-01-15 29 买商铺和写字楼 2025-01-15 30 买房看机会成本 2025-01-15 31 买房要注意几件事 2025-01-16 32 买房还是租房好 2025-01-16 33 政府何为要调控楼市 2025-01-16 34 楼市调控还会继续吗？ 2025-01-17 35 房地产税会退出吗？ 2025-01-17 36 房地产税推出后，房价会下跌吗？ 2025-01-17 37 买房防止变成资产 2025-01-19 38 警惕房地产泡沫 2025-01-19 39 全球楼市涨跌互见 2025-01-19 第七期：股市 # 40 炒股要懂经济学 2025-01-20 41 股票是如何诞生的？ 2025-01-20 42 东印度公司的第一张股票 2025-01-20 43 英美为什么发股票 2025-01-21 44 荷兰证券交易所的诞生 2025-01-21 45 纽约证券交易所的由来 2025-01-21 46 道琼斯指数的故事 2025-01-21 47 股票价格与股价指数 2025-01-21 48 股市的投资理念 2025-01-21 49 炒股应该注意什么？2025-02-09 50 参与股市的几种方式 2025-02-09 51 郁金香泡沫 2025-02-09 52 密西西比泡沫 2025-02-10 53 南海泡沫 2025-02-10 54 美国1929年股灾 2025-02-10 55 中国2007年股市暴涨 56 中国2015年股灾 57 教你判断股市趋势 第八期：汇市 # 58 汇率的基本知识 59 人民币汇率 60 美元的霸权 61 欧元的诞生 62 人民币国际化 "},{"id":40,"href":"/zh/post/life/podcast/","title":"podcast","section":"Life","content":" podcast # 小宇宙 # 码农姐妹 经济新闻每日速递 纵横说 "},{"id":41,"href":"/zh/zh/post/life/podcast/","title":"podcast","section":"Life","content":" podcast # 小宇宙 # 码农姐妹 经济新闻每日速递 纵横说 "},{"id":42,"href":"/zh/post/life/politics/","title":"politics","section":"Life","content":" politics # 茶党 # \u0026ldquo;茶党\u0026rdquo;（Tea Party）通常指的是美国的一个政治运动，这个运动始于2009年，主要由保守派共和党支持者组成，强调减少政府开支、降低税收、限制政府权力以及遵守美国宪法。茶党的名字来源于1773年的波士顿茶叶事件，这是一个反对英国殖民统治和高税收的历史事件，象征着对政府过度干预的抗议。\n茶党成员经常组织示威活动，尤其是在经济政策和财政责任方面。他们在2010年的中期选举中对美国政治产生了显著影响，支持了多位共和党候选人的当选，这些候选人随后在美国国会中代表了更加保守的立场。\n随着时间的发展，茶党的影响力有所减弱，但它仍然是美国政治中一个重要的保守力量。如果你有关于茶党的更具体问题，欢迎继续提问。\n茶党和共和党建制派的区别是什么 # 茶党和共和党建制派是美国共和党内两个不同的政治派别，它们在政治立场、策略和目标上存在一些显著差异：\n政治立场：\n茶党：茶党通常被视为共和党内的激进派，强调极端保守的经济政策，比如大幅减税、削减政府开支、反对政府干预市场、减少债务和赤字。此外，茶党成员往往强烈反对奥巴马政府时期的医疗保健改革（即“奥巴马医改”）等政策。 共和党建制派：相比之下，建制派共和党人虽然也支持保守政策，但他们的立场相对温和，愿意与民主党合作以实现政治目标。建制派更倾向于维护共和党的传统利益，包括与大企业和精英阶层的关系。 策略和方法：\n茶党：茶党成员倾向于采取更为激进的策略，包括组织大规模抗议活动、支持极端保守的候选人、反对妥协。他们通常认为现有的政治体系已经腐败，需要彻底改革。 共和党建制派：建制派共和党人更倾向于通过传统政治渠道实现目标，如立法谈判、建立联盟和政治筹款。他们更注重保持共和党的整体稳定和长期利益。 目标：\n茶党：茶党的目标是推动共和党向更加保守的方向发展，减少政府规模和干预，保护个人自由和财产权。 共和党建制派：建制派的目标是保持共和党的主流地位，通过务实的政治策略赢得选举，维护共和党的长期利益和权力。 支持者基础：\n茶党：茶党的支持者通常是中下层中产阶级，他们对经济困境和政府过度干预感到不满，希望通过政治行动表达自己的诉求。 共和党建制派：建制派的支持者更多来自大企业和精英阶层，他们希望通过共和党的政策维护自身的经济利益。 总结来说，茶党和共和党建制派在政治立场、策略和目标上存在明显的差异，茶党更激进、更强调基层动员，而建制派则更温和、更注重政治稳定和长期利益。\n"},{"id":43,"href":"/zh/zh/post/life/politics/","title":"politics","section":"Life","content":" politics # 茶党 # \u0026ldquo;茶党\u0026rdquo;（Tea Party）通常指的是美国的一个政治运动，这个运动始于2009年，主要由保守派共和党支持者组成，强调减少政府开支、降低税收、限制政府权力以及遵守美国宪法。茶党的名字来源于1773年的波士顿茶叶事件，这是一个反对英国殖民统治和高税收的历史事件，象征着对政府过度干预的抗议。\n茶党成员经常组织示威活动，尤其是在经济政策和财政责任方面。他们在2010年的中期选举中对美国政治产生了显著影响，支持了多位共和党候选人的当选，这些候选人随后在美国国会中代表了更加保守的立场。\n随着时间的发展，茶党的影响力有所减弱，但它仍然是美国政治中一个重要的保守力量。如果你有关于茶党的更具体问题，欢迎继续提问。\n茶党和共和党建制派的区别是什么 # 茶党和共和党建制派是美国共和党内两个不同的政治派别，它们在政治立场、策略和目标上存在一些显著差异：\n政治立场：\n茶党：茶党通常被视为共和党内的激进派，强调极端保守的经济政策，比如大幅减税、削减政府开支、反对政府干预市场、减少债务和赤字。此外，茶党成员往往强烈反对奥巴马政府时期的医疗保健改革（即“奥巴马医改”）等政策。 共和党建制派：相比之下，建制派共和党人虽然也支持保守政策，但他们的立场相对温和，愿意与民主党合作以实现政治目标。建制派更倾向于维护共和党的传统利益，包括与大企业和精英阶层的关系。 策略和方法：\n茶党：茶党成员倾向于采取更为激进的策略，包括组织大规模抗议活动、支持极端保守的候选人、反对妥协。他们通常认为现有的政治体系已经腐败，需要彻底改革。 共和党建制派：建制派共和党人更倾向于通过传统政治渠道实现目标，如立法谈判、建立联盟和政治筹款。他们更注重保持共和党的整体稳定和长期利益。 目标：\n茶党：茶党的目标是推动共和党向更加保守的方向发展，减少政府规模和干预，保护个人自由和财产权。 共和党建制派：建制派的目标是保持共和党的主流地位，通过务实的政治策略赢得选举，维护共和党的长期利益和权力。 支持者基础：\n茶党：茶党的支持者通常是中下层中产阶级，他们对经济困境和政府过度干预感到不满，希望通过政治行动表达自己的诉求。 共和党建制派：建制派的支持者更多来自大企业和精英阶层，他们希望通过共和党的政策维护自身的经济利益。 总结来说，茶党和共和党建制派在政治立场、策略和目标上存在明显的差异，茶党更激进、更强调基层动员，而建制派则更温和、更注重政治稳定和长期利益。\n"},{"id":44,"href":"/zh/post/computer-science/raspberrypi/","title":"raspberry pi","section":"Computer Science","content":" raspberry pi # reference # 树莓派文档 clash # reference 为什么全局代理后， CMD 依然 Ping 不通 Google？ 树莓派 Clash 透明代理(TProxy) 在 Raspberry Pi 上运行 Clash 作为透明代理 解决 Clash Meta 中TUN模式无法上网的问题：正确配置DNS设置 解决 树莓派ping: baidu.com: 域名解析暂时失败 树莓派安装clash，实现科学上网 在 Raspberry Pi 上运行 Clash 作为透明代理 http://yacd.haishan.me yt-dlp # 使用这个工具，可以下载 youtube 视频\n后台下载命令 nohup yt-dlp -N 20 {{video_url}} --merge-output-format mp4 \u0026amp; 实时查看后台下载进度 tail -f nohup.out 停止下载 查询后台进程号 ps -aux | grep yt-dlp 杀死进程 kill -9 {{进程号}} tomcat # 树莓派安装Tomcat wget https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.36/bin/apache-tomcat-9.0.36.tar.gz tar zxvf apache-tomcat-9.0.36.tar.gz cd ~/apache-tomcat-9.0.36/bin sudo ./startup.sh dd # dd 命令是一个非常强大的工具，可以用来复制和转换文件。通过创建一个临时文件并测量其读写速度，可以测试存储介质的性能。\n打开终端：您可以通过SSH连接到您的树莓派，或者直接在树莓派上打开终端。\n测试写入速度：\n创建一个 1GB 的临时文件，并测量写入速度： sudo dd if=/dev/zero of=testfile bs=1M count=1024 conv=fdatasync 解释： if=/dev/zero：从 /dev/zero 读取数据（这是一个无限的零流）。 of=testfile：将数据写入名为 testfile 的文件。 bs=1M：每次读写 1MB 的数据块。 count=1024：写入 1024 个 1MB 的数据块，总共 1GB。 conv=fdatasync：确保所有数据都写入磁盘后再结束命令。 测试读取速度：\n读取刚刚创建的文件，并测量读取速度： sudo dd if=testfile of=/dev/null bs=1M 解释： if=testfile：从 testfile 文件读取数据。 of=/dev/null：将数据写入 /dev/null（丢弃数据）。 bs=1M：每次读取 1MB 的数据块。 删除测试文件：\n测试完成后，删除 testfile 以释放空间： sudo rm testfile iwlist # sudo iwlist wlan0 scan sudo iwlist wlan0 scan | grep SSID 定时任务 # 查看当前的定时任务 crontab -l 编辑定时任务 crontab -e 外网登录 # 如何从外网登录访问树莓派Raspberry Pi holer Wisdom wisdom-projects/holer 方式一：使用公开的holer映射或者开通holer服务，通过holer客户端软件经holer服务器实现公网访问 方式二：使用holer服务端软件搭建holer服务，通过holer客户端软件经自己服务器实现公网访问， Holer端口映射软件使用教程 cpolar # cpolar 3.3 将隧道配置为后台服务 Cpolar快速入门教程：树莓派系列 后台管理页面 http://localhost:9200 zsh: corrupt history file /home/me/.zsh_history # 怎样修复zsh历史记录错误：zsh: corrupt history file /home/me/.zsh_history cd ~ mv .zsh_history .zsh_history_bad strings -eS .zsh_history_bad \u0026gt; .zsh_history fc -R .zsh_history "},{"id":45,"href":"/zh/zh/post/computer-science/raspberrypi/","title":"raspberry pi","section":"Computer Science","content":" raspberry pi # reference # 树莓派文档 clash # reference 为什么全局代理后， CMD 依然 Ping 不通 Google？ 树莓派 Clash 透明代理(TProxy) 在 Raspberry Pi 上运行 Clash 作为透明代理 解决 Clash Meta 中TUN模式无法上网的问题：正确配置DNS设置 解决 树莓派ping: baidu.com: 域名解析暂时失败 树莓派安装clash，实现科学上网 在 Raspberry Pi 上运行 Clash 作为透明代理 http://yacd.haishan.me yt-dlp # 使用这个工具，可以下载 youtube 视频\n后台下载命令 nohup yt-dlp -N 20 {{video_url}} --merge-output-format mp4 \u0026amp; 实时查看后台下载进度 tail -f nohup.out 停止下载 查询后台进程号 ps -aux | grep yt-dlp 杀死进程 kill -9 {{进程号}} tomcat # 树莓派安装Tomcat wget https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.36/bin/apache-tomcat-9.0.36.tar.gz tar zxvf apache-tomcat-9.0.36.tar.gz cd ~/apache-tomcat-9.0.36/bin sudo ./startup.sh dd # dd 命令是一个非常强大的工具，可以用来复制和转换文件。通过创建一个临时文件并测量其读写速度，可以测试存储介质的性能。\n打开终端：您可以通过SSH连接到您的树莓派，或者直接在树莓派上打开终端。\n测试写入速度：\n创建一个 1GB 的临时文件，并测量写入速度： sudo dd if=/dev/zero of=testfile bs=1M count=1024 conv=fdatasync 解释： if=/dev/zero：从 /dev/zero 读取数据（这是一个无限的零流）。 of=testfile：将数据写入名为 testfile 的文件。 bs=1M：每次读写 1MB 的数据块。 count=1024：写入 1024 个 1MB 的数据块，总共 1GB。 conv=fdatasync：确保所有数据都写入磁盘后再结束命令。 测试读取速度：\n读取刚刚创建的文件，并测量读取速度： sudo dd if=testfile of=/dev/null bs=1M 解释： if=testfile：从 testfile 文件读取数据。 of=/dev/null：将数据写入 /dev/null（丢弃数据）。 bs=1M：每次读取 1MB 的数据块。 删除测试文件：\n测试完成后，删除 testfile 以释放空间： sudo rm testfile iwlist # sudo iwlist wlan0 scan sudo iwlist wlan0 scan | grep SSID 定时任务 # 查看当前的定时任务 crontab -l 编辑定时任务 crontab -e 外网登录 # 如何从外网登录访问树莓派Raspberry Pi holer Wisdom wisdom-projects/holer 方式一：使用公开的holer映射或者开通holer服务，通过holer客户端软件经holer服务器实现公网访问 方式二：使用holer服务端软件搭建holer服务，通过holer客户端软件经自己服务器实现公网访问， Holer端口映射软件使用教程 cpolar # cpolar 3.3 将隧道配置为后台服务 Cpolar快速入门教程：树莓派系列 后台管理页面 http://localhost:9200 zsh: corrupt history file /home/me/.zsh_history # 怎样修复zsh历史记录错误：zsh: corrupt history file /home/me/.zsh_history cd ~ mv .zsh_history .zsh_history_bad strings -eS .zsh_history_bad \u0026gt; .zsh_history fc -R .zsh_history "},{"id":46,"href":"/zh/post/computer-science/security/","title":"security","section":"Computer Science","content":" security # man-in-the-middle attack 中间人攻击 # SSL Pinning is a technique we use on the client side to avoid a man-in-the-middle attack by validating the server certificates. The developers embed (or pin) a list of trustful certificates in the client application during development and use them to compare against the server certificates during runtime.\nIf there is a mismatch between the server and the local copy of certificates, the connection will be disrupted, and no further user data will be sent to that server. This enforcement ensures that user devices communicate only with dedicated, trustful servers.\nSSL Pinning prevents a man-in-the-middle attack, which means an attacker can not intercept the traffic and modify the data. If an attacker can not intercept the traffic, the application automatically prevents many server-side vulnerabilities. Because an attacker can not perform API-level test cases, implementing SSL is very important.\nSSL pinning # reference Charles Proxy for Mobile apps that use SSL Pinning 8 Ways to Bypass SSL Pinning in iOS "},{"id":47,"href":"/zh/zh/post/computer-science/security/","title":"security","section":"Computer Science","content":" security # man-in-the-middle attack 中间人攻击 # SSL Pinning is a technique we use on the client side to avoid a man-in-the-middle attack by validating the server certificates. The developers embed (or pin) a list of trustful certificates in the client application during development and use them to compare against the server certificates during runtime.\nIf there is a mismatch between the server and the local copy of certificates, the connection will be disrupted, and no further user data will be sent to that server. This enforcement ensures that user devices communicate only with dedicated, trustful servers.\nSSL Pinning prevents a man-in-the-middle attack, which means an attacker can not intercept the traffic and modify the data. If an attacker can not intercept the traffic, the application automatically prevents many server-side vulnerabilities. Because an attacker can not perform API-level test cases, implementing SSL is very important.\nSSL pinning # reference Charles Proxy for Mobile apps that use SSL Pinning 8 Ways to Bypass SSL Pinning in iOS "},{"id":48,"href":"/zh/post/computer-science/vue/","title":"vue","section":"Computer Science","content":" vue # vuejs.org 文档 vue2 教程 Vue 2.0 在 2023 年 12 月 31 日停止更新 vue3 教程 快速上手 # 安装 node.js 使用 brew 安装 brew install node 检查 node 是否安装成功 node -v npm -v 创建 vue 项目 npm create vue@latest cd my-vue-project 修改镜像源 reference npm、yarn、pnpm 最新国内镜像源设置和常见问题解决 npm install npm run dev Local http://localhost:5173 Vue DevTools http://localhost:5173/__devtools__/ reference 如何在 macOS 上安装 Node.js "},{"id":49,"href":"/zh/zh/post/computer-science/vue/","title":"vue","section":"Computer Science","content":" vue # vuejs.org 文档 vue2 教程 Vue 2.0 在 2023 年 12 月 31 日停止更新 vue3 教程 快速上手 # 安装 node.js 使用 brew 安装 brew install node 检查 node 是否安装成功 node -v npm -v 创建 vue 项目 npm create vue@latest cd my-vue-project 修改镜像源 reference npm、yarn、pnpm 最新国内镜像源设置和常见问题解决 npm install npm run dev Local http://localhost:5173 Vue DevTools http://localhost:5173/__devtools__/ reference 如何在 macOS 上安装 Node.js "},{"id":50,"href":"/zh/post/life/goal/","title":"goal","section":"Life","content":" goal # 2025-01-12 # 过年前完成(1月24日内) 面试经典150题(一天完成5道题, 应该完成70道题左右) Spring实战 第6版 Book (读完这本书) 清华韩秀云精品课（第一季，64集）(大概应该看到56集) 美国困局：“新右翼” 的兴起与挑战 (读完这本书) OAuth 2 in Action Microservices Security in Action API Security in Action ActiveMQ in Action RabbitMQ in Depth（Manning，2017年） Alvaro Videla和Jason J.W. Williams合著的RabbitMQ in Action（Manning，2012年） Kafka in Action （Manning，2017年） Enterprise Integration Patterns（Addison-Wesley，2003年） Functional Programming in Java（Manning，2017年） Grokking Functional Programming（Manning，2021年） "},{"id":51,"href":"/zh/zh/post/life/goal/","title":"goal","section":"Life","content":" goal # 2025-01-12 # 过年前完成(1月24日内) 面试经典150题(一天完成5道题, 应该完成70道题左右) Spring实战 第6版 Book (读完这本书) 清华韩秀云精品课（第一季，64集）(大概应该看到56集) 美国困局：“新右翼” 的兴起与挑战 (读完这本书) OAuth 2 in Action Microservices Security in Action API Security in Action ActiveMQ in Action RabbitMQ in Depth（Manning，2017年） Alvaro Videla和Jason J.W. Williams合著的RabbitMQ in Action（Manning，2012年） Kafka in Action （Manning，2017年） Enterprise Integration Patterns（Addison-Wesley，2003年） Functional Programming in Java（Manning，2017年） Grokking Functional Programming（Manning，2021年） "},{"id":52,"href":"/zh/post/life/accumulation/","title":"accumulation","section":"Life","content":" accumulation # cycling # 微信读书 # 2025 85 hour, 32 min 2024 8 hour, 45 min 2023 24 hour, 48 min 2022 8 hour, 47 min 2021 1 min 2020 7 min 轻听英语 # 2025 2024 70 hour, 55 min 2023 5 hour, 36 min 2022 2 hour, 6 min 2021 1 hour, 3 min 2020 15 hour, 39 min 2019 38 hour, 42 min 2018 11 hour, 16 min 2017 7 hour, 57 min 小宇宙 # accumulation 2025-01-13 10 h, 3 min 码农姐妹 2025-01-13 3 h, 36 min 经济新闻每日速递 2025-01-13 3 h, 5 min 纵横说 2025-01-13 2 h, 9 min "},{"id":53,"href":"/zh/zh/post/life/accumulation/","title":"accumulation","section":"Life","content":" accumulation # cycling # 微信读书 # 2025 85 hour, 32 min 2024 8 hour, 45 min 2023 24 hour, 48 min 2022 8 hour, 47 min 2021 1 min 2020 7 min 轻听英语 # 2025 2024 70 hour, 55 min 2023 5 hour, 36 min 2022 2 hour, 6 min 2021 1 hour, 3 min 2020 15 hour, 39 min 2019 38 hour, 42 min 2018 11 hour, 16 min 2017 7 hour, 57 min 小宇宙 # accumulation 2025-01-13 10 h, 3 min 码农姐妹 2025-01-13 3 h, 36 min 经济新闻每日速递 2025-01-13 3 h, 5 min 纵横说 2025-01-13 2 h, 9 min "},{"id":54,"href":"/zh/post/life/coffee/","title":"coffee","section":"Life","content":" coffee # 咖啡碎碎念#1 一次探店2家上海“天花板”咖啡馆？！喝到一半老板直接开始上课？#上海VLOG（上） 科普丨意式咖啡傻傻分不清？10分钟带你全部看懂 马克西姆咖啡机 马克西姆使用评测（上）3000+价位段最值得入手半自动意式咖啡机一体机 马克西姆咖啡机评测（下）使用成本低是最好的入手理由 马克西姆咖啡机用了一年，总结出5个使用技巧 马克西姆半自动家用咖啡机，如何调试和定量出品，掌握核心2点，控制好粉重和粉液比 "},{"id":55,"href":"/zh/zh/post/life/coffee/","title":"coffee","section":"Life","content":" coffee # 咖啡碎碎念#1 一次探店2家上海“天花板”咖啡馆？！喝到一半老板直接开始上课？#上海VLOG（上） 科普丨意式咖啡傻傻分不清？10分钟带你全部看懂 马克西姆咖啡机 马克西姆使用评测（上）3000+价位段最值得入手半自动意式咖啡机一体机 马克西姆咖啡机评测（下）使用成本低是最好的入手理由 马克西姆咖啡机用了一年，总结出5个使用技巧 马克西姆半自动家用咖啡机，如何调试和定量出品，掌握核心2点，控制好粉重和粉液比 "},{"id":56,"href":"/zh/post/computer-science/algorithm/","title":"Algorithm","section":"Computer Science","content":" Algorithm # 代码随想录 Tips # 如果我要创建一个列表，并且需要一直在列表的开头插入元素，我要怎么实现代码保证效率 # 在 Java 中，如果你需要频繁在列表的开头插入元素，使用 LinkedList 会比 ArrayList 更高效。因为 LinkedList 在列表开头插入元素的时间复杂度是 O(1)，而 ArrayList 在开头插入元素的时间复杂度是 O(n)，需要移动所有元素。\n使用 LinkedList 的示例代码：\nimport java.util.LinkedList; import java.util.List; public class Main { public static void main(String[] args) { // 创建一个 LinkedList List\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 在列表开头插入元素 list.add(0, 1); // 插入元素 1 list.add(0, 2); // 插入元素 2 list.add(0, 3); // 插入元素 3 // 输出列表 System.out.println(list); // 输出: [3, 2, 1] } } 为什么 LinkedList 更高效？\nLinkedList 是基于双向链表实现的，插入和删除操作只需要调整节点的指针，时间复杂度为 O(1)。 ArrayList 是基于动态数组实现的，插入和删除操作需要移动元素，时间复杂度为 O(n)。 总结：\n如果你需要频繁在列表开头插入元素，优先选择 LinkedList 以保证效率。\nLinkedList 在任意位置插入和删除节点，时间复杂度都是O(1)吗？ # 不是的，LinkedList 在任意位置插入和删除节点的时间复杂度并不总是 O(1)。具体的时间复杂度取决于操作的位置。\nLinkedList 的时间复杂度分析：\n在头部或尾部插入/删除节点：\n时间复杂度是 O(1)，因为 LinkedList 是双向链表，直接操作头节点或尾节点即可。 在任意位置插入/删除节点：\n时间复杂度是 O(n)，因为需要从头节点或尾节点开始遍历链表，找到目标位置后才能进行操作。 为什么任意位置插入/删除是 O(n)？\nLinkedList 是基于双向链表实现的，虽然插入和删除操作本身只需要调整指针（O(1)），但找到目标位置需要遍历链表。 平均情况下，遍历链表的时间复杂度是 O(n/2) ≈ O(n)。 示例代码：\nimport java.util.LinkedList; public class Main { public static void main(String[] args) { LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); // 在索引 1 处插入元素（需要遍历到索引 1） list.add(1, 10); // 时间复杂度 O(n) // 删除索引 2 处的元素（需要遍历到索引 2） list.remove(2); // 时间复杂度 O(n) System.out.println(list); // 输出: [1, 10, 3] } } 总结：\nLinkedList 在头部或尾部插入/删除节点的时间复杂度是 O(1)。 在任意位置插入/删除节点的时间复杂度是 O(n)，因为需要遍历链表找到目标位置。 如果你需要频繁在任意位置插入或删除节点，并且希望时间复杂度更低，可以考虑使用其他数据结构（如 ArrayList 或自定义数据结构），具体选择取决于你的使用场景。\n如果我要不断往list的末尾添加元素，是使用LinkedList还是ArrayList？ # 如果你需要不断往列表的末尾添加元素，使用 ArrayList 会比 LinkedList 更高效。以下是原因和详细分析：\nArrayList 的优势 时间复杂度： 在末尾添加元素的平均时间复杂度是 O(1)。 只有在数组容量不足时，ArrayList 需要扩容（创建一个新的更大的数组并复制元素），此时时间复杂度是 O(n)。但扩容操作是分摊的，平均下来仍然是 O(1)。 空间效率： ArrayList 是基于数组实现的，内存连续，存储效率高，没有额外的指针开销。 缓存友好： 数组的内存布局是连续的，对 CPU 缓存更友好，访问速度更快。 LinkedList 的劣势 时间复杂度： 在末尾添加元素的时间复杂度是 O(1)，但每次添加都需要创建一个新的节点对象，并调整指针。 空间效率： LinkedList 是基于双向链表实现的，每个节点需要额外的空间存储前驱和后继指针，内存开销更大。 缓存不友好： 链表的内存布局是分散的，对 CPU 缓存不友好，访问速度较慢。 性能对比 ArrayList： 添加元素时，大多数情况下是 O(1)，偶尔扩容时是 O(n)。 内存连续，访问速度快。 LinkedList： 添加元素时，每次都是 O(1)，但需要创建节点对象和调整指针。 内存分散，访问速度慢。 代码示例 使用 ArrayList：\nimport java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 不断往末尾添加元素 for (int i = 0; i \u0026lt; 1000000; i++) { list.add(i); // 平均时间复杂度 O(1) } System.out.println(\u0026#34;ArrayList 添加完成\u0026#34;); } } 使用 LinkedList：\nimport java.util.LinkedList; import java.util.List; public class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 不断往末尾添加元素 for (int i = 0; i \u0026lt; 1000000; i++) { list.add(i); // 时间复杂度 O(1)，但性能不如 ArrayList } System.out.println(\u0026#34;LinkedList 添加完成\u0026#34;); } } 实测性能 在实际测试中，ArrayList 的性能通常优于 LinkedList，尤其是在大量添加元素时。以下是一个简单的性能对比：\n操作 ArrayList 耗时 LinkedList 耗时 添加 100 万个元素 ~50 ms ~100 ms 添加 1000 万个元素 ~500 ms ~1200 ms 总结 如果你需要不断往列表末尾添加元素，优先选择 ArrayList。 它的时间复杂度更低（平均 O(1)）。 它的内存效率更高，访问速度更快。 只有在需要频繁在列表头部或中间插入/删除元素时，才考虑使用 LinkedList。 希望这个解答对你有帮助！如果还有其他问题，欢迎随时提问！\n如果我想要构造一个字符串，我会不断往字符串头部添加字符，我该怎么编码保证效率 # 如果你需要不断往字符串的头部添加字符，直接使用 Java 的 String 或 StringBuilder 会导致性能问题，因为它们的底层实现不适合频繁在头部插入操作。以下是原因和高效解决方案：\n为什么 String 和 StringBuilder 不适合？ String： String 是不可变的，每次修改都会创建一个新的字符串对象，频繁在头部插入字符会导致大量对象创建和复制，性能极差。 StringBuilder： StringBuilder 是可变的，适合在尾部添加字符（时间复杂度 O(1)），但在头部插入字符的时间复杂度是 O(n)，因为需要移动所有现有字符。 高效解决方案 为了高效地在字符串头部添加字符，可以使用以下数据结构：\n方案 1：使用 LinkedList\u0026lt;Character\u0026gt;\nLinkedList 在头部插入元素的时间复杂度是 O(1)，非常适合频繁在头部添加字符的场景。 插入完成后，可以将 LinkedList 转换为字符串。 方案 2：使用 Deque\u0026lt;Character\u0026gt;（双端队列）\nDeque 是基于双向链表实现的，支持在头部和尾部高效插入和删除元素。 插入完成后，可以将 Deque 转换为字符串。 代码实现 方案 1：使用 LinkedList\u0026lt;Character\u0026gt;\nimport java.util.LinkedList; public class Main { public static void main(String[] args) { // 创建一个 LinkedList 来存储字符 LinkedList\u0026lt;Character\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 不断往头部添加字符 list.addFirst(\u0026#39;a\u0026#39;); // 添加字符 \u0026#39;a\u0026#39; list.addFirst(\u0026#39;b\u0026#39;); // 添加字符 \u0026#39;b\u0026#39; list.addFirst(\u0026#39;c\u0026#39;); // 添加字符 \u0026#39;c\u0026#39; // 将 LinkedList 转换为字符串 StringBuilder sb = new StringBuilder(); for (char c : list) { sb.append(c); } String result = sb.toString(); System.out.println(result); // 输出: cba } } 方案 2：使用 Deque\u0026lt;Character\u0026gt;\nimport java.util.Deque; import java.util.LinkedList; public class Main { public static void main(String[] args) { // 创建一个 Deque 来存储字符 Deque\u0026lt;Character\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); // 不断往头部添加字符 deque.addFirst(\u0026#39;a\u0026#39;); // 添加字符 \u0026#39;a\u0026#39; deque.addFirst(\u0026#39;b\u0026#39;); // 添加字符 \u0026#39;b\u0026#39; deque.addFirst(\u0026#39;c\u0026#39;); // 添加字符 \u0026#39;c\u0026#39; // 将 Deque 转换为字符串 StringBuilder sb = new StringBuilder(); for (char c : deque) { sb.append(c); } String result = sb.toString(); System.out.println(result); // 输出: cba } } 性能分析 时间复杂度： 在头部插入字符的时间复杂度是 O(1)。 转换为字符串的时间复杂度是 O(n)，其中 n 是字符的数量。 空间复杂度： 使用 LinkedList 或 Deque 会额外存储每个字符的节点信息（前驱和后继指针），空间开销略高于 StringBuilder。 为什么不直接使用 StringBuilder？ StringBuilder 在头部插入字符的时间复杂度是 O(n)，因为需要移动所有现有字符。 示例： StringBuilder sb = new StringBuilder(); sb.insert(0, \u0026#39;a\u0026#39;); // O(n) sb.insert(0, \u0026#39;b\u0026#39;); // O(n) sb.insert(0, \u0026#39;c\u0026#39;); // O(n) System.out.println(sb.toString()); // 输出: cba 这种方法在频繁插入时性能较差。 总结 如果需要不断往字符串头部添加字符，推荐使用 LinkedList\u0026lt;Character\u0026gt; 或 Deque\u0026lt;Character\u0026gt;。 它们在头部插入字符的时间复杂度是 O(1)，性能最优。 插入完成后，可以将其转换为字符串。 如果插入操作较少，或者主要在尾部添加字符，可以使用 StringBuilder。 希望这个解答对你有帮助！如果还有其他问题，欢迎随时提问！\n面试经典150题 # 面试经典150题 数组/字符串 # 移除元素 # 2025-01-11 击败3.36% class Solution { public int removeElement(int[] nums, int val) { Arrays.sort(nums); int flagIndex = -1; int count = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] == val \u0026amp;\u0026amp; count == 0) { flagIndex = i; count++; } else if (nums[i] == val) { count++; } } if (flagIndex != -1 \u0026amp;\u0026amp; count != 0) { for (int i = flagIndex; i \u0026lt; flagIndex + count; i++) { nums[i] = nums[nums.length - (i - flagIndex) - 1]; } } return nums.length - count; } } 一维动态规划 # 爬楼梯 # 2025-01-11 击败100% class Solution { public int climbStairs(int n) { if (n == 0) return 0; if (n == 1) return 1; if (n == 2) return 2; int[] dp = new int[n + 1]; dp[0] = 0; dp[1] = 1; dp[2] = 2; for (int i = 3; i \u0026lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } } 面试经典150题 # 面试经典150题 数组/字符串 # 合并两个有序数组 # 合并两个有序数组 2025-01-12 public class Solution88 { public static void merge(int[] nums1, int m, int[] nums2, int n) { if (n == 0) return; int nIndex = 0; for (int i = m; i \u0026lt; m + n; i++) { nums1[i] = nums2[nIndex++]; } Arrays.sort(nums1); } public static void main(String[] args) { int[] nums1 = {1, 2, 3, 0, 0, 0}; int m = 3; int[] nums2 = {2, 5, 6}; int n = 3; merge(nums1, m, nums2, n); for (int i : nums1) { System.out.print(i + \u0026#34; \u0026#34;); } } } 移除元素 # 移除元素 2025-01-11 删除有序数组中的重复项 # 删除有序数组中的重复项 2025-01-11 没有做出来，看的官方题解 2025-01-11 做完删除有序数组中的重复项 II之后再尝试重新解题完成 public class Solution26 { public static int removeDuplicates(int[] nums) { if (nums.length \u0026lt;= 1) return nums.length; int slow = 1; int fast = 1; while (slow \u0026lt;= fast \u0026amp;\u0026amp; fast \u0026lt; nums.length) { if (nums[fast] != nums[fast - 1]) { nums[slow] = nums[fast]; slow++; } fast++; } return slow; } public static void main(String[] args) { int[] nums = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4}; for (int num : nums) { System.out.print(num + \u0026#34; \u0026#34;); } System.out.println(); System.out.println(removeDuplicates(nums)); for (int num : nums) { System.out.print(num + \u0026#34; \u0026#34;); } } } 删除有序数组中的重复项 II # 删除有序数组中的重复项 II 2025-01-11 public class Solution80 { public static int removeDuplicates(int[] nums) { if (nums.length \u0026lt;= 2) return nums.length; int slow = -1; int fast = 1; int count = 1; while (slow \u0026lt;= fast \u0026amp;\u0026amp; fast \u0026lt; nums.length) { if (nums[fast] == nums[fast - 1]) { count++; if (count \u0026gt; 2 \u0026amp;\u0026amp; slow == -1) { slow = fast; } else if (count \u0026lt;= 2 \u0026amp;\u0026amp; slow != -1) { nums[slow] = nums[fast]; slow++; } } else if (nums[fast] != nums[fast - 1]) { if (slow != -1) { nums[slow] = nums[fast]; slow++; } count = 1; } fast++; } return slow == -1 ? nums.length : slow; } public static void main(String[] args) { //int[] nums = {0,0,1,1,1,1,2,3,3}; //int[] nums = {1,2,2}; int[] nums = {1, 1, 1, 2, 2, 2, 3, 3}; for (int num : nums) { System.out.print(num + \u0026#34; \u0026#34;); } System.out.println(); System.out.println(removeDuplicates(nums)); for (int num : nums) { System.out.print(num + \u0026#34; \u0026#34;); } } } 多数元素 # 多数元素 2025-01-12 轮转数组 # 轮转数组 2025-01-18 进阶 尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 买卖股票的最佳时机 # 买卖股票的最佳时机 2025-01-11 看官方题解做出来的 2025-01-17 review 买卖股票的最佳时机 II # 买卖股票的最佳时机 II 官方题解 理解 2025-01-17 方法一：动态规划 方法二：贪心 跳跃游戏 # 跳跃游戏 2025-01-17 官方题解理解 贪心 2025-01-18 跳跃游戏 II # 跳跃游戏 II 2025-01-18 算法超时了 理解官方题解 2025-01-18 方法一：反向查找出发位置 Solution45.jump2 2025-01-18 方法二：正向查找可达到的最大位置 Solution45.jump3 H 指数 # H 指数\n2025-01-18 Tips An easy approach is to sort the array first. What are the possible values of h-index? A faster approach is to use extra space. O(1) 时间插入、删除和获取随机元素\n除自身以外数组的乘积\n加油站\n分发糖果\n接雨水\n罗马数字转整数\n2025-01-12 整数转罗马数字\n最后一个单词的长度\n2025-01-12 最长公共前缀\n2025-01-12 反转字符串中的单词\n2025-01-18 进阶 如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。 Z 字形变换\n找出字符串中第一个匹配项的下标\n2025-01-12 文本左右对齐\n双指针 # 验证回文串 # 验证回文串 2025-01-13 判断子序列 # 判断子序列 2025-01-13 两数之和 II - 输入有序数组 # 两数之和 II - 输入有序数组\n2025-01-13 运行有时候会超过时间限制 盛最多水的容器\n三数之和\n滑动窗口 # 长度最小的子数组 # 长度最小的子数组 2025-01-22 无重复字符的最长子串 # 无重复字符的最长子串 2025-01-22 串联所有单词的子串 # 串联所有单词的子串 2025-01-22 最小覆盖子串 # 最小覆盖子串 矩阵 # 有效的数独 # 有效的数独 2025-01-18 螺旋矩阵 # 螺旋矩阵 2025-01-18 旋转图像 # 旋转图像 理解官方题解 2025-01-18 方法一：使用辅助数组 2025-01-18 方法二：原地旋转 有数学公式的推导，需要自己推导一次 2025-01-18 方法三：用翻转代替旋转 有数学公式的推导，需要自己推导一次 矩阵置零 # 矩阵置零 2025-01-18 生命游戏 # 生命游戏 2025-01-18 进阶 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？ ✅ 哈希表 # ✅ 赎金信 # 赎金信 2025-01-13 ✅ 同构字符串 # 同构字符串 2025-01-13 ✅ 单词规律 # 单词规律 2025-01-13 ✅ 有效的字母异位词 # 有效的字母异位词 2025-01-13 ✅ 字母异位词分组 # 字母异位词分组 2025-01-16 第一遍算法超时，看了官方题解思路后实现通过 ✅ 两数之和 # 两数之和 2025-01-13 ✅ 快乐数 # 快乐数 2025-01-13 ✅ 存在重复元素 II # 存在重复元素 II 2025-01-13 ✅ 最长连续序列 # 最长连续序列 2025-01-16 看了官方题解后完成 区间 # 栈 # 有效的括号 # 有效的括号 2025-01-22 简化路径 # 简化路径 2025-01-22 最小栈 # 最小栈 2025-01-22 理解官方题解 文字描述后完成 2025-01-22 理解官方题解 逆波兰表达式求值 # 逆波兰表达式求值 2025-01-22 基本计算器 # 基本计算器 链表 # ✅ 环形链表 # 环形链表 2025-01-20 理解官方题解 2025-01-20 方法一：哈希表 方法二：快慢指针 ✅ 两数相加 # 两数相加 2025-01-20 ✅ 合并两个有序链表 # 合并两个有序链表 2025-01-20 ✅ 随机链表的复制 # 随机链表的复制 2025-01-20 ✅ 反转链表 II # 反转链表 II 2025-01-20 K 个一组翻转链表 # K 个一组翻转链表 ✅ 删除链表的倒数第 N 个结点 # 删除链表的倒数第 N 个结点 2025-01-20 进阶 2025-01-20 你能尝试使用一趟扫描实现吗？ ✅ 删除排序链表中的重复元素 II # 删除排序链表中的重复元素 II 2025-01-21 ✅ 旋转链表 # 旋转链表 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 2025-01-20 public class Solution61 { public static ListNode rotateRight(ListNode head, int k) { if (head == null || head.next == null) return head; ListNode _head = head; int nodeCount = 1; while (_head.next != null) { _head = _head.next; nodeCount++; } _head.next = head; _head = head; for (int i = 0; i \u0026lt; (nodeCount - k % nodeCount) - 1; i++) { _head = _head.next; } head = _head.next; _head.next = null; return head; } public static void main(String[] args) { test002(); test001(); } public static void test001() { ListNode node0 = new ListNode(1); ListNode node1 = new ListNode(2); ListNode node2 = new ListNode(3); ListNode node3 = new ListNode(4); ListNode node4 = new ListNode(5); node0.next = node1; node1.next = node2; node2.next = node3; node3.next = node4; ListNode listNode = rotateRight(node0, 2); while (listNode != null) { System.out.print(listNode.val + \u0026#34; \u0026#34;); listNode = listNode.next; } System.out.println(); } public static void test002() { ListNode node0 = new ListNode(0); ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(2); node0.next = node1; node1.next = node2; ListNode listNode = rotateRight(node0, 4); while (listNode != null) { System.out.print(listNode.val + \u0026#34; \u0026#34;); listNode = listNode.next; } System.out.println(); } static public class ListNode { int val; ListNode next; ListNode() { } ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } } ✅ 分隔链表 # 分隔链表 2025-01-21 public class Solution86 { public static ListNode partition(ListNode head, int x) { ListNode solder = new ListNode(-1); solder.next = head; ListNode insertPreNode = solder; ListNode insertNode = insertPreNode.next; while (insertNode != null \u0026amp;\u0026amp; insertNode.val \u0026lt; x) { insertPreNode = insertNode; insertNode = insertNode.next; } ListNode preNode = insertPreNode; ListNode currentNode = preNode.next; ListNode nextNode = currentNode != null ? currentNode.next : null; while (currentNode != null) { if (currentNode.val \u0026lt; x) { preNode.next = nextNode; insertPreNode.next = currentNode; currentNode.next = insertNode; insertPreNode = currentNode; } else { preNode = currentNode; } currentNode = nextNode; nextNode = currentNode != null ? currentNode.next : null; } return solder.next; } public static void main(String[] args) { test002(); test001(); } public static void test001() { ListNode node0 = new ListNode(1); ListNode node1 = new ListNode(4); ListNode node2 = new ListNode(3); ListNode node3 = new ListNode(2); ListNode node4 = new ListNode(5); ListNode node5 = new ListNode(2); node0.next = node1; node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; ListNode listNode = partition(node0, 3); while (listNode != null) { System.out.print(listNode.val + \u0026#34; \u0026#34;); listNode = listNode.next; } System.out.println(); } public static void test002() { ListNode node0 = new ListNode(2); ListNode node1 = new ListNode(1); node0.next = node1; ListNode listNode = partition(node0, 2); while (listNode != null) { System.out.print(listNode.val + \u0026#34; \u0026#34;); listNode = listNode.next; } System.out.println(); } static public class ListNode { int val; ListNode next; ListNode() { } ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } } ✅ LRU 缓存 # LRU 缓存 2025-01-22 理解官方题解 二叉树 # 二叉树的最大深度 # 二叉树的最大深度 2025-01-15 相同的树 # 相同的树 2025-01-15 翻转二叉树 # 翻转二叉树 2025-01-15 对称二叉树 # 对称二叉树 没做出来，看的官方题解 从前序与中序遍历序列构造二叉树 # 从前序与中序遍历序列构造二叉树 从中序与后序遍历序列构造二叉树 # 从中序与后序遍历序列构造二叉树 填充每个节点的下一个右侧节点指针 II # 填充每个节点的下一个右侧节点指针 II 二叉树展开为链表 # 二叉树展开为链表 路径总和 # 路径总和 求根节点到叶节点数字之和 # 求根节点到叶节点数字之和 二叉树中的最大路径和 # 二叉树中的最大路径和 二叉搜索树迭代器 # 二叉搜索树迭代器 完全二叉树的节点个数 # 完全二叉树的节点个数 二叉树的最近公共祖先 # 二叉树的最近公共祖先 二叉树层次遍历 # 二叉搜索树 # 图 # 图的广度优先搜索 # 字典树 # ✅ 回溯 # ✅ 电话号码的字母组合 # 电话号码的字母组合 2025-01-15 ✅ 组合 # 组合 2025-01-15 ✅ 全排列 # 全排列 2025-01-15 ✅ 组合总和 # 组合总和 2025-01-15 ✅ N 皇后 II # N 皇后 II 2025-01-15 ✅ 括号生成 # 括号生成 2025-01-15 ✅ 单词搜索 # 单词搜索 2025-01-15 分治 # kadane算法 # 二分查找 # 堆 # 位运算 # 二进制求和 # 给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。 示例 1： 输入:a = \u0026ldquo;11\u0026rdquo;, b = \u0026ldquo;1\u0026rdquo; 输出：\u0026ldquo;100\u0026rdquo; 示例 2： 输入：a = \u0026ldquo;1010\u0026rdquo;, b = \u0026ldquo;1011\u0026rdquo; -输出：\u0026ldquo;10101\u0026rdquo; 提示： 1 \u0026lt;= a.length, b.length \u0026lt;= 104 a 和 b 仅由字符 \u0026lsquo;0\u0026rsquo; 或 \u0026lsquo;1\u0026rsquo; 组成 字符串如果不是 \u0026ldquo;0\u0026rdquo; ，就不含前导零 二进制求和 2025-01-16 public class Solution67 { public static String addBinary(String a, String b) { StringBuilder sb = new StringBuilder(); int aIndex = a.length() - 1; int bIndex = b.length() - 1; int flag = 0; while (true) { int count = (aIndex \u0026lt; 0 ? \u0026#39;0\u0026#39; : a.charAt(aIndex)) - \u0026#39;0\u0026#39; + (bIndex \u0026lt; 0 ? \u0026#39;0\u0026#39; : b.charAt(bIndex)) - \u0026#39;0\u0026#39; + flag; sb.insert(0, count % 2); flag = count / 2; aIndex--; bIndex--; if (aIndex \u0026lt; 0 \u0026amp;\u0026amp; bIndex \u0026lt; 0 \u0026amp;\u0026amp; flag == 0) break; } return sb.toString(); } public static void main(String[] args) { System.out.println(addBinary(\u0026#34;11\u0026#34;, \u0026#34;1\u0026#34;)); System.out.println(addBinary(\u0026#34;1010\u0026#34;, \u0026#34;1011\u0026#34;)); } } 颠倒二进制位 # 颠倒二进制位 2025-01-16 没做出来, 参考这篇文章LeetCode 190. 颠倒二进制位 （位运算 分治） 2025-01-17 复习了一遍 2025-01-17 新增了中间值打印的代码在算法中 位1的个数 # 位1的个数 2025-01-17 只出现一次的数字 # 只出现一次的数字 2025-01-17 只出现一次的数字 II # 只出现一次的数字 II 2025-01-17 理解了官方题解 方法2 数字范围按位与 # 数字范围按位与 2025-01-17 理解了官方题解 方法2 数学 # 回文数 # 回文数 2025-01-17 不将整数转为字符串来解决这个问题 public class Solution9 { public static boolean isPalindrome(int x) { String numberString = String.valueOf(x); int left = 0; int right = numberString.length() - 1; while (left \u0026lt;= right) { if (numberString.charAt(left) != numberString.charAt(right)) { return false; } left++; // 左边指针向右移动一个位置 right--; // 右边指针向左边移动一个位置 } return true; } public static void main(String[] args) { System.out.println(isPalindrome(121)); System.out.println(isPalindrome(-121)); //负数肯定不是回文数 System.out.println(isPalindrome(10)); } } 加一 # 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1： 输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 示例 2： 输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 示例 3： 输入：digits = [9] 输出：[1,0] 解释：输入数组表示数字 9。 加 1 得到了 9 + 1 = 10。 因此，结果应该是 [1,0]。 加一 2025-01-17 public class Solution66 { public static int[] plusOne(int[] digits) { ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int digit : digits) { list.add(digit); } int flag = 0; // 表示进位 int number = list.get(list.size() - 1); // 最右边一位 int _number = number; number = (_number + 1) % 10; flag = (_number + 1) / 10; list.set(list.size() - 1, number); if (list.size() \u0026gt;= 2) { // 原数字位数大于1 for (int i = list.size() - 2; i \u0026gt;= 0; i--) { int numberTmp = list.get(i); list.set(i, (numberTmp + flag) % 10); flag = (numberTmp + flag) / 10; } } if (flag != 0) { // 如果还有一个进位，就在最左边新增一位 list.add(0, 1); } // 构造一个整数数组返回结果 int[] result = new int[list.size()]; for (int i = 0; i \u0026lt; list.size(); i++) { result[i] = list.get(i); } return result; } public static void main(String[] args) { int[] result = plusOne(new int[]{9, 9}); for (int number : result) { System.out.print(number + \u0026#34; \u0026#34;); } System.out.println(); result = plusOne(new int[]{9}); for (int number : result) { System.out.print(number + \u0026#34; \u0026#34;); } System.out.println(); result = plusOne(new int[]{1, 2, 3}); for (int number : result) { System.out.print(number + \u0026#34; \u0026#34;); } System.out.println(); result = plusOne(new int[]{4, 3, 2, 1}); for (int number : result) { System.out.print(number + \u0026#34; \u0026#34;); } System.out.println(); } } 阶乘后的零 # 给定一个整数 n ，返回 n! 结果中尾随零的数量。 提示 n! = n * (n - 1) * (n - 2) * \u0026hellip; * 3 * 2 * 1 示例 1： 输入：n = 3 输出：0 解释：3! = 6 ，不含尾随 0 示例 2： 输入：n = 5 输出：1 解释：5! = 120 ，有一个尾随 0 示例 3： 输入：n = 0 输出：0 提示：0 \u0026lt;= n \u0026lt;= 10^4 阶乘后的零 2025-01-17 version 1 # public class Solution172 { // 因式分解 public static int trailingZeroes(int n) { int result = 0; int[] countArr = new int[]{0, 0}; for (int i = n; i \u0026gt;= 1; i--) { int number = i; while (number % 10 == 0) { result++; number /= 10; } while (number % 5 == 0) { countArr[1]++; number /= 5; } while (number % 2 == 0) { countArr[0]++; number /= 2; } int min = Math.min(countArr[0], countArr[1]); if (min != 0) { countArr[0] -= min; countArr[1] -= min; result += min; } } return result; } public static void main(String[] args) { for (int i = 5; i \u0026lt; 10000; i++) { System.out.println(i + \u0026#34; : \u0026#34; + trailingZeroes(i)); } } } version 2 # 只需要因式分解 2 和 5 就行了，不用分解 10（已经包含了 2 和 5 ） class Solution { public static int trailingZeroes(int n) { int result = 0; int[] countArr = new int[]{0, 0}; for (int i = n; i \u0026gt;= 1; i--) { int number = i; while (number % 5 == 0) { countArr[1]++; number /= 5; } while (number % 2 == 0) { countArr[0]++; number /= 2; } int min = Math.min(countArr[0], countArr[1]); if (min != 0) { countArr[0] -= min; countArr[1] -= min; result += min; } } return result; } } x 的平方根 # 给你一个非负整数 x ，计算并返回 x 的 算术平方根 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 示例 1： 输入：x = 4 输出：2 示例 2： 输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842\u0026hellip;, 由于返回类型是整数，小数部分将被舍去。 提示： 0 \u0026lt;= x \u0026lt;= 2^31 - 1 x 的平方根 2025-01-17 package com.penruins.leetcode; public class Solution69 { public static int mySqrt(int x) { long xLong = Long.valueOf(x).longValue(); if (xLong == 0) return 0; if (xLong == 1) return 1; for (long i = 1; i \u0026lt; xLong; i++) { if (i * i == xLong || (i * i \u0026lt; xLong \u0026amp;\u0026amp; (i + 1) * (i + 1) \u0026gt; xLong)) { return (int) i; } } return -1; } public static void main(String[] args) { System.out.println(mySqrt(2147483647)); System.out.println(2147483647); System.out.println(46340 * 46340); System.out.println(46341l * 46341l); // for (int i = 0; i \u0026lt; Integer.MAX_VALUE; i++) { // System.out.println(i + \u0026#34; : \u0026#34; + mySqrt(i)); // } } } Pow(x, n) # 实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，x^n ）。 示例 1： 输入：x = 2.00000, n = 10 输出：1024.00000 示例 2： 输入：x = 2.10000, n = 3 输出：9.26100 示例 3： 输入：x = 2.00000, n = -2 输出：0.25000 解释：2-2 = 1/22 = 1/4 = 0.25 提示： -100.0 \u0026lt; x \u0026lt; 100.0 -2^31 \u0026lt;= n \u0026lt;= 2^31-1 n 是一个整数 要么 x 不为零，要么 n \u0026gt; 0 -10^4 \u0026lt;= xn \u0026lt;= 10^4 Pow(x, n) 2025-01-17 超时了 2025-01-17 看懂了官方题解 直线上最多的点数 # 直线上最多的点数 2025-01-17 看了官方题解，但还是不太理解 一维动态规划 # 爬楼梯 2025-01-11 通过 多维动态规划 # "},{"id":57,"href":"/zh/zh/post/computer-science/algorithm/","title":"Algorithm","section":"Computer Science","content":" Algorithm # 代码随想录 Tips # 如果我要创建一个列表，并且需要一直在列表的开头插入元素，我要怎么实现代码保证效率 # 在 Java 中，如果你需要频繁在列表的开头插入元素，使用 LinkedList 会比 ArrayList 更高效。因为 LinkedList 在列表开头插入元素的时间复杂度是 O(1)，而 ArrayList 在开头插入元素的时间复杂度是 O(n)，需要移动所有元素。\n使用 LinkedList 的示例代码：\nimport java.util.LinkedList; import java.util.List; public class Main { public static void main(String[] args) { // 创建一个 LinkedList List\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 在列表开头插入元素 list.add(0, 1); // 插入元素 1 list.add(0, 2); // 插入元素 2 list.add(0, 3); // 插入元素 3 // 输出列表 System.out.println(list); // 输出: [3, 2, 1] } } 为什么 LinkedList 更高效？\nLinkedList 是基于双向链表实现的，插入和删除操作只需要调整节点的指针，时间复杂度为 O(1)。 ArrayList 是基于动态数组实现的，插入和删除操作需要移动元素，时间复杂度为 O(n)。 总结：\n如果你需要频繁在列表开头插入元素，优先选择 LinkedList 以保证效率。\nLinkedList 在任意位置插入和删除节点，时间复杂度都是O(1)吗？ # 不是的，LinkedList 在任意位置插入和删除节点的时间复杂度并不总是 O(1)。具体的时间复杂度取决于操作的位置。\nLinkedList 的时间复杂度分析：\n在头部或尾部插入/删除节点：\n时间复杂度是 O(1)，因为 LinkedList 是双向链表，直接操作头节点或尾节点即可。 在任意位置插入/删除节点：\n时间复杂度是 O(n)，因为需要从头节点或尾节点开始遍历链表，找到目标位置后才能进行操作。 为什么任意位置插入/删除是 O(n)？\nLinkedList 是基于双向链表实现的，虽然插入和删除操作本身只需要调整指针（O(1)），但找到目标位置需要遍历链表。 平均情况下，遍历链表的时间复杂度是 O(n/2) ≈ O(n)。 示例代码：\nimport java.util.LinkedList; public class Main { public static void main(String[] args) { LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); // 在索引 1 处插入元素（需要遍历到索引 1） list.add(1, 10); // 时间复杂度 O(n) // 删除索引 2 处的元素（需要遍历到索引 2） list.remove(2); // 时间复杂度 O(n) System.out.println(list); // 输出: [1, 10, 3] } } 总结：\nLinkedList 在头部或尾部插入/删除节点的时间复杂度是 O(1)。 在任意位置插入/删除节点的时间复杂度是 O(n)，因为需要遍历链表找到目标位置。 如果你需要频繁在任意位置插入或删除节点，并且希望时间复杂度更低，可以考虑使用其他数据结构（如 ArrayList 或自定义数据结构），具体选择取决于你的使用场景。\n如果我要不断往list的末尾添加元素，是使用LinkedList还是ArrayList？ # 如果你需要不断往列表的末尾添加元素，使用 ArrayList 会比 LinkedList 更高效。以下是原因和详细分析：\nArrayList 的优势 时间复杂度： 在末尾添加元素的平均时间复杂度是 O(1)。 只有在数组容量不足时，ArrayList 需要扩容（创建一个新的更大的数组并复制元素），此时时间复杂度是 O(n)。但扩容操作是分摊的，平均下来仍然是 O(1)。 空间效率： ArrayList 是基于数组实现的，内存连续，存储效率高，没有额外的指针开销。 缓存友好： 数组的内存布局是连续的，对 CPU 缓存更友好，访问速度更快。 LinkedList 的劣势 时间复杂度： 在末尾添加元素的时间复杂度是 O(1)，但每次添加都需要创建一个新的节点对象，并调整指针。 空间效率： LinkedList 是基于双向链表实现的，每个节点需要额外的空间存储前驱和后继指针，内存开销更大。 缓存不友好： 链表的内存布局是分散的，对 CPU 缓存不友好，访问速度较慢。 性能对比 ArrayList： 添加元素时，大多数情况下是 O(1)，偶尔扩容时是 O(n)。 内存连续，访问速度快。 LinkedList： 添加元素时，每次都是 O(1)，但需要创建节点对象和调整指针。 内存分散，访问速度慢。 代码示例 使用 ArrayList：\nimport java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 不断往末尾添加元素 for (int i = 0; i \u0026lt; 1000000; i++) { list.add(i); // 平均时间复杂度 O(1) } System.out.println(\u0026#34;ArrayList 添加完成\u0026#34;); } } 使用 LinkedList：\nimport java.util.LinkedList; import java.util.List; public class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 不断往末尾添加元素 for (int i = 0; i \u0026lt; 1000000; i++) { list.add(i); // 时间复杂度 O(1)，但性能不如 ArrayList } System.out.println(\u0026#34;LinkedList 添加完成\u0026#34;); } } 实测性能 在实际测试中，ArrayList 的性能通常优于 LinkedList，尤其是在大量添加元素时。以下是一个简单的性能对比：\n操作 ArrayList 耗时 LinkedList 耗时 添加 100 万个元素 ~50 ms ~100 ms 添加 1000 万个元素 ~500 ms ~1200 ms 总结 如果你需要不断往列表末尾添加元素，优先选择 ArrayList。 它的时间复杂度更低（平均 O(1)）。 它的内存效率更高，访问速度更快。 只有在需要频繁在列表头部或中间插入/删除元素时，才考虑使用 LinkedList。 希望这个解答对你有帮助！如果还有其他问题，欢迎随时提问！\n如果我想要构造一个字符串，我会不断往字符串头部添加字符，我该怎么编码保证效率 # 如果你需要不断往字符串的头部添加字符，直接使用 Java 的 String 或 StringBuilder 会导致性能问题，因为它们的底层实现不适合频繁在头部插入操作。以下是原因和高效解决方案：\n为什么 String 和 StringBuilder 不适合？ String： String 是不可变的，每次修改都会创建一个新的字符串对象，频繁在头部插入字符会导致大量对象创建和复制，性能极差。 StringBuilder： StringBuilder 是可变的，适合在尾部添加字符（时间复杂度 O(1)），但在头部插入字符的时间复杂度是 O(n)，因为需要移动所有现有字符。 高效解决方案 为了高效地在字符串头部添加字符，可以使用以下数据结构：\n方案 1：使用 LinkedList\u0026lt;Character\u0026gt;\nLinkedList 在头部插入元素的时间复杂度是 O(1)，非常适合频繁在头部添加字符的场景。 插入完成后，可以将 LinkedList 转换为字符串。 方案 2：使用 Deque\u0026lt;Character\u0026gt;（双端队列）\nDeque 是基于双向链表实现的，支持在头部和尾部高效插入和删除元素。 插入完成后，可以将 Deque 转换为字符串。 代码实现 方案 1：使用 LinkedList\u0026lt;Character\u0026gt;\nimport java.util.LinkedList; public class Main { public static void main(String[] args) { // 创建一个 LinkedList 来存储字符 LinkedList\u0026lt;Character\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 不断往头部添加字符 list.addFirst(\u0026#39;a\u0026#39;); // 添加字符 \u0026#39;a\u0026#39; list.addFirst(\u0026#39;b\u0026#39;); // 添加字符 \u0026#39;b\u0026#39; list.addFirst(\u0026#39;c\u0026#39;); // 添加字符 \u0026#39;c\u0026#39; // 将 LinkedList 转换为字符串 StringBuilder sb = new StringBuilder(); for (char c : list) { sb.append(c); } String result = sb.toString(); System.out.println(result); // 输出: cba } } 方案 2：使用 Deque\u0026lt;Character\u0026gt;\nimport java.util.Deque; import java.util.LinkedList; public class Main { public static void main(String[] args) { // 创建一个 Deque 来存储字符 Deque\u0026lt;Character\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); // 不断往头部添加字符 deque.addFirst(\u0026#39;a\u0026#39;); // 添加字符 \u0026#39;a\u0026#39; deque.addFirst(\u0026#39;b\u0026#39;); // 添加字符 \u0026#39;b\u0026#39; deque.addFirst(\u0026#39;c\u0026#39;); // 添加字符 \u0026#39;c\u0026#39; // 将 Deque 转换为字符串 StringBuilder sb = new StringBuilder(); for (char c : deque) { sb.append(c); } String result = sb.toString(); System.out.println(result); // 输出: cba } } 性能分析 时间复杂度： 在头部插入字符的时间复杂度是 O(1)。 转换为字符串的时间复杂度是 O(n)，其中 n 是字符的数量。 空间复杂度： 使用 LinkedList 或 Deque 会额外存储每个字符的节点信息（前驱和后继指针），空间开销略高于 StringBuilder。 为什么不直接使用 StringBuilder？ StringBuilder 在头部插入字符的时间复杂度是 O(n)，因为需要移动所有现有字符。 示例： StringBuilder sb = new StringBuilder(); sb.insert(0, \u0026#39;a\u0026#39;); // O(n) sb.insert(0, \u0026#39;b\u0026#39;); // O(n) sb.insert(0, \u0026#39;c\u0026#39;); // O(n) System.out.println(sb.toString()); // 输出: cba 这种方法在频繁插入时性能较差。 总结 如果需要不断往字符串头部添加字符，推荐使用 LinkedList\u0026lt;Character\u0026gt; 或 Deque\u0026lt;Character\u0026gt;。 它们在头部插入字符的时间复杂度是 O(1)，性能最优。 插入完成后，可以将其转换为字符串。 如果插入操作较少，或者主要在尾部添加字符，可以使用 StringBuilder。 希望这个解答对你有帮助！如果还有其他问题，欢迎随时提问！\n面试经典150题 # 面试经典150题 数组/字符串 # 移除元素 # 2025-01-11 击败3.36% class Solution { public int removeElement(int[] nums, int val) { Arrays.sort(nums); int flagIndex = -1; int count = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] == val \u0026amp;\u0026amp; count == 0) { flagIndex = i; count++; } else if (nums[i] == val) { count++; } } if (flagIndex != -1 \u0026amp;\u0026amp; count != 0) { for (int i = flagIndex; i \u0026lt; flagIndex + count; i++) { nums[i] = nums[nums.length - (i - flagIndex) - 1]; } } return nums.length - count; } } 一维动态规划 # 爬楼梯 # 2025-01-11 击败100% class Solution { public int climbStairs(int n) { if (n == 0) return 0; if (n == 1) return 1; if (n == 2) return 2; int[] dp = new int[n + 1]; dp[0] = 0; dp[1] = 1; dp[2] = 2; for (int i = 3; i \u0026lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } } 面试经典150题 # 面试经典150题 数组/字符串 # 合并两个有序数组 # 合并两个有序数组 2025-01-12 public class Solution88 { public static void merge(int[] nums1, int m, int[] nums2, int n) { if (n == 0) return; int nIndex = 0; for (int i = m; i \u0026lt; m + n; i++) { nums1[i] = nums2[nIndex++]; } Arrays.sort(nums1); } public static void main(String[] args) { int[] nums1 = {1, 2, 3, 0, 0, 0}; int m = 3; int[] nums2 = {2, 5, 6}; int n = 3; merge(nums1, m, nums2, n); for (int i : nums1) { System.out.print(i + \u0026#34; \u0026#34;); } } } 移除元素 # 移除元素 2025-01-11 删除有序数组中的重复项 # 删除有序数组中的重复项 2025-01-11 没有做出来，看的官方题解 2025-01-11 做完删除有序数组中的重复项 II之后再尝试重新解题完成 public class Solution26 { public static int removeDuplicates(int[] nums) { if (nums.length \u0026lt;= 1) return nums.length; int slow = 1; int fast = 1; while (slow \u0026lt;= fast \u0026amp;\u0026amp; fast \u0026lt; nums.length) { if (nums[fast] != nums[fast - 1]) { nums[slow] = nums[fast]; slow++; } fast++; } return slow; } public static void main(String[] args) { int[] nums = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4}; for (int num : nums) { System.out.print(num + \u0026#34; \u0026#34;); } System.out.println(); System.out.println(removeDuplicates(nums)); for (int num : nums) { System.out.print(num + \u0026#34; \u0026#34;); } } } 删除有序数组中的重复项 II # 删除有序数组中的重复项 II 2025-01-11 public class Solution80 { public static int removeDuplicates(int[] nums) { if (nums.length \u0026lt;= 2) return nums.length; int slow = -1; int fast = 1; int count = 1; while (slow \u0026lt;= fast \u0026amp;\u0026amp; fast \u0026lt; nums.length) { if (nums[fast] == nums[fast - 1]) { count++; if (count \u0026gt; 2 \u0026amp;\u0026amp; slow == -1) { slow = fast; } else if (count \u0026lt;= 2 \u0026amp;\u0026amp; slow != -1) { nums[slow] = nums[fast]; slow++; } } else if (nums[fast] != nums[fast - 1]) { if (slow != -1) { nums[slow] = nums[fast]; slow++; } count = 1; } fast++; } return slow == -1 ? nums.length : slow; } public static void main(String[] args) { //int[] nums = {0,0,1,1,1,1,2,3,3}; //int[] nums = {1,2,2}; int[] nums = {1, 1, 1, 2, 2, 2, 3, 3}; for (int num : nums) { System.out.print(num + \u0026#34; \u0026#34;); } System.out.println(); System.out.println(removeDuplicates(nums)); for (int num : nums) { System.out.print(num + \u0026#34; \u0026#34;); } } } 多数元素 # 多数元素 2025-01-12 轮转数组 # 轮转数组 2025-01-18 进阶 尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 买卖股票的最佳时机 # 买卖股票的最佳时机 2025-01-11 看官方题解做出来的 2025-01-17 review 买卖股票的最佳时机 II # 买卖股票的最佳时机 II 官方题解 理解 2025-01-17 方法一：动态规划 方法二：贪心 跳跃游戏 # 跳跃游戏 2025-01-17 官方题解理解 贪心 2025-01-18 跳跃游戏 II # 跳跃游戏 II 2025-01-18 算法超时了 理解官方题解 2025-01-18 方法一：反向查找出发位置 Solution45.jump2 2025-01-18 方法二：正向查找可达到的最大位置 Solution45.jump3 H 指数 # H 指数\n2025-01-18 Tips An easy approach is to sort the array first. What are the possible values of h-index? A faster approach is to use extra space. O(1) 时间插入、删除和获取随机元素\n除自身以外数组的乘积\n加油站\n分发糖果\n接雨水\n罗马数字转整数\n2025-01-12 整数转罗马数字\n最后一个单词的长度\n2025-01-12 最长公共前缀\n2025-01-12 反转字符串中的单词\n2025-01-18 进阶 如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。 Z 字形变换\n找出字符串中第一个匹配项的下标\n2025-01-12 文本左右对齐\n双指针 # 验证回文串 # 验证回文串 2025-01-13 判断子序列 # 判断子序列 2025-01-13 两数之和 II - 输入有序数组 # 两数之和 II - 输入有序数组\n2025-01-13 运行有时候会超过时间限制 盛最多水的容器\n三数之和\n滑动窗口 # 长度最小的子数组 # 长度最小的子数组 2025-01-22 无重复字符的最长子串 # 无重复字符的最长子串 2025-01-22 串联所有单词的子串 # 串联所有单词的子串 2025-01-22 最小覆盖子串 # 最小覆盖子串 矩阵 # 有效的数独 # 有效的数独 2025-01-18 螺旋矩阵 # 螺旋矩阵 2025-01-18 旋转图像 # 旋转图像 理解官方题解 2025-01-18 方法一：使用辅助数组 2025-01-18 方法二：原地旋转 有数学公式的推导，需要自己推导一次 2025-01-18 方法三：用翻转代替旋转 有数学公式的推导，需要自己推导一次 矩阵置零 # 矩阵置零 2025-01-18 生命游戏 # 生命游戏 2025-01-18 进阶 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？ ✅ 哈希表 # ✅ 赎金信 # 赎金信 2025-01-13 ✅ 同构字符串 # 同构字符串 2025-01-13 ✅ 单词规律 # 单词规律 2025-01-13 ✅ 有效的字母异位词 # 有效的字母异位词 2025-01-13 ✅ 字母异位词分组 # 字母异位词分组 2025-01-16 第一遍算法超时，看了官方题解思路后实现通过 ✅ 两数之和 # 两数之和 2025-01-13 ✅ 快乐数 # 快乐数 2025-01-13 ✅ 存在重复元素 II # 存在重复元素 II 2025-01-13 ✅ 最长连续序列 # 最长连续序列 2025-01-16 看了官方题解后完成 区间 # 栈 # 有效的括号 # 有效的括号 2025-01-22 简化路径 # 简化路径 2025-01-22 最小栈 # 最小栈 2025-01-22 理解官方题解 文字描述后完成 2025-01-22 理解官方题解 逆波兰表达式求值 # 逆波兰表达式求值 2025-01-22 基本计算器 # 基本计算器 链表 # ✅ 环形链表 # 环形链表 2025-01-20 理解官方题解 2025-01-20 方法一：哈希表 方法二：快慢指针 ✅ 两数相加 # 两数相加 2025-01-20 ✅ 合并两个有序链表 # 合并两个有序链表 2025-01-20 ✅ 随机链表的复制 # 随机链表的复制 2025-01-20 ✅ 反转链表 II # 反转链表 II 2025-01-20 K 个一组翻转链表 # K 个一组翻转链表 ✅ 删除链表的倒数第 N 个结点 # 删除链表的倒数第 N 个结点 2025-01-20 进阶 2025-01-20 你能尝试使用一趟扫描实现吗？ ✅ 删除排序链表中的重复元素 II # 删除排序链表中的重复元素 II 2025-01-21 ✅ 旋转链表 # 旋转链表 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 2025-01-20 public class Solution61 { public static ListNode rotateRight(ListNode head, int k) { if (head == null || head.next == null) return head; ListNode _head = head; int nodeCount = 1; while (_head.next != null) { _head = _head.next; nodeCount++; } _head.next = head; _head = head; for (int i = 0; i \u0026lt; (nodeCount - k % nodeCount) - 1; i++) { _head = _head.next; } head = _head.next; _head.next = null; return head; } public static void main(String[] args) { test002(); test001(); } public static void test001() { ListNode node0 = new ListNode(1); ListNode node1 = new ListNode(2); ListNode node2 = new ListNode(3); ListNode node3 = new ListNode(4); ListNode node4 = new ListNode(5); node0.next = node1; node1.next = node2; node2.next = node3; node3.next = node4; ListNode listNode = rotateRight(node0, 2); while (listNode != null) { System.out.print(listNode.val + \u0026#34; \u0026#34;); listNode = listNode.next; } System.out.println(); } public static void test002() { ListNode node0 = new ListNode(0); ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(2); node0.next = node1; node1.next = node2; ListNode listNode = rotateRight(node0, 4); while (listNode != null) { System.out.print(listNode.val + \u0026#34; \u0026#34;); listNode = listNode.next; } System.out.println(); } static public class ListNode { int val; ListNode next; ListNode() { } ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } } ✅ 分隔链表 # 分隔链表 2025-01-21 public class Solution86 { public static ListNode partition(ListNode head, int x) { ListNode solder = new ListNode(-1); solder.next = head; ListNode insertPreNode = solder; ListNode insertNode = insertPreNode.next; while (insertNode != null \u0026amp;\u0026amp; insertNode.val \u0026lt; x) { insertPreNode = insertNode; insertNode = insertNode.next; } ListNode preNode = insertPreNode; ListNode currentNode = preNode.next; ListNode nextNode = currentNode != null ? currentNode.next : null; while (currentNode != null) { if (currentNode.val \u0026lt; x) { preNode.next = nextNode; insertPreNode.next = currentNode; currentNode.next = insertNode; insertPreNode = currentNode; } else { preNode = currentNode; } currentNode = nextNode; nextNode = currentNode != null ? currentNode.next : null; } return solder.next; } public static void main(String[] args) { test002(); test001(); } public static void test001() { ListNode node0 = new ListNode(1); ListNode node1 = new ListNode(4); ListNode node2 = new ListNode(3); ListNode node3 = new ListNode(2); ListNode node4 = new ListNode(5); ListNode node5 = new ListNode(2); node0.next = node1; node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; ListNode listNode = partition(node0, 3); while (listNode != null) { System.out.print(listNode.val + \u0026#34; \u0026#34;); listNode = listNode.next; } System.out.println(); } public static void test002() { ListNode node0 = new ListNode(2); ListNode node1 = new ListNode(1); node0.next = node1; ListNode listNode = partition(node0, 2); while (listNode != null) { System.out.print(listNode.val + \u0026#34; \u0026#34;); listNode = listNode.next; } System.out.println(); } static public class ListNode { int val; ListNode next; ListNode() { } ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } } ✅ LRU 缓存 # LRU 缓存 2025-01-22 理解官方题解 二叉树 # 二叉树的最大深度 # 二叉树的最大深度 2025-01-15 相同的树 # 相同的树 2025-01-15 翻转二叉树 # 翻转二叉树 2025-01-15 对称二叉树 # 对称二叉树 没做出来，看的官方题解 从前序与中序遍历序列构造二叉树 # 从前序与中序遍历序列构造二叉树 从中序与后序遍历序列构造二叉树 # 从中序与后序遍历序列构造二叉树 填充每个节点的下一个右侧节点指针 II # 填充每个节点的下一个右侧节点指针 II 二叉树展开为链表 # 二叉树展开为链表 路径总和 # 路径总和 求根节点到叶节点数字之和 # 求根节点到叶节点数字之和 二叉树中的最大路径和 # 二叉树中的最大路径和 二叉搜索树迭代器 # 二叉搜索树迭代器 完全二叉树的节点个数 # 完全二叉树的节点个数 二叉树的最近公共祖先 # 二叉树的最近公共祖先 二叉树层次遍历 # 二叉搜索树 # 图 # 图的广度优先搜索 # 字典树 # ✅ 回溯 # ✅ 电话号码的字母组合 # 电话号码的字母组合 2025-01-15 ✅ 组合 # 组合 2025-01-15 ✅ 全排列 # 全排列 2025-01-15 ✅ 组合总和 # 组合总和 2025-01-15 ✅ N 皇后 II # N 皇后 II 2025-01-15 ✅ 括号生成 # 括号生成 2025-01-15 ✅ 单词搜索 # 单词搜索 2025-01-15 分治 # kadane算法 # 二分查找 # 堆 # 位运算 # 二进制求和 # 给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。 示例 1： 输入:a = \u0026ldquo;11\u0026rdquo;, b = \u0026ldquo;1\u0026rdquo; 输出：\u0026ldquo;100\u0026rdquo; 示例 2： 输入：a = \u0026ldquo;1010\u0026rdquo;, b = \u0026ldquo;1011\u0026rdquo; -输出：\u0026ldquo;10101\u0026rdquo; 提示： 1 \u0026lt;= a.length, b.length \u0026lt;= 104 a 和 b 仅由字符 \u0026lsquo;0\u0026rsquo; 或 \u0026lsquo;1\u0026rsquo; 组成 字符串如果不是 \u0026ldquo;0\u0026rdquo; ，就不含前导零 二进制求和 2025-01-16 public class Solution67 { public static String addBinary(String a, String b) { StringBuilder sb = new StringBuilder(); int aIndex = a.length() - 1; int bIndex = b.length() - 1; int flag = 0; while (true) { int count = (aIndex \u0026lt; 0 ? \u0026#39;0\u0026#39; : a.charAt(aIndex)) - \u0026#39;0\u0026#39; + (bIndex \u0026lt; 0 ? \u0026#39;0\u0026#39; : b.charAt(bIndex)) - \u0026#39;0\u0026#39; + flag; sb.insert(0, count % 2); flag = count / 2; aIndex--; bIndex--; if (aIndex \u0026lt; 0 \u0026amp;\u0026amp; bIndex \u0026lt; 0 \u0026amp;\u0026amp; flag == 0) break; } return sb.toString(); } public static void main(String[] args) { System.out.println(addBinary(\u0026#34;11\u0026#34;, \u0026#34;1\u0026#34;)); System.out.println(addBinary(\u0026#34;1010\u0026#34;, \u0026#34;1011\u0026#34;)); } } 颠倒二进制位 # 颠倒二进制位 2025-01-16 没做出来, 参考这篇文章LeetCode 190. 颠倒二进制位 （位运算 分治） 2025-01-17 复习了一遍 2025-01-17 新增了中间值打印的代码在算法中 位1的个数 # 位1的个数 2025-01-17 只出现一次的数字 # 只出现一次的数字 2025-01-17 只出现一次的数字 II # 只出现一次的数字 II 2025-01-17 理解了官方题解 方法2 数字范围按位与 # 数字范围按位与 2025-01-17 理解了官方题解 方法2 数学 # 回文数 # 回文数 2025-01-17 不将整数转为字符串来解决这个问题 public class Solution9 { public static boolean isPalindrome(int x) { String numberString = String.valueOf(x); int left = 0; int right = numberString.length() - 1; while (left \u0026lt;= right) { if (numberString.charAt(left) != numberString.charAt(right)) { return false; } left++; // 左边指针向右移动一个位置 right--; // 右边指针向左边移动一个位置 } return true; } public static void main(String[] args) { System.out.println(isPalindrome(121)); System.out.println(isPalindrome(-121)); //负数肯定不是回文数 System.out.println(isPalindrome(10)); } } 加一 # 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1： 输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 示例 2： 输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 示例 3： 输入：digits = [9] 输出：[1,0] 解释：输入数组表示数字 9。 加 1 得到了 9 + 1 = 10。 因此，结果应该是 [1,0]。 加一 2025-01-17 public class Solution66 { public static int[] plusOne(int[] digits) { ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int digit : digits) { list.add(digit); } int flag = 0; // 表示进位 int number = list.get(list.size() - 1); // 最右边一位 int _number = number; number = (_number + 1) % 10; flag = (_number + 1) / 10; list.set(list.size() - 1, number); if (list.size() \u0026gt;= 2) { // 原数字位数大于1 for (int i = list.size() - 2; i \u0026gt;= 0; i--) { int numberTmp = list.get(i); list.set(i, (numberTmp + flag) % 10); flag = (numberTmp + flag) / 10; } } if (flag != 0) { // 如果还有一个进位，就在最左边新增一位 list.add(0, 1); } // 构造一个整数数组返回结果 int[] result = new int[list.size()]; for (int i = 0; i \u0026lt; list.size(); i++) { result[i] = list.get(i); } return result; } public static void main(String[] args) { int[] result = plusOne(new int[]{9, 9}); for (int number : result) { System.out.print(number + \u0026#34; \u0026#34;); } System.out.println(); result = plusOne(new int[]{9}); for (int number : result) { System.out.print(number + \u0026#34; \u0026#34;); } System.out.println(); result = plusOne(new int[]{1, 2, 3}); for (int number : result) { System.out.print(number + \u0026#34; \u0026#34;); } System.out.println(); result = plusOne(new int[]{4, 3, 2, 1}); for (int number : result) { System.out.print(number + \u0026#34; \u0026#34;); } System.out.println(); } } 阶乘后的零 # 给定一个整数 n ，返回 n! 结果中尾随零的数量。 提示 n! = n * (n - 1) * (n - 2) * \u0026hellip; * 3 * 2 * 1 示例 1： 输入：n = 3 输出：0 解释：3! = 6 ，不含尾随 0 示例 2： 输入：n = 5 输出：1 解释：5! = 120 ，有一个尾随 0 示例 3： 输入：n = 0 输出：0 提示：0 \u0026lt;= n \u0026lt;= 10^4 阶乘后的零 2025-01-17 version 1 # public class Solution172 { // 因式分解 public static int trailingZeroes(int n) { int result = 0; int[] countArr = new int[]{0, 0}; for (int i = n; i \u0026gt;= 1; i--) { int number = i; while (number % 10 == 0) { result++; number /= 10; } while (number % 5 == 0) { countArr[1]++; number /= 5; } while (number % 2 == 0) { countArr[0]++; number /= 2; } int min = Math.min(countArr[0], countArr[1]); if (min != 0) { countArr[0] -= min; countArr[1] -= min; result += min; } } return result; } public static void main(String[] args) { for (int i = 5; i \u0026lt; 10000; i++) { System.out.println(i + \u0026#34; : \u0026#34; + trailingZeroes(i)); } } } version 2 # 只需要因式分解 2 和 5 就行了，不用分解 10（已经包含了 2 和 5 ） class Solution { public static int trailingZeroes(int n) { int result = 0; int[] countArr = new int[]{0, 0}; for (int i = n; i \u0026gt;= 1; i--) { int number = i; while (number % 5 == 0) { countArr[1]++; number /= 5; } while (number % 2 == 0) { countArr[0]++; number /= 2; } int min = Math.min(countArr[0], countArr[1]); if (min != 0) { countArr[0] -= min; countArr[1] -= min; result += min; } } return result; } } x 的平方根 # 给你一个非负整数 x ，计算并返回 x 的 算术平方根 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 示例 1： 输入：x = 4 输出：2 示例 2： 输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842\u0026hellip;, 由于返回类型是整数，小数部分将被舍去。 提示： 0 \u0026lt;= x \u0026lt;= 2^31 - 1 x 的平方根 2025-01-17 package com.penruins.leetcode; public class Solution69 { public static int mySqrt(int x) { long xLong = Long.valueOf(x).longValue(); if (xLong == 0) return 0; if (xLong == 1) return 1; for (long i = 1; i \u0026lt; xLong; i++) { if (i * i == xLong || (i * i \u0026lt; xLong \u0026amp;\u0026amp; (i + 1) * (i + 1) \u0026gt; xLong)) { return (int) i; } } return -1; } public static void main(String[] args) { System.out.println(mySqrt(2147483647)); System.out.println(2147483647); System.out.println(46340 * 46340); System.out.println(46341l * 46341l); // for (int i = 0; i \u0026lt; Integer.MAX_VALUE; i++) { // System.out.println(i + \u0026#34; : \u0026#34; + mySqrt(i)); // } } } Pow(x, n) # 实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，x^n ）。 示例 1： 输入：x = 2.00000, n = 10 输出：1024.00000 示例 2： 输入：x = 2.10000, n = 3 输出：9.26100 示例 3： 输入：x = 2.00000, n = -2 输出：0.25000 解释：2-2 = 1/22 = 1/4 = 0.25 提示： -100.0 \u0026lt; x \u0026lt; 100.0 -2^31 \u0026lt;= n \u0026lt;= 2^31-1 n 是一个整数 要么 x 不为零，要么 n \u0026gt; 0 -10^4 \u0026lt;= xn \u0026lt;= 10^4 Pow(x, n) 2025-01-17 超时了 2025-01-17 看懂了官方题解 直线上最多的点数 # 直线上最多的点数 2025-01-17 看了官方题解，但还是不太理解 一维动态规划 # 爬楼梯 2025-01-11 通过 多维动态规划 # "},{"id":58,"href":"/zh/zh/","title":"Penruins","section":"Penruins","content":" Penruins # penruins 的博客，分享技术🤖，生活🤹🏻，电影🎬，骑行🚴🏽‍♂️，English和其他一些有趣的东西(📖学习记录, ⛰️爬山)\n2025-02-05 大年初八 # mac上用safari浏览网页，可以在 screen time 中统计每个网页的浏览时长\n2025-02-04 大年初七 # 超完美地狱 ycx\n开始使用微信输入法，比搜狗输入法更简洁舒服\n开始使用 Aisten，可以用来听英语播客，它会自动生成播客字幕，并且能统计时长，有按周、按月、按年统计时长，很不错\n2025-02-03 大年初六 # 良心护士 ycx。想不通为什么他要用这样的方式杀死那么多无辜的人。\n2025-02-02 大年初五 # 网络谜踪 ycx。电影里苹果全家桶的操作太丝滑了\n2025-01-31 大年初三 # 草海一圈\n2025-01-30 大年初二 # 滇池绿道探路\nApp Store下载了DeepSeek 之后登录不上，查了一下是被攻击了还在修复中，晚一点终于登录上去了。界面和清爽，简单玩了一下\n2025-01-29 大年初一 # 置身事内：中国政府与经济发展\n人工智能入行实战：从校园到职场\n2025-01-27 # 热水袋破了被烫伤了。。。。\n2025-01-26 # 门徒 ycx\n用地图看懂世界格局\n2025-01-19 # 美国困局\n树莓派开始，玩转linux\n2025-01-18 Saturday # 使用 stream 这个app可以抓 ios app 接口的包\n2025-01-16 # Spring实战（第6版）\n2025-01-10 Friday # 卧云山环线练车 #oado\n2025-01-09 # hugo 博客自定义 toc 的深度 Is there any way I can set how deep the level is to show the TOC at right side? #52 2025-01-08 # 四重奏 E07\n2025-01-07 # 开始爬彩云中路的坡\n四重奏 E06\n如果国宝会说话 第三季 2025-01-06 # 四重奏 E05\n2025-01-05 # 四重奏 E04\n2025-01-04 # 身体恢复的差不多了，开始骑车\n四重奏 E03\n如果国宝会说话 第二季 2025-01-03 # 四重奏 E02\n2025-01-02 # 四重奏 E01\n2025-01-01 # 如果国宝会说话 第一季 2024-12-31 # 辛德勒的名单（2）\n2024-12-29 # 生病中\n2024-12-28 # 生病中\n2024-12-26 # 西安 陕西历史博物馆\n西安城墙骑车🚲\n看钟楼夜景\n2024-12-25 # 西安 翠华山\n2024-12-24 # 兵马俑\n骊山\n长恨歌表演\n2024-12-23 # 西安 大雁塔\n大唐不夜城\n2024-10-13 # 金铜盆爬山\n尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？此余之所得也！\n"},{"id":59,"href":"/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/","title":"Java并发编程实战","section":"Computer Science","content":" Java并发编程实战 第1章 简介 # 1.1 并发简史 # 1.2 线程的优势 # 1.3 线程带来的风险 # 1.4 线程无处不在 # 开发线程安全的类比开发非线程安全的类要更加谨慎和细致 每个Java应用程序都会使用线程 当JVM启动时，它将为JVM的内部任务（例如，垃圾收集、终结操作等）创建后台线程，并创建一个主线程来运行main方法。 AWT（Abstract Window Toolkit，抽象窗口工具库）和Swing的用户界面框架将创建线程来管理用户界面事件。 Timer将创建线程来执行延迟任务。 一些组件框架，例如Servlet和RMI，都会创建线程池并调用这些线程中的方法。 当某个框架在应用程序中引入并发性时，通常不可能将并发性仅局限于框架代码，因为框架本身会回调（Callback）应用程序的代码，而这些代码将访问应用程序的状态。 对线程安全性的需求也不能局限于被调用的代码，而是要延伸到需要访问这些代码所访问的程序状态的所有代码路径。因此，对线程安全性的需求将在程序中蔓延开来。 第2章 线程安全性 # 要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的（Shared）和可变的（Mutable）状态的访问。 “共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。 一个对象是否需要是线程安全的，取决于它是否被多个线程访问 当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。 Java中的主要同步机制是关键字synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括volatile类型的变量，显式锁（Explicit Lock）以及原子变量。 2.1 什么是线程安全性 # 在线程安全性的定义中，最核心的概念就是正确性。如果对线程安全性的定义是模糊的，那么就是因为缺乏对正确性的清晰定义。 正确性的含义是，某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件（Postcondition）来描述对象操作的结果。 线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。 在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。 无状态对象一定是线程安全的 大多数Servlet都是无状态的，从而极大地降低了在实现Servlet线程安全性时的复杂性。只有当Servlet在处理请求时需要保存一些信息，线程安全性才会成为一个问题。 2.2 原子性 # 在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件（Race Condition） 2.2.1 竞态条件 # 当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。换句话说，就是正确的结果要取决于运气 “先检查后执行”：首先观察到某个条件为真（例如文件X不存在），然后根据这个观察结果采用相应的动作（创建文件X），但事实上，在你观察到这个结果以及开始创建文件之间，观察结果可能变得无效（另一个线程在这期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。 2.2.2 示例：延迟初始化中的竞态条件 # 延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。 假定线程A和线程B同时执行getInstance。A看到instance为空，因而创建一个新的ExpensiveObject实例。B同样需要判断instance是否为空。此时的instance是否为空，要取决于不可预测的时序，包括线程的调度方式，以及A需要花多长时间来初始化ExpensiveObject并设置instance。如果当B检查时，instance为空，那么在两次调用getInstance时可能会得到不同的结果，即使getInstance通常被认为是返回相同的实例。 2.2.3 复合操作 # 要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。 原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。 在java.util.concurrent.atomic包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。通过用AtomicLong来代替long类型的计数器，能够确保所有对计数器状态的访问操作都是原子的。 当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的 当状态变量的数量由一个变为多个时，并不会像状态变量数量由零个变为一个那样简单 在实际情况中，应尽可能地使用现有的线程安全对象（例如AtomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。 2.3 加锁机制 # 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。 2.3.1 内置锁 # Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。 以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。 每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock） 2.3.2 重入 # 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞 由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用” 重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。 当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。 2.4 用锁来保护状态 # 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。 之所以每个对象都有一个内置锁，只是为了免去显式地创建锁对象。 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。 一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。 并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。 2.5 活跃性与性能 # 不良并发（Poor Concurrency）应用程序：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。 当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。 无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。 当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。 第3章 对象的共享 # 同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。 3.1 可见性 # 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。 3.1.1 失效数据 # 3.1.2　非原子的64位操作 # 当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-air safety） 最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量（double和long，请参见3.1.4节）。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位￼。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。 3.1.3　加锁与可见性 # 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。 3.1.4　Volatile变量 # Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 在当前大多数处理器架构上，读取volatile变量的开销只比读取非volatile变量的开销略高一些。 我们并不建议过度依赖volatile变量提供的可见性。如果在代码中依赖volatile变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。 如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。 volatile的语义不足以确保递增操作（count++）的原子性，除非你能确保只有一个线程对变量执行写操作。 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。 当且仅当满足以下所有条件时，才应该使用volatile变量 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。 该变量不会与其他状态变量一起纳入不变性条件中。 在访问变量时不需要加锁。 调试小提示：对于服务器应用程序，无论在开发阶段还是在测试阶段，当启动JVM时一定都要指定-server命令行选项。server模式的JVM将比client模式的JVM进行更多的优化，例如将循环中未被修改的变量提升到循环外部，因此在开发环境（client模式的JVM）中能正确运行的代码，可能会在部署环境（server模式的JVM）中运行失败。例如，如果在程序清单3-4中“忘记”把asleep变量声明为volatile类型，那么server模式的JVM会将asleep的判断条件提升到循环体外部（这将导致一个无限循环），但client模式的JVM不会这么做。在解决开发环境中出现无限循环问题时，解决这个问题的开销远小于解决在应用环境出现无限循环的开销。 3.2 发布与逸出 # “发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。 将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。在许多情况中，我们要确保对象及其内部状态不被发布。而在某些情况下，我们又需要发布某个对象，但如果在发布时要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象构造完成之前就发布该对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）。 发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象 一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。 当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。这正是需要使用封装的最主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。 安全的对象构造过程 不要在构造过程中使this引用逸出 在构造过程中使this引用逸出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。 在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动 在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），同样会导致this引用在构造过程中逸出。 如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法（Factory Method），从而避免不正确的构造过程 3.3 线程封闭 # Swing应用程序的许多并发错误都是由于错误地在另一个线程中使用了这些被封闭的对象。 线程封闭是在程序设计中的一个考虑因素，必须在程序中实现。 3.3.1 Ad-hoc线程封闭 # 在volatile变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竞态条件，并且volatile变量的可见性保证还确保了其他线程能看到最新的值。 由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭或ThreadLocal类）。 3.3.2 栈封闭 # 栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。 由于任何方法都无法获得对基本类型的引用，因此Java语言的这种语义就确保了基本类型的局部变量始终封闭在线程内。 3.3.3 ThreadLocal 类 # ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。 假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象（如果全局变量的语义允许），可以维持线程安全性。 3.4 不变性 # 如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。 不可变对象一定是线程安全的 虽然在Java语言规范和Java内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。 当满足以下条件时，对象才是不可变的： 对象创建以后其状态就不能修改。 对象的所有域都是final类型。 对象是正确创建的（在对象的创建期间，this引用没有逸出）。 3.4.1 Final域 # 关键字final可以视为C++中const机制的一种受限版本，用于构造不可变性对象。final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。 即使对象是可变的，通过将对象的某些域声明为final类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。 正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”[EJ Item 12]是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。 3.4.2 示例：使用volatile类型来发布不可变对象 # 通过使用包含多个状态变量的容器对象来维持不变性条件，并使用一个volatile类型的引用来确保可见性，使得Volatile Cached Factorizer在没有显式地使用锁的情况下仍然是线程安全的 3.5 安全发布 # 3.5.1 不正确的发布：正确的对象被破坏 # 你不能指望一个尚未被完全创建的对象拥有完整性。某个观察该对象的线程将看到对象处于不一致的状态，然后看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。 3.5.2 不可变对象与初始化安全性 # 我们已经知道，即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一致的视图，就必须使用同步。 任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。 在没有额外同步的情况下，也可以安全地访问final类型的域。然而，如果final类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。 3.5.3 安全发布的常用模式 # 可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时都必须使用同步。 要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见 在静态初始化函数中初始化一个对象引用。 将对象的引用保存到volatile类型的域或者AtomicReferance对象中。 将对象的引用保存到某个正确构造对象的final类型域中。 将对象的引用保存到一个由锁保护的域中。 在线程安全容器内部的同步意味着，在将对象放入到某个容器，例如Vector或synchronizedList时，将满足上述最后一条需求。如果线程A将对象X放入一个线程安全的容器，随后线程B读取这个对象，那么可以确保B看到A设置的X状态，即便在这段读/写X的应用程序代码中没有包含显式的同步。 线程安全库中的容器类提供了以下的安全发布保证 通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。 通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。 通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。 要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器 public static Holder holder=new Holder（42） 静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布 3.5.4 事实不可变对象 # 如果对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全地访问这些对象的线程来说，安全发布是足够的。 如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）” 通过使用事实不可变对象，不仅可以简化开发过程，而且还能由于减少了同步而提高性能。 例如，Date本身是可变的￼，但如果将它作为不可变对象来使用，那么在多个线程之间共享Date对象时，就可以省去对锁的使用 3.5.5 可变对象 # 如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。 在并发程序中使用和共享对象时，可以使用一些实用的策略，包括： 线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。 只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。 保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。 3.5.6 安全地共享对象 # 第4章 对象的组合 # 4.1 设计线程安全的类 # 4.2 实例封闭 # 4.3 线程安全性的委托 # 4.4 在现有的线程安全类中添加功能 # 4.5 将同步策略文档化 # 第5章 基础构建模块 # 5.1 同步容器类 # 5.2 并发容器 # 5.3 阻塞队列和生产者-消费者模式 # 5.4 阻塞方法与中断方法 # 5.5 同步工具类 # 5.6 构建高效且可伸缩的结果缓存 # 第6章 任务执行 # 6.1 在线程中执行任务 # 6.2 Executor框架 # 6.3 找出可利用的并行性 # 第7章 取消与关闭 # 7.1 任务取消 # 7.2 停止基于线程的服务 # 7.3 处理非正常的线程终止 # 7.4 JVM关闭 # 第8章 线程池的使用 # 8.1 在任务与执行策略之间的隐性耦合 # 8.2 设置线程池的大小 # 8.3 配置ThreadPoolExecutor # 8.4 扩展ThreadPoolExecutor # 8.5 递归算法的并行化 # 第9章 图形用户界面应用程序 # 9.1 为什么GUI是单线程的 # 9.2 短时间的GUI任务 # 9.3 长时间的GUI任务 # 9.4 共享数据模型 # 9.5 其他形式的单线程子系统 # 第10章 避免活跃性危险 # 10.1 死锁 # 10.2 死锁的避免与诊断 # 10.3 其他活跃性危险 # 第11章 性能与可伸缩性 # 11.1 对性能的思考 # 11.2 Amdahl定律 # 11.3 线程引入的开销 # 11.4 减少锁的竞争 # 11.5 示例：比较Map的性能 # 11.6 减少上下文切换的开销 # 第12章 并发程序的测试 # 12.1 正确性测试 # 12.2 性能测试 # 12.3 避免性能测试的陷阱 # 12.4 其他的测试方法 # 第13章 显式锁 # 13.1 Lock与ReentrantLock # 13.2 性能考虑因素 # 13.3 公平性 # 13.4 在synchronized和ReentrantLock之间进行选择 # 13.5 读-写锁 # 第14章 构建自定义的同步工具 # 14.1 状态依赖性的管理 # 14.2 使用条件队列 # 14.3 显式的Condition对象 # 14.4 Synchronizer剖析 # 14.5 AbstractQueuedSynchronizer # 14.6 java.util.concurrent同步器类中的AQS # 第15章 原子变量与非阻塞同步机制 # 15.1 锁的劣势 # 15.2 硬件对并发的支持 # 15.3 原子变量类 # 15.4 非阻塞算法 # 第16章 Java内存模型 # 16.1 什么是内存模型，为什么需要它 # 16.2 发布 # 16.3 初始化过程中的安全性 # "},{"id":60,"href":"/zh/zh/post/books/computer-science/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/","title":"Java并发编程实战","section":"Computer Science","content":" Java并发编程实战 第1章 简介 # 1.1 并发简史 # 1.2 线程的优势 # 1.3 线程带来的风险 # 1.4 线程无处不在 # 开发线程安全的类比开发非线程安全的类要更加谨慎和细致 每个Java应用程序都会使用线程 当JVM启动时，它将为JVM的内部任务（例如，垃圾收集、终结操作等）创建后台线程，并创建一个主线程来运行main方法。 AWT（Abstract Window Toolkit，抽象窗口工具库）和Swing的用户界面框架将创建线程来管理用户界面事件。 Timer将创建线程来执行延迟任务。 一些组件框架，例如Servlet和RMI，都会创建线程池并调用这些线程中的方法。 当某个框架在应用程序中引入并发性时，通常不可能将并发性仅局限于框架代码，因为框架本身会回调（Callback）应用程序的代码，而这些代码将访问应用程序的状态。 对线程安全性的需求也不能局限于被调用的代码，而是要延伸到需要访问这些代码所访问的程序状态的所有代码路径。因此，对线程安全性的需求将在程序中蔓延开来。 第2章 线程安全性 # 要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的（Shared）和可变的（Mutable）状态的访问。 “共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。 一个对象是否需要是线程安全的，取决于它是否被多个线程访问 当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。 Java中的主要同步机制是关键字synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括volatile类型的变量，显式锁（Explicit Lock）以及原子变量。 2.1 什么是线程安全性 # 在线程安全性的定义中，最核心的概念就是正确性。如果对线程安全性的定义是模糊的，那么就是因为缺乏对正确性的清晰定义。 正确性的含义是，某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件（Postcondition）来描述对象操作的结果。 线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。 在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。 无状态对象一定是线程安全的 大多数Servlet都是无状态的，从而极大地降低了在实现Servlet线程安全性时的复杂性。只有当Servlet在处理请求时需要保存一些信息，线程安全性才会成为一个问题。 2.2 原子性 # 在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件（Race Condition） 2.2.1 竞态条件 # 当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。换句话说，就是正确的结果要取决于运气 “先检查后执行”：首先观察到某个条件为真（例如文件X不存在），然后根据这个观察结果采用相应的动作（创建文件X），但事实上，在你观察到这个结果以及开始创建文件之间，观察结果可能变得无效（另一个线程在这期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。 2.2.2 示例：延迟初始化中的竞态条件 # 延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。 假定线程A和线程B同时执行getInstance。A看到instance为空，因而创建一个新的ExpensiveObject实例。B同样需要判断instance是否为空。此时的instance是否为空，要取决于不可预测的时序，包括线程的调度方式，以及A需要花多长时间来初始化ExpensiveObject并设置instance。如果当B检查时，instance为空，那么在两次调用getInstance时可能会得到不同的结果，即使getInstance通常被认为是返回相同的实例。 2.2.3 复合操作 # 要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。 原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。 在java.util.concurrent.atomic包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。通过用AtomicLong来代替long类型的计数器，能够确保所有对计数器状态的访问操作都是原子的。 当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的 当状态变量的数量由一个变为多个时，并不会像状态变量数量由零个变为一个那样简单 在实际情况中，应尽可能地使用现有的线程安全对象（例如AtomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。 2.3 加锁机制 # 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。 2.3.1 内置锁 # Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。 以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。 每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock） 2.3.2 重入 # 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞 由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用” 重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。 当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。 2.4 用锁来保护状态 # 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。 之所以每个对象都有一个内置锁，只是为了免去显式地创建锁对象。 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。 一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。 并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。 2.5 活跃性与性能 # 不良并发（Poor Concurrency）应用程序：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。 当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。 无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。 当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。 第3章 对象的共享 # 同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。 3.1 可见性 # 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。 3.1.1 失效数据 # 3.1.2　非原子的64位操作 # 当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-air safety） 最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量（double和long，请参见3.1.4节）。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位￼。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。 3.1.3　加锁与可见性 # 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。 3.1.4　Volatile变量 # Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 在当前大多数处理器架构上，读取volatile变量的开销只比读取非volatile变量的开销略高一些。 我们并不建议过度依赖volatile变量提供的可见性。如果在代码中依赖volatile变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。 如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。 volatile的语义不足以确保递增操作（count++）的原子性，除非你能确保只有一个线程对变量执行写操作。 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。 当且仅当满足以下所有条件时，才应该使用volatile变量 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。 该变量不会与其他状态变量一起纳入不变性条件中。 在访问变量时不需要加锁。 调试小提示：对于服务器应用程序，无论在开发阶段还是在测试阶段，当启动JVM时一定都要指定-server命令行选项。server模式的JVM将比client模式的JVM进行更多的优化，例如将循环中未被修改的变量提升到循环外部，因此在开发环境（client模式的JVM）中能正确运行的代码，可能会在部署环境（server模式的JVM）中运行失败。例如，如果在程序清单3-4中“忘记”把asleep变量声明为volatile类型，那么server模式的JVM会将asleep的判断条件提升到循环体外部（这将导致一个无限循环），但client模式的JVM不会这么做。在解决开发环境中出现无限循环问题时，解决这个问题的开销远小于解决在应用环境出现无限循环的开销。 3.2 发布与逸出 # “发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。 将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。在许多情况中，我们要确保对象及其内部状态不被发布。而在某些情况下，我们又需要发布某个对象，但如果在发布时要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象构造完成之前就发布该对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）。 发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象 一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。 当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。这正是需要使用封装的最主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。 安全的对象构造过程 不要在构造过程中使this引用逸出 在构造过程中使this引用逸出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。 在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动 在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），同样会导致this引用在构造过程中逸出。 如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法（Factory Method），从而避免不正确的构造过程 3.3 线程封闭 # Swing应用程序的许多并发错误都是由于错误地在另一个线程中使用了这些被封闭的对象。 线程封闭是在程序设计中的一个考虑因素，必须在程序中实现。 3.3.1 Ad-hoc线程封闭 # 在volatile变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竞态条件，并且volatile变量的可见性保证还确保了其他线程能看到最新的值。 由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭或ThreadLocal类）。 3.3.2 栈封闭 # 栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。 由于任何方法都无法获得对基本类型的引用，因此Java语言的这种语义就确保了基本类型的局部变量始终封闭在线程内。 3.3.3 ThreadLocal 类 # ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。 假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象（如果全局变量的语义允许），可以维持线程安全性。 3.4 不变性 # 如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。 不可变对象一定是线程安全的 虽然在Java语言规范和Java内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。 当满足以下条件时，对象才是不可变的： 对象创建以后其状态就不能修改。 对象的所有域都是final类型。 对象是正确创建的（在对象的创建期间，this引用没有逸出）。 3.4.1 Final域 # 关键字final可以视为C++中const机制的一种受限版本，用于构造不可变性对象。final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。 即使对象是可变的，通过将对象的某些域声明为final类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。 正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”[EJ Item 12]是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。 3.4.2 示例：使用volatile类型来发布不可变对象 # 通过使用包含多个状态变量的容器对象来维持不变性条件，并使用一个volatile类型的引用来确保可见性，使得Volatile Cached Factorizer在没有显式地使用锁的情况下仍然是线程安全的 3.5 安全发布 # 3.5.1 不正确的发布：正确的对象被破坏 # 你不能指望一个尚未被完全创建的对象拥有完整性。某个观察该对象的线程将看到对象处于不一致的状态，然后看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。 3.5.2 不可变对象与初始化安全性 # 我们已经知道，即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一致的视图，就必须使用同步。 任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。 在没有额外同步的情况下，也可以安全地访问final类型的域。然而，如果final类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。 3.5.3 安全发布的常用模式 # 可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时都必须使用同步。 要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见 在静态初始化函数中初始化一个对象引用。 将对象的引用保存到volatile类型的域或者AtomicReferance对象中。 将对象的引用保存到某个正确构造对象的final类型域中。 将对象的引用保存到一个由锁保护的域中。 在线程安全容器内部的同步意味着，在将对象放入到某个容器，例如Vector或synchronizedList时，将满足上述最后一条需求。如果线程A将对象X放入一个线程安全的容器，随后线程B读取这个对象，那么可以确保B看到A设置的X状态，即便在这段读/写X的应用程序代码中没有包含显式的同步。 线程安全库中的容器类提供了以下的安全发布保证 通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。 通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。 通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。 要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器 public static Holder holder=new Holder（42） 静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布 3.5.4 事实不可变对象 # 如果对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全地访问这些对象的线程来说，安全发布是足够的。 如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）” 通过使用事实不可变对象，不仅可以简化开发过程，而且还能由于减少了同步而提高性能。 例如，Date本身是可变的￼，但如果将它作为不可变对象来使用，那么在多个线程之间共享Date对象时，就可以省去对锁的使用 3.5.5 可变对象 # 如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。 在并发程序中使用和共享对象时，可以使用一些实用的策略，包括： 线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。 只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。 保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。 3.5.6 安全地共享对象 # 第4章 对象的组合 # 4.1 设计线程安全的类 # 4.2 实例封闭 # 4.3 线程安全性的委托 # 4.4 在现有的线程安全类中添加功能 # 4.5 将同步策略文档化 # 第5章 基础构建模块 # 5.1 同步容器类 # 5.2 并发容器 # 5.3 阻塞队列和生产者-消费者模式 # 5.4 阻塞方法与中断方法 # 5.5 同步工具类 # 5.6 构建高效且可伸缩的结果缓存 # 第6章 任务执行 # 6.1 在线程中执行任务 # 6.2 Executor框架 # 6.3 找出可利用的并行性 # 第7章 取消与关闭 # 7.1 任务取消 # 7.2 停止基于线程的服务 # 7.3 处理非正常的线程终止 # 7.4 JVM关闭 # 第8章 线程池的使用 # 8.1 在任务与执行策略之间的隐性耦合 # 8.2 设置线程池的大小 # 8.3 配置ThreadPoolExecutor # 8.4 扩展ThreadPoolExecutor # 8.5 递归算法的并行化 # 第9章 图形用户界面应用程序 # 9.1 为什么GUI是单线程的 # 9.2 短时间的GUI任务 # 9.3 长时间的GUI任务 # 9.4 共享数据模型 # 9.5 其他形式的单线程子系统 # 第10章 避免活跃性危险 # 10.1 死锁 # 10.2 死锁的避免与诊断 # 10.3 其他活跃性危险 # 第11章 性能与可伸缩性 # 11.1 对性能的思考 # 11.2 Amdahl定律 # 11.3 线程引入的开销 # 11.4 减少锁的竞争 # 11.5 示例：比较Map的性能 # 11.6 减少上下文切换的开销 # 第12章 并发程序的测试 # 12.1 正确性测试 # 12.2 性能测试 # 12.3 避免性能测试的陷阱 # 12.4 其他的测试方法 # 第13章 显式锁 # 13.1 Lock与ReentrantLock # 13.2 性能考虑因素 # 13.3 公平性 # 13.4 在synchronized和ReentrantLock之间进行选择 # 13.5 读-写锁 # 第14章 构建自定义的同步工具 # 14.1 状态依赖性的管理 # 14.2 使用条件队列 # 14.3 显式的Condition对象 # 14.4 Synchronizer剖析 # 14.5 AbstractQueuedSynchronizer # 14.6 java.util.concurrent同步器类中的AQS # 第15章 原子变量与非阻塞同步机制 # 15.1 锁的劣势 # 15.2 硬件对并发的支持 # 15.3 原子变量类 # 15.4 非阻塞算法 # 第16章 Java内存模型 # 16.1 什么是内存模型，为什么需要它 # 16.2 发布 # 16.3 初始化过程中的安全性 # "},{"id":61,"href":"/zh/post/books/computer-science/java%E5%AE%9E%E6%88%98/","title":"Java实战","section":"Computer Science","content":" Java实战 # Java实战（第2版） 第一部分 基础知识 # 第1章　Java 8、9、10以及11的变化　2 # 1.1 为什么要关心Java的变化 2 # 1.2 Java怎么还在变 4 # 1.2.1 Java在编程语言生态系统中的位置 5 1.2.2 流处理 6 1.2.3 用行为参数化把代码传递给方法 7 1.2.4 并行与共享的可变数据 8 1.2.5 Java需要演变 9 1.3 Java中的函数 9 # 1.3.1 方法和Lambda作为一等值 10 1.3.2 传递代码：一个例子 11 1.3.3 从传递方法到Lambda 13 1.4 流 14 # 1.5 默认方法及Java模块 17 # 1.6 来自函数式编程的其他好思想 19 # 1.7 小结 20 # 第2章　通过行为参数化传递代码　22 # 2.1 应对不断变化的需求 23 # 2.1.1 初试牛刀：筛选绿苹果 23 2.1.2 再展身手：把颜色作为参数 23 2.1.3 第三次尝试：对你能想到的每个属性做筛选 24 2.2 行为参数化 25 # 2.3 对付啰唆 30 # 2.3.1 匿名类 30 2.3.2 第五次尝试：使用匿名类 31 2.3.3 第六次尝试：使用Lambda表达式 32 2.3.4 第七次尝试：将List类型抽象化 33 2.4 真实的例子 33 # 2.4.1 用Comparator来排序 33 2.4.2 用Runnable执行代码块 34 2.4.3 通过Callable返回结果 35 2.4.4 GUI事件处理 35 2.5 小结 36 # 第3章　Lambda表达式　37 # 3.1 Lambda管中窥豹 37 # 3.2 在哪里以及如何使用Lambda 40 # 3.2.1 函数式接口 40 3.2.2 函数描述符 42 3.3 把Lambda付诸实践：环绕执行模式 44 # 3.3.1 第1 步：记得行为参数化 44 3.3.2 第2 步：使用函数式接口来传递行为 45 3.3.3 第3 步：执行一个行为 45 3.3.4 第4 步：传递Lambda 46 3.4 使用函数式接口 47 # 3.4.1 Predicate 47 3.4.2 Consumer 47 3.4.3 Function 48 3.5 类型检查、类型推断以及限制 52 # 3.5.1 类型检查 52 3.5.2 同样的Lambda，不同的函数式接口 53 3.5.3 类型推断 55 3.5.4 使用局部变量 56 3.6 方法引用 57 # 3.6.1 管中窥豹 57 3.6.2 构造函数引用 60 3.7 Lambda和方法引用实战 62 # 3.7.1 第1 步：传递代码 62 3.7.2 第2 步：使用匿名类 62 3.7.3 第3 步：使用Lambda表达式 62 3.7.4 第4 步：使用方法引用 63 3.8 复合Lambda表达式的有用方法 63 # 3.8.1 比较器复合 64 3.8.2 谓词复合 64 3.8.3 函数复合 65 3.9 数学中的类似思想 66 # 3.9.1 积分 66 3.9.2 与Java 8的Lambda联系起来 68 3.10 小结 68 # 第二部分 使用流进行函数式数据处理 # 第4章　引入流　72 # 4.1 流是什么 72 # 4.2 流简介 76 # 4.3 流与集合 78 # 4.3.1 只能遍历一次 79 4.3.2 外部迭代与内部迭代 80 4.4 流操作 82 # 4.4.1 中间操作 83 4.4.2 终端操作 84 4.4.3 使用流 84 4.5 路线图 85 # 4.6 小结 85 # 第5章　使用流　86 # 5.1 筛选 87 # 5.1.1 用谓词筛选 87 5.1.2 筛选各异的元素 87 5.2 流的切片 88 # 5.2.1 使用谓词对流进行切片 88 5.2.2 截短流 90 5.2.3 跳过元素 90 5.3 映射 91 # 5.3.1 对流中每一个元素应用函数 91 5.3.2 流的扁平化 92 5.4 查找和匹配 95 # 5.4.1 检查谓词是否至少匹配一个元素 95 5.4.2 检查谓词是否匹配所有元素 96 5.4.3 查找元素 96 5.4.4 查找第一个元素 97 5.5 归约 98 # 5.5.1 元素求和 98 5.5.2 最大值和最小值 100 5.6 付诸实践 103 # 5.6.1 领域：交易员和交易 103 5.6.2 解答 104 5.7 数值流 106 # 5.7.1 原始类型流特化 107 5.7.2 数值范围 108 5.7.3 数值流应用：勾股数 108 5.8 构建流 111 # 5.8.1 由值创建流 111 5.8.2 由可空对象创建流 111 5.8.3 由数组创建流 112 5.8.4 由文件生成流 112 5.8.5 由函数生成流：创建无限流 113 5.9 概述 116 # 5.10 小结 116 # 第6章　用流收集数据　118 # 6.1 收集器简介 119 # 6.1.1 收集器用作高级归约 119 6.1.2 预定义收集器 120 6.2 归约和汇总 121 # 6.2.1 查找流中的最大值和最小值 121 6.2.2 汇总 122 6.2.3 连接字符串 123 6.2.4 广义的归约汇总 124 6.3 分组 127 # 6.3.1 操作分组的元素 128 6.3.2 多级分组 130 6.3.3 按子组收集数据 131 6.4 分区 134 # 6.4.1 分区的优势 135 6.4.2 将数字按质数和非质数分区 136 6.5 收集器接口 138 # 6.5.1 理解Collector接口声明的方法 139 6.5.2 全部融合到一起 143 6.6 开发你自己的收集器以获得更好的性能 144 # 6.6.1 仅用质数做除数 145 6.6.2 比较收集器的性能 148 6.7 小结 150 # 第7章　并行数据处理与性能　151 # 7.1 并行流 152 # 7.1.1 将顺序流转换为并行流 52 7.1.2 测量流性能 154 7.1.3 正确使用并行流 158 7.1.4 高效使用并行流 159 7.2 分支/合并框架 161 # 7.2.1 使用RecursiveTask 161 7.2.2 使用分支/合并框架的最佳做法 164 7.2.3 工作窃取 165 7.3 Spliterator 166 # 7.3.1 拆分过程 167 7.3.2 实现你自己的Spliterator 168 7.4 小结 173 # 第三部分 使用流和Lambda进行高效编程 # 第8章　Collection API的增强功能　176 # 8.1 集合工厂 176 # 8.1.1 List工厂 177 8.1.2 Set工厂 178 8.1.3 Map工厂 179 8.2 使用List和Set 180 # 8.2.1 removeIf方法 180 8.2.2 replaceAll方法 181 8.3 使用Map 181 # 8.3.1 forEach方法 182 8.3.2 排序 182 8.3.3 getOrDefault方法 183 8.3.4 计算模式 183 8.3.5 删除模式 184 8.3.6 替换模式 185 8.3.7 merge方法 185 8.4 改进的ConcurrentHashMap 187 # 8.4.1 归约和搜索 187 8.4.2 计数 188 8.4.3 Set视图 188 8.5 小结 188 # 第9章　重构、测试和调试　189 # 9.1 为改善可读性和灵活性重构代码 189 # 9.1.1 改善代码的可读性 190 9.1.2 从匿名类到Lambda表达式的转换 190 9.1.3 从Lambda表达式到方法引用的转换 191 9.1.4 从命令式的数据处理切换到Stream 193 9.1.5 增加代码的灵活性 193 9.2 使用Lambda重构面向对象的设计模式 195 # 9.2.1 策略模式 196 9.2.2 模板方法 197 9.2.3 观察者模式 198 9.2.4 责任链模式 201 9.2.5 工厂模式 202 9.3 测试Lambda表达式 204 # 9.3.1 测试可见Lambda函数的行为 204 9.3.2 测试使用Lambda的方法的行为 205 9.3.3 将复杂的Lambda表达式分为不同的方法 205 9.3.4 高阶函数的测试 206 9.4 调试 206 # 9.4.1 查看栈跟踪 206 9.4.2 使用日志调试 208 9.5 小结 209 # 第10章　基于Lambda的领域特定语言　210 # 10.1 领域特定语言 212 # 10.1.1 DSL的优点和弊端 212 10.1.2 JVM中已提供的DSL解决方案 214 10.2 现代Java API中的小型DSL 217 # 10.2.1 把Stream API当成DSL去操作集合 219 10.2.2 将Collectors作为DSL汇总数据 220 10.3 使用Java创建DSL的模式与技巧 221 # 10.3.1 方法链接 224 10.3.2 使用嵌套函数 226 10.3.3 使用Lambda表达式的函数序列 228 10.3.4 把它们都放到一起 230 10.3.5 在DSL中使用方法引用 232 10.4 Java 8 DSL的实际应用 234 # 10.4.1 jOOQ 235 10.4.2 Cucumber 236 10.4.3 Spring Integration 238 10.5 小结 239 # 第四部分 无所不在的Java # 第11章　用Optional取代null　242 # 11.1 如何为缺失的值建模 243 # 11.1.1 采用防御式检查减少NullPointerException 243 11.1.2 null带来的种种问题 245 11.1.3 其他语言中null的替代品 245 11.2 Optional类入门 246 # 11.3 应用Optional的几种模式 248 # 11.3.1 创建Optional对象 248 11.3.2 使用map从Optional对象中提取和转换值 248 11.3.3 使用flatMap链接Optional对象 249 11.3.4 操纵由Optional对象构成的Stream 253 11.3.5 默认行为及解引用Optional对象 254 11.3.6 两个Optional对象的组合 255 11.3.7 使用filter剔除特定的值 257 11.4 使用Optional的实战示例 258 # 11.4.1 用Optional 封装可能为null的值 259 11.4.2 异常与Optional的对比 259 11.4.3 基础类型的Optional对象，以及为什么应该避免使用它们 260 11.4.4 把所有内容整合起来 260 11.5 小结 262 # 第12章　新的日期和时间API　263 # 12.1 LocalDate、LocalTime、LocalDateTime、Instant、Duration以及Period 264 # 12.1.1 使用LocalDate和LocalTime 264 12.1.2 合并日期和时间 265 12.1.3 机器的日期和时间格式 266 12.1.4 定义Duration或Period 267 12.2 操纵、解析和格式化日期 268 # 12.2.1 使用TemporalAdjuster 270 12.2.2 打印输出及解析日期–时间对象 272 12.3 处理不同的时区和历法 274 # 12.3.1 使用时区 274 12.3.2 利用和UTC/格林尼治时间的固定偏差计算时区 275 12.3.3 使用别的日历系统 276 12.4 小结 277 # 第13章　默认方法　278 # 13.1 不断演进的API 280 # 13.1.1 初始版本的API 281 13.1.2 第二版API 281 13.2 概述默认方法 283 # 13.3 默认方法的使用模式 285 # 13.3.1 可选方法 285 13.3.2 行为的多继承 286 13.4 解决冲突的规则 289 # 13.4.1 解决问题的三条规则 289 13.4.2 选择提供了最具体实现的默认方法的接口 290 13.4.3 冲突及如何显式地消除歧义 291 13.4.4 菱形继承问题 293 13.5 小结 294 # 第14章　Java模块系统　295 # 14.1 模块化的驱动力：软件的推理 295 # 14.1.1 关注点分离 295 14.1.2 信息隐藏 296 14.1.3 Java软件 296 14.2 为什么要设计Java模块系统 297 # 14.2.1 模块化的局限性 297 14.2.2 单体型的JDK 298 14.2.3 与OSGi的比较 299 14.3 Java模块：全局视图 300 # 14.4 使用Java模块系统开发应用 301 # 14.4.1 从头开始搭建一个应用 302 14.4.2 细粒度和粗粒度的模块化 303 14.4.3 Java模块系统基础 303 14.5 使用多个模块 304 # 14.5.1 exports子句 304 14.5.2 requires子句 305 14.5.3 命名 306 14.6 编译及打包 306 # 14.7 自动模块 310 # 14.8 模块声明及子句 311 # 14.8.1 requires 311 14.8.2 exports 311 14.8.3 requires的传递 311 14.8.4 exports to 312 14.8.5 open和opens 312 14.8.6 uses和provides 313 14.9 通过一个更复杂的例子了解更多 313 # 14.10 小结 314 # 第五部分 提升Java的并发性 # 第15章　CompletableFuture及反应式编程背后的概念　316 # 15.1 为支持并发而不断演进的Java 318 # 15.1.1 线程以及更高层的抽象 319 15.1.2 执行器和线程池 320 15.1.3 其他的线程抽象：非嵌套方法调用 322 15.1.4 你希望线程为你带来什么 324 15.2 同步及异步API 324 # 15.2.1 Future风格的API 326 15.2.2 反应式风格的API 327 15.2.3 有害的睡眠及其他阻塞式操作 328 15.2.4 实战验证 329 15.2.5 如何使用异步API进行异常处理 330 15.3 “线框–管道”模型 331 # 15.4 为并发而生的CompletableFuture和结合器 332 # 15.5 “发布–订阅”以及反应式编程 335 # 15.5.1 示例：对两个流求和 337 15.5.2 背压 341 15.5.3 一种简单的真实背压 341 15.6 反应式系统和反应式编程 342 # 15.7 路线图 342 # 15.8 小结 343 # 第16章　CompletableFuture：组合式异步编程　344 # 16.1 Future接口 344 # 16.1.1 Future接口的局限性 346 16.1.2 使用CompletableFuture构建异步应用 346 16.2 实现异步API 347 # 16.2.1 将同步方法转换为异步方法 348 16.2.2 错误处理 350 16.3 让你的代码免受阻塞之苦 352 # 16.3.1 使用并行流对请求进行并行操作 353 16.3.2 使用CompletableFuture发起异步请求 353 16.3.3 寻找更好的方案 355 16.3.4 使用定制的执行器 356 16.4 对多个异步任务进行流水线操作 358 # 16.4.1 实现折扣服务 358 16.4.2 使用Discount服务 359 16.4.3 构造同步和异步操作 360 16.4.4 将两个CompletableFuture对象整合起来，无论它们是否存在依赖 363 16.4.5 对Future和Completable-Future 的回顾 364 16.4.6 高效地使用超时机制 365 16.5 响应CompletableFuture的completion事件 366 # 16.5.1 对最佳价格查询器应用的优化 367 16.5.2 付诸实践 368 16.6 路线图 369 # 16.7 小结 369 # 第17章　反应式编程　370 # 17.1 反应式宣言 371 # 17.1.1 应用层的反应式编程 371 17.1.2 反应式系统 373 17.2 反应式流以及Flow API 373 # 17.2.1 Flow类 374 17.2.2 创建你的第一个反应式应用 377 17.2.3 使用Processor转换数据 381 17.2.4 为什么Java并未提供Flow API的实现 383 17.3 使用反应式库RxJava 384 # 17.3.1 创建和使用Observable 385 17.3.2 转换及整合多个Observable 392 第六部分 函数式编程以及Java未来的演进 # 第18章　函数式的思考　396 # 18.1 实现和维护系统 396 # 18.1.1 共享的可变数据 397 18.1.2 声明式编程 398 18.1.3 为什么要采用函数式编程 399 18.2 什么是函数式编程 399 # 18.2.1 函数式Java编程 400 18.2.2 引用透明性 402 18.2.3 面向对象的编程和函数式编程的对比 402 18.2.4 函数式编程实战 403 18.3 递归和迭代 405 # 18.4 小结 408 # 第19章　函数式编程的技巧　409 # 19.1 无处不在的函数 409 # 19.1.1 高阶函数 410 19.1.2 柯里化 411 19.2 持久化数据结构 412 # 19.2.1 破坏式更新和函数式更新的比较 413 19.2.2 另一个使用Tree的例子 415 19.2.3 采用函数式的方法 416 19.3 Stream的延迟计算 418 # 19.3.1 自定义的Stream 418 19.3.2 创建你自己的延迟列表 420 19.4 模式匹配 425 # 19.4.1 访问者模式 425 19.4.2 用模式匹配力挽狂澜 426 19.5 杂项 429 # 19.5.1 缓存或记忆表 429 19.5.2 “返回同样的对象”意味着什么 430 19.5.3 结合器 431 19.6 小结 432 # 第20章　面向对象和函数式编程的混合：Java和Scala的比较　433 # 20.1 Scala简介 434 # 20.1.1 你好，啤酒 434 20.1.2 基础数据结构：List、Set、Map、Tuple、Stream以及Option 436 20.2 函数 440 # 20.2.1 Scala中的一等函数 441 20.2.2 匿名函数和闭包 442 20.2.3 柯里化 443 20.3 类和trait 444 # 20.3.1 更加简洁的Scala类 445 20.3.2 Scala的trait与Java 8的接口对比 446 20.4 小结 447 # 第21章　结论以及Java的未来　448 # 21.1 回顾Java 8的语言特性 448 # 21.1.1 行为参数化（Lambda以及方法引用） 449 21.1.2 流 449 21.1.3 CompletableFuture 450 21.1.4 Optional 450 21.1.5 Flow API 451 21.1.6 默认方法 451 21.2 Java 9的模块系统 451 # 21.3 Java 10的局部变量类型推断 453 # 21.4 Java的未来 454 # 21.4.1 声明处型变 454 21.4.2 模式匹配 454 21.4.3 更加丰富的泛型形式 455 21.4.4 对不变性的更深层支持 457 21.4.5 值类型 458 21.5 让Java发展得更快 461 # 21.6 写在最后的话 462 # 附录A 其他语言特性的更新 463 附录B 其他类库的更新 467 附录C 如何以并发方式在同一个流上执行多种操作 475 附录D Lambda表达式和JVM字节码 483 "},{"id":62,"href":"/zh/zh/post/books/computer-science/java%E5%AE%9E%E6%88%98/","title":"Java实战","section":"Computer Science","content":" Java实战 # Java实战（第2版） 第一部分 基础知识 # 第1章　Java 8、9、10以及11的变化　2 # 1.1 为什么要关心Java的变化 2 # 1.2 Java怎么还在变 4 # 1.2.1 Java在编程语言生态系统中的位置 5 1.2.2 流处理 6 1.2.3 用行为参数化把代码传递给方法 7 1.2.4 并行与共享的可变数据 8 1.2.5 Java需要演变 9 1.3 Java中的函数 9 # 1.3.1 方法和Lambda作为一等值 10 1.3.2 传递代码：一个例子 11 1.3.3 从传递方法到Lambda 13 1.4 流 14 # 1.5 默认方法及Java模块 17 # 1.6 来自函数式编程的其他好思想 19 # 1.7 小结 20 # 第2章　通过行为参数化传递代码　22 # 2.1 应对不断变化的需求 23 # 2.1.1 初试牛刀：筛选绿苹果 23 2.1.2 再展身手：把颜色作为参数 23 2.1.3 第三次尝试：对你能想到的每个属性做筛选 24 2.2 行为参数化 25 # 2.3 对付啰唆 30 # 2.3.1 匿名类 30 2.3.2 第五次尝试：使用匿名类 31 2.3.3 第六次尝试：使用Lambda表达式 32 2.3.4 第七次尝试：将List类型抽象化 33 2.4 真实的例子 33 # 2.4.1 用Comparator来排序 33 2.4.2 用Runnable执行代码块 34 2.4.3 通过Callable返回结果 35 2.4.4 GUI事件处理 35 2.5 小结 36 # 第3章　Lambda表达式　37 # 3.1 Lambda管中窥豹 37 # 3.2 在哪里以及如何使用Lambda 40 # 3.2.1 函数式接口 40 3.2.2 函数描述符 42 3.3 把Lambda付诸实践：环绕执行模式 44 # 3.3.1 第1 步：记得行为参数化 44 3.3.2 第2 步：使用函数式接口来传递行为 45 3.3.3 第3 步：执行一个行为 45 3.3.4 第4 步：传递Lambda 46 3.4 使用函数式接口 47 # 3.4.1 Predicate 47 3.4.2 Consumer 47 3.4.3 Function 48 3.5 类型检查、类型推断以及限制 52 # 3.5.1 类型检查 52 3.5.2 同样的Lambda，不同的函数式接口 53 3.5.3 类型推断 55 3.5.4 使用局部变量 56 3.6 方法引用 57 # 3.6.1 管中窥豹 57 3.6.2 构造函数引用 60 3.7 Lambda和方法引用实战 62 # 3.7.1 第1 步：传递代码 62 3.7.2 第2 步：使用匿名类 62 3.7.3 第3 步：使用Lambda表达式 62 3.7.4 第4 步：使用方法引用 63 3.8 复合Lambda表达式的有用方法 63 # 3.8.1 比较器复合 64 3.8.2 谓词复合 64 3.8.3 函数复合 65 3.9 数学中的类似思想 66 # 3.9.1 积分 66 3.9.2 与Java 8的Lambda联系起来 68 3.10 小结 68 # 第二部分 使用流进行函数式数据处理 # 第4章　引入流　72 # 4.1 流是什么 72 # 4.2 流简介 76 # 4.3 流与集合 78 # 4.3.1 只能遍历一次 79 4.3.2 外部迭代与内部迭代 80 4.4 流操作 82 # 4.4.1 中间操作 83 4.4.2 终端操作 84 4.4.3 使用流 84 4.5 路线图 85 # 4.6 小结 85 # 第5章　使用流　86 # 5.1 筛选 87 # 5.1.1 用谓词筛选 87 5.1.2 筛选各异的元素 87 5.2 流的切片 88 # 5.2.1 使用谓词对流进行切片 88 5.2.2 截短流 90 5.2.3 跳过元素 90 5.3 映射 91 # 5.3.1 对流中每一个元素应用函数 91 5.3.2 流的扁平化 92 5.4 查找和匹配 95 # 5.4.1 检查谓词是否至少匹配一个元素 95 5.4.2 检查谓词是否匹配所有元素 96 5.4.3 查找元素 96 5.4.4 查找第一个元素 97 5.5 归约 98 # 5.5.1 元素求和 98 5.5.2 最大值和最小值 100 5.6 付诸实践 103 # 5.6.1 领域：交易员和交易 103 5.6.2 解答 104 5.7 数值流 106 # 5.7.1 原始类型流特化 107 5.7.2 数值范围 108 5.7.3 数值流应用：勾股数 108 5.8 构建流 111 # 5.8.1 由值创建流 111 5.8.2 由可空对象创建流 111 5.8.3 由数组创建流 112 5.8.4 由文件生成流 112 5.8.5 由函数生成流：创建无限流 113 5.9 概述 116 # 5.10 小结 116 # 第6章　用流收集数据　118 # 6.1 收集器简介 119 # 6.1.1 收集器用作高级归约 119 6.1.2 预定义收集器 120 6.2 归约和汇总 121 # 6.2.1 查找流中的最大值和最小值 121 6.2.2 汇总 122 6.2.3 连接字符串 123 6.2.4 广义的归约汇总 124 6.3 分组 127 # 6.3.1 操作分组的元素 128 6.3.2 多级分组 130 6.3.3 按子组收集数据 131 6.4 分区 134 # 6.4.1 分区的优势 135 6.4.2 将数字按质数和非质数分区 136 6.5 收集器接口 138 # 6.5.1 理解Collector接口声明的方法 139 6.5.2 全部融合到一起 143 6.6 开发你自己的收集器以获得更好的性能 144 # 6.6.1 仅用质数做除数 145 6.6.2 比较收集器的性能 148 6.7 小结 150 # 第7章　并行数据处理与性能　151 # 7.1 并行流 152 # 7.1.1 将顺序流转换为并行流 52 7.1.2 测量流性能 154 7.1.3 正确使用并行流 158 7.1.4 高效使用并行流 159 7.2 分支/合并框架 161 # 7.2.1 使用RecursiveTask 161 7.2.2 使用分支/合并框架的最佳做法 164 7.2.3 工作窃取 165 7.3 Spliterator 166 # 7.3.1 拆分过程 167 7.3.2 实现你自己的Spliterator 168 7.4 小结 173 # 第三部分 使用流和Lambda进行高效编程 # 第8章　Collection API的增强功能　176 # 8.1 集合工厂 176 # 8.1.1 List工厂 177 8.1.2 Set工厂 178 8.1.3 Map工厂 179 8.2 使用List和Set 180 # 8.2.1 removeIf方法 180 8.2.2 replaceAll方法 181 8.3 使用Map 181 # 8.3.1 forEach方法 182 8.3.2 排序 182 8.3.3 getOrDefault方法 183 8.3.4 计算模式 183 8.3.5 删除模式 184 8.3.6 替换模式 185 8.3.7 merge方法 185 8.4 改进的ConcurrentHashMap 187 # 8.4.1 归约和搜索 187 8.4.2 计数 188 8.4.3 Set视图 188 8.5 小结 188 # 第9章　重构、测试和调试　189 # 9.1 为改善可读性和灵活性重构代码 189 # 9.1.1 改善代码的可读性 190 9.1.2 从匿名类到Lambda表达式的转换 190 9.1.3 从Lambda表达式到方法引用的转换 191 9.1.4 从命令式的数据处理切换到Stream 193 9.1.5 增加代码的灵活性 193 9.2 使用Lambda重构面向对象的设计模式 195 # 9.2.1 策略模式 196 9.2.2 模板方法 197 9.2.3 观察者模式 198 9.2.4 责任链模式 201 9.2.5 工厂模式 202 9.3 测试Lambda表达式 204 # 9.3.1 测试可见Lambda函数的行为 204 9.3.2 测试使用Lambda的方法的行为 205 9.3.3 将复杂的Lambda表达式分为不同的方法 205 9.3.4 高阶函数的测试 206 9.4 调试 206 # 9.4.1 查看栈跟踪 206 9.4.2 使用日志调试 208 9.5 小结 209 # 第10章　基于Lambda的领域特定语言　210 # 10.1 领域特定语言 212 # 10.1.1 DSL的优点和弊端 212 10.1.2 JVM中已提供的DSL解决方案 214 10.2 现代Java API中的小型DSL 217 # 10.2.1 把Stream API当成DSL去操作集合 219 10.2.2 将Collectors作为DSL汇总数据 220 10.3 使用Java创建DSL的模式与技巧 221 # 10.3.1 方法链接 224 10.3.2 使用嵌套函数 226 10.3.3 使用Lambda表达式的函数序列 228 10.3.4 把它们都放到一起 230 10.3.5 在DSL中使用方法引用 232 10.4 Java 8 DSL的实际应用 234 # 10.4.1 jOOQ 235 10.4.2 Cucumber 236 10.4.3 Spring Integration 238 10.5 小结 239 # 第四部分 无所不在的Java # 第11章　用Optional取代null　242 # 11.1 如何为缺失的值建模 243 # 11.1.1 采用防御式检查减少NullPointerException 243 11.1.2 null带来的种种问题 245 11.1.3 其他语言中null的替代品 245 11.2 Optional类入门 246 # 11.3 应用Optional的几种模式 248 # 11.3.1 创建Optional对象 248 11.3.2 使用map从Optional对象中提取和转换值 248 11.3.3 使用flatMap链接Optional对象 249 11.3.4 操纵由Optional对象构成的Stream 253 11.3.5 默认行为及解引用Optional对象 254 11.3.6 两个Optional对象的组合 255 11.3.7 使用filter剔除特定的值 257 11.4 使用Optional的实战示例 258 # 11.4.1 用Optional 封装可能为null的值 259 11.4.2 异常与Optional的对比 259 11.4.3 基础类型的Optional对象，以及为什么应该避免使用它们 260 11.4.4 把所有内容整合起来 260 11.5 小结 262 # 第12章　新的日期和时间API　263 # 12.1 LocalDate、LocalTime、LocalDateTime、Instant、Duration以及Period 264 # 12.1.1 使用LocalDate和LocalTime 264 12.1.2 合并日期和时间 265 12.1.3 机器的日期和时间格式 266 12.1.4 定义Duration或Period 267 12.2 操纵、解析和格式化日期 268 # 12.2.1 使用TemporalAdjuster 270 12.2.2 打印输出及解析日期–时间对象 272 12.3 处理不同的时区和历法 274 # 12.3.1 使用时区 274 12.3.2 利用和UTC/格林尼治时间的固定偏差计算时区 275 12.3.3 使用别的日历系统 276 12.4 小结 277 # 第13章　默认方法　278 # 13.1 不断演进的API 280 # 13.1.1 初始版本的API 281 13.1.2 第二版API 281 13.2 概述默认方法 283 # 13.3 默认方法的使用模式 285 # 13.3.1 可选方法 285 13.3.2 行为的多继承 286 13.4 解决冲突的规则 289 # 13.4.1 解决问题的三条规则 289 13.4.2 选择提供了最具体实现的默认方法的接口 290 13.4.3 冲突及如何显式地消除歧义 291 13.4.4 菱形继承问题 293 13.5 小结 294 # 第14章　Java模块系统　295 # 14.1 模块化的驱动力：软件的推理 295 # 14.1.1 关注点分离 295 14.1.2 信息隐藏 296 14.1.3 Java软件 296 14.2 为什么要设计Java模块系统 297 # 14.2.1 模块化的局限性 297 14.2.2 单体型的JDK 298 14.2.3 与OSGi的比较 299 14.3 Java模块：全局视图 300 # 14.4 使用Java模块系统开发应用 301 # 14.4.1 从头开始搭建一个应用 302 14.4.2 细粒度和粗粒度的模块化 303 14.4.3 Java模块系统基础 303 14.5 使用多个模块 304 # 14.5.1 exports子句 304 14.5.2 requires子句 305 14.5.3 命名 306 14.6 编译及打包 306 # 14.7 自动模块 310 # 14.8 模块声明及子句 311 # 14.8.1 requires 311 14.8.2 exports 311 14.8.3 requires的传递 311 14.8.4 exports to 312 14.8.5 open和opens 312 14.8.6 uses和provides 313 14.9 通过一个更复杂的例子了解更多 313 # 14.10 小结 314 # 第五部分 提升Java的并发性 # 第15章　CompletableFuture及反应式编程背后的概念　316 # 15.1 为支持并发而不断演进的Java 318 # 15.1.1 线程以及更高层的抽象 319 15.1.2 执行器和线程池 320 15.1.3 其他的线程抽象：非嵌套方法调用 322 15.1.4 你希望线程为你带来什么 324 15.2 同步及异步API 324 # 15.2.1 Future风格的API 326 15.2.2 反应式风格的API 327 15.2.3 有害的睡眠及其他阻塞式操作 328 15.2.4 实战验证 329 15.2.5 如何使用异步API进行异常处理 330 15.3 “线框–管道”模型 331 # 15.4 为并发而生的CompletableFuture和结合器 332 # 15.5 “发布–订阅”以及反应式编程 335 # 15.5.1 示例：对两个流求和 337 15.5.2 背压 341 15.5.3 一种简单的真实背压 341 15.6 反应式系统和反应式编程 342 # 15.7 路线图 342 # 15.8 小结 343 # 第16章　CompletableFuture：组合式异步编程　344 # 16.1 Future接口 344 # 16.1.1 Future接口的局限性 346 16.1.2 使用CompletableFuture构建异步应用 346 16.2 实现异步API 347 # 16.2.1 将同步方法转换为异步方法 348 16.2.2 错误处理 350 16.3 让你的代码免受阻塞之苦 352 # 16.3.1 使用并行流对请求进行并行操作 353 16.3.2 使用CompletableFuture发起异步请求 353 16.3.3 寻找更好的方案 355 16.3.4 使用定制的执行器 356 16.4 对多个异步任务进行流水线操作 358 # 16.4.1 实现折扣服务 358 16.4.2 使用Discount服务 359 16.4.3 构造同步和异步操作 360 16.4.4 将两个CompletableFuture对象整合起来，无论它们是否存在依赖 363 16.4.5 对Future和Completable-Future 的回顾 364 16.4.6 高效地使用超时机制 365 16.5 响应CompletableFuture的completion事件 366 # 16.5.1 对最佳价格查询器应用的优化 367 16.5.2 付诸实践 368 16.6 路线图 369 # 16.7 小结 369 # 第17章　反应式编程　370 # 17.1 反应式宣言 371 # 17.1.1 应用层的反应式编程 371 17.1.2 反应式系统 373 17.2 反应式流以及Flow API 373 # 17.2.1 Flow类 374 17.2.2 创建你的第一个反应式应用 377 17.2.3 使用Processor转换数据 381 17.2.4 为什么Java并未提供Flow API的实现 383 17.3 使用反应式库RxJava 384 # 17.3.1 创建和使用Observable 385 17.3.2 转换及整合多个Observable 392 第六部分 函数式编程以及Java未来的演进 # 第18章　函数式的思考　396 # 18.1 实现和维护系统 396 # 18.1.1 共享的可变数据 397 18.1.2 声明式编程 398 18.1.3 为什么要采用函数式编程 399 18.2 什么是函数式编程 399 # 18.2.1 函数式Java编程 400 18.2.2 引用透明性 402 18.2.3 面向对象的编程和函数式编程的对比 402 18.2.4 函数式编程实战 403 18.3 递归和迭代 405 # 18.4 小结 408 # 第19章　函数式编程的技巧　409 # 19.1 无处不在的函数 409 # 19.1.1 高阶函数 410 19.1.2 柯里化 411 19.2 持久化数据结构 412 # 19.2.1 破坏式更新和函数式更新的比较 413 19.2.2 另一个使用Tree的例子 415 19.2.3 采用函数式的方法 416 19.3 Stream的延迟计算 418 # 19.3.1 自定义的Stream 418 19.3.2 创建你自己的延迟列表 420 19.4 模式匹配 425 # 19.4.1 访问者模式 425 19.4.2 用模式匹配力挽狂澜 426 19.5 杂项 429 # 19.5.1 缓存或记忆表 429 19.5.2 “返回同样的对象”意味着什么 430 19.5.3 结合器 431 19.6 小结 432 # 第20章　面向对象和函数式编程的混合：Java和Scala的比较　433 # 20.1 Scala简介 434 # 20.1.1 你好，啤酒 434 20.1.2 基础数据结构：List、Set、Map、Tuple、Stream以及Option 436 20.2 函数 440 # 20.2.1 Scala中的一等函数 441 20.2.2 匿名函数和闭包 442 20.2.3 柯里化 443 20.3 类和trait 444 # 20.3.1 更加简洁的Scala类 445 20.3.2 Scala的trait与Java 8的接口对比 446 20.4 小结 447 # 第21章　结论以及Java的未来　448 # 21.1 回顾Java 8的语言特性 448 # 21.1.1 行为参数化（Lambda以及方法引用） 449 21.1.2 流 449 21.1.3 CompletableFuture 450 21.1.4 Optional 450 21.1.5 Flow API 451 21.1.6 默认方法 451 21.2 Java 9的模块系统 451 # 21.3 Java 10的局部变量类型推断 453 # 21.4 Java的未来 454 # 21.4.1 声明处型变 454 21.4.2 模式匹配 454 21.4.3 更加丰富的泛型形式 455 21.4.4 对不变性的更深层支持 457 21.4.5 值类型 458 21.5 让Java发展得更快 461 # 21.6 写在最后的话 462 # 附录A 其他语言特性的更新 463 附录B 其他类库的更新 467 附录C 如何以并发方式在同一个流上执行多种操作 475 附录D Lambda表达式和JVM字节码 483 "},{"id":63,"href":"/zh/post/computer-science/linux/","title":"linux","section":"Computer Science","content":" linux # resources # 鸟哥的Linux私房菜：基础学习篇 第四版 tail # tail -f xxxx "},{"id":64,"href":"/zh/zh/post/computer-science/linux/","title":"linux","section":"Computer Science","content":" linux # resources # 鸟哥的Linux私房菜：基础学习篇 第四版 tail # tail -f xxxx "},{"id":65,"href":"/zh/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","title":"Python神经网络编程","section":"Computer Science","content":" 第1章 神经网络如何工作 # "},{"id":66,"href":"/zh/zh/post/books/computer-science/python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","title":"Python神经网络编程","section":"Computer Science","content":" 第1章 神经网络如何工作 # "},{"id":67,"href":"/zh/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/","title":"Redis设计与实现","section":"Computer Science","content":" 第2章 简单动态字符串 # Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS（Simple Dynamic String，简单动态字符串）作为字符串表示。 比起C字符串，SDS具有以下优点： 1）常数复杂度获取字符串长度。 2）杜绝缓冲区溢出。 3）减少修改字符串长度时所需的内存重分配次数。 4）二进制安全。 5）兼容部分C字符串函数 第3章 链表 # 链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。 每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。 每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。 因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。 通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。 第4章 字典 # 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。 Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的。 第5章 跳跃表 # 跳跃表是有序集合的底层实现之一。 Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。 每个跳跃表节点的层高都是1至32之间的随机数。 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。 第6章 整数集合 # 整数集合是集合键的底层实现之一 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存 整数集合只支持升级操作，不支持降级操作 第7章 压缩列表 # 压缩列表是一种为节约内存而开发的顺序型数据结构 压缩列表被用作列表键和哈希键的底层实现之一 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高 第8章 对象 # Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象） 对象的类型 字符串对象 REDIS_STRING 列表对象 REDIS_LIST 哈希对象 REDIS_HASH 集合对象 REDIS_SET 有序集合对象 REDIS_ZSET 对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种 当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象” 当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象” TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型 因为键的类型始终为字符串 "},{"id":68,"href":"/zh/zh/post/books/computer-science/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/","title":"Redis设计与实现","section":"Computer Science","content":" 第2章 简单动态字符串 # Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS（Simple Dynamic String，简单动态字符串）作为字符串表示。 比起C字符串，SDS具有以下优点： 1）常数复杂度获取字符串长度。 2）杜绝缓冲区溢出。 3）减少修改字符串长度时所需的内存重分配次数。 4）二进制安全。 5）兼容部分C字符串函数 第3章 链表 # 链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。 每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。 每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。 因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。 通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。 第4章 字典 # 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。 Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的。 第5章 跳跃表 # 跳跃表是有序集合的底层实现之一。 Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。 每个跳跃表节点的层高都是1至32之间的随机数。 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。 第6章 整数集合 # 整数集合是集合键的底层实现之一 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存 整数集合只支持升级操作，不支持降级操作 第7章 压缩列表 # 压缩列表是一种为节约内存而开发的顺序型数据结构 压缩列表被用作列表键和哈希键的底层实现之一 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高 第8章 对象 # Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象） 对象的类型 字符串对象 REDIS_STRING 列表对象 REDIS_LIST 哈希对象 REDIS_HASH 集合对象 REDIS_SET 有序集合对象 REDIS_ZSET 对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种 当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象” 当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象” TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型 因为键的类型始终为字符串 "},{"id":69,"href":"/zh/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/","title":"Spring Cloud微服务：入门、实战与进阶","section":"Computer Science","content":" 1.3 什么是Spring Cloud # Eureka 服务注册中心，用于服务管理 Ribbon 基于客户端的负载均衡组件 Hystrix 容错框架，能够防止服务的雪崩效应 Feign Web服务客户端，能够简化HTTP接口的调用 Zuul API网关，提供路由转发、请求过滤等功能 Config 分布式配置管理 Sleuth 服务跟踪 Stream 构建消息驱动的微服务应用程序的框架 Bus 消息代理的集群消息总线。 第3章　Eureka注册中心 # Spring Cloud Eureka是一个基于REST的服务，并且提供了基于Java的客户端组件，能够非常方便地将服务注册到Spring Cloud Eureka中进行统一管理。 服务治理是微服务架构中必不可少的一部分，阿里开源的Dubbo框架就是针对服务治理的。服务治理必须要有一个注册中心，除了用Eureka作为注册中心外，我们还可以使用Consul、Etcd、Zookeeper等来作为服务的注册中心。 用过Dubbo的读者应该清楚，Dubbo中也有几种注册中心，比如基于Zookeeper、基于Redis等，不过用得最多的还是Zookeeper方式。至于使用哪种方式都是可以的，注册中心无非就是管理所有服务的信息和状态。 程序也是一样，当你需要调用某一个服务的时候，你会先去Eureka中去拉取服务列表，查看你调用的服务在不在其中，在的话就拿到服务地址、端口等信息，然后调用。 为什么Eureka比Zookeeper更适合作为注册中心呢？ 主要是因为Eureka是基于AP原则构建的，而ZooKeeper是基于CP原则构建的。在分布式系统领域有个著名的CAP定理，即C为数据一致性；A为服务可用性；P为服务对网络分区故障的容错性。这三个特性在任何分布式系统中都不能同时满足，最多同时满足两个。 Zookeeper有一个Leader，而且在这个Leader无法使用的时候通过Paxos(ZAB)算法选举出一个新的Leader。这个Leader的任务就是保证写数据的时候只向这个Leader写入，Leader会同步信息到其他节点。通过这个操作就可以保证数据的一致性。 总而言之，想要保证AP就要用Eureka，想要保证CP就要用Zookeeper。Dubbo中大部分都是基于Zookeeper作为注册中心的。Spring Cloud中当然首选Eureka。 第4章　客户端负载均衡Ribbon # 目前主流的负载方案分为两种：一种是集中式负载均衡，在消费者和服务提供方中间使用独立的代理方式进行负载，有硬件的（比如F5），也有软件的（比如Nginx）。另一种则是客户端自己做负载均衡，根据自己的请求情况做负载，Ribbon就属于客户端自己做负载。 Ribbon作为一款客户端负载均衡框架，默认的负载策略是轮询，同时也提供了很多其他的策略，能够让用户根据自身的业务需求进行选择。 第6章　Hystrix服务容错处理 # 在微服务架构中存在多个可直接调用的服务，这些服务若在调用时出现故障会导致连锁效应，也就是可能会让整个系统变得不可用，这种情况我们称之为服务雪崩效应。 Hystrix是Netflix针对微服务分布式系统采用的熔断保护中间件，相当于电路中的保险丝。 "},{"id":70,"href":"/zh/zh/post/books/computer-science/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/","title":"Spring Cloud微服务：入门、实战与进阶","section":"Computer Science","content":" 1.3 什么是Spring Cloud # Eureka 服务注册中心，用于服务管理 Ribbon 基于客户端的负载均衡组件 Hystrix 容错框架，能够防止服务的雪崩效应 Feign Web服务客户端，能够简化HTTP接口的调用 Zuul API网关，提供路由转发、请求过滤等功能 Config 分布式配置管理 Sleuth 服务跟踪 Stream 构建消息驱动的微服务应用程序的框架 Bus 消息代理的集群消息总线。 第3章　Eureka注册中心 # Spring Cloud Eureka是一个基于REST的服务，并且提供了基于Java的客户端组件，能够非常方便地将服务注册到Spring Cloud Eureka中进行统一管理。 服务治理是微服务架构中必不可少的一部分，阿里开源的Dubbo框架就是针对服务治理的。服务治理必须要有一个注册中心，除了用Eureka作为注册中心外，我们还可以使用Consul、Etcd、Zookeeper等来作为服务的注册中心。 用过Dubbo的读者应该清楚，Dubbo中也有几种注册中心，比如基于Zookeeper、基于Redis等，不过用得最多的还是Zookeeper方式。至于使用哪种方式都是可以的，注册中心无非就是管理所有服务的信息和状态。 程序也是一样，当你需要调用某一个服务的时候，你会先去Eureka中去拉取服务列表，查看你调用的服务在不在其中，在的话就拿到服务地址、端口等信息，然后调用。 为什么Eureka比Zookeeper更适合作为注册中心呢？ 主要是因为Eureka是基于AP原则构建的，而ZooKeeper是基于CP原则构建的。在分布式系统领域有个著名的CAP定理，即C为数据一致性；A为服务可用性；P为服务对网络分区故障的容错性。这三个特性在任何分布式系统中都不能同时满足，最多同时满足两个。 Zookeeper有一个Leader，而且在这个Leader无法使用的时候通过Paxos(ZAB)算法选举出一个新的Leader。这个Leader的任务就是保证写数据的时候只向这个Leader写入，Leader会同步信息到其他节点。通过这个操作就可以保证数据的一致性。 总而言之，想要保证AP就要用Eureka，想要保证CP就要用Zookeeper。Dubbo中大部分都是基于Zookeeper作为注册中心的。Spring Cloud中当然首选Eureka。 第4章　客户端负载均衡Ribbon # 目前主流的负载方案分为两种：一种是集中式负载均衡，在消费者和服务提供方中间使用独立的代理方式进行负载，有硬件的（比如F5），也有软件的（比如Nginx）。另一种则是客户端自己做负载均衡，根据自己的请求情况做负载，Ribbon就属于客户端自己做负载。 Ribbon作为一款客户端负载均衡框架，默认的负载策略是轮询，同时也提供了很多其他的策略，能够让用户根据自身的业务需求进行选择。 第6章　Hystrix服务容错处理 # 在微服务架构中存在多个可直接调用的服务，这些服务若在调用时出现故障会导致连锁效应，也就是可能会让整个系统变得不可用，这种情况我们称之为服务雪崩效应。 Hystrix是Netflix针对微服务分布式系统采用的熔断保护中间件，相当于电路中的保险丝。 "},{"id":71,"href":"/zh/post/books/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E7%AC%AC%E4%B8%89%E7%89%88/","title":"宏观经济学 第三版","section":"Books","content":" 宏观经济学 第三版 # 第1章 经济学原理的实践 # 第2章 经济科学：运用数据和模型理解世界 # 第3章 优化：竭力做到最好 # 第4章 需求，供给与均衡 # 第5章 国家财富：定义和测算宏观经济总量 # 第6章 总收入 # 第7章 经济增长 # 第8章 为什么很多地区仍然不发达？ # 第9章 就业与失业 # 第10章 信贷市场 # 信贷：我们把包括企业家、购房者和学生在内的借款主体称为债务人，他们所借入的资金被称为信贷\n借款当然不是免费的，借款人需要支付利息。借款的初始金额被称为本金。利率是借款者在偿还本金之外，需要（在满一年时）为每1美元贷款支付的额外费用。也可以说，利率就是一笔1美元贷款的年度成本。\n如果你借了1年期利率为i的L美元，1年后你要偿还本金L美元加上i×L美元的利息。为了和实际利率区分开来，我们把利率i称为名义利率。\n实际利率=名义利率-通货膨胀率\n实际GDP=名义GDP-通货膨胀率 几乎所有的贷款都是以名义利率发放的 我现在理解了韩秀云说的贷款买房比全款买房更好，因为实际利率会随着通货膨胀越来越低，甚至可能低于越来的本金 通货膨胀率指的是整体经济中物价上涨的速度。\n其他条件不变时，通货膨胀率越高，企业销售的商品和服务价格就会越高，在给定的名义利率下偿还贷款就会越容易。 信贷需求曲线：信贷需求量与实际利率之间的关系\n政府所感知到的商业机会变化、家庭偏好或预期的变化、政府政策的变化，会使得信贷需求曲线左移或右移 实际利率：人们因存钱而得到的回报，因为今天存的1美元，在一年后的购买力是1+r美元，其中r是实际利率\n换句话说，实际利率是当前消费的机会成本，也就是你基于未来的购买力而放弃的东西。因此，较高的实际利率会增加当前消费的机会成本，鼓励更高水平的储蓄。 真实市场中，为了补偿出借人，具有不同违约风险的借款者需面对不同的实际利率。 信贷供给曲线：信贷供给量与实际利率之间的关系\n信贷供给曲线的移动则源于实际利率不变的情况下，追求优化的经济主体储蓄动机的变化（家庭储蓄动机的变化、企业储蓄动机的变化） 人们为什么要储蓄？\n为退休储蓄 为孩子存钱 为一些可预见的大额支出而存钱 投资个人事业而存钱 以备不时之需 信贷市场：借款者从储蓄者那里获取资金的市场，有时也被称为可贷资金市场\n信贷市场均衡：信贷供给曲线与信贷需求曲线的交点所对应的实际利率和信贷量 交点决定了市场中的信贷总量(Q*)和均衡实际利率(r*)。在均衡实际利率下，信贷需求量等于信贷供给量。实际利率高于均衡水平将导致超额的信贷供给，这通常会给实际利率带来下行压力。实际利率低于均衡水平将导致超额的信贷需求，给实际利率带来上行压力。 信贷市场的作用：通过使储蓄者把多余的钱出借给借款者，信贷市场改善了经济中的资源配置\n金融资本：金融资本存在多种不同的形式，包括信贷（也被称为债务）和股权。\n当一个储蓄者将其存款变成信贷时，他就把自己的储蓄借给了另一个人，换来的是连本带息偿还贷款的承诺。 当一个储蓄者把自己的存款变成股权时，他就利用其储蓄变成了一家公司的股东，这意味着他获得了公司的所有权和对公司未来利润的索取权。这些利润会以股息的形式支付给公司股东。 独角兽：越来越多科技初创公司的市值超过10亿美元。在向公众发行股票之前估值超过这一门槛的公司被称为独角兽。\n第11章 货币体系 # 第12章 短期波动 # 第13章 逆周期宏观经济政策 # 第14章 宏观经济学和国际贸易 # 第15章 开放经济的宏观经济学 # "},{"id":72,"href":"/zh/zh/post/books/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E7%AC%AC%E4%B8%89%E7%89%88/","title":"宏观经济学 第三版","section":"Books","content":" 宏观经济学 第三版 # 第1章 经济学原理的实践 # 第2章 经济科学：运用数据和模型理解世界 # 第3章 优化：竭力做到最好 # 第4章 需求，供给与均衡 # 第5章 国家财富：定义和测算宏观经济总量 # 第6章 总收入 # 第7章 经济增长 # 第8章 为什么很多地区仍然不发达？ # 第9章 就业与失业 # 第10章 信贷市场 # 信贷：我们把包括企业家、购房者和学生在内的借款主体称为债务人，他们所借入的资金被称为信贷\n借款当然不是免费的，借款人需要支付利息。借款的初始金额被称为本金。利率是借款者在偿还本金之外，需要（在满一年时）为每1美元贷款支付的额外费用。也可以说，利率就是一笔1美元贷款的年度成本。\n如果你借了1年期利率为i的L美元，1年后你要偿还本金L美元加上i×L美元的利息。为了和实际利率区分开来，我们把利率i称为名义利率。\n实际利率=名义利率-通货膨胀率\n实际GDP=名义GDP-通货膨胀率 几乎所有的贷款都是以名义利率发放的 我现在理解了韩秀云说的贷款买房比全款买房更好，因为实际利率会随着通货膨胀越来越低，甚至可能低于越来的本金 通货膨胀率指的是整体经济中物价上涨的速度。\n其他条件不变时，通货膨胀率越高，企业销售的商品和服务价格就会越高，在给定的名义利率下偿还贷款就会越容易。 信贷需求曲线：信贷需求量与实际利率之间的关系\n政府所感知到的商业机会变化、家庭偏好或预期的变化、政府政策的变化，会使得信贷需求曲线左移或右移 实际利率：人们因存钱而得到的回报，因为今天存的1美元，在一年后的购买力是1+r美元，其中r是实际利率\n换句话说，实际利率是当前消费的机会成本，也就是你基于未来的购买力而放弃的东西。因此，较高的实际利率会增加当前消费的机会成本，鼓励更高水平的储蓄。 真实市场中，为了补偿出借人，具有不同违约风险的借款者需面对不同的实际利率。 信贷供给曲线：信贷供给量与实际利率之间的关系\n信贷供给曲线的移动则源于实际利率不变的情况下，追求优化的经济主体储蓄动机的变化（家庭储蓄动机的变化、企业储蓄动机的变化） 人们为什么要储蓄？\n为退休储蓄 为孩子存钱 为一些可预见的大额支出而存钱 投资个人事业而存钱 以备不时之需 信贷市场：借款者从储蓄者那里获取资金的市场，有时也被称为可贷资金市场\n信贷市场均衡：信贷供给曲线与信贷需求曲线的交点所对应的实际利率和信贷量 交点决定了市场中的信贷总量(Q*)和均衡实际利率(r*)。在均衡实际利率下，信贷需求量等于信贷供给量。实际利率高于均衡水平将导致超额的信贷供给，这通常会给实际利率带来下行压力。实际利率低于均衡水平将导致超额的信贷需求，给实际利率带来上行压力。 信贷市场的作用：通过使储蓄者把多余的钱出借给借款者，信贷市场改善了经济中的资源配置\n金融资本：金融资本存在多种不同的形式，包括信贷（也被称为债务）和股权。\n当一个储蓄者将其存款变成信贷时，他就把自己的储蓄借给了另一个人，换来的是连本带息偿还贷款的承诺。 当一个储蓄者把自己的存款变成股权时，他就利用其储蓄变成了一家公司的股东，这意味着他获得了公司的所有权和对公司未来利润的索取权。这些利润会以股息的形式支付给公司股东。 独角兽：越来越多科技初创公司的市值超过10亿美元。在向公众发行股票之前估值超过这一门槛的公司被称为独角兽。\n第11章 货币体系 # 第12章 短期波动 # 第13章 逆周期宏观经济政策 # 第14章 宏观经济学和国际贸易 # 第15章 开放经济的宏观经济学 # "},{"id":73,"href":"/zh/post/books/computer-science/%E5%89%91%E6%8C%87offer/","title":"剑指Offer","section":"Computer Science","content":" 剑指Offer 第1章 面试的流程 1 # 1.1 面试官谈面试 1 # 1.2 面试的三种形式 2 # 1.2.1 电话面试 2 # 1.2.2 共享桌面远程面试 3 # 1.2.3 现场面试 4 # 1.3 面试的三个环节 5 # 1.3.1 行为面试环节 5 # 应聘者的项目经验 6 # 应聘者掌握的技能 7 # 回答“为什么跳槽” 8 # 1.3.2 技术面试环节 10 # 扎实的基础知识 10 # 高质量的代码 11 # 清晰的思路 14 # 优化效率的能力 15 # 优秀的综合能力 16 # 1.3.3 应聘者提问环节 17 # 1.4 本章小结 18 # 第2章 面试需要的基础知识 20 # 2.1 面试官谈基础知识 20 # 2.2 编程语言 22 # 2.2.1 C++ 22 # 面试题1：赋值运算符函数 24 # 经典的解法，适用于初级程序员 25 # 考虑异常安全性的解法，高级程序员必备 26 # 2.2.2 C# 27 # 面试题2：实现Singleton模式 31 # 不好的解法一：只适用于单线程 31 # 不好的解法二：可用于多线程但效率不高 32 # 可行的解法：同步锁前后两次判断 33 # 推荐的解法一：利用静态构造函数 34 # 推荐的解法二：按需创建实例 34 # 解法比较 35 # 2.3 数据结构 36 # 2.3.1 数组 36 # 面试题3：二维数组中的查找 38 # 2.3.2 字符串 42 # 面试题4：替换空格 44 # O(n2)的解法，不足以拿到Offer 45 # O(n)的解法，搞定Offer就靠它 46 # 2.3.3 链表 49 # 面试题5：从尾到头打印链表 51 # 2.3.4 树 53 # 面试题6：重建二叉树 55 # 2.3.5 栈和队列 58 # 面试题7：用两个栈实现队列 59 # 2.4 算法和数据操作 62 # 2.4.1 查找和排序 63 # 面试题8：旋转数组的最小数字 66 # 2.4.2 递归和循环 71 # 面试题9：斐波那契数列 73 # 效率很低的解法，面试官不会喜欢 73 # 面试官期待的实用解法 74 # O(logn)但不够实用的解法 74 # 解法比较 75 # 2.4.3 位运算 77 # 面试题10：二进制中1的个数 78 # 可能引起死循环的解法 79 # 常规解法 79 # 能给面试官带来惊喜的解法 80 # 2.5 本章小结 82 # 第3章 高质量的代码 84 # 3.1 面试官谈代码质量 84 # 3.2 代码的规范性 86 # 3.3 代码的完整性 87 # 从3方面确保代码的完整性 87 # 3种错误处理的方法 88 # 面试题11：数值的整数次方 90 # 自以为题目简单的解法 90 # 全面但不够高效的解法，离Offer已经很近了 90 # 全面又高效的解法，确保能拿到Offer 92 # 面试题12：打印1到最大的n位数 94 # 跳进面试官陷阱 94 # 在字符串上模拟数字加法 94 # 把问题转换成数字排列 97 # 面试题13：在O(1)时间删除链表结点 99 # 面试题14：调整数组顺序使奇数位于偶数前面 102 # 只完成基本功能的解法，仅适用于初级程序员 102 # 考虑可扩展性的解法，能秒杀Offer 104 # 3.4 代码的鲁棒性 106 # 面试题15：链表中倒数第k个结点 107 # 面试题16：反转链表 112 # 面试题17：合并两个排序的链表 114 # 面试题18：树的子结构 117 # 3.5 本章小结 121 # 第4章 解决面试题的思路 123 # 4.1 面试官谈面试思路 123 # 面试题19：二叉树的镜像 125 # 4.2 画图让抽象问题形象化 125 # 面试题20：顺时针打印矩阵 127 # 4.3 举例让抽象问题具体化 131 # 面试题21：包含min函数的栈 132 # 面试题22：栈的压入、弹出序列 134 # 面试题23：从上往下打印二叉树 137 # 面试题24：二叉搜索树的后序遍历序列 140 # 面试题25：二叉树中和为某一值的路径 143 # 4.4 分解让复杂问题简单化 146 # 面试题26：复杂链表的复制 147 # 面试题27：二叉搜索树与双向链表 151 # 面试题28：字符串的排列 154 # 4.5 本章小结 158 # 第5章 优化时间和空间效率 160 # 5.1 面试官谈效率 160 # 5.2 时间效率 162 # 面试题29：数组中出现次数超过一半的数字 163 # 基于Partition函数的O(n)算法 163 # 利用数组特点的O(n)算法 165 # 解法比较 166 # 面试题30：最小的k个数 167 # O(n)的算法，只当可以修改输入数组时可用 167 # O(nlogk)的算法，适合处理海量数据 168 # 解法比较 169 # 面试题31：连续子数组的最大和 171 # 举例分析数组的规律 171 # 应用动态规划法 173 # 面试题32：从1到n整数中1出现的次数 174 # 不考虑效率的解法，想拿Offer有点难 174 # 明显提高效率的解法，让面试官耳目一新 175 # 面试题33：把数组排成最小的数 177 # 5.3 时间效率与空间效率的平衡 181 # 面试题34：丑数 182 # 逐个判断整数是不是丑数的解法 182 # 创建数组保存已经找到的丑数的解法 183 # 面试题35：第一个只出现一次的字符 186 # 面试题36：数组中的逆序对 189 # 面试题37：两个链表的第一个公共结点 193 # 5.4 本章小结 196 # 第6章 面试中的各项能力 198 # 6.1 面试官谈能力 198 # 6.2 沟通能力和学习能力 200 # 沟通能力 200 # 学习能力 200 # 善于学习、沟通的人也善于提问 201 # 6.3 知识迁移能力 203 # 面试题38：数字在排序数组中出现的次数 204 # 面试题39：二叉树的深度 207 # 重复遍历结点的解法，不足以打动面试官 209 # 只遍历结点一次的解法，正是面试官喜欢的 209 # 面试题40：数组中只出现一次的数字 211 # 面试题41：和为s的两个数字VS和为s的连续正数序列 214 # 面试题42：翻转单词顺序 VS左旋转字符串 218 # 6.4 抽象建模能力 222 # 面试题43：n个骰子的点数 223 # 基于递归求骰子点数，时间效率不够高 223 # 基于循环求骰子点数，时间性能好 224 # 面试题44：扑克牌的顺子 226 # 面试题45：圆圈中最后剩下的数字 228 # 经典的解法，用循环链表模拟圆圈 229 # 创新的解法，拿到Offer不在话下 230 # 6.5 发散思维能力 232 # 面试题46：求1+2+…+n 233 # 利用构造函数求解 234 # 利用虚函数求解 234 # 利用函数指针求解 235 # 利用模板类型求解 236 # 面试题47：不用加减乘除做加法 237 # 面试题48：不能被继承的类 239 # 常规的解法：把构造函数设为私有函数 239 # 新奇的解法：利用虚拟继承 240 # 6.6 本章小结 241 # 第7章 两个面试案例 243 # 7.1 案例一：（面试题49）把字符串转换成整数 244 # 7.2 案例二：（面试题50）树中两个结点的最低公共祖先 252 # 第8章 英文版新增面试题 261 # 8.1 数组 261 # 面试题51：数组中重复的数字 261 # 面试题52：构建乘积数组 263 # 8.2 字符串 265 # 面试题53：正则表达式匹配 265 # 面试题54：表示数值的字符串 267 # 面试题55：字符流中第一个不重复的字符 269 # 8.3 链表 270 # 面试题56：链表中环的入口结点 270 # 面试题57：删除链表中重复的结点 273 # 8.4 树 275 # 面试题58：二叉树的下一个结点 275 # 面试题59：对称的二叉树 277 # 面试题60：把二叉树打印成多行 278 # 面试题61：按之字形顺序打印二叉树 280 # 面试题62：序列化二叉树 283 # 面试题63：二叉搜索树的第k个结点 285 # 面试题64：数据流中的中位数 286 # 8.5 栈和队列 290 # 面试题65：滑动窗口的最大值 290 # 8.6 回溯法 294 # 面试题66：矩阵中的路径 294 # 面试题67：机器人的运动范围 296 # "},{"id":74,"href":"/zh/zh/post/books/computer-science/%E5%89%91%E6%8C%87offer/","title":"剑指Offer","section":"Computer Science","content":" 剑指Offer 第1章 面试的流程 1 # 1.1 面试官谈面试 1 # 1.2 面试的三种形式 2 # 1.2.1 电话面试 2 # 1.2.2 共享桌面远程面试 3 # 1.2.3 现场面试 4 # 1.3 面试的三个环节 5 # 1.3.1 行为面试环节 5 # 应聘者的项目经验 6 # 应聘者掌握的技能 7 # 回答“为什么跳槽” 8 # 1.3.2 技术面试环节 10 # 扎实的基础知识 10 # 高质量的代码 11 # 清晰的思路 14 # 优化效率的能力 15 # 优秀的综合能力 16 # 1.3.3 应聘者提问环节 17 # 1.4 本章小结 18 # 第2章 面试需要的基础知识 20 # 2.1 面试官谈基础知识 20 # 2.2 编程语言 22 # 2.2.1 C++ 22 # 面试题1：赋值运算符函数 24 # 经典的解法，适用于初级程序员 25 # 考虑异常安全性的解法，高级程序员必备 26 # 2.2.2 C# 27 # 面试题2：实现Singleton模式 31 # 不好的解法一：只适用于单线程 31 # 不好的解法二：可用于多线程但效率不高 32 # 可行的解法：同步锁前后两次判断 33 # 推荐的解法一：利用静态构造函数 34 # 推荐的解法二：按需创建实例 34 # 解法比较 35 # 2.3 数据结构 36 # 2.3.1 数组 36 # 面试题3：二维数组中的查找 38 # 2.3.2 字符串 42 # 面试题4：替换空格 44 # O(n2)的解法，不足以拿到Offer 45 # O(n)的解法，搞定Offer就靠它 46 # 2.3.3 链表 49 # 面试题5：从尾到头打印链表 51 # 2.3.4 树 53 # 面试题6：重建二叉树 55 # 2.3.5 栈和队列 58 # 面试题7：用两个栈实现队列 59 # 2.4 算法和数据操作 62 # 2.4.1 查找和排序 63 # 面试题8：旋转数组的最小数字 66 # 2.4.2 递归和循环 71 # 面试题9：斐波那契数列 73 # 效率很低的解法，面试官不会喜欢 73 # 面试官期待的实用解法 74 # O(logn)但不够实用的解法 74 # 解法比较 75 # 2.4.3 位运算 77 # 面试题10：二进制中1的个数 78 # 可能引起死循环的解法 79 # 常规解法 79 # 能给面试官带来惊喜的解法 80 # 2.5 本章小结 82 # 第3章 高质量的代码 84 # 3.1 面试官谈代码质量 84 # 3.2 代码的规范性 86 # 3.3 代码的完整性 87 # 从3方面确保代码的完整性 87 # 3种错误处理的方法 88 # 面试题11：数值的整数次方 90 # 自以为题目简单的解法 90 # 全面但不够高效的解法，离Offer已经很近了 90 # 全面又高效的解法，确保能拿到Offer 92 # 面试题12：打印1到最大的n位数 94 # 跳进面试官陷阱 94 # 在字符串上模拟数字加法 94 # 把问题转换成数字排列 97 # 面试题13：在O(1)时间删除链表结点 99 # 面试题14：调整数组顺序使奇数位于偶数前面 102 # 只完成基本功能的解法，仅适用于初级程序员 102 # 考虑可扩展性的解法，能秒杀Offer 104 # 3.4 代码的鲁棒性 106 # 面试题15：链表中倒数第k个结点 107 # 面试题16：反转链表 112 # 面试题17：合并两个排序的链表 114 # 面试题18：树的子结构 117 # 3.5 本章小结 121 # 第4章 解决面试题的思路 123 # 4.1 面试官谈面试思路 123 # 面试题19：二叉树的镜像 125 # 4.2 画图让抽象问题形象化 125 # 面试题20：顺时针打印矩阵 127 # 4.3 举例让抽象问题具体化 131 # 面试题21：包含min函数的栈 132 # 面试题22：栈的压入、弹出序列 134 # 面试题23：从上往下打印二叉树 137 # 面试题24：二叉搜索树的后序遍历序列 140 # 面试题25：二叉树中和为某一值的路径 143 # 4.4 分解让复杂问题简单化 146 # 面试题26：复杂链表的复制 147 # 面试题27：二叉搜索树与双向链表 151 # 面试题28：字符串的排列 154 # 4.5 本章小结 158 # 第5章 优化时间和空间效率 160 # 5.1 面试官谈效率 160 # 5.2 时间效率 162 # 面试题29：数组中出现次数超过一半的数字 163 # 基于Partition函数的O(n)算法 163 # 利用数组特点的O(n)算法 165 # 解法比较 166 # 面试题30：最小的k个数 167 # O(n)的算法，只当可以修改输入数组时可用 167 # O(nlogk)的算法，适合处理海量数据 168 # 解法比较 169 # 面试题31：连续子数组的最大和 171 # 举例分析数组的规律 171 # 应用动态规划法 173 # 面试题32：从1到n整数中1出现的次数 174 # 不考虑效率的解法，想拿Offer有点难 174 # 明显提高效率的解法，让面试官耳目一新 175 # 面试题33：把数组排成最小的数 177 # 5.3 时间效率与空间效率的平衡 181 # 面试题34：丑数 182 # 逐个判断整数是不是丑数的解法 182 # 创建数组保存已经找到的丑数的解法 183 # 面试题35：第一个只出现一次的字符 186 # 面试题36：数组中的逆序对 189 # 面试题37：两个链表的第一个公共结点 193 # 5.4 本章小结 196 # 第6章 面试中的各项能力 198 # 6.1 面试官谈能力 198 # 6.2 沟通能力和学习能力 200 # 沟通能力 200 # 学习能力 200 # 善于学习、沟通的人也善于提问 201 # 6.3 知识迁移能力 203 # 面试题38：数字在排序数组中出现的次数 204 # 面试题39：二叉树的深度 207 # 重复遍历结点的解法，不足以打动面试官 209 # 只遍历结点一次的解法，正是面试官喜欢的 209 # 面试题40：数组中只出现一次的数字 211 # 面试题41：和为s的两个数字VS和为s的连续正数序列 214 # 面试题42：翻转单词顺序 VS左旋转字符串 218 # 6.4 抽象建模能力 222 # 面试题43：n个骰子的点数 223 # 基于递归求骰子点数，时间效率不够高 223 # 基于循环求骰子点数，时间性能好 224 # 面试题44：扑克牌的顺子 226 # 面试题45：圆圈中最后剩下的数字 228 # 经典的解法，用循环链表模拟圆圈 229 # 创新的解法，拿到Offer不在话下 230 # 6.5 发散思维能力 232 # 面试题46：求1+2+…+n 233 # 利用构造函数求解 234 # 利用虚函数求解 234 # 利用函数指针求解 235 # 利用模板类型求解 236 # 面试题47：不用加减乘除做加法 237 # 面试题48：不能被继承的类 239 # 常规的解法：把构造函数设为私有函数 239 # 新奇的解法：利用虚拟继承 240 # 6.6 本章小结 241 # 第7章 两个面试案例 243 # 7.1 案例一：（面试题49）把字符串转换成整数 244 # 7.2 案例二：（面试题50）树中两个结点的最低公共祖先 252 # 第8章 英文版新增面试题 261 # 8.1 数组 261 # 面试题51：数组中重复的数字 261 # 面试题52：构建乘积数组 263 # 8.2 字符串 265 # 面试题53：正则表达式匹配 265 # 面试题54：表示数值的字符串 267 # 面试题55：字符流中第一个不重复的字符 269 # 8.3 链表 270 # 面试题56：链表中环的入口结点 270 # 面试题57：删除链表中重复的结点 273 # 8.4 树 275 # 面试题58：二叉树的下一个结点 275 # 面试题59：对称的二叉树 277 # 面试题60：把二叉树打印成多行 278 # 面试题61：按之字形顺序打印二叉树 280 # 面试题62：序列化二叉树 283 # 面试题63：二叉搜索树的第k个结点 285 # 面试题64：数据流中的中位数 286 # 8.5 栈和队列 290 # 面试题65：滑动窗口的最大值 290 # 8.6 回溯法 294 # 面试题66：矩阵中的路径 294 # 面试题67：机器人的运动范围 296 # "},{"id":75,"href":"/zh/post/books/%E7%BE%8E%E5%9B%BD%E5%9B%B0%E5%B1%80/","title":"美国困局","section":"Books","content":" 美国困局 # 美国困局 导论 从美国内政视角研究美国变局 # 一、缘起 # 二、 理解特朗普和“新右翼”的一些误区 # 三、本书框架 # 第一章 “新右翼”是什么 # 一、政治而非经济：“新右翼”带来的欧美政治议题 # 二、公权与私权：“新右翼”的核心诉求 # 三、西方民粹主义的现实面向 # 第二章“奥巴马选民”vs“特朗普选民”：关键性选举与美国政党选民联盟重组 # 一、变局：“奥巴马选民”联盟浮现 # 二、共和党的两个应对思路 # 三、“特朗普选民”联盟：颠覆性的新议题 # 四、2020年大选：例外的大选与稳固的政党选民联盟 # 五、小结与前瞻 # 第三章 “人权优先”还是“主权优先”？：美国政治中的非法移民议题 # 一、特朗普与民主党的政策逻辑差异 # 二、地域与阶层：白人群体的分裂 # 三、“反常”的亚裔 # 四、拉美裔美国人未必欢迎非法移民老乡 # 五、小结 # 第四章 从“和稀泥”到“旗帜鲜明”：美国政治营销模式变迁 # 一、政治风格：个人特质与外在环境的共同产物 # 二、反非法移民：特朗普vs克鲁兹 # 三、“Love Trumps Hate”：特朗普vs希拉里 # 四、变革时代需要“旗帜鲜明”的政治风格 # 五、“想当总统首先要身体好”：零售政治在美国的复兴 # 第五章 “新右翼”执政方略（一）：特朗普“减税”计划 # 一、经济政策的政治分析 # 二、 为什么富人反对给富人“减税”？ # 三、“减税”计划背后的阶层冲突 # 四、 一个失败的“减税”先例：“茶党” 的堪萨斯实验 # 五、特朗普“减税”计划的配套举措 # 第六章“新右翼”执政方略（二）：其他举措 # 一、能源与气候政策 # 二、产业政策：以威斯康星州富士康项目为例 # 三、贸易政策 # 四、医保改革 # 第七章 从“驯服特朗普”到“被特朗普驯服”：共和党的党内斗争 # 一、从2016年大选至今共和党党内斗争的四个阶段 # 二、失败的“驯服特朗普” # 三、共和党的“特朗普化” # 第八章 民主党的路线之争 # 一、民主党的传统派系格局及其政治主张 # 二、桑德斯与激进派 # 三、激进派崛起与民主党现实政治格局的变化 # 第九章“自由派主张+进步派标签+工人家庭的孩子”：拜登政府的执政策略 # 一、2020年民主党初选与“自由派主张+进步派标签”竞选策略的诞生 # 二、拜登执政后对“自由派主张+进步派标签”策略的进一步运用 # 三、“宾夕法尼亚州工人家庭的孩子”：拜登政府的贸易政策与社会议题 # 后记 # "},{"id":76,"href":"/zh/zh/post/books/%E7%BE%8E%E5%9B%BD%E5%9B%B0%E5%B1%80/","title":"美国困局","section":"Books","content":" 美国困局 # 美国困局 导论 从美国内政视角研究美国变局 # 一、缘起 # 二、 理解特朗普和“新右翼”的一些误区 # 三、本书框架 # 第一章 “新右翼”是什么 # 一、政治而非经济：“新右翼”带来的欧美政治议题 # 二、公权与私权：“新右翼”的核心诉求 # 三、西方民粹主义的现实面向 # 第二章“奥巴马选民”vs“特朗普选民”：关键性选举与美国政党选民联盟重组 # 一、变局：“奥巴马选民”联盟浮现 # 二、共和党的两个应对思路 # 三、“特朗普选民”联盟：颠覆性的新议题 # 四、2020年大选：例外的大选与稳固的政党选民联盟 # 五、小结与前瞻 # 第三章 “人权优先”还是“主权优先”？：美国政治中的非法移民议题 # 一、特朗普与民主党的政策逻辑差异 # 二、地域与阶层：白人群体的分裂 # 三、“反常”的亚裔 # 四、拉美裔美国人未必欢迎非法移民老乡 # 五、小结 # 第四章 从“和稀泥”到“旗帜鲜明”：美国政治营销模式变迁 # 一、政治风格：个人特质与外在环境的共同产物 # 二、反非法移民：特朗普vs克鲁兹 # 三、“Love Trumps Hate”：特朗普vs希拉里 # 四、变革时代需要“旗帜鲜明”的政治风格 # 五、“想当总统首先要身体好”：零售政治在美国的复兴 # 第五章 “新右翼”执政方略（一）：特朗普“减税”计划 # 一、经济政策的政治分析 # 二、 为什么富人反对给富人“减税”？ # 三、“减税”计划背后的阶层冲突 # 四、 一个失败的“减税”先例：“茶党” 的堪萨斯实验 # 五、特朗普“减税”计划的配套举措 # 第六章“新右翼”执政方略（二）：其他举措 # 一、能源与气候政策 # 二、产业政策：以威斯康星州富士康项目为例 # 三、贸易政策 # 四、医保改革 # 第七章 从“驯服特朗普”到“被特朗普驯服”：共和党的党内斗争 # 一、从2016年大选至今共和党党内斗争的四个阶段 # 二、失败的“驯服特朗普” # 三、共和党的“特朗普化” # 第八章 民主党的路线之争 # 一、民主党的传统派系格局及其政治主张 # 二、桑德斯与激进派 # 三、激进派崛起与民主党现实政治格局的变化 # 第九章“自由派主张+进步派标签+工人家庭的孩子”：拜登政府的执政策略 # 一、2020年民主党初选与“自由派主张+进步派标签”竞选策略的诞生 # 二、拜登执政后对“自由派主张+进步派标签”策略的进一步运用 # 三、“宾夕法尼亚州工人家庭的孩子”：拜登政府的贸易政策与社会议题 # 后记 # "},{"id":77,"href":"/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","title":"深入理解Java虚拟机：JVM高级特性与最佳实践","section":"Computer Science","content":" 第1章　走近Java # 1.1　概述 / 2 1.2　Java技术体系 / 3 1.3　Java发展史 / 5 1.4　展望Java技术的未来 / 9 1.4.1　模块化 / 9 1.4.2　混合语言 / 9 1.4.3　多核并行 / 11 1.4.4　进一步丰富语法 / 12 1.4.5　64位虚拟机 / 13 1.5　实战：自己编译JDK / 13 1.5.1　获取JDK源码 / 13 1.5.2　系统需求 / 14 1.5.3　构建编译环境 / 15 1.5.4　准备依赖项 / 17 1.5.5　进行编译 / 18 1.6　本章小结 / 21\n第2章　Java内存区域与内存溢出异常 # Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。\n2.1　概述 # 2.2　运行时数据区域 # 2.2.1　程序计数器 # 程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。 Java虚拟机的概念模型里￼，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。 2.2.2　Java虚拟机栈 # 与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stack)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧￼(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 经常有人把Java内存区域笼统地划分为堆内存(Heap)和栈内存(Stack)，这种划分方式直接继承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区域是“堆”和“栈”两块。其中，“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或者更多的情况下只是指虚拟机栈中局部变量表部分。 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。 在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展￼，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。 2.2.3　本地方法栈 # 本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。 《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。 2.2.4　Java堆 # 对于Java应用程序来说，Java堆(Java Heap)是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。 在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配￼”，而这里笔者写的“几乎”是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换￼优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。 Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。 如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer，TLAB)，以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。 根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。 Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。 2.2.5　方法区 # 方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”(Non-Heap)，目的是与Java堆区分开来。 《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。 2.2.6　运行时常量池 # 运行时常量池(Runtime Constant Pool)是方法区的一部分 Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 2.2.7　直接内存 # 在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 2.3　HotSpot虚拟机对象探秘 # 2.3.1 对象的创建 # 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定将在2.3.2节中介绍），为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。 假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”(Bump The Pointer)。 但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”(Free List)。 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理(Compact)的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除(Sweep)算法的收集器时，理论上￼就只能采用较为复杂的空闲列表来分配内存。 对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。 一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性 另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。 内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。 接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header)之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。new指令之后会接着执行()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。 2.3.2 对象的内存布局 # 在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分： 对象头(Header) 第一类是用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。 对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。 实例数据(Instance Data) HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers，OOPs)，从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。 对齐填充(Padding) 对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。 2.3.3 对象的访问定位 # 如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息 如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。 使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机HotSpot而言，它主要使用第二种方式进行对象访问 2.4　实战：OutOfMemoryError异常 # 2.4.1　Java堆溢出 # Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。 2.4.2　虚拟机栈和本地方法栈溢出 # 2.4.3　方法区和运行时常量池溢出 # 2.4.4　本机直接内存溢出 # 2.5　本章小结 # 第3章　垃圾收集器与内存分配策略 # 3.1　概述 # 哪些内存需要回收？ 什么时候回收？ 如何回收？ 每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。 而Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理 3.2　对象已死？ # 3.2.1　引用计数算法 # 3.2.2　可达性分析算法 # 如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。 在Java技术体系里面，固定可作为GC Roots的对象包括以下几种： 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用。 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。 Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。 所有被同步锁（synchronized关键字）持有的对象。 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。 3.2.3　再谈引用 # 强引用(Strongly Re-ference) 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 软引用(Soft Reference) 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。 弱引用(Weak Reference) 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。 虚引用(Phantom Reference) 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。 3.2.4　生存还是死亡？ # 3.2.5　回收方法区 # 方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。 要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件： 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。 3.3　垃圾收集算法 # 3.3.1　分代收集理论 # 分代假说 1)弱分代假说(Weak Generational Hypothesis)：绝大多数对象都是朝生夕灭的。 2)强分代假说(Strong Generational Hypothesis)：熬过越多次垃圾收集过程的对象就越难以消亡。 3)跨代引用假说(Intergenerational Reference Hypothesis)：跨代引用相对于同代引用来说仅占极少数。 如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。 收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。 如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间 在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分 把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为新生代(Young Generation)和老年代(Old Generation)两个区域 在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。 分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会存在跨代引用。 假如要现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样 新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。 部分收集(Partial GC)：指目标不是完整收集整个Java堆的垃圾收集，其中又分为： 新生代收集(Minor GC/Young GC)：指目标只是新生代的垃圾收集。 老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。 混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。 整堆收集(Full GC)：收集整个Java堆和方法区的垃圾收集。 3.3.2　标记-清除算法 # 3.3.3　标记-复制算法 # 分配担保 3.3.4　标记-整理算法 # 即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。 3.4　HotSpot的算法细节实现 # 3.4.1　根节点枚举 # 迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。 现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行——这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。 3.4.2　安全点 # 有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。 3.4.3　安全区域 # 3.4.4　记忆集与卡表 # 讲解分代收集理论的时候，提到了为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集(Remembered Set)的数据结构，用以避免把整个老年代加进GC Roots扫描范围。 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。 3.4.5　写屏障 # 3.4.6　并发的可达性分析 # 3.5　经典垃圾收集器 3.5.1　Serial收集器 3.5.2　ParNew收集器 92 3.5.3　Parallel Scavenge收集器 93 3.5.4　Serial Old收集器 94 3.5.5　Parallel Old收集器 95 3.5.6　CMS收集器 96 3.5.7　Garbage First收集器 98 3.6　低延迟垃圾收集器 104 3.6.1　Shenandoah收集器 105 3.6.2　ZGC收集器 112 3.7　选择合适的垃圾收集器 121 3.7.1　Epsilon收集器 121 3.7.2　收集器的权衡 121 3.7.3　虚拟机及垃圾收集器日志 122 3.7.4　垃圾收集器参数总结 127 3.8　实战：内存分配与回收策略 129 3.8.1　对象优先在Eden分配 130 3.8.2　大对象直接进入老年代 131 3.8.3　长期存活的对象将进入老年代 132 3.8.4　动态对象年龄判定 134 3.8.5　空间分配担保 135 3.9　本章小结 137\n第4章　虚拟机性能监控、故障处理工具 # 4.1　概述 138 4.2　基础故障处理工具 138 4.2.1　jps：虚拟机进程状况工具 141 4.2.2　jstat：虚拟机统计信息监视工具 142 4.2.3　jinfo：Java配置信息工具 143 4.2.4　jmap：Java内存映像工具 144 4.2.5　jhat：虚拟机堆转储快照分析工具 145 4.2.6　jstack：Java堆栈跟踪工具 146 4.2.7　基础工具总结 148 4.3　可视化故障处理工具 151 4.3.1　JHSDB：基于服务性代理的调试工具 152 4.3.2　JConsole：Java监视与管理控制台 157 4.3.3　VisualVM：多合-故障处理工具 164 4.3.4　Java Mission Control：可持续在线的监控工具 171 4.4　HotSpot虚拟机插件及工具 175 4.5　本章小结 180\n第5章　调优案例分析与实战 # 5.1　概述 181 5.2　案例分析 181 5.2.1　大内存硬件上的程序部署策略 182 5.2.2　集群间同步导致的内存溢出 184 5.2.3　堆外内存导致的溢出错误 185 5.2.4　外部命令导致系统缓慢 187 5.2.5　服务器虚拟机进程崩溃 187 5.2.6　不恰当数据结构导致内存占用过大 188 5.2.7　由Windows虚拟内存导致的长时间停顿 189 5.2.8　由安全点导致长时间停顿 190 5.3　实战：Eclipse运行速度调优 192 5.3.1　调优前的程序运行状态 193 5.3.2　升级JDK版本的性能变化及兼容问题 196 5.3.3　编译时间和类加载时间的优化 200 5.3.4　调整内存设置控制垃圾收集频率 203 5.3.5　选择收集器降低延迟 206 5.4　本章小结 209 第三部分　虚拟机执行子系统\n第6章　类文件结构 # 6.1　概述 212 6.2　无关性的基石 212 6.3　Class类文件的结构 214 6.3.1　魔数与Class文件的版本 215 6.3.2　常量池 218 6.3.3　访问标志 224 6.3.4　类索引、父类索引与接口索引集合 225 6.3.5　字段表集合 226 6.3.6　方法表集合 229 6.3.7　属性表集合 230 6.4　字节码指令简介 251 6.4.1　字节码与数据类型 251 6.4.2　加载和存储指令 253 6.4.3　运算指令 254 6.4.4　类型转换指令 255 6.4.5　对象创建与访问指令 256 6.4.6　操作数栈管理指令 256 6.4.7　控制转移指令 257 6.4.8　方法调用和返回指令 257 6.4.9　异常处理指令 258 6.4.10　同步指令 258 6.5　公有设计，私有实现 259 6.6　Class文件结构的发展 260 6.7　本章小结 261\n第7章　虚拟机类加载机制 # 7.1　概述 262 7.2　类加载的时机 263 7.3　类加载的过程 267 7.3.1　加载 267 7.3.2　验证 268 7.3.3　准备 271 7.3.4　解析 272 7.3.5　初始化 277 7.4　类加载器 279 7.4.1　类与类加载器 280 7.4.2　双亲委派模型 281 7.4.3　破坏双亲委派模型 285 7.5　Java模块化系统 287 7.5.1　模块的兼容性 288 7.5.2　模块化下的类加载器 290 7.6　本章小结 292\n第8章　虚拟机字节码执行引擎 # 8.1　概述 293 8.2　运行时栈帧结构 294 8.2.1　局部变量表 294 8.2.2　操作数栈 299 8.2.3　动态连接 300 8.2.4　方法返回地址 300 8.2.5　附加信息 301 8.3　方法调用 301 8.3.1　解析 301 8.3.2　分派 303 8.4　动态类型语言支持 315 8.4.1　动态类型语言 316 8.4.2　Java与动态类型 317 8.4.3　java.lang.invoke包 318 8.4.4　invokedynamic指令 321 8.4.5　实战：掌控方法分派规则 324 8.5　基于栈的字节码解释执行引擎 326 8.5.1　解释执行 327 8.5.2　基于栈的指令集与基于寄存器的指令集 328 8.5.3　基于栈的解释器执行过程 329 8.6　本章小结 334\n第9章　类加载及执行子系统的案例与实战 # 9.1　概述 335 9.2　案例分析 335 9.2.1　Tomcat：正统的类加载器架构 335 9.2.2　OSGi：灵活的类加载器架构 338 9.2.3　字节码生成技术与动态代理的实现 341 9.2.4　Backport工具：Java的时光机器 345 9.3　实战：自己动手实现远程执行功能 348 9.3.1　目标 348 9.3.2　思路 349 9.3.3　实现 350 9.3.4　验证 355 9.4　本章小结 356\n第10章　前端编译与优化 # 10.1　概述 358 10.2　Javac编译器 359 10.2.1　Javac的源码与调试 359 10.2.2　解析与填充符号表 362 10.2.3　注解处理器 363 10.2.4　语义分析与字节码生成 364 10.3　Java语法糖的味道 367 10.3.1　泛型 367 10.3.2　自动装箱、拆箱与遍历循环 375 10.3.3　条件编译 377 10.4　实战：插入式注解处理器 378 10.4.1　实战目标 379 10.4.2　代码实现 379 10.4.3　运行与测试 385 10.4.4　其他应用案例 386 10.5　本章小结 386\n第11章　后端编译与优化 # 11.1　概述 388 11.2　即时编译器 389 11.2.1　解释器与编译器 389 11.2.2　编译对象与触发条件 392 11.2.3　编译过程 397 11.2.4　实战：查看及分析即时编译结果 398 11.3　提前编译器 404 11.3.1　提前编译的优劣得失 405 11.3.2　实战：Jaotc的提前编译 408 11.4　编译器优化技术 411 11.4.1　优化技术概览 411 11.4.2　方法内联 415 11.4.3　逃逸分析 417 11.4.4　公共子表达式消除 420 11.4.5　数组边界检查消除 421 11.5　实战：深入理解Graal编译器 423 11.5.1　历史背景 423 11.5.2　构建编译调试环境 424 11.5.3　JVMCI编译器接口 426 11.5.4　代码中间表示 429 11.5.5　代码优化与生成 432 11.6　本章小结 436\n第12章　Java内存模型与线程 # 12.1　概述 438 12.2　硬件的效率与一致性 439 12.3　Java内存模型 440 12.3.1　主内存与工作内存 441 12.3.2　内存间交互操作 442 12.3.3　对于volatile型变量的特殊规则 444 12.3.4　针对long和double型变量的特殊规则 450 12.3.5　原子性、可见性与有序性 450 12.3.6　先行发生原则 452 12.4　Java与线程 455 12.4.1　线程的实现 455 12.4.2　Java线程调度 458 12.4.3　状态转换 460 12.5　Java与协程 461 12.5.1　内核线程的局限 461 12.5.2　协程的复苏 462 12.5.3　Java的解决方案 464 12.6　本章小结 465\n第13章　线程安全与锁优化 # 13.1　概述 466 13.2　线程安全 466 13.2.1　Java语言中的线程安全 467 13.2.2　线程安全的实现方法 471 13.3　锁优化 479 13.3.1　自旋锁与自适应自旋 479 13.3.2　锁消除 480 13.3.3　锁粗化 481 13.3.4　轻量级锁 481 13.3.5　偏向锁 483 13.4　本章小结 485 附录A　在Windows系统下编译OpenJDK 6 486 附录B　展望Java技术的未来（2013年版） 493 附录C　虚拟机字节码指令表 499 附录D　对象查询语言（OQL）简介 506 附录E　JDK历史版本轨迹 512\n"},{"id":78,"href":"/zh/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","title":"深入理解Java虚拟机：JVM高级特性与最佳实践","section":"Computer Science","content":" 第1章　走近Java # 1.1　概述 / 2 1.2　Java技术体系 / 3 1.3　Java发展史 / 5 1.4　展望Java技术的未来 / 9 1.4.1　模块化 / 9 1.4.2　混合语言 / 9 1.4.3　多核并行 / 11 1.4.4　进一步丰富语法 / 12 1.4.5　64位虚拟机 / 13 1.5　实战：自己编译JDK / 13 1.5.1　获取JDK源码 / 13 1.5.2　系统需求 / 14 1.5.3　构建编译环境 / 15 1.5.4　准备依赖项 / 17 1.5.5　进行编译 / 18 1.6　本章小结 / 21\n第2章　Java内存区域与内存溢出异常 # Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。\n2.1　概述 # 2.2　运行时数据区域 # 2.2.1　程序计数器 # 程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。 Java虚拟机的概念模型里￼，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。 2.2.2　Java虚拟机栈 # 与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stack)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧￼(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 经常有人把Java内存区域笼统地划分为堆内存(Heap)和栈内存(Stack)，这种划分方式直接继承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区域是“堆”和“栈”两块。其中，“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或者更多的情况下只是指虚拟机栈中局部变量表部分。 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。 在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展￼，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。 2.2.3　本地方法栈 # 本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。 《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。 2.2.4　Java堆 # 对于Java应用程序来说，Java堆(Java Heap)是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。 在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配￼”，而这里笔者写的“几乎”是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换￼优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。 Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。 如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer，TLAB)，以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。 根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。 Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。 2.2.5　方法区 # 方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”(Non-Heap)，目的是与Java堆区分开来。 《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。 2.2.6　运行时常量池 # 运行时常量池(Runtime Constant Pool)是方法区的一部分 Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 2.2.7　直接内存 # 在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 2.3　HotSpot虚拟机对象探秘 # 2.3.1 对象的创建 # 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定将在2.3.2节中介绍），为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。 假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”(Bump The Pointer)。 但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”(Free List)。 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理(Compact)的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除(Sweep)算法的收集器时，理论上￼就只能采用较为复杂的空闲列表来分配内存。 对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。 一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性 另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。 内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。 接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header)之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。new指令之后会接着执行()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。 2.3.2 对象的内存布局 # 在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分： 对象头(Header) 第一类是用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。 对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。 实例数据(Instance Data) HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers，OOPs)，从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。 对齐填充(Padding) 对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。 2.3.3 对象的访问定位 # 如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息 如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。 使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机HotSpot而言，它主要使用第二种方式进行对象访问 2.4　实战：OutOfMemoryError异常 # 2.4.1　Java堆溢出 # Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。 2.4.2　虚拟机栈和本地方法栈溢出 # 2.4.3　方法区和运行时常量池溢出 # 2.4.4　本机直接内存溢出 # 2.5　本章小结 # 第3章　垃圾收集器与内存分配策略 # 3.1　概述 # 哪些内存需要回收？ 什么时候回收？ 如何回收？ 每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。 而Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理 3.2　对象已死？ # 3.2.1　引用计数算法 # 3.2.2　可达性分析算法 # 如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。 在Java技术体系里面，固定可作为GC Roots的对象包括以下几种： 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用。 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。 Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。 所有被同步锁（synchronized关键字）持有的对象。 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。 3.2.3　再谈引用 # 强引用(Strongly Re-ference) 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 软引用(Soft Reference) 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。 弱引用(Weak Reference) 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。 虚引用(Phantom Reference) 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。 3.2.4　生存还是死亡？ # 3.2.5　回收方法区 # 方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。 要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件： 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。 3.3　垃圾收集算法 # 3.3.1　分代收集理论 # 分代假说 1)弱分代假说(Weak Generational Hypothesis)：绝大多数对象都是朝生夕灭的。 2)强分代假说(Strong Generational Hypothesis)：熬过越多次垃圾收集过程的对象就越难以消亡。 3)跨代引用假说(Intergenerational Reference Hypothesis)：跨代引用相对于同代引用来说仅占极少数。 如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。 收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。 如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间 在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分 把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为新生代(Young Generation)和老年代(Old Generation)两个区域 在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。 分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会存在跨代引用。 假如要现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样 新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。 部分收集(Partial GC)：指目标不是完整收集整个Java堆的垃圾收集，其中又分为： 新生代收集(Minor GC/Young GC)：指目标只是新生代的垃圾收集。 老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。 混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。 整堆收集(Full GC)：收集整个Java堆和方法区的垃圾收集。 3.3.2　标记-清除算法 # 3.3.3　标记-复制算法 # 分配担保 3.3.4　标记-整理算法 # 即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。 3.4　HotSpot的算法细节实现 # 3.4.1　根节点枚举 # 迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。 现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行——这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。 3.4.2　安全点 # 有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。 3.4.3　安全区域 # 3.4.4　记忆集与卡表 # 讲解分代收集理论的时候，提到了为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集(Remembered Set)的数据结构，用以避免把整个老年代加进GC Roots扫描范围。 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。 3.4.5　写屏障 # 3.4.6　并发的可达性分析 # 3.5　经典垃圾收集器 3.5.1　Serial收集器 3.5.2　ParNew收集器 92 3.5.3　Parallel Scavenge收集器 93 3.5.4　Serial Old收集器 94 3.5.5　Parallel Old收集器 95 3.5.6　CMS收集器 96 3.5.7　Garbage First收集器 98 3.6　低延迟垃圾收集器 104 3.6.1　Shenandoah收集器 105 3.6.2　ZGC收集器 112 3.7　选择合适的垃圾收集器 121 3.7.1　Epsilon收集器 121 3.7.2　收集器的权衡 121 3.7.3　虚拟机及垃圾收集器日志 122 3.7.4　垃圾收集器参数总结 127 3.8　实战：内存分配与回收策略 129 3.8.1　对象优先在Eden分配 130 3.8.2　大对象直接进入老年代 131 3.8.3　长期存活的对象将进入老年代 132 3.8.4　动态对象年龄判定 134 3.8.5　空间分配担保 135 3.9　本章小结 137\n第4章　虚拟机性能监控、故障处理工具 # 4.1　概述 138 4.2　基础故障处理工具 138 4.2.1　jps：虚拟机进程状况工具 141 4.2.2　jstat：虚拟机统计信息监视工具 142 4.2.3　jinfo：Java配置信息工具 143 4.2.4　jmap：Java内存映像工具 144 4.2.5　jhat：虚拟机堆转储快照分析工具 145 4.2.6　jstack：Java堆栈跟踪工具 146 4.2.7　基础工具总结 148 4.3　可视化故障处理工具 151 4.3.1　JHSDB：基于服务性代理的调试工具 152 4.3.2　JConsole：Java监视与管理控制台 157 4.3.3　VisualVM：多合-故障处理工具 164 4.3.4　Java Mission Control：可持续在线的监控工具 171 4.4　HotSpot虚拟机插件及工具 175 4.5　本章小结 180\n第5章　调优案例分析与实战 # 5.1　概述 181 5.2　案例分析 181 5.2.1　大内存硬件上的程序部署策略 182 5.2.2　集群间同步导致的内存溢出 184 5.2.3　堆外内存导致的溢出错误 185 5.2.4　外部命令导致系统缓慢 187 5.2.5　服务器虚拟机进程崩溃 187 5.2.6　不恰当数据结构导致内存占用过大 188 5.2.7　由Windows虚拟内存导致的长时间停顿 189 5.2.8　由安全点导致长时间停顿 190 5.3　实战：Eclipse运行速度调优 192 5.3.1　调优前的程序运行状态 193 5.3.2　升级JDK版本的性能变化及兼容问题 196 5.3.3　编译时间和类加载时间的优化 200 5.3.4　调整内存设置控制垃圾收集频率 203 5.3.5　选择收集器降低延迟 206 5.4　本章小结 209 第三部分　虚拟机执行子系统\n第6章　类文件结构 # 6.1　概述 212 6.2　无关性的基石 212 6.3　Class类文件的结构 214 6.3.1　魔数与Class文件的版本 215 6.3.2　常量池 218 6.3.3　访问标志 224 6.3.4　类索引、父类索引与接口索引集合 225 6.3.5　字段表集合 226 6.3.6　方法表集合 229 6.3.7　属性表集合 230 6.4　字节码指令简介 251 6.4.1　字节码与数据类型 251 6.4.2　加载和存储指令 253 6.4.3　运算指令 254 6.4.4　类型转换指令 255 6.4.5　对象创建与访问指令 256 6.4.6　操作数栈管理指令 256 6.4.7　控制转移指令 257 6.4.8　方法调用和返回指令 257 6.4.9　异常处理指令 258 6.4.10　同步指令 258 6.5　公有设计，私有实现 259 6.6　Class文件结构的发展 260 6.7　本章小结 261\n第7章　虚拟机类加载机制 # 7.1　概述 262 7.2　类加载的时机 263 7.3　类加载的过程 267 7.3.1　加载 267 7.3.2　验证 268 7.3.3　准备 271 7.3.4　解析 272 7.3.5　初始化 277 7.4　类加载器 279 7.4.1　类与类加载器 280 7.4.2　双亲委派模型 281 7.4.3　破坏双亲委派模型 285 7.5　Java模块化系统 287 7.5.1　模块的兼容性 288 7.5.2　模块化下的类加载器 290 7.6　本章小结 292\n第8章　虚拟机字节码执行引擎 # 8.1　概述 293 8.2　运行时栈帧结构 294 8.2.1　局部变量表 294 8.2.2　操作数栈 299 8.2.3　动态连接 300 8.2.4　方法返回地址 300 8.2.5　附加信息 301 8.3　方法调用 301 8.3.1　解析 301 8.3.2　分派 303 8.4　动态类型语言支持 315 8.4.1　动态类型语言 316 8.4.2　Java与动态类型 317 8.4.3　java.lang.invoke包 318 8.4.4　invokedynamic指令 321 8.4.5　实战：掌控方法分派规则 324 8.5　基于栈的字节码解释执行引擎 326 8.5.1　解释执行 327 8.5.2　基于栈的指令集与基于寄存器的指令集 328 8.5.3　基于栈的解释器执行过程 329 8.6　本章小结 334\n第9章　类加载及执行子系统的案例与实战 # 9.1　概述 335 9.2　案例分析 335 9.2.1　Tomcat：正统的类加载器架构 335 9.2.2　OSGi：灵活的类加载器架构 338 9.2.3　字节码生成技术与动态代理的实现 341 9.2.4　Backport工具：Java的时光机器 345 9.3　实战：自己动手实现远程执行功能 348 9.3.1　目标 348 9.3.2　思路 349 9.3.3　实现 350 9.3.4　验证 355 9.4　本章小结 356\n第10章　前端编译与优化 # 10.1　概述 358 10.2　Javac编译器 359 10.2.1　Javac的源码与调试 359 10.2.2　解析与填充符号表 362 10.2.3　注解处理器 363 10.2.4　语义分析与字节码生成 364 10.3　Java语法糖的味道 367 10.3.1　泛型 367 10.3.2　自动装箱、拆箱与遍历循环 375 10.3.3　条件编译 377 10.4　实战：插入式注解处理器 378 10.4.1　实战目标 379 10.4.2　代码实现 379 10.4.3　运行与测试 385 10.4.4　其他应用案例 386 10.5　本章小结 386\n第11章　后端编译与优化 # 11.1　概述 388 11.2　即时编译器 389 11.2.1　解释器与编译器 389 11.2.2　编译对象与触发条件 392 11.2.3　编译过程 397 11.2.4　实战：查看及分析即时编译结果 398 11.3　提前编译器 404 11.3.1　提前编译的优劣得失 405 11.3.2　实战：Jaotc的提前编译 408 11.4　编译器优化技术 411 11.4.1　优化技术概览 411 11.4.2　方法内联 415 11.4.3　逃逸分析 417 11.4.4　公共子表达式消除 420 11.4.5　数组边界检查消除 421 11.5　实战：深入理解Graal编译器 423 11.5.1　历史背景 423 11.5.2　构建编译调试环境 424 11.5.3　JVMCI编译器接口 426 11.5.4　代码中间表示 429 11.5.5　代码优化与生成 432 11.6　本章小结 436\n第12章　Java内存模型与线程 # 12.1　概述 438 12.2　硬件的效率与一致性 439 12.3　Java内存模型 440 12.3.1　主内存与工作内存 441 12.3.2　内存间交互操作 442 12.3.3　对于volatile型变量的特殊规则 444 12.3.4　针对long和double型变量的特殊规则 450 12.3.5　原子性、可见性与有序性 450 12.3.6　先行发生原则 452 12.4　Java与线程 455 12.4.1　线程的实现 455 12.4.2　Java线程调度 458 12.4.3　状态转换 460 12.5　Java与协程 461 12.5.1　内核线程的局限 461 12.5.2　协程的复苏 462 12.5.3　Java的解决方案 464 12.6　本章小结 465\n第13章　线程安全与锁优化 # 13.1　概述 466 13.2　线程安全 466 13.2.1　Java语言中的线程安全 467 13.2.2　线程安全的实现方法 471 13.3　锁优化 479 13.3.1　自旋锁与自适应自旋 479 13.3.2　锁消除 480 13.3.3　锁粗化 481 13.3.4　轻量级锁 481 13.3.5　偏向锁 483 13.4　本章小结 485 附录A　在Windows系统下编译OpenJDK 6 486 附录B　展望Java技术的未来（2013年版） 493 附录C　虚拟机字节码指令表 499 附录D　对象查询语言（OQL）简介 506 附录E　JDK历史版本轨迹 512\n"},{"id":79,"href":"/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/","title":"深入浅出HTTPS：从原理到实战","section":"Computer Science","content":" 2015年百度搜索引擎完成其历史上最大的系统性升级——全面由HTTP升级到HTTPS 2016年苹果公告要求App Store中的所有应用在2017年1月1日之后都必须使用HTTPS加密连接 2017年1月9日微信上线小程序后，要求开发者的所有服务端请求必须为HTTPS 同时Google已调整搜索引擎算法，让采用HTTPS的网站在搜索结果中排名更靠前，并宣布从2018年7月开始所有的HTTP网站将标记为“不安全” 第1章 HTTP介绍 # HTTP的特点 客户端/服务器模型 客户端和服务器是否正确传输依赖于TCP这个协议。 HTTP是无状态的 所谓的无状态就是每次请求完成后，不会在客户端和服务器上保存任何的信息，对于客户端和服务器来说，根本不知道上一次请求的信息是什么，甚至不知道本次连接的对端是不是上次连接的那一端，它的生命周期随着TCP/IP连接的关闭结束了 无状态的设计已经不能适应新的情况，为了保持状态，出现了Cookie和Session技术，但是Cookie技术设计得非常不严谨，引发了很多安全问题。 介绍下Cookie是如何进行会话保持的，客户端第一次请求完成后，服务器会发送Cookie信息到客户端的计算机上，客户端下次请求的时候会携带该Cookie信息，这样服务器就知道该用户就是上一次请求的用户了。 HTTP是跨平台的 通过上面的讲解，读者知道HTTP就是具备一定规则的纯文本信息，任何开发语言都可以实现HTTP或者基于HTTP进行开发，开发出来的软件也很容易移植，受系统环境的影响非常少。 HTTP用途很广泛 1.3 网络模型 # HTTP是应用层协议，应用层协议是TCP/IP的一部分 OSI模型是一个通用的网络协议标准，但实际使用的标准却是TCP/IP标准，TCP/IP包含的不仅仅是TCP或者IP，它是一个协议族，网络应用开发都需要掌握TCP/IP。 TCP/IP有两个最大的特点，分别是分层和封包/拆包机制 每一层和它的上下层都有标准的接口规范，每一层无须关心上下层是如何工作的，它只关心上下层是否正确基于规范实现了接口 应用层 如果没有应用层，那么网络中传输的数据没有任何意义，因为人类无法理解数据的含义。而有了应用层，软件就能解释应用层数据的含义。在Web应用中，有了HTTP和HTML标准，浏览器才能呈现对用户有意义的内容。 应用层协议有很多，比如HTTP、FTP、邮件协议，开发者开发的软件一般都是应用层协议软件。 传输层 网络层 网络层主要是IP这个协议，客户端和服务器传输的时候，会经过很多节点，IP就是选择一条最优的路径。每个终端上都有一张路由表，路由表负责将数据传输到下一个节点，下一个节点再传输到下下个节点，最终到达目的地址。 链路层 应用层、传输层、网络层都是虚拟的，只有链路层才是实体设备，包括光纤、网卡等设备。基于这些设备，数据最终才能到达终端。 接下来简单描述封包/拆包机制，对于客户端请求来说，传输层接收到应用层消息后，在HTTP数据包前面增加TCP包头，然后发送给网络层；网络层在TCP数据包前面加上IP包头发送给链路层；链路层在IP数据包前面加上以太网包头；最终服务器接收到完整的数据包。 然后服务器进行拆包：首先在网络层去除链路层包头；在传输层去除IP包头；在应用层去除TCP包头；最终得到完整的HTTP应用层数据。 1.4 协议安全分析 # 协议不安全的根本原因 数据没有加密 无法验证身份 数据易篡改 第2章 密码学 # 2.1 对于密码学的认知 # OpenSSL OpenSSL命令行功能非常强大，有很多的子命令和参数，如果不理解密码学算法，根本无法理解子命令和参数的含义，这是难学习的根本原因，也说明学习OpenSSL之前必须先掌握密码学算法。 不同版本的OpenSSL命令行工具在使用的时候有一些差别，同样一条命令，读者会发现在特定版本下可能无法正确运行。 OpenSSL命令行的帮助手册和文档描写得不是很通俗，很难进行系统的学习。 完成同样一个操作，OpenSSL命令行有许多方法实现，这可能会干扰读者的学习。 2.2 随机数 # 而对于PRNG来说，内部状态的数值来自于模拟的数值，称为种子（seed）。随机数生成器每次生成随机数的时候，内部状态的值都会变化，这样才能产生不一样的随机数，如果每次熵和种子是一样的，生成的随机数也是相同的，所以熵和种子对于随机数生成器非常重要。 2.2.1 随机数的类型 # 真正的随机数生成器 需要从物理设备获取 伪随机数生成器 通过算法获取 密码学伪随机数生成器 用于密码学 随机数的特性 效率 随机性 不可预测性 不可重现性 2.2.2 随机数的工作原理 # 2.2.3 常见的随机数生成器 # 2.2.4 密码学算法中的随机数 # 2.3 Hash算法 # 2.3.1 加密基元 # 加密基元就是一些基础的密码学算法，通过它们才能够构建更多的密码学算法、协议、应用程序 2.3.2 Hash算法和密码学Hash算法 # 2.3.3 密码学Hash算法的特性 # 由于Hash算法有很多功能，所以Hash算法有多种称呼，比如摘要算法（Message Digest Algorithms）、单向散列函数（Cryptographic One-way Hash Functions）。输出值也有多种称呼，比如摘要值、散列、指纹。读者看到这些名词的时候，都可以理解为Hash算法 密码学Hash算法的主要特性 相同的消息总是能得到同样的摘要值，特定的Hash算法，不管消息长度是多少，最终的摘要值长度是相同的。 不管多长的消息，Hash运算非常快速，这是非常重要的特性。 通过摘要值很难逆向计算出原始消息，Hash算法具备单向性，摘要值是不可逆的，这也是非常重要的特性。为了逆向计算出原始消息，唯一的方法就是采用暴力攻击、字典攻击、彩虹表，对不同的消息组合进行迭代运算，运算的结果如果匹配该消息的摘要值，表示该Hash算法不应该用于密码学。 原始消息一旦修改，即使是很轻微的修改，最终的摘要值也会产生变化。 很难找出两个不同的消息，并且它们的摘要值是相同的。 2.3.4 Hash算法的用途 # 文件比较 身份校验 2.3.5 什么是安全的密码学Hash算法 # 强抗碰撞性（Collision Resistance） 弱抗碰撞性（Second pre-image Resistance） 单向性（Pre-image Resistance） 2.3.6 密码学Hash算法的分类 # MD5 MD5是一种比较常用的Hash算法，摘要值长度固定是128比特，MD5算法目前被证明已经不安全了，MD5算法违反了强抗碰撞性原则，但是还没有破坏单一性原则。 理论上经过2^80次运算就能产生碰撞，但目前最快只要经过2^63次运算就能破坏强抗碰撞性。 SHA SHA（Secure Hash Algorithms）算法是美国国家标准与技术研究院（NIST）指定的算法，SHA算法不是一个算法，而是一组算法，主要分为三类算法。 SHA-1 SHA-2 SHA-3 2.4 对称加密算法 # 建议使用AES算法，该算法是对称加密算法的标准算法 美国国家标准与技术研究院（National Institute of Standards and Technology, NIST）对众多的对称加密算法进行了考核，从安全性和效率进行了多方面评测，最终选取Rijndael算法作为对称加密算法的标准。以Rijndael算法为原型，创建了AES（Advanced Encryption Standard）算法，AES就是最终的对称加密算法标准。Rijndael算法和AES算法略微不同，但在理解的时候可以认为是相同的算法。 流密码算法 块密码算法 迭代模式 **ECB模式（Electronic Codebook）**是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。 ECB模式（Electronic Codebook）是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。 **CBC模式（Cipher Block Chaining）**是比较常见的一种迭代模式，解决了ECB模式的安全问题。 迭代运算数据块不能并行处理，只有处理完第n个数据块，才能继续处理第n+1个数据块。 **CTR模式（counter）**在迭代的时候，相当于是一个流密码的运行模式。每次迭代运算的时候要生成一个密钥流（keystream），生成密钥流的方法可以是任意的，但是各个密钥流之间是有关系的，最简单的方式就是密钥流不断递增，所以才叫作计数器模式。 2.4.1 流密码算法 # 2.4.2 块密码算法 # 2.4.3 填充标准 # 2.4.4 对称加密算法实践 # 2.5 消息验证码 # MAC值一般和原始消息一起传输，原始消息可以选择加密，也可以选择不加密，通信双方会以相同的方式生成MAC值，然后进行比较 CBC-MAC算法 HMAC算法 Hash-based Message Authentication Code 加密算法不能提供完整性，加密的同时必须引入MAC算法避免消息被篡改 使用者结合对称加密算法和MAC算法，提供机密性和完整性的模式也叫作Authenticated Encryption（AE）加密模式，主要有三种 Encrypt-and-MAC (E\u0026amp;M) MAC-then-Encrypt (MtE) 这种模式（图2-12）先对消息进行MAC计算，然后将消息和MAC值组合在一起再进行加密，最终的加密值再发送给接收方。在HTTPS中，一般使用这种模式进行处理，比如AES-128-CBC#PKCS7-HMAC-SHA256模式。 Encrypt-then-MAC (EtM) 不管是Encrypt-and-MAC模式还是MAC-then-Encrypt模式，使用不当的话都会存在安全问题，目前建议使用Encrypt-then-MAC模式。需要强调的是，这三种模式使用者必须分别处理，一旦处理不当，就可能会存在安全风险，那有没有一种方法在底层直接提供加密和MAC运算呢？无须使用者分别处理加密和MAC运算，这就是接下来讲解的AEAD模式。 AEAD加密模式 CCM模式 GCM模式 ChaCha20-Poly1305 2.5.1 什么是消息验证码 # 在密码学应用中，很多情况下，传递的消息没有必要加密，只要确保消息是完整且没有被篡改即可 比如开发者开发了一组天气API，接口返回的数据并没有加密，原因可能如下 接口的数据并不重要，对隐私性要求不高 加密和解密过程很消耗性能 所以接口的设计目标仅仅是避免消息被篡改，读者可能说那很简单啊，接口消息通过Hash算法得到一个摘要值，摘要值和接口消息同时作为接口内容返回不就解决问题了吗？ 攻击者对消息进行拦截，同时修改接口消息和消息的摘要值然后发送给接收方，接收方收到消息后，对接口消息计算摘要值，然后与接收到的摘要值进行比较，如果相同，接收方认为消息是完整的。可实际呢？消息虽然是完整的，但被篡改了，或者说消息被伪装了，但对于接收方来说，仅仅通过摘要值无法验证消息是不是篡改了 消息验证码算法的特点 证明消息没有被篡改，这和Hash算法类似。 消息是正确的发送者发送的，也就是说消息是经过验证的 如何确保消息是特定人发送的呢？在通信双方可以维护同一个密钥，只有拥有密钥的通信双方才能生成和验证消息验证码，消息验证码算法需要一个密钥，这和对称加密算法是一样的，通信双方在消息传递之前需要获得同样的密钥。 2.5.2 MAC 算法的种类 # CBC-MAC算法 CBC-MAC算法从块密码算法的CBC分组模式演变而来，简单地说就是最后一个密文分组的值就是MAC值 HMAC算法 在HTTP中应用最多的MAC算法是HMAC算法 HMAC（Hash-based Message Authentication Code）算法使用Hash算法作为加密基元，HMAC结合Hash算法有多种变种，比如HMAC-SHA-1、HMAC-SHA256、HMAC-SHA512 读者不要误以为HMAC算法就是Hash算法加上一个密钥，HMAC算法只是基于Hash算法的，内部的实现还是相当复杂的 2.5.3 消息验证码算法实践 # 2.5.4 加密算法不能提供完整性 # 完整性的意思是消息没有被篡改，仅仅加密数据是无法保证数据完整性的，初听起来可能觉得很奇怪。攻击者如果没有密钥就无法破解原文，也就无法篡改，数据必然是完整的。遗憾的是攻击者虽然无法破解数据，但是可以修改密文的部分数据，然后发送给接收者，接收者通过密钥发现能够解密，但是解密出来的值实际上不是原文，消息已经被修改了，也就是说加密操作不能提供完整性。 hash算法可以作为消息验证码吗？ # 是的，哈希算法可以作为消息验证码（MAC）的一部分，但单独使用哈希算法并不能直接构成消息验证码。消息验证码（MAC）是一种用于验证消息完整性和真实性的技术，通常需要结合密钥来确保安全性。\n哈希算法与MAC的区别\n哈希算法：如SHA-256、MD5等，用于生成固定长度的哈希值，确保数据完整性，但不涉及密钥，无法防止篡改。 消息验证码（MAC）：结合哈希算法和密钥，生成一个与消息和密钥相关的验证码，确保消息未被篡改且来自可信来源。 使用哈希算法构建MAC\n常见的方法是HMAC（Hash-based Message Authentication Code），它通过以下步骤生成MAC：\n将密钥与一个固定值（如ipad）异或，生成k_ipad。 将k_ipad与消息拼接，计算哈希值。 将密钥与另一个固定值（如opad）异或，生成k_opad。 将k_opad与步骤2的哈希值拼接，再次计算哈希值，得到最终的MAC。 示例\n假设使用SHA-256和密钥key，消息为message，HMAC生成过程如下：\n生成k_ipad和k_opad。 计算hash(k_ipad + message)。 计算hash(k_opad + hash(k_ipad + message))，得到MAC。 总结\n哈希算法可以作为MAC的基础，但单独使用无法提供完整的安全性。HMAC等结合密钥的方法才能确保消息的完整性和真实性。\n接收方怎么验证消息验证码？ # 接收方验证消息验证码（MAC）的过程需要确保消息的完整性和真实性。以下是验证步骤的详细说明：\n验证过程\n接收消息和MAC：\n接收方从发送方获取消息（明文）和对应的MAC值。 重新计算MAC：\n接收方使用与发送方相同的密钥和哈希算法（如HMAC-SHA256），对接收到的消息重新计算MAC值。 比较MAC值：\n将接收方计算出的MAC值与发送方提供的MAC值进行比较。 如果两者一致，说明消息未被篡改且来自可信来源。 如果不一致，说明消息可能被篡改或来源不可信。 具体步骤示例\n假设使用HMAC-SHA256算法，密钥为key，消息为message，发送方提供的MAC值为received_mac。\n接收方重新计算MAC：\n使用HMAC-SHA256算法，输入密钥key和消息message，计算出新的MAC值，记为computed_mac。 比较MAC值：\n比较computed_mac和received_mac： 如果computed_mac == received_mac，验证通过。 如果computed_mac != received_mac，验证失败。 注意事项\n密钥的安全性：\n密钥必须通过安全渠道共享，且只有发送方和接收方知道。如果密钥泄露，攻击者可以伪造MAC。 哈希算法的选择：\n使用安全的哈希算法（如SHA-256、SHA-3），避免使用已被破解的算法（如MD5、SHA-1）。 防止重放攻击：\nMAC只能验证消息的完整性和真实性，但不能防止重放攻击。如果需要防止重放攻击，可以结合时间戳或序列号。 伪代码示例\nimport hmac import hashlib def verify_mac(message, received_mac, key): # 重新计算MAC computed_mac = hmac.new(key.encode(), message.encode(), hashlib.sha256).hexdigest() # 比较MAC值 if computed_mac == received_mac: return True # 验证通过 else: return False # 验证失败 # 示例 message = \u0026#34;Hello, World!\u0026#34; received_mac = \u0026#34;a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e\u0026#34; key = \u0026#34;secret_key\u0026#34; if verify_mac(message, received_mac, key): print(\u0026#34;MAC验证成功：消息未被篡改。\u0026#34;) else: print(\u0026#34;MAC验证失败：消息可能被篡改或来源不可信。\u0026#34;) 总结\n接收方通过重新计算MAC并与接收到的MAC值进行比较来验证消息的完整性和真实性。这一过程依赖于共享密钥的安全性以及哈希算法的强度。\n发送方什么时候非接收方提供密钥的？ # 发送方和接收方之间的密钥共享是消息验证码（MAC）安全性的核心。密钥必须在通信开始之前通过安全渠道共享，且不能被第三方获取。以下是密钥共享的常见方式和时机：\n1. 预先共享密钥（Pre-shared Key, PSK）\n时机：在通信开始之前，发送方和接收方通过安全的线下或线上渠道共享密钥。 方式： 线下交换：面对面交换密钥（如写在纸上或通过硬件设备）。 安全通信协议：通过安全的通信协议（如TLS/SSL）在线交换密钥。 适用场景： 小规模系统或固定设备之间的通信（如物联网设备）。 需要长期使用的密钥。 2. 密钥协商协议\n时机：在通信开始时，通过密钥协商协议动态生成共享密钥。 方式： 使用Diffie-Hellman密钥交换等协议，在不安全的信道中安全地生成共享密钥。 结合公钥加密（如RSA）确保密钥交换的安全性。 适用场景： 需要动态生成密钥的场景（如即时通信、HTTPS）。 大规模分布式系统。 3. 基于公钥基础设施（PKI）的密钥分发\n时机：在通信开始时，通过公钥加密技术分发密钥。 方式： 发送方使用接收方的公钥加密密钥，接收方使用自己的私钥解密。 结合数字证书验证公钥的真实性。 适用场景： 需要高安全性的场景（如银行交易、政府通信）。 大规模系统中身份验证和密钥分发。 4. 密钥派生\n时机：在通信过程中，通过主密钥派生出会话密钥。 方式： 使用密钥派生函数（如HKDF）从主密钥派生出新的密钥。 主密钥可以通过预先共享或密钥协商获得。 适用场景： 需要频繁更换密钥的场景（如实时通信）。 增强密钥安全性。 密钥共享的安全性要求\n保密性： 密钥在传输和存储过程中必须保密，不能被第三方获取。 完整性： 密钥在传输过程中不能被篡改。 真实性： 密钥必须来自可信的发送方。 示例场景\nHTTPS通信： 客户端和服务器通过TLS握手协议协商对称密钥，用于后续的MAC计算和加密。 物联网设备： 设备在出厂时预置共享密钥，用于设备与服务器之间的通信。 即时通信： 使用Diffie-Hellman密钥交换生成会话密钥，用于消息的MAC验证和加密。 总结\n发送方和接收方之间的密钥共享通常在通信开始之前或通信开始时通过安全渠道完成。具体方式包括预先共享密钥、密钥协商协议、公钥加密技术或密钥派生。密钥的安全性直接决定了MAC的有效性，因此密钥管理是消息验证码系统的关键环节。\n2.6 公开密钥算法(非对称加密) # 相比对称加密算法来说，公开密钥算法尤其是RSA算法运算非常缓慢，一般情况下，需要加密的明文数据都非常大，如果使用公开密钥算法进行加密，运算性能会惨不忍睹。公开密钥算法在密码学中一般进行密钥协商或者数字签名，因为这两者运算的数据相对较小。 公开密钥算法最重要和最广泛使用的算法就是RSA算法，该算法是Ron Rivest、Adi Shamir、Leonard Adleman三个人创建的，以三个人名字的首字母命名。 和对称密钥算法一样，公开密钥算法也有使用标准，公开密钥算法的标准称为PKCS（Public Key Cryptography Standards），这个标准由很多的子标准组成，指导使用者正确地使用公开密钥算法。 RSA加密算法的应用场景 单步加密 双向加密 2.6.1 理解RSA的内部结构 # 2.6.2 PKCS标准 # 2.6.3 RSA加密算法的应用场景 # 2.6.4 RSA加密算法实践 # 2.7 密钥 # 口令（password或者passphrase）也可以认为是一种密钥，都需要保密，不能泄露。口令和密钥最大的区别在于口令更容易生成、更容易记忆，一般情况下口令记录在人脑中，口令可以认为是一种弱密钥，由固定的字母、数字、符号组成，长度也有一定的限制。 在密码学中很少直接用口令进行加密，容易受到暴力攻击和字典攻击，暴力攻击的原理在于口令都是由固定的字母、数字、符号组成的，攻击者可以生成所有可能的口令，然后使用口令迭代去解密，一旦成功解密，就表示口令被暴力破解了。 字典攻击本质上也是一种暴力攻击，只是能够加快破解效率（时间和空间），人类一般使用常见的字母、数字、符号组合成口令（比如很多人喜欢用字母password作为口令），攻击者可以将常见的口令保存在一张字典中，然后用字典中的口令迭代去解密密文。除了字典攻击，还有彩虹表攻击方式，破解的关键点就在于口令相对容易猜测和预测。 密钥存储和传输 2.7.1 生成密钥 # 2.7.2 口令和PEB算法 # 2.7.3 密钥存储和传输 # 2.8 密钥协商算法 # RSA密钥协商算法 DH密钥协商算法 Diffie-Hellman算法，简称DH算法，是Whitfield Diffie和Martin Hellman在1976年公布的一个公开密钥算法，它的历史比RSA公开密钥算法更悠久。 使用RSA密钥协商算法传输会话密钥的时候，会话密钥完全由客户端控制，并没有服务器的参与，所以叫作密钥传输。 而DH算法确切地说，实现的是密钥交换或者密钥协商，DH算法在进行密钥协商的时候，通信双方的任何一方无法独自计算出一个会话密钥，通信双方各自保留一部分关键信息，再将另外一部分信息告诉对方，双方有了全部信息才能共同计算出相同的会话密钥。 2.8.1 RSA密钥协商算法 # 2.8.2 DH密钥协商算法 # Diffie-Hellman算法，简称DH算法，是Whitfield Diffie和Martin Hellman在1976年公布的一个公开密钥算法，它的历史比RSA公开密钥算法更悠久。 使用RSA密钥协商算法传输会话密钥的时候，会话密钥完全由客户端控制，并没有服务器的参与，所以叫作密钥传输。 而DH算法确切地说，实现的是密钥交换或者密钥协商，DH算法在进行密钥协商的时候，通信双方的任何一方无法独自计算出一个会话密钥，通信双方各自保留一部分关键信息，再将另外一部分信息告诉对方，双方有了全部信息才能共同计算出相同的会话密钥。 客户端和服务器端协商会话密钥的时候，需要互相传递消息，消息即使被挟持，攻击者也无法计算出会话密钥，因为攻击者没有足够的信息（通信双方各自保留的信息）计算出同样的会话密钥。 参数文件 在使用DH算法之前，先要生成一些公共参数，这些参数是公开的，无须担心攻击者能够看到这些参数值，这些参数可以由客户端或者服务器端生成，一般由服务器端生成。参数在协商密钥之前必须发给对端。 参数有两个，分别是p和g, p是一个很大的质数，建议长度在1024比特以上，这个长度也决定了DH算法的安全程度，g表示为一个生成器，这个值很小，可以是2或者5。通过参数，服务器端和客户端会生各自生成一个DH密钥对，私钥需要保密。 DH算法处理过程 通信双方的任何一方可以生成公共参数p和g，这两个数是公开的，被截获了也没有任何关系，一般情况下由通信双方的服务器端计算。 客户端连接服务器端，服务器端将参数发送给客户端。 客户端根据公开参数生成一个随机数a，这个随机数是私钥，只有客户端知道，且不会进行发送，然后计算Yc = (g ^ a) mod p, Yc就是公钥，需要发送给服务器端。 服务器端根据公开参数生成一个随机数b，这个随机数是私钥，需要服务器端保密，然后计算Ys = (g ^ b) mod p, Ys是公钥，需要发送给客户端。 客户端发送Yc数值给服务器端，服务器端计算Z = (Yc ^ b) mod p。 服务器端发送Ys数值给发送方，客户端计算Z = (Ys ^ a) mod p。 服务器端和客户端生成的Z就是会话密钥，协商完成。 这里的关键点就是私钥a和b不应该泄露，分别由通信双方维护，另外Ys和Yc进行互换才能完成协商，这两个值被截获对攻击者来说没有任何价值。换句话说，只要私钥不发生泄露，攻击者即使有了Ys和Yc也不会计算出会话密钥。 看到幂运算和求模过程，就知道DH算法和RSA算法一样，如果需要破解密钥，就必须面临离散对数和因式分解问题。和其他公开密钥算法一样，只要确保一定的密钥长度，DH算法具有很高的安全性。RSA和DH密钥对一样能够受到暴力攻击，提高密钥对的长度能够有效避免攻击。 2.8.3 DH算法分类 # 静态DH算法(DH算法) 静态DH算法，p和g两个参数永远是固定的，而且服务器的公钥（Ys）也是固定的。和RSA密钥协商算法一样，一旦服务器对应的DH私钥泄露，就不能提供前向安全性。静态DH算法的好处就是避免在初始化连接时服务器频繁生成参数p和g，因为该过程是非常消耗CPU运算的。 临时DH算法(EDH算法) 在每次初始化连接的时候，服务器都会重新生成DH密钥对，DH密钥对仅仅保存在内存中，不像RSA那样私钥是保存在磁盘中的，攻击者即使从内存中破解了私钥，也仅仅影响本次通信，因为每次初始化的时候密钥对是动态变化的。更安全的是，协商出会话密钥后，a和b两个私钥可以丢弃，进一步提升了安全性，在有限的时间、有效的空间生成了密钥对。 2.8.4 DH密钥协商算法实践 # 2.9 椭圆曲线密码学 # 为了保证DH的密钥对不被破解，提升安全性的主要手段就是增加密钥对的长度，但是长度越长，性能越低。公开密钥算法是一个O(n)操作，n就是密钥对的长度，n越小，操作越快。为了解决性能问题，需要了解下椭圆曲线密码学（Elliptic Curve Cryptography），简称为ECC。 ECC是新一代的公开密钥算法，主要的优点就是安全性，极短的密钥能够提供很大的安全性。比如224比特的ECC密钥和2048比特的RSA密钥可以达到同样的安全水平，由于ECC密钥具有很短的长度，运算速度非常快。ECC基于非常复杂的算法，到目前位置，对于ECC进行逆操作还是很难的，数学上被证明是不可破解的，ECC算法的优势就是性能和安全性非常高。 在具体应用的时候，ECC可以结合其他公开密钥算法形成更快、更安全的公开密钥算法，比如结合DH密钥协商算法组成ECDH密钥协商算法，结合数字签名DSA算法组成ECDSA数字签名算法。 2.9.1 ECC算法的基本模型 # 2.9.2 使用OpenSSL了解命名曲线 # 2.9.3 ECDH协商算法 # 2.9.4 命名曲线 # 2.10 数字签名 # 2.10.1 数字签名的用途 # 身份验证 私钥只有密钥对的生成者持有，如果不考虑密钥泄露的问题，私钥拥有者使用密钥（注意不是加密操作）签署一条消息，然后发送给任意的接收方，接收方只要拥有私钥对应的公钥，就能成功反解签署消息，由于只有私钥持有者才能“签署”消息，不能抵赖说这条签署消息不是他发送的，这就是数字签名技术的全部。 2.10.2 数字签名的流程 # 2.10.3 RSA数字签名算法 # RSA算法的用途非常广泛，可以进行数字签名。和RSA加密算法相似，不同的是，RSA加密算法是公钥加密，私钥解密；RSA签名算法是私钥签名，公钥验证签名。 2.10.4 RSA数字签名实践 # 2.11 DSA数字签名算法 # 防篡改和防伪造的区别是什么 # 防篡改和防伪造是信息安全中的两个重要概念，虽然它们都涉及数据的完整性和真实性，但它们的关注点和应用场景有所不同。以下是它们的区别：\n1. 防篡改（Tamper Resistance）\n定义：防止数据在传输或存储过程中被未经授权的修改。 关注点：确保数据的完整性，即数据未被篡改。 实现方式： 使用哈希算法（如SHA-256）生成数据的哈希值，接收方通过比较哈希值验证数据是否被篡改。 使用消息验证码（MAC）或数字签名，结合密钥确保数据的完整性。 应用场景： 文件传输：确保文件在传输过程中未被修改。 软件更新：确保下载的软件包未被篡改。 数据库记录：确保存储的数据未被恶意修改。 2. 防伪造（Forgery Resistance）\n定义：防止攻击者伪造数据或身份，冒充合法用户或系统。 关注点：确保数据的真实性，即数据来源可信。 实现方式： 使用数字签名，发送方用私钥对数据签名，接收方用公钥验证签名，确保数据来自可信来源。 使用公钥基础设施（PKI）和数字证书，验证用户或系统的身份。 应用场景： 身份认证：防止攻击者冒充合法用户登录系统。 电子合同：确保合同签署者的身份真实。 区块链交易：确保交易发起者的身份真实。 对比总结\n特性 防篡改 防伪造 目标 确保数据未被修改 确保数据来源可信 关注点 数据完整性 数据真实性 实现技术 哈希算法、MAC 数字签名、PKI 典型应用 文件传输、软件更新 身份认证、电子合同 示例\n防篡改： 发送方发送文件并附带哈希值，接收方计算哈希值并比对，确保文件未被篡改。 防伪造： 发送方用私钥对文件签名，接收方用发送方的公钥验证签名，确保文件来自可信来源。 总结\n防篡改关注的是数据是否被修改，确保数据的完整性。 防伪造关注的是数据是否来自可信来源，确保数据的真实性。 两者通常结合使用，以同时保障数据的完整性和真实性。例如，数字签名既可以防篡改（验证数据完整性），也可以防伪造（验证数据来源）。 第3章 宏观理解TLS # 解决HTTP三大问题的通用解决方案就是TLS协议 读者可能听说过**TLS（Transport Layer Security）协议，也可能听说过SSL（Secure Sockets Layer）**协议，在理解的时候可以认为两者是一样的，TLS协议是SSL协议的升级版，本书使用TLS/SSL协议代表TLS协议或者SSL协议。 TLS/SSL协议位于应用层协议和TCP之间，构建在TCP之上，由TCP协议保证数据传输的可靠性，任何数据到达TCP之前，都经过TLS/SSL协议处理。 对于应用层协议来说，它无须过多改变，引入TLS/SSL协议即可保证数据机密性和完整性。任何应用层协议（HTTP、SMTP、FTP、其他自定义应用层协议）都可以结合TLS/SSL协议。 TLS/SSL协议一般构建在TCP之上，也可以构建在UDP之上，称为DTLS（Datagram Transport Layer Security）协议，DTLS协议在Web中使用得比较少。 3.1 TLS/SSL 协议综述 # 3.2 TLS/SSL协议背后的算法 # 为了对数据进行加密，可以采用对称加密算法或者公开密钥加密算法，有加密算法必定就有MAC算法，两者是一个整体。 使用何种密钥协商算法也是由客户端和服务器端共同决定的，或者说由密码套件决定，对于HTTPS来说，在连接阶段必须协商出一个双方认可的密码套件，密码套件是各个密码学算法组合。 在HTTPS中，一般采用RSA或者DH算法协商预备主密钥 3.2.1 加密算法和MAC算法 # 为了对数据进行加密，可以采用对称加密算法或者公开密钥加密算法，有加密算法必定就有MAC算法，两者是一个整体 使用公开密钥加密算法的缺点就是运算慢，尤其是HTTP传输的数据都非常大，所以在大部分Web应用中很少使用公开密钥算法进行加密解密运算。唯一的可行方案就是对称加密算法，比如AES、DES算法。在Web应用中使用比较多的MAC算法是HMAC算法，比如HMAC-SHA-1、HMAC-SHA256算法。 协商 本章处处可见协商两个字，所以会重点描述协商的概念，在TLS/SSL协议中，协商的另外一个关键名词就是密码套件（CipherSuite），协商的结果就是双方都认可的密码套件，密码套件决定了本次连接采用哪一种加密算法、密钥协商算法、HMAC算法 3.2.2 密钥协商算法 # 不管采用哪种密钥协商算法，客户端和服务器端最终会协商出预备主密钥（Premaster Secret），预备主密钥转换为主密钥，主密钥最终再转换为密钥块。 预备主密钥的特点 每个客户端和服务器端初始化连接的时候生成预备主密钥，每次的值都是不一样的。 预备主密钥在会话结束后（连接关闭后），会自动释放，这是很关键的特性，预备主密钥不会持久保存。 预备主密钥必须保证是机密的，确保攻击者无法解密出预备主密钥，也无法猜测出预备主密钥。 在HTTPS中，一般采用RSA或者DH算法协商预备主密钥 RSA 客户端向服务器端发起连接请求，服务器端发送RSA密钥对的公钥给客户端。 客户端通过随机数生成器生成一个预备主密钥，用服务器的公钥加密并发送给服务器端。 服务器解密预备主密钥，假如能够正确解密，则说明客户端和服务器端共同协商出一个预备主密钥。 DH算法 流程 客户端向服务器端发起连接请求 服务器端生成一个RSA密钥对，并将公钥发送给客户端 服务器端生成DH参数和服务器DH密钥对，用RSA私钥签名DH参数和服务器DH公钥，最后将签名值、DH参数、服务器DH公钥发送给客户端 客户端通过服务器RSA的公钥验证签名，获取到DH参数和服务器DH公钥 客户端通过DH参数生成客户端的DH密钥对，并将客户端DH公钥发送给服务器端 客户端通过客户端DH私钥和服务器端DH公钥计算出预备主密钥 服务器端接收到客户端的DH公钥，结合服务器的DH私钥计算出预备主密钥。 最终客户端和服务器端计算出的预备主密钥能够保持一致。 分类 静态DH算法 临时DH算法(EDH算法) 在HTTPS中，服务器在发送DH参数和服务器DH公钥之前会对这两个值进行签名运算，确保传递的值没有被篡改和伪造，也可以看出HTTPS就是使用多种算法确保安全性 在HTTPS中，使用DH密钥协商算法需要客户端和服务器端经过多次通信才能协商出预备主密钥，而RSA密钥协商算法只要很少的步骤就能协商出。 3.2.3 前向安全性 # 前向安全性（Perfect Forward Secrecy）是TLS/SSL协议中很重要的一个话题，必须充分理解。RSA密钥协商算法和静态DH算法都不能确保前向安全 对于动态DH算法来说，客户端每次连接的时候，DH密钥对都是重新生成的，即使在某次连接中泄露了，也仅仅会导致本次连接中的加密数据被破解，安全风险相对较小。 3.2.4 密钥衍生算法 # **密钥衍生算法（Key Derivation Function, KDF）**是一种用于从初始密钥（如密码或主密钥）生成一个或多个密钥的密码学算法。它的主要目的是增强密钥的安全性，并生成适合特定用途的密钥（如加密密钥、认证密钥等）。\n密钥衍生算法在HTTPS是怎么应用的？ # 密钥衍生算法在HTTPS中的应用主要体现在安全地生成会话密钥，确保客户端与服务器之间的通信安全。具体来说，这个过程通常涉及以下几个步骤：\n握手协议：当客户端（如浏览器）尝试与服务器建立HTTPS连接时，首先会通过SSL/TLS握手协议开始通信。在这个过程中，双方会交换一些必要的信息用于生成对称密钥。\n密钥交换算法：为了安全地协商出一个共享的秘密（即预主密钥），客户端和服务器可能会使用诸如RSA、Diffie-Hellman等密钥交换算法。例如，在基于RSA的密钥交换中，客户端生成一个随机的预主密钥并用服务器的公钥加密后发送给服务器；而在Diffie-Hellman方法中，则是通过数学运算来安全地生成共享秘密。\n密钥衍生函数（KDF）：一旦预主密钥确定下来，就会使用密钥衍生函数（如HKDF或PBKDF2）从预主密钥生成实际使用的对称密钥。这些函数接受输入（如预主密钥、客户端和服务器随机数等）并通过一系列操作生成最终用于加密通信的密钥。这一步骤增强了安全性，因为它增加了攻击者预测密钥的难度。\n数据加密：使用上述过程中生成的对称密钥，客户端和服务器就可以采用对称加密算法（如AES）来加密和解密它们之间传输的数据，保证了数据的保密性和完整性。\n总之，密钥衍生算法在HTTPS中的作用至关重要，它不仅保障了密钥的安全生成，还提高了整个通信过程的安全性，防止潜在的信息泄露和中间人攻击。\n在HTTPS中，会使用密钥衍生算法生成哪些密钥，能具体列举出来吗？ # 在HTTPS（实际上是其底层的SSL/TLS协议）中，密钥衍生算法用于生成多个密钥和参数，以确保通信的安全性。以下是通过密钥衍生过程通常会生成的一些关键元素：\n客户端写密钥（Client Write Key）：这是用来加密从客户端发送到服务器的数据的对称密钥。\n服务器写密钥（Server Write Key）：相对地，这是用来加密从服务器发送到客户端的数据的对称密钥。\n客户端写MAC密钥（Client Write MAC Key）：用于客户端数据完整性验证的消息认证码(MAC)密钥，在现代TLS版本中被基于哈希的消息认证码(HMAC)替代。\n服务器写MAC密钥（Server Write MAC Key）：用于服务器数据完整性验证的消息认证码(MAC)密钥，在现代TLS版本中也被基于哈希的消息认证码(HMAC)替代。\n初始化向量（IV）：对于某些加密模式（如CBC模式），需要一个初始化向量来确保即使是相同的数据块使用相同的密钥加密时也会产生不同的输出。不过，在使用AEAD（如GCM模式）的情况下，这个IV有时也被称为nonce，并且它与密钥一起用于提供数据完整性和保密性。\n临时密钥材料（Ephemeral Keys）：在一些密钥交换机制中，例如短暂的Diffie-Hellman（DHE或ECDHE），会产生临时密钥材料用于一次性的密钥协商，增加了前向安全性。\n这些密钥和参数是通过密钥衍生函数（KDF），比如在TLS 1.2及之前使用的PRF（伪随机函数），以及在TLS 1.3中更明确地定义的KDFs（如HKDF）从预主密钥、客户端随机数、服务器随机数等信息派生出来的。每个连接都会生成一套新的密钥，从而保证了通信的安全性和隐私保护。\n3.2.5 中间人攻击 # 所谓中间人攻击就是服务器传递给客户端的公钥可能被攻击者替换，这样安全性就荡然无存了。 客户端向服务器端发起连接请求，期望获取服务器的RSA公钥，攻击者劫持了这个请求。 攻击者自己生成一对RSA密钥对，然后将攻击者的RSA公钥发送给客户端。 攻击者然后再向服务器端发送请求，服务器生成RSA密钥对，将RSA公钥发送给客户端，实际上是发送给攻击者。 客户端通过攻击者的公钥加密密钥块并发送给服务器，实际上是发送给攻击者。 攻击者用自己的RSA私钥解密了密钥块A，然后自己生成一个密钥块B，用服务器的RSA公钥加密后发送给服务器端。 服务器端接收到请求后，用自己的RSA私钥解密出攻击者的密钥块B。 客户端使用攻击者的密钥块A，采用AES算法加密数据并发送给服务器端，实际上是发送给攻击者。 攻击者使用自己的密钥块A、采用AES算法解密出明文，客户端相当于泄露了隐私，攻击者使用密钥块B，采用AES算法加密明文后发送给服务器。 服务器使用密钥块B，采用AES算法加密数据并发送给攻击者。 攻击者使用密钥块B，采用AES算法解密出明文数据，此时客户端和服务器端的加密数据被成功破解。 在SSL/TLS协议（HTTPS的安全基础）中，\u0026ldquo;密钥块\u0026rdquo;（Key Block）是一个概念，它指的是通过密钥衍生函数（KDF）从预主密钥生成的一系列加密材料的集合。这个密钥块包含了用于保护客户端和服务器之间通信所需的所有密钥和参数。\n客户端和服务器之间只传递预主密钥，密钥块是两边分别计算出来的，是这样吗 # 是的，您的理解基本正确。在SSL/TLS协议中，客户端和服务器之间并不会直接传递完整的密钥块，而是通过交换信息来安全地生成一个预主密钥（Pre-Master Secret），然后各自独立地使用这个预主密钥以及双方在握手初期交换的随机数（Client Random和Server Random）来计算出最终的密钥材料，即所谓的密钥块（Key Block）。具体过程如下：\n密钥交换：根据所采用的具体密钥交换算法（如RSA、Diffie-Hellman等），客户端和服务器会进行一系列的操作来安全地确定一个预主密钥。例如，在基于RSA的密钥交换中，客户端生成一个预主密钥并用服务器的公钥加密后发送给服务器；而在Diffie-Hellman方法中，则是通过数学运算来安全地生成共享的秘密。\n生成密钥块：一旦预主密钥确定下来，客户端和服务器都会使用相同的密钥衍生函数（KDF），比如TLS 1.2中的伪随机函数（PRF）或TLS 1.3中的HKDF，结合预主密钥和之前交换的随机数值，分别独立计算出所需的密钥材料。这包括了客户端写密钥、服务器写密钥、客户端写MAC密钥、服务器写MAC密钥（在TLS 1.2及之前版本中）、初始化向量（IV）或nonce等。\n独立计算的优势：这种方式不仅减少了通信负担，还增强了安全性。因为预主密钥本身并不直接用于加密通信，而是用于派生出实际使用的对称密钥和其他安全参数。即使攻击者能够拦截到所有公开交换的信息，他们也无法轻易推算出最终的密钥材料，除非他们能破解密钥交换算法或者预测KDF的结果。\n因此，客户端和服务器确实只交换必要的信息以确定预主密钥，并且之后各自独立计算出密钥块，这种机制确保了通信的安全性和效率。\n3.2.6 PKI # 和身份证一样，CA机构会签发一张证书（可以理解为就是一张身份证），证书中包含了一些关键信息，比如服务器的主机、服务器的公钥 CA机构也拥有一个密钥对，比如RSA密钥对（与服务器的RSA密钥对没有任何关系），它用私钥对证书进行数字签名，将签名的证书发送给服务器。浏览器再连接服务器，服务器发送证书给浏览器，浏览器拥有CA机构的公钥（内嵌在浏览器中），然后校验证书的签名，一旦校验成功，就代表这个证书是可信的CA机构签发的。 3.3 HTTPS总结 # 3.3.1 握手 # 1 认证 # 客户端在进行密钥交换之前，必须认证服务器的身份，否则就会存在中间人攻击，而服务器实体并不能自己证明自己，所以需要通过CA机构来进行认证，认证的技术解决方案就是签名的数字证书。证书中会说明CA机构采用的数字签名算法，客户端获取到证书后，会采用相应的签名算法进行验证，一旦验证通过，则表示客户端成功认证了服务器端的身份。 2 密码套件协商 # 密码套件是一系列密码学算法的组合，主要包括多个密码学算法 身份验证算法 密码协商算法 加密算法或者加密模式 HMAC算法的加密基元 PRF算法的加密基元，需要注意的是，不同的TLS/SSL协议版本、密码套件，PRF算法最终使用的加密基元和HMAC算法使用的加密基元是不一样的 TLS_密钥协商_身份验证_WITH_加密算法_HMAC或PRF算法 密码套件的例子 TLS_DH_RSA_WITH_AES_CBC_128_SHA RSA：身份验证算法，这个称呼具备一定的干扰性，本例中的RSA表示证书中包含的服务器公钥是RSA公钥，对于不同的密钥协商算法，RSA公钥的作用也不一样。读者可能会问，为何没有涉及身份验证，身份验证对应的数字签名算法由证书指定，客户端获取到证书的时候，证书会说明该证书由何种数字签名算法签名，验证证书签名的公钥和服务器的公钥没有任何关系。 DH：表示密钥协商算法，用来协商出预备主密钥（PremasterSecret），那么客户端如何获取DH参数呢？服务器会发送DH参数和服务器DH公钥。 AES_CBC_128，表示加密算法，用于保证机密性，在本例中使用的是AES对称加密算法、加密模式是CBC模式、密钥长度是128比特。 SHA：表示HMAC算法，用于保证完整性，在本例中是HMAC_SHA1算法。 PRF算法：PRF算法采用的加密基元不一定是SHA1算法，由TLS/SSL协议版本和协商出的密码套件决定。 TLS_RSA_WITH_AES_CBC_128_SHA 理解密码套件的几个关键点 密码套件是密码学算法的组合，但并不是随便组合的，每一种密码套件都由IANA指定和分配。 不同的TLS/SSL版本，密码套件的解释有细微的差别，比如在TLS v1.0版本中，PRF具体使用的算法是硬编码的（不依赖于密码套件），是HMAC-MD5和HMAC-SHA1算法的组合，而在TLS v1.2版本中，PRF默认采用的是HMAC-SHA256算法。 不同的TLS/SSL版本，有不同的密码套件组合，主要是从安全性和性能的角度考虑，版本越高，包含的密码套件安全性就更高，也会废弃一些相对不安全的密码套件。 密码套件在服务器端是可以配置的，比如Nginx服务器可以通过指令配置密码套件，可以去除一些不安全的密码套件。 客户端和服务器端选择密码套件的基本原则就是优先级，从安全角度看应该由服务器决定协商出的最终密码套件。 密码套件仅仅是一个配置，不代表服务器就支持该套件，比如服务器可以配置TLS_ECDHE_WITH_ECDSA_AES_128_GCM_SHA256套件，但是服务器上并没有ECDSA密钥对，那么最终不能协商出该密码套件。 3 密钥协商 # 如果使用RSA密钥协商算法，那么服务器的密钥对非常重要，服务器的公钥不仅仅要进行身份验证，还要进行密钥协商，一旦私钥泄露，就失去了前向安全性。 如果使用静态DH算法，服务器证书中会包含固定的DH参数和DH公钥，也会失去前向安全性，所以现在密码套件很少支持DH算法，CA机构在签发证书的时候也不会包含DH参数和DH公钥。 为了保持前向安全性，目前使用最多的密钥协商算法就是DHE算法和ECDHE算法，这两个算法和服务器的密钥对关系不大，也就是说密钥的协商不取决于服务器的密钥对，所以服务器的私钥即使泄露，也不会造成太大的安全风险。 4 握手消息完整性校验 # 握手过程中传递的消息全部是明文传输的，任何攻击者都能截获，握手消息存在被篡改的可能性 读者会说不是有身份验证了吗，怎么还存在中间人攻击？确实是这样，证书校验能够确保服务器的真实身份，但密钥协商是身份校验之后的过程，攻击者无法攻击身份校验过程，但可以在后续的握手过程中篡改消息 下面简单描述TLS/SSL协议如何对消息进行加密和完整性保护 客户端将发送和接收到的所有握手消息组合在一起，然后计算出摘要数据，握手层使用密钥块对摘要数据进行加密和完整性保护，然后发送给服务器。 服务器接收到验证消息后，使用加密块解密出摘要数据。 紧接着服务器自行计算发送和接收的所有握手消息，再计算出消息的摘要数据，如果摘要数据和解密出的摘要数据相同，代表客户端发送的消息没有被篡改。 Finished消息：客户端和服务器各自发送“Finished”消息，这些消息包含整个握手过程的一个哈希值（通常是基于之前所有握手消息的摘要），并用新协商的密钥进行加密。这一步骤用于最终验证握手过程的完整性和一致性。 完整性校验：通过比较收到的“Finished”消息中的哈希值与本地计算出的握手消息摘要是否一致，双方可以确认对方确实参与了相同的握手流程，且没有发生任何篡改。\nFinished 消息包含的哈希值是怎么计算的，以及是怎么比较的 # 在SSL/TLS握手过程中，\u0026ldquo;Finished\u0026quot;消息中的哈希值是通过特定的计算方法生成的，并且用于确保握手过程的完整性和一致性。以下是详细的步骤和机制说明：\n计算 \u0026ldquo;Finished\u0026rdquo; 消息中的哈希值\n握手上下文（Handshake Context）：\n在整个握手过程中，客户端和服务器会交换一系列的消息，如Client Hello、Server Hello、Certificate、Server Key Exchange、Client Key Exchange等。 这些消息的内容会被收集起来形成一个握手上下文（handshake context），通常是一个字节流，包含了所有已发送和接收的手握消息。 PRF（伪随机函数）或HKDF：\nSSL/TLS使用伪随机函数（PRF）或基于哈希的消息认证码（HMAC）来生成密钥材料和其他安全参数。 在TLS 1.2及之前版本中，PRF被用来生成“Finished”消息中的验证数据（verify_data）。 在TLS 1.3中，使用了更现代的HKDF（Key Derivation Function）来进行类似的计算。 计算哈希值：\nTLS 1.2及之前版本： PRF根据以下公式计算出“Finished”消息中的verify_data： verify_data = PRF(master_secret, \u0026#34;client finished\u0026#34;, Hash(handshake_messages)) [for client] verify_data = PRF(master_secret, \u0026#34;server finished\u0026#34;, Hash(handshake_messages)) [for server] 其中： master_secret 是通过密钥交换算法生成的主密钥。 \u0026quot;client finished\u0026quot; 或 \u0026quot;server finished\u0026quot; 是标签字符串，用于区分客户端和服务器的计算。 Hash(handshake_messages) 是对所有握手消息进行哈希运算的结果（通常是SHA-256或其他协商的哈希算法）。 TLS 1.3： 使用HKDF提取和扩展函数来生成verify_data： verify_data = HKDF-Expand-Label(transcript_hash, \u0026#34;finished\u0026#34;, \u0026#34;\u0026#34;, length) 其中： transcript_hash 是所有握手消息的哈希摘要。 \u0026quot;finished\u0026quot; 是标签字符串。 length 是所需输出的长度。 发送和比较 \u0026ldquo;Finished\u0026rdquo; 消息\n客户端发送 \u0026ldquo;Finished\u0026rdquo; 消息：\n客户端根据上述方法计算出自己的verify_data，并将其作为“Finished”消息的一部分加密后发送给服务器。 服务器发送 \u0026ldquo;Finished\u0026rdquo; 消息：\n服务器同样按照相同的方法计算出自己的verify_data，并将其作为“Finished”消息的一部分加密后发送给客户端。 比较哈希值：\n客户端验证服务器的 “Finished” 消息：\n客户端收到服务器的“Finished”消息后，解密并从中提取出verify_data。 然后，客户端使用相同的PRF或HKDF算法，基于自己记录的所有握手消息重新计算预期的verify_data。 如果计算结果与接收到的verify_data匹配，则认为握手过程未被篡改，服务器的身份是可信的。 服务器验证客户端的 “Finished” 消息：\n同样地，服务器也会对接收到的客户端“Finished”消息进行验证，确保客户端参与了相同的握手流程，并且没有发生任何篡改。 示例\n假设在一个TLS 1.2握手过程中：\n握手消息包括：Client Hello、Server Hello、Certificate、Server Key Exchange、Client Key Exchange、Change Cipher Spec。 客户端和服务器各自计算出 Hash(handshake_messages)。 使用PRF和 master_secret 计算出各自的verify_data： Client Finished: PRF(master_secret, \u0026#34;client finished\u0026#34;, Hash(handshake_messages)) Server Finished: PRF(master_secret, \u0026#34;server finished\u0026#34;, Hash(handshake_messages)) 双方将这些verify_data作为“Finished”消息的一部分发送给对方，并在接收到对方的“Finished”消息时重新计算verify_data进行比较。 通过这种方式，\u0026ldquo;Finished\u0026quot;消息不仅确认了双方已经成功完成了密钥交换，还验证了整个握手过程的完整性和一致性，从而有效防止了中间人攻击和其他形式的数据篡改。\n使用Charles来解密https请求内容的原理是什么？ # 使用Charles等代理工具解密HTTPS请求内容的基本原理涉及到中间人（Man-in-the-Middle, MITM）技术的应用。以下是详细步骤和原理说明：\n基本原理\n安装Charles的根证书：\n为了能够解密HTTPS流量，用户首先需要在设备或浏览器中安装Charles提供的自签名根证书。 这个证书使得Charles可以作为受信任的CA（证书颁发机构），从而生成用于与目标网站通信的伪造证书。 拦截HTTPS连接：\n当客户端尝试建立一个HTTPS连接时，Charles作为代理服务器会拦截这个请求。 Charles代替原始服务器向客户端发送自己签发的伪造证书（基于之前安装的根证书），而不是服务器的真实证书。 客户端验证伪造证书：\n客户端收到伪造证书后，会根据已安装的信任证书列表进行验证。 因为用户已经安装了Charles的根证书，所以客户端认为这个伪造证书是有效的，并继续建立加密连接。 双向解密与重新加密：\nCharles能够解密从客户端发来的加密请求，因为它拥有对应的私钥（用于伪造证书的那一对公私钥）。 解密后的明文信息被显示给用户查看。 然后，Charles使用目标服务器的真实证书与服务器建立另一个独立的HTTPS连接，并将请求转发给服务器。 对于响应数据，Charles同样先从服务器接收加密响应，解密，展示给用户，再用伪造证书加密返回给客户端。 注意事项\n安全性风险：虽然这种方法对于调试和开发非常有用，但它也存在显著的安全隐患。如果恶意软件利用类似的技术，它可以窃听用户的敏感信息。因此，在公共网络或不受信任的环境中不应该随意安装未知来源的根证书。\n透明度和同意：实际操作中，使用这类工具通常要求明确告知用户并获得其同意，尤其是在涉及处理个人敏感信息时。\n通过这种方式，Charles能够在不破坏原有HTTPS加密机制的前提下，实现对HTTPS流量的监控和分析。这对于开发者来说是一个强大的工具，可以帮助他们调试应用程序、检查API调用以及确保网络安全配置正确无误。然而，使用此类工具时应谨慎考虑隐私和安全问题。\n在使用charles进行https抓包的时候，有些接口会连接失败，这是什么原因 # 在使用Charles进行HTTPS抓包时，如果某些接口连接失败，可能有以下几个原因：\n证书未正确安装\n客户端未信任Charles的根证书：确保已在客户端（如手机或浏览器）上正确安装并信任了Charles的根证书。对于移动设备，还需要特别注意是否针对该设备类型正确配置了证书。 应用不支持自定义证书：一些应用程序为了增强安全性，内置了对特定证书颁发机构（CA）的信任列表，并拒绝接受非官方或用户安装的证书。这种情况下，即使你安装了Charles的证书，这些应用也不会信任它，从而导致HTTPS请求失败。 SSL Pinning\nSSL Pinning技术的应用：部分应用程序实施了SSL Pinning（SSL锁定），这是一种安全措施，通过硬编码服务器的公钥或证书到应用程序中，强制要求与预设的服务器证书匹配。如果检测到中间人代理（如Charles）提供的伪造证书，即使这个证书是被系统信任的，应用程序也会拒绝建立连接。 网络配置问题\n代理设置错误：确保设备或浏览器已经正确设置了Charles作为HTTP/HTTPS代理。如果代理设置有误，可能导致请求无法正常路由到目标服务器。 防火墙或网络限制：某些网络环境可能设置了严格的防火墙规则或代理策略，阻止了通过第三方代理软件发送的请求。 服务器端限制\nIP地址黑名单：有些服务器可能会维护一个黑名单，列出不允许访问其资源的IP地址范围。如果你正在使用的代理服务器的IP地址被列入黑名单，那么通过该代理发出的所有请求都可能被服务器拒绝。 请求频率限制：频繁的抓包测试可能会触发服务器的速率限制机制，导致部分请求被拒绝。 解决方法\n检查并重新安装证书：确保Charles的根证书已正确安装并在设备上被信任。对于移动端，按照Charles的官方指南进行操作。 绕过SSL Pinning：对于支持修改的应用程序，可以尝试关闭SSL Pinning功能；不过，这通常需要反编译应用，修改代码后再重新打包，这对大多数普通用户来说较为复杂且可能违反服务条款。 确认代理设置：仔细检查设备上的代理设置，确保它们指向了运行Charles的主机和端口。 测试不同网络环境：尝试切换到不同的网络环境，排除因当前网络设置导致的问题。 联系服务提供商：如果是由于服务器端限制（如黑名单、速率限制等）导致的问题，可能需要联系服务提供商解决。 理解上述潜在原因后，你可以针对性地排查问题所在，并采取相应的解决措施。如果是在开发环境中遇到此类问题，开发者还可以利用调试工具或日志来进一步诊断具体的故障点。\n3.3.2 加密 # 3.4 实施HTTPS网站的必备条件 # 3.4.1 证书和密钥对 # 3.4.2 部署和配置HTTPS网站 # 3.4.3 全站HTTPS策略 # 3.5 从用户的角度看HTTPS # 3.5.1 绿色小锁图标 # 3.5.2 TLS/SSL握手失败 # 3.5.3 混合内容 # 第4章 选择HTTPS的必要性和疑惑 # 第5章 快速搭建一个HTTPS网站 # "},{"id":80,"href":"/zh/zh/post/books/computer-science/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/","title":"深入浅出HTTPS：从原理到实战","section":"Computer Science","content":" 2015年百度搜索引擎完成其历史上最大的系统性升级——全面由HTTP升级到HTTPS 2016年苹果公告要求App Store中的所有应用在2017年1月1日之后都必须使用HTTPS加密连接 2017年1月9日微信上线小程序后，要求开发者的所有服务端请求必须为HTTPS 同时Google已调整搜索引擎算法，让采用HTTPS的网站在搜索结果中排名更靠前，并宣布从2018年7月开始所有的HTTP网站将标记为“不安全” 第1章 HTTP介绍 # HTTP的特点 客户端/服务器模型 客户端和服务器是否正确传输依赖于TCP这个协议。 HTTP是无状态的 所谓的无状态就是每次请求完成后，不会在客户端和服务器上保存任何的信息，对于客户端和服务器来说，根本不知道上一次请求的信息是什么，甚至不知道本次连接的对端是不是上次连接的那一端，它的生命周期随着TCP/IP连接的关闭结束了 无状态的设计已经不能适应新的情况，为了保持状态，出现了Cookie和Session技术，但是Cookie技术设计得非常不严谨，引发了很多安全问题。 介绍下Cookie是如何进行会话保持的，客户端第一次请求完成后，服务器会发送Cookie信息到客户端的计算机上，客户端下次请求的时候会携带该Cookie信息，这样服务器就知道该用户就是上一次请求的用户了。 HTTP是跨平台的 通过上面的讲解，读者知道HTTP就是具备一定规则的纯文本信息，任何开发语言都可以实现HTTP或者基于HTTP进行开发，开发出来的软件也很容易移植，受系统环境的影响非常少。 HTTP用途很广泛 1.3 网络模型 # HTTP是应用层协议，应用层协议是TCP/IP的一部分 OSI模型是一个通用的网络协议标准，但实际使用的标准却是TCP/IP标准，TCP/IP包含的不仅仅是TCP或者IP，它是一个协议族，网络应用开发都需要掌握TCP/IP。 TCP/IP有两个最大的特点，分别是分层和封包/拆包机制 每一层和它的上下层都有标准的接口规范，每一层无须关心上下层是如何工作的，它只关心上下层是否正确基于规范实现了接口 应用层 如果没有应用层，那么网络中传输的数据没有任何意义，因为人类无法理解数据的含义。而有了应用层，软件就能解释应用层数据的含义。在Web应用中，有了HTTP和HTML标准，浏览器才能呈现对用户有意义的内容。 应用层协议有很多，比如HTTP、FTP、邮件协议，开发者开发的软件一般都是应用层协议软件。 传输层 网络层 网络层主要是IP这个协议，客户端和服务器传输的时候，会经过很多节点，IP就是选择一条最优的路径。每个终端上都有一张路由表，路由表负责将数据传输到下一个节点，下一个节点再传输到下下个节点，最终到达目的地址。 链路层 应用层、传输层、网络层都是虚拟的，只有链路层才是实体设备，包括光纤、网卡等设备。基于这些设备，数据最终才能到达终端。 接下来简单描述封包/拆包机制，对于客户端请求来说，传输层接收到应用层消息后，在HTTP数据包前面增加TCP包头，然后发送给网络层；网络层在TCP数据包前面加上IP包头发送给链路层；链路层在IP数据包前面加上以太网包头；最终服务器接收到完整的数据包。 然后服务器进行拆包：首先在网络层去除链路层包头；在传输层去除IP包头；在应用层去除TCP包头；最终得到完整的HTTP应用层数据。 1.4 协议安全分析 # 协议不安全的根本原因 数据没有加密 无法验证身份 数据易篡改 第2章 密码学 # 2.1 对于密码学的认知 # OpenSSL OpenSSL命令行功能非常强大，有很多的子命令和参数，如果不理解密码学算法，根本无法理解子命令和参数的含义，这是难学习的根本原因，也说明学习OpenSSL之前必须先掌握密码学算法。 不同版本的OpenSSL命令行工具在使用的时候有一些差别，同样一条命令，读者会发现在特定版本下可能无法正确运行。 OpenSSL命令行的帮助手册和文档描写得不是很通俗，很难进行系统的学习。 完成同样一个操作，OpenSSL命令行有许多方法实现，这可能会干扰读者的学习。 2.2 随机数 # 而对于PRNG来说，内部状态的数值来自于模拟的数值，称为种子（seed）。随机数生成器每次生成随机数的时候，内部状态的值都会变化，这样才能产生不一样的随机数，如果每次熵和种子是一样的，生成的随机数也是相同的，所以熵和种子对于随机数生成器非常重要。 2.2.1 随机数的类型 # 真正的随机数生成器 需要从物理设备获取 伪随机数生成器 通过算法获取 密码学伪随机数生成器 用于密码学 随机数的特性 效率 随机性 不可预测性 不可重现性 2.2.2 随机数的工作原理 # 2.2.3 常见的随机数生成器 # 2.2.4 密码学算法中的随机数 # 2.3 Hash算法 # 2.3.1 加密基元 # 加密基元就是一些基础的密码学算法，通过它们才能够构建更多的密码学算法、协议、应用程序 2.3.2 Hash算法和密码学Hash算法 # 2.3.3 密码学Hash算法的特性 # 由于Hash算法有很多功能，所以Hash算法有多种称呼，比如摘要算法（Message Digest Algorithms）、单向散列函数（Cryptographic One-way Hash Functions）。输出值也有多种称呼，比如摘要值、散列、指纹。读者看到这些名词的时候，都可以理解为Hash算法 密码学Hash算法的主要特性 相同的消息总是能得到同样的摘要值，特定的Hash算法，不管消息长度是多少，最终的摘要值长度是相同的。 不管多长的消息，Hash运算非常快速，这是非常重要的特性。 通过摘要值很难逆向计算出原始消息，Hash算法具备单向性，摘要值是不可逆的，这也是非常重要的特性。为了逆向计算出原始消息，唯一的方法就是采用暴力攻击、字典攻击、彩虹表，对不同的消息组合进行迭代运算，运算的结果如果匹配该消息的摘要值，表示该Hash算法不应该用于密码学。 原始消息一旦修改，即使是很轻微的修改，最终的摘要值也会产生变化。 很难找出两个不同的消息，并且它们的摘要值是相同的。 2.3.4 Hash算法的用途 # 文件比较 身份校验 2.3.5 什么是安全的密码学Hash算法 # 强抗碰撞性（Collision Resistance） 弱抗碰撞性（Second pre-image Resistance） 单向性（Pre-image Resistance） 2.3.6 密码学Hash算法的分类 # MD5 MD5是一种比较常用的Hash算法，摘要值长度固定是128比特，MD5算法目前被证明已经不安全了，MD5算法违反了强抗碰撞性原则，但是还没有破坏单一性原则。 理论上经过2^80次运算就能产生碰撞，但目前最快只要经过2^63次运算就能破坏强抗碰撞性。 SHA SHA（Secure Hash Algorithms）算法是美国国家标准与技术研究院（NIST）指定的算法，SHA算法不是一个算法，而是一组算法，主要分为三类算法。 SHA-1 SHA-2 SHA-3 2.4 对称加密算法 # 建议使用AES算法，该算法是对称加密算法的标准算法 美国国家标准与技术研究院（National Institute of Standards and Technology, NIST）对众多的对称加密算法进行了考核，从安全性和效率进行了多方面评测，最终选取Rijndael算法作为对称加密算法的标准。以Rijndael算法为原型，创建了AES（Advanced Encryption Standard）算法，AES就是最终的对称加密算法标准。Rijndael算法和AES算法略微不同，但在理解的时候可以认为是相同的算法。 流密码算法 块密码算法 迭代模式 **ECB模式（Electronic Codebook）**是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。 ECB模式（Electronic Codebook）是最简单的一种迭代模式，这种迭代模式是存在安全问题的，一般不建议使用。 **CBC模式（Cipher Block Chaining）**是比较常见的一种迭代模式，解决了ECB模式的安全问题。 迭代运算数据块不能并行处理，只有处理完第n个数据块，才能继续处理第n+1个数据块。 **CTR模式（counter）**在迭代的时候，相当于是一个流密码的运行模式。每次迭代运算的时候要生成一个密钥流（keystream），生成密钥流的方法可以是任意的，但是各个密钥流之间是有关系的，最简单的方式就是密钥流不断递增，所以才叫作计数器模式。 2.4.1 流密码算法 # 2.4.2 块密码算法 # 2.4.3 填充标准 # 2.4.4 对称加密算法实践 # 2.5 消息验证码 # MAC值一般和原始消息一起传输，原始消息可以选择加密，也可以选择不加密，通信双方会以相同的方式生成MAC值，然后进行比较 CBC-MAC算法 HMAC算法 Hash-based Message Authentication Code 加密算法不能提供完整性，加密的同时必须引入MAC算法避免消息被篡改 使用者结合对称加密算法和MAC算法，提供机密性和完整性的模式也叫作Authenticated Encryption（AE）加密模式，主要有三种 Encrypt-and-MAC (E\u0026amp;M) MAC-then-Encrypt (MtE) 这种模式（图2-12）先对消息进行MAC计算，然后将消息和MAC值组合在一起再进行加密，最终的加密值再发送给接收方。在HTTPS中，一般使用这种模式进行处理，比如AES-128-CBC#PKCS7-HMAC-SHA256模式。 Encrypt-then-MAC (EtM) 不管是Encrypt-and-MAC模式还是MAC-then-Encrypt模式，使用不当的话都会存在安全问题，目前建议使用Encrypt-then-MAC模式。需要强调的是，这三种模式使用者必须分别处理，一旦处理不当，就可能会存在安全风险，那有没有一种方法在底层直接提供加密和MAC运算呢？无须使用者分别处理加密和MAC运算，这就是接下来讲解的AEAD模式。 AEAD加密模式 CCM模式 GCM模式 ChaCha20-Poly1305 2.5.1 什么是消息验证码 # 在密码学应用中，很多情况下，传递的消息没有必要加密，只要确保消息是完整且没有被篡改即可 比如开发者开发了一组天气API，接口返回的数据并没有加密，原因可能如下 接口的数据并不重要，对隐私性要求不高 加密和解密过程很消耗性能 所以接口的设计目标仅仅是避免消息被篡改，读者可能说那很简单啊，接口消息通过Hash算法得到一个摘要值，摘要值和接口消息同时作为接口内容返回不就解决问题了吗？ 攻击者对消息进行拦截，同时修改接口消息和消息的摘要值然后发送给接收方，接收方收到消息后，对接口消息计算摘要值，然后与接收到的摘要值进行比较，如果相同，接收方认为消息是完整的。可实际呢？消息虽然是完整的，但被篡改了，或者说消息被伪装了，但对于接收方来说，仅仅通过摘要值无法验证消息是不是篡改了 消息验证码算法的特点 证明消息没有被篡改，这和Hash算法类似。 消息是正确的发送者发送的，也就是说消息是经过验证的 如何确保消息是特定人发送的呢？在通信双方可以维护同一个密钥，只有拥有密钥的通信双方才能生成和验证消息验证码，消息验证码算法需要一个密钥，这和对称加密算法是一样的，通信双方在消息传递之前需要获得同样的密钥。 2.5.2 MAC 算法的种类 # CBC-MAC算法 CBC-MAC算法从块密码算法的CBC分组模式演变而来，简单地说就是最后一个密文分组的值就是MAC值 HMAC算法 在HTTP中应用最多的MAC算法是HMAC算法 HMAC（Hash-based Message Authentication Code）算法使用Hash算法作为加密基元，HMAC结合Hash算法有多种变种，比如HMAC-SHA-1、HMAC-SHA256、HMAC-SHA512 读者不要误以为HMAC算法就是Hash算法加上一个密钥，HMAC算法只是基于Hash算法的，内部的实现还是相当复杂的 2.5.3 消息验证码算法实践 # 2.5.4 加密算法不能提供完整性 # 完整性的意思是消息没有被篡改，仅仅加密数据是无法保证数据完整性的，初听起来可能觉得很奇怪。攻击者如果没有密钥就无法破解原文，也就无法篡改，数据必然是完整的。遗憾的是攻击者虽然无法破解数据，但是可以修改密文的部分数据，然后发送给接收者，接收者通过密钥发现能够解密，但是解密出来的值实际上不是原文，消息已经被修改了，也就是说加密操作不能提供完整性。 hash算法可以作为消息验证码吗？ # 是的，哈希算法可以作为消息验证码（MAC）的一部分，但单独使用哈希算法并不能直接构成消息验证码。消息验证码（MAC）是一种用于验证消息完整性和真实性的技术，通常需要结合密钥来确保安全性。\n哈希算法与MAC的区别\n哈希算法：如SHA-256、MD5等，用于生成固定长度的哈希值，确保数据完整性，但不涉及密钥，无法防止篡改。 消息验证码（MAC）：结合哈希算法和密钥，生成一个与消息和密钥相关的验证码，确保消息未被篡改且来自可信来源。 使用哈希算法构建MAC\n常见的方法是HMAC（Hash-based Message Authentication Code），它通过以下步骤生成MAC：\n将密钥与一个固定值（如ipad）异或，生成k_ipad。 将k_ipad与消息拼接，计算哈希值。 将密钥与另一个固定值（如opad）异或，生成k_opad。 将k_opad与步骤2的哈希值拼接，再次计算哈希值，得到最终的MAC。 示例\n假设使用SHA-256和密钥key，消息为message，HMAC生成过程如下：\n生成k_ipad和k_opad。 计算hash(k_ipad + message)。 计算hash(k_opad + hash(k_ipad + message))，得到MAC。 总结\n哈希算法可以作为MAC的基础，但单独使用无法提供完整的安全性。HMAC等结合密钥的方法才能确保消息的完整性和真实性。\n接收方怎么验证消息验证码？ # 接收方验证消息验证码（MAC）的过程需要确保消息的完整性和真实性。以下是验证步骤的详细说明：\n验证过程\n接收消息和MAC：\n接收方从发送方获取消息（明文）和对应的MAC值。 重新计算MAC：\n接收方使用与发送方相同的密钥和哈希算法（如HMAC-SHA256），对接收到的消息重新计算MAC值。 比较MAC值：\n将接收方计算出的MAC值与发送方提供的MAC值进行比较。 如果两者一致，说明消息未被篡改且来自可信来源。 如果不一致，说明消息可能被篡改或来源不可信。 具体步骤示例\n假设使用HMAC-SHA256算法，密钥为key，消息为message，发送方提供的MAC值为received_mac。\n接收方重新计算MAC：\n使用HMAC-SHA256算法，输入密钥key和消息message，计算出新的MAC值，记为computed_mac。 比较MAC值：\n比较computed_mac和received_mac： 如果computed_mac == received_mac，验证通过。 如果computed_mac != received_mac，验证失败。 注意事项\n密钥的安全性：\n密钥必须通过安全渠道共享，且只有发送方和接收方知道。如果密钥泄露，攻击者可以伪造MAC。 哈希算法的选择：\n使用安全的哈希算法（如SHA-256、SHA-3），避免使用已被破解的算法（如MD5、SHA-1）。 防止重放攻击：\nMAC只能验证消息的完整性和真实性，但不能防止重放攻击。如果需要防止重放攻击，可以结合时间戳或序列号。 伪代码示例\nimport hmac import hashlib def verify_mac(message, received_mac, key): # 重新计算MAC computed_mac = hmac.new(key.encode(), message.encode(), hashlib.sha256).hexdigest() # 比较MAC值 if computed_mac == received_mac: return True # 验证通过 else: return False # 验证失败 # 示例 message = \u0026#34;Hello, World!\u0026#34; received_mac = \u0026#34;a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e\u0026#34; key = \u0026#34;secret_key\u0026#34; if verify_mac(message, received_mac, key): print(\u0026#34;MAC验证成功：消息未被篡改。\u0026#34;) else: print(\u0026#34;MAC验证失败：消息可能被篡改或来源不可信。\u0026#34;) 总结\n接收方通过重新计算MAC并与接收到的MAC值进行比较来验证消息的完整性和真实性。这一过程依赖于共享密钥的安全性以及哈希算法的强度。\n发送方什么时候非接收方提供密钥的？ # 发送方和接收方之间的密钥共享是消息验证码（MAC）安全性的核心。密钥必须在通信开始之前通过安全渠道共享，且不能被第三方获取。以下是密钥共享的常见方式和时机：\n1. 预先共享密钥（Pre-shared Key, PSK）\n时机：在通信开始之前，发送方和接收方通过安全的线下或线上渠道共享密钥。 方式： 线下交换：面对面交换密钥（如写在纸上或通过硬件设备）。 安全通信协议：通过安全的通信协议（如TLS/SSL）在线交换密钥。 适用场景： 小规模系统或固定设备之间的通信（如物联网设备）。 需要长期使用的密钥。 2. 密钥协商协议\n时机：在通信开始时，通过密钥协商协议动态生成共享密钥。 方式： 使用Diffie-Hellman密钥交换等协议，在不安全的信道中安全地生成共享密钥。 结合公钥加密（如RSA）确保密钥交换的安全性。 适用场景： 需要动态生成密钥的场景（如即时通信、HTTPS）。 大规模分布式系统。 3. 基于公钥基础设施（PKI）的密钥分发\n时机：在通信开始时，通过公钥加密技术分发密钥。 方式： 发送方使用接收方的公钥加密密钥，接收方使用自己的私钥解密。 结合数字证书验证公钥的真实性。 适用场景： 需要高安全性的场景（如银行交易、政府通信）。 大规模系统中身份验证和密钥分发。 4. 密钥派生\n时机：在通信过程中，通过主密钥派生出会话密钥。 方式： 使用密钥派生函数（如HKDF）从主密钥派生出新的密钥。 主密钥可以通过预先共享或密钥协商获得。 适用场景： 需要频繁更换密钥的场景（如实时通信）。 增强密钥安全性。 密钥共享的安全性要求\n保密性： 密钥在传输和存储过程中必须保密，不能被第三方获取。 完整性： 密钥在传输过程中不能被篡改。 真实性： 密钥必须来自可信的发送方。 示例场景\nHTTPS通信： 客户端和服务器通过TLS握手协议协商对称密钥，用于后续的MAC计算和加密。 物联网设备： 设备在出厂时预置共享密钥，用于设备与服务器之间的通信。 即时通信： 使用Diffie-Hellman密钥交换生成会话密钥，用于消息的MAC验证和加密。 总结\n发送方和接收方之间的密钥共享通常在通信开始之前或通信开始时通过安全渠道完成。具体方式包括预先共享密钥、密钥协商协议、公钥加密技术或密钥派生。密钥的安全性直接决定了MAC的有效性，因此密钥管理是消息验证码系统的关键环节。\n2.6 公开密钥算法(非对称加密) # 相比对称加密算法来说，公开密钥算法尤其是RSA算法运算非常缓慢，一般情况下，需要加密的明文数据都非常大，如果使用公开密钥算法进行加密，运算性能会惨不忍睹。公开密钥算法在密码学中一般进行密钥协商或者数字签名，因为这两者运算的数据相对较小。 公开密钥算法最重要和最广泛使用的算法就是RSA算法，该算法是Ron Rivest、Adi Shamir、Leonard Adleman三个人创建的，以三个人名字的首字母命名。 和对称密钥算法一样，公开密钥算法也有使用标准，公开密钥算法的标准称为PKCS（Public Key Cryptography Standards），这个标准由很多的子标准组成，指导使用者正确地使用公开密钥算法。 RSA加密算法的应用场景 单步加密 双向加密 2.6.1 理解RSA的内部结构 # 2.6.2 PKCS标准 # 2.6.3 RSA加密算法的应用场景 # 2.6.4 RSA加密算法实践 # 2.7 密钥 # 口令（password或者passphrase）也可以认为是一种密钥，都需要保密，不能泄露。口令和密钥最大的区别在于口令更容易生成、更容易记忆，一般情况下口令记录在人脑中，口令可以认为是一种弱密钥，由固定的字母、数字、符号组成，长度也有一定的限制。 在密码学中很少直接用口令进行加密，容易受到暴力攻击和字典攻击，暴力攻击的原理在于口令都是由固定的字母、数字、符号组成的，攻击者可以生成所有可能的口令，然后使用口令迭代去解密，一旦成功解密，就表示口令被暴力破解了。 字典攻击本质上也是一种暴力攻击，只是能够加快破解效率（时间和空间），人类一般使用常见的字母、数字、符号组合成口令（比如很多人喜欢用字母password作为口令），攻击者可以将常见的口令保存在一张字典中，然后用字典中的口令迭代去解密密文。除了字典攻击，还有彩虹表攻击方式，破解的关键点就在于口令相对容易猜测和预测。 密钥存储和传输 2.7.1 生成密钥 # 2.7.2 口令和PEB算法 # 2.7.3 密钥存储和传输 # 2.8 密钥协商算法 # RSA密钥协商算法 DH密钥协商算法 Diffie-Hellman算法，简称DH算法，是Whitfield Diffie和Martin Hellman在1976年公布的一个公开密钥算法，它的历史比RSA公开密钥算法更悠久。 使用RSA密钥协商算法传输会话密钥的时候，会话密钥完全由客户端控制，并没有服务器的参与，所以叫作密钥传输。 而DH算法确切地说，实现的是密钥交换或者密钥协商，DH算法在进行密钥协商的时候，通信双方的任何一方无法独自计算出一个会话密钥，通信双方各自保留一部分关键信息，再将另外一部分信息告诉对方，双方有了全部信息才能共同计算出相同的会话密钥。 2.8.1 RSA密钥协商算法 # 2.8.2 DH密钥协商算法 # Diffie-Hellman算法，简称DH算法，是Whitfield Diffie和Martin Hellman在1976年公布的一个公开密钥算法，它的历史比RSA公开密钥算法更悠久。 使用RSA密钥协商算法传输会话密钥的时候，会话密钥完全由客户端控制，并没有服务器的参与，所以叫作密钥传输。 而DH算法确切地说，实现的是密钥交换或者密钥协商，DH算法在进行密钥协商的时候，通信双方的任何一方无法独自计算出一个会话密钥，通信双方各自保留一部分关键信息，再将另外一部分信息告诉对方，双方有了全部信息才能共同计算出相同的会话密钥。 客户端和服务器端协商会话密钥的时候，需要互相传递消息，消息即使被挟持，攻击者也无法计算出会话密钥，因为攻击者没有足够的信息（通信双方各自保留的信息）计算出同样的会话密钥。 参数文件 在使用DH算法之前，先要生成一些公共参数，这些参数是公开的，无须担心攻击者能够看到这些参数值，这些参数可以由客户端或者服务器端生成，一般由服务器端生成。参数在协商密钥之前必须发给对端。 参数有两个，分别是p和g, p是一个很大的质数，建议长度在1024比特以上，这个长度也决定了DH算法的安全程度，g表示为一个生成器，这个值很小，可以是2或者5。通过参数，服务器端和客户端会生各自生成一个DH密钥对，私钥需要保密。 DH算法处理过程 通信双方的任何一方可以生成公共参数p和g，这两个数是公开的，被截获了也没有任何关系，一般情况下由通信双方的服务器端计算。 客户端连接服务器端，服务器端将参数发送给客户端。 客户端根据公开参数生成一个随机数a，这个随机数是私钥，只有客户端知道，且不会进行发送，然后计算Yc = (g ^ a) mod p, Yc就是公钥，需要发送给服务器端。 服务器端根据公开参数生成一个随机数b，这个随机数是私钥，需要服务器端保密，然后计算Ys = (g ^ b) mod p, Ys是公钥，需要发送给客户端。 客户端发送Yc数值给服务器端，服务器端计算Z = (Yc ^ b) mod p。 服务器端发送Ys数值给发送方，客户端计算Z = (Ys ^ a) mod p。 服务器端和客户端生成的Z就是会话密钥，协商完成。 这里的关键点就是私钥a和b不应该泄露，分别由通信双方维护，另外Ys和Yc进行互换才能完成协商，这两个值被截获对攻击者来说没有任何价值。换句话说，只要私钥不发生泄露，攻击者即使有了Ys和Yc也不会计算出会话密钥。 看到幂运算和求模过程，就知道DH算法和RSA算法一样，如果需要破解密钥，就必须面临离散对数和因式分解问题。和其他公开密钥算法一样，只要确保一定的密钥长度，DH算法具有很高的安全性。RSA和DH密钥对一样能够受到暴力攻击，提高密钥对的长度能够有效避免攻击。 2.8.3 DH算法分类 # 静态DH算法(DH算法) 静态DH算法，p和g两个参数永远是固定的，而且服务器的公钥（Ys）也是固定的。和RSA密钥协商算法一样，一旦服务器对应的DH私钥泄露，就不能提供前向安全性。静态DH算法的好处就是避免在初始化连接时服务器频繁生成参数p和g，因为该过程是非常消耗CPU运算的。 临时DH算法(EDH算法) 在每次初始化连接的时候，服务器都会重新生成DH密钥对，DH密钥对仅仅保存在内存中，不像RSA那样私钥是保存在磁盘中的，攻击者即使从内存中破解了私钥，也仅仅影响本次通信，因为每次初始化的时候密钥对是动态变化的。更安全的是，协商出会话密钥后，a和b两个私钥可以丢弃，进一步提升了安全性，在有限的时间、有效的空间生成了密钥对。 2.8.4 DH密钥协商算法实践 # 2.9 椭圆曲线密码学 # 为了保证DH的密钥对不被破解，提升安全性的主要手段就是增加密钥对的长度，但是长度越长，性能越低。公开密钥算法是一个O(n)操作，n就是密钥对的长度，n越小，操作越快。为了解决性能问题，需要了解下椭圆曲线密码学（Elliptic Curve Cryptography），简称为ECC。 ECC是新一代的公开密钥算法，主要的优点就是安全性，极短的密钥能够提供很大的安全性。比如224比特的ECC密钥和2048比特的RSA密钥可以达到同样的安全水平，由于ECC密钥具有很短的长度，运算速度非常快。ECC基于非常复杂的算法，到目前位置，对于ECC进行逆操作还是很难的，数学上被证明是不可破解的，ECC算法的优势就是性能和安全性非常高。 在具体应用的时候，ECC可以结合其他公开密钥算法形成更快、更安全的公开密钥算法，比如结合DH密钥协商算法组成ECDH密钥协商算法，结合数字签名DSA算法组成ECDSA数字签名算法。 2.9.1 ECC算法的基本模型 # 2.9.2 使用OpenSSL了解命名曲线 # 2.9.3 ECDH协商算法 # 2.9.4 命名曲线 # 2.10 数字签名 # 2.10.1 数字签名的用途 # 身份验证 私钥只有密钥对的生成者持有，如果不考虑密钥泄露的问题，私钥拥有者使用密钥（注意不是加密操作）签署一条消息，然后发送给任意的接收方，接收方只要拥有私钥对应的公钥，就能成功反解签署消息，由于只有私钥持有者才能“签署”消息，不能抵赖说这条签署消息不是他发送的，这就是数字签名技术的全部。 2.10.2 数字签名的流程 # 2.10.3 RSA数字签名算法 # RSA算法的用途非常广泛，可以进行数字签名。和RSA加密算法相似，不同的是，RSA加密算法是公钥加密，私钥解密；RSA签名算法是私钥签名，公钥验证签名。 2.10.4 RSA数字签名实践 # 2.11 DSA数字签名算法 # 防篡改和防伪造的区别是什么 # 防篡改和防伪造是信息安全中的两个重要概念，虽然它们都涉及数据的完整性和真实性，但它们的关注点和应用场景有所不同。以下是它们的区别：\n1. 防篡改（Tamper Resistance）\n定义：防止数据在传输或存储过程中被未经授权的修改。 关注点：确保数据的完整性，即数据未被篡改。 实现方式： 使用哈希算法（如SHA-256）生成数据的哈希值，接收方通过比较哈希值验证数据是否被篡改。 使用消息验证码（MAC）或数字签名，结合密钥确保数据的完整性。 应用场景： 文件传输：确保文件在传输过程中未被修改。 软件更新：确保下载的软件包未被篡改。 数据库记录：确保存储的数据未被恶意修改。 2. 防伪造（Forgery Resistance）\n定义：防止攻击者伪造数据或身份，冒充合法用户或系统。 关注点：确保数据的真实性，即数据来源可信。 实现方式： 使用数字签名，发送方用私钥对数据签名，接收方用公钥验证签名，确保数据来自可信来源。 使用公钥基础设施（PKI）和数字证书，验证用户或系统的身份。 应用场景： 身份认证：防止攻击者冒充合法用户登录系统。 电子合同：确保合同签署者的身份真实。 区块链交易：确保交易发起者的身份真实。 对比总结\n特性 防篡改 防伪造 目标 确保数据未被修改 确保数据来源可信 关注点 数据完整性 数据真实性 实现技术 哈希算法、MAC 数字签名、PKI 典型应用 文件传输、软件更新 身份认证、电子合同 示例\n防篡改： 发送方发送文件并附带哈希值，接收方计算哈希值并比对，确保文件未被篡改。 防伪造： 发送方用私钥对文件签名，接收方用发送方的公钥验证签名，确保文件来自可信来源。 总结\n防篡改关注的是数据是否被修改，确保数据的完整性。 防伪造关注的是数据是否来自可信来源，确保数据的真实性。 两者通常结合使用，以同时保障数据的完整性和真实性。例如，数字签名既可以防篡改（验证数据完整性），也可以防伪造（验证数据来源）。 第3章 宏观理解TLS # 解决HTTP三大问题的通用解决方案就是TLS协议 读者可能听说过**TLS（Transport Layer Security）协议，也可能听说过SSL（Secure Sockets Layer）**协议，在理解的时候可以认为两者是一样的，TLS协议是SSL协议的升级版，本书使用TLS/SSL协议代表TLS协议或者SSL协议。 TLS/SSL协议位于应用层协议和TCP之间，构建在TCP之上，由TCP协议保证数据传输的可靠性，任何数据到达TCP之前，都经过TLS/SSL协议处理。 对于应用层协议来说，它无须过多改变，引入TLS/SSL协议即可保证数据机密性和完整性。任何应用层协议（HTTP、SMTP、FTP、其他自定义应用层协议）都可以结合TLS/SSL协议。 TLS/SSL协议一般构建在TCP之上，也可以构建在UDP之上，称为DTLS（Datagram Transport Layer Security）协议，DTLS协议在Web中使用得比较少。 3.1 TLS/SSL 协议综述 # 3.2 TLS/SSL协议背后的算法 # 为了对数据进行加密，可以采用对称加密算法或者公开密钥加密算法，有加密算法必定就有MAC算法，两者是一个整体。 使用何种密钥协商算法也是由客户端和服务器端共同决定的，或者说由密码套件决定，对于HTTPS来说，在连接阶段必须协商出一个双方认可的密码套件，密码套件是各个密码学算法组合。 在HTTPS中，一般采用RSA或者DH算法协商预备主密钥 3.2.1 加密算法和MAC算法 # 为了对数据进行加密，可以采用对称加密算法或者公开密钥加密算法，有加密算法必定就有MAC算法，两者是一个整体 使用公开密钥加密算法的缺点就是运算慢，尤其是HTTP传输的数据都非常大，所以在大部分Web应用中很少使用公开密钥算法进行加密解密运算。唯一的可行方案就是对称加密算法，比如AES、DES算法。在Web应用中使用比较多的MAC算法是HMAC算法，比如HMAC-SHA-1、HMAC-SHA256算法。 协商 本章处处可见协商两个字，所以会重点描述协商的概念，在TLS/SSL协议中，协商的另外一个关键名词就是密码套件（CipherSuite），协商的结果就是双方都认可的密码套件，密码套件决定了本次连接采用哪一种加密算法、密钥协商算法、HMAC算法 3.2.2 密钥协商算法 # 不管采用哪种密钥协商算法，客户端和服务器端最终会协商出预备主密钥（Premaster Secret），预备主密钥转换为主密钥，主密钥最终再转换为密钥块。 预备主密钥的特点 每个客户端和服务器端初始化连接的时候生成预备主密钥，每次的值都是不一样的。 预备主密钥在会话结束后（连接关闭后），会自动释放，这是很关键的特性，预备主密钥不会持久保存。 预备主密钥必须保证是机密的，确保攻击者无法解密出预备主密钥，也无法猜测出预备主密钥。 在HTTPS中，一般采用RSA或者DH算法协商预备主密钥 RSA 客户端向服务器端发起连接请求，服务器端发送RSA密钥对的公钥给客户端。 客户端通过随机数生成器生成一个预备主密钥，用服务器的公钥加密并发送给服务器端。 服务器解密预备主密钥，假如能够正确解密，则说明客户端和服务器端共同协商出一个预备主密钥。 DH算法 流程 客户端向服务器端发起连接请求 服务器端生成一个RSA密钥对，并将公钥发送给客户端 服务器端生成DH参数和服务器DH密钥对，用RSA私钥签名DH参数和服务器DH公钥，最后将签名值、DH参数、服务器DH公钥发送给客户端 客户端通过服务器RSA的公钥验证签名，获取到DH参数和服务器DH公钥 客户端通过DH参数生成客户端的DH密钥对，并将客户端DH公钥发送给服务器端 客户端通过客户端DH私钥和服务器端DH公钥计算出预备主密钥 服务器端接收到客户端的DH公钥，结合服务器的DH私钥计算出预备主密钥。 最终客户端和服务器端计算出的预备主密钥能够保持一致。 分类 静态DH算法 临时DH算法(EDH算法) 在HTTPS中，服务器在发送DH参数和服务器DH公钥之前会对这两个值进行签名运算，确保传递的值没有被篡改和伪造，也可以看出HTTPS就是使用多种算法确保安全性 在HTTPS中，使用DH密钥协商算法需要客户端和服务器端经过多次通信才能协商出预备主密钥，而RSA密钥协商算法只要很少的步骤就能协商出。 3.2.3 前向安全性 # 前向安全性（Perfect Forward Secrecy）是TLS/SSL协议中很重要的一个话题，必须充分理解。RSA密钥协商算法和静态DH算法都不能确保前向安全 对于动态DH算法来说，客户端每次连接的时候，DH密钥对都是重新生成的，即使在某次连接中泄露了，也仅仅会导致本次连接中的加密数据被破解，安全风险相对较小。 3.2.4 密钥衍生算法 # **密钥衍生算法（Key Derivation Function, KDF）**是一种用于从初始密钥（如密码或主密钥）生成一个或多个密钥的密码学算法。它的主要目的是增强密钥的安全性，并生成适合特定用途的密钥（如加密密钥、认证密钥等）。\n密钥衍生算法在HTTPS是怎么应用的？ # 密钥衍生算法在HTTPS中的应用主要体现在安全地生成会话密钥，确保客户端与服务器之间的通信安全。具体来说，这个过程通常涉及以下几个步骤：\n握手协议：当客户端（如浏览器）尝试与服务器建立HTTPS连接时，首先会通过SSL/TLS握手协议开始通信。在这个过程中，双方会交换一些必要的信息用于生成对称密钥。\n密钥交换算法：为了安全地协商出一个共享的秘密（即预主密钥），客户端和服务器可能会使用诸如RSA、Diffie-Hellman等密钥交换算法。例如，在基于RSA的密钥交换中，客户端生成一个随机的预主密钥并用服务器的公钥加密后发送给服务器；而在Diffie-Hellman方法中，则是通过数学运算来安全地生成共享秘密。\n密钥衍生函数（KDF）：一旦预主密钥确定下来，就会使用密钥衍生函数（如HKDF或PBKDF2）从预主密钥生成实际使用的对称密钥。这些函数接受输入（如预主密钥、客户端和服务器随机数等）并通过一系列操作生成最终用于加密通信的密钥。这一步骤增强了安全性，因为它增加了攻击者预测密钥的难度。\n数据加密：使用上述过程中生成的对称密钥，客户端和服务器就可以采用对称加密算法（如AES）来加密和解密它们之间传输的数据，保证了数据的保密性和完整性。\n总之，密钥衍生算法在HTTPS中的作用至关重要，它不仅保障了密钥的安全生成，还提高了整个通信过程的安全性，防止潜在的信息泄露和中间人攻击。\n在HTTPS中，会使用密钥衍生算法生成哪些密钥，能具体列举出来吗？ # 在HTTPS（实际上是其底层的SSL/TLS协议）中，密钥衍生算法用于生成多个密钥和参数，以确保通信的安全性。以下是通过密钥衍生过程通常会生成的一些关键元素：\n客户端写密钥（Client Write Key）：这是用来加密从客户端发送到服务器的数据的对称密钥。\n服务器写密钥（Server Write Key）：相对地，这是用来加密从服务器发送到客户端的数据的对称密钥。\n客户端写MAC密钥（Client Write MAC Key）：用于客户端数据完整性验证的消息认证码(MAC)密钥，在现代TLS版本中被基于哈希的消息认证码(HMAC)替代。\n服务器写MAC密钥（Server Write MAC Key）：用于服务器数据完整性验证的消息认证码(MAC)密钥，在现代TLS版本中也被基于哈希的消息认证码(HMAC)替代。\n初始化向量（IV）：对于某些加密模式（如CBC模式），需要一个初始化向量来确保即使是相同的数据块使用相同的密钥加密时也会产生不同的输出。不过，在使用AEAD（如GCM模式）的情况下，这个IV有时也被称为nonce，并且它与密钥一起用于提供数据完整性和保密性。\n临时密钥材料（Ephemeral Keys）：在一些密钥交换机制中，例如短暂的Diffie-Hellman（DHE或ECDHE），会产生临时密钥材料用于一次性的密钥协商，增加了前向安全性。\n这些密钥和参数是通过密钥衍生函数（KDF），比如在TLS 1.2及之前使用的PRF（伪随机函数），以及在TLS 1.3中更明确地定义的KDFs（如HKDF）从预主密钥、客户端随机数、服务器随机数等信息派生出来的。每个连接都会生成一套新的密钥，从而保证了通信的安全性和隐私保护。\n3.2.5 中间人攻击 # 所谓中间人攻击就是服务器传递给客户端的公钥可能被攻击者替换，这样安全性就荡然无存了。 客户端向服务器端发起连接请求，期望获取服务器的RSA公钥，攻击者劫持了这个请求。 攻击者自己生成一对RSA密钥对，然后将攻击者的RSA公钥发送给客户端。 攻击者然后再向服务器端发送请求，服务器生成RSA密钥对，将RSA公钥发送给客户端，实际上是发送给攻击者。 客户端通过攻击者的公钥加密密钥块并发送给服务器，实际上是发送给攻击者。 攻击者用自己的RSA私钥解密了密钥块A，然后自己生成一个密钥块B，用服务器的RSA公钥加密后发送给服务器端。 服务器端接收到请求后，用自己的RSA私钥解密出攻击者的密钥块B。 客户端使用攻击者的密钥块A，采用AES算法加密数据并发送给服务器端，实际上是发送给攻击者。 攻击者使用自己的密钥块A、采用AES算法解密出明文，客户端相当于泄露了隐私，攻击者使用密钥块B，采用AES算法加密明文后发送给服务器。 服务器使用密钥块B，采用AES算法加密数据并发送给攻击者。 攻击者使用密钥块B，采用AES算法解密出明文数据，此时客户端和服务器端的加密数据被成功破解。 在SSL/TLS协议（HTTPS的安全基础）中，\u0026ldquo;密钥块\u0026rdquo;（Key Block）是一个概念，它指的是通过密钥衍生函数（KDF）从预主密钥生成的一系列加密材料的集合。这个密钥块包含了用于保护客户端和服务器之间通信所需的所有密钥和参数。\n客户端和服务器之间只传递预主密钥，密钥块是两边分别计算出来的，是这样吗 # 是的，您的理解基本正确。在SSL/TLS协议中，客户端和服务器之间并不会直接传递完整的密钥块，而是通过交换信息来安全地生成一个预主密钥（Pre-Master Secret），然后各自独立地使用这个预主密钥以及双方在握手初期交换的随机数（Client Random和Server Random）来计算出最终的密钥材料，即所谓的密钥块（Key Block）。具体过程如下：\n密钥交换：根据所采用的具体密钥交换算法（如RSA、Diffie-Hellman等），客户端和服务器会进行一系列的操作来安全地确定一个预主密钥。例如，在基于RSA的密钥交换中，客户端生成一个预主密钥并用服务器的公钥加密后发送给服务器；而在Diffie-Hellman方法中，则是通过数学运算来安全地生成共享的秘密。\n生成密钥块：一旦预主密钥确定下来，客户端和服务器都会使用相同的密钥衍生函数（KDF），比如TLS 1.2中的伪随机函数（PRF）或TLS 1.3中的HKDF，结合预主密钥和之前交换的随机数值，分别独立计算出所需的密钥材料。这包括了客户端写密钥、服务器写密钥、客户端写MAC密钥、服务器写MAC密钥（在TLS 1.2及之前版本中）、初始化向量（IV）或nonce等。\n独立计算的优势：这种方式不仅减少了通信负担，还增强了安全性。因为预主密钥本身并不直接用于加密通信，而是用于派生出实际使用的对称密钥和其他安全参数。即使攻击者能够拦截到所有公开交换的信息，他们也无法轻易推算出最终的密钥材料，除非他们能破解密钥交换算法或者预测KDF的结果。\n因此，客户端和服务器确实只交换必要的信息以确定预主密钥，并且之后各自独立计算出密钥块，这种机制确保了通信的安全性和效率。\n3.2.6 PKI # 和身份证一样，CA机构会签发一张证书（可以理解为就是一张身份证），证书中包含了一些关键信息，比如服务器的主机、服务器的公钥 CA机构也拥有一个密钥对，比如RSA密钥对（与服务器的RSA密钥对没有任何关系），它用私钥对证书进行数字签名，将签名的证书发送给服务器。浏览器再连接服务器，服务器发送证书给浏览器，浏览器拥有CA机构的公钥（内嵌在浏览器中），然后校验证书的签名，一旦校验成功，就代表这个证书是可信的CA机构签发的。 3.3 HTTPS总结 # 3.3.1 握手 # 1 认证 # 客户端在进行密钥交换之前，必须认证服务器的身份，否则就会存在中间人攻击，而服务器实体并不能自己证明自己，所以需要通过CA机构来进行认证，认证的技术解决方案就是签名的数字证书。证书中会说明CA机构采用的数字签名算法，客户端获取到证书后，会采用相应的签名算法进行验证，一旦验证通过，则表示客户端成功认证了服务器端的身份。 2 密码套件协商 # 密码套件是一系列密码学算法的组合，主要包括多个密码学算法 身份验证算法 密码协商算法 加密算法或者加密模式 HMAC算法的加密基元 PRF算法的加密基元，需要注意的是，不同的TLS/SSL协议版本、密码套件，PRF算法最终使用的加密基元和HMAC算法使用的加密基元是不一样的 TLS_密钥协商_身份验证_WITH_加密算法_HMAC或PRF算法 密码套件的例子 TLS_DH_RSA_WITH_AES_CBC_128_SHA RSA：身份验证算法，这个称呼具备一定的干扰性，本例中的RSA表示证书中包含的服务器公钥是RSA公钥，对于不同的密钥协商算法，RSA公钥的作用也不一样。读者可能会问，为何没有涉及身份验证，身份验证对应的数字签名算法由证书指定，客户端获取到证书的时候，证书会说明该证书由何种数字签名算法签名，验证证书签名的公钥和服务器的公钥没有任何关系。 DH：表示密钥协商算法，用来协商出预备主密钥（PremasterSecret），那么客户端如何获取DH参数呢？服务器会发送DH参数和服务器DH公钥。 AES_CBC_128，表示加密算法，用于保证机密性，在本例中使用的是AES对称加密算法、加密模式是CBC模式、密钥长度是128比特。 SHA：表示HMAC算法，用于保证完整性，在本例中是HMAC_SHA1算法。 PRF算法：PRF算法采用的加密基元不一定是SHA1算法，由TLS/SSL协议版本和协商出的密码套件决定。 TLS_RSA_WITH_AES_CBC_128_SHA 理解密码套件的几个关键点 密码套件是密码学算法的组合，但并不是随便组合的，每一种密码套件都由IANA指定和分配。 不同的TLS/SSL版本，密码套件的解释有细微的差别，比如在TLS v1.0版本中，PRF具体使用的算法是硬编码的（不依赖于密码套件），是HMAC-MD5和HMAC-SHA1算法的组合，而在TLS v1.2版本中，PRF默认采用的是HMAC-SHA256算法。 不同的TLS/SSL版本，有不同的密码套件组合，主要是从安全性和性能的角度考虑，版本越高，包含的密码套件安全性就更高，也会废弃一些相对不安全的密码套件。 密码套件在服务器端是可以配置的，比如Nginx服务器可以通过指令配置密码套件，可以去除一些不安全的密码套件。 客户端和服务器端选择密码套件的基本原则就是优先级，从安全角度看应该由服务器决定协商出的最终密码套件。 密码套件仅仅是一个配置，不代表服务器就支持该套件，比如服务器可以配置TLS_ECDHE_WITH_ECDSA_AES_128_GCM_SHA256套件，但是服务器上并没有ECDSA密钥对，那么最终不能协商出该密码套件。 3 密钥协商 # 如果使用RSA密钥协商算法，那么服务器的密钥对非常重要，服务器的公钥不仅仅要进行身份验证，还要进行密钥协商，一旦私钥泄露，就失去了前向安全性。 如果使用静态DH算法，服务器证书中会包含固定的DH参数和DH公钥，也会失去前向安全性，所以现在密码套件很少支持DH算法，CA机构在签发证书的时候也不会包含DH参数和DH公钥。 为了保持前向安全性，目前使用最多的密钥协商算法就是DHE算法和ECDHE算法，这两个算法和服务器的密钥对关系不大，也就是说密钥的协商不取决于服务器的密钥对，所以服务器的私钥即使泄露，也不会造成太大的安全风险。 4 握手消息完整性校验 # 握手过程中传递的消息全部是明文传输的，任何攻击者都能截获，握手消息存在被篡改的可能性 读者会说不是有身份验证了吗，怎么还存在中间人攻击？确实是这样，证书校验能够确保服务器的真实身份，但密钥协商是身份校验之后的过程，攻击者无法攻击身份校验过程，但可以在后续的握手过程中篡改消息 下面简单描述TLS/SSL协议如何对消息进行加密和完整性保护 客户端将发送和接收到的所有握手消息组合在一起，然后计算出摘要数据，握手层使用密钥块对摘要数据进行加密和完整性保护，然后发送给服务器。 服务器接收到验证消息后，使用加密块解密出摘要数据。 紧接着服务器自行计算发送和接收的所有握手消息，再计算出消息的摘要数据，如果摘要数据和解密出的摘要数据相同，代表客户端发送的消息没有被篡改。 Finished消息：客户端和服务器各自发送“Finished”消息，这些消息包含整个握手过程的一个哈希值（通常是基于之前所有握手消息的摘要），并用新协商的密钥进行加密。这一步骤用于最终验证握手过程的完整性和一致性。 完整性校验：通过比较收到的“Finished”消息中的哈希值与本地计算出的握手消息摘要是否一致，双方可以确认对方确实参与了相同的握手流程，且没有发生任何篡改。\nFinished 消息包含的哈希值是怎么计算的，以及是怎么比较的 # 在SSL/TLS握手过程中，\u0026ldquo;Finished\u0026quot;消息中的哈希值是通过特定的计算方法生成的，并且用于确保握手过程的完整性和一致性。以下是详细的步骤和机制说明：\n计算 \u0026ldquo;Finished\u0026rdquo; 消息中的哈希值\n握手上下文（Handshake Context）：\n在整个握手过程中，客户端和服务器会交换一系列的消息，如Client Hello、Server Hello、Certificate、Server Key Exchange、Client Key Exchange等。 这些消息的内容会被收集起来形成一个握手上下文（handshake context），通常是一个字节流，包含了所有已发送和接收的手握消息。 PRF（伪随机函数）或HKDF：\nSSL/TLS使用伪随机函数（PRF）或基于哈希的消息认证码（HMAC）来生成密钥材料和其他安全参数。 在TLS 1.2及之前版本中，PRF被用来生成“Finished”消息中的验证数据（verify_data）。 在TLS 1.3中，使用了更现代的HKDF（Key Derivation Function）来进行类似的计算。 计算哈希值：\nTLS 1.2及之前版本： PRF根据以下公式计算出“Finished”消息中的verify_data： verify_data = PRF(master_secret, \u0026#34;client finished\u0026#34;, Hash(handshake_messages)) [for client] verify_data = PRF(master_secret, \u0026#34;server finished\u0026#34;, Hash(handshake_messages)) [for server] 其中： master_secret 是通过密钥交换算法生成的主密钥。 \u0026quot;client finished\u0026quot; 或 \u0026quot;server finished\u0026quot; 是标签字符串，用于区分客户端和服务器的计算。 Hash(handshake_messages) 是对所有握手消息进行哈希运算的结果（通常是SHA-256或其他协商的哈希算法）。 TLS 1.3： 使用HKDF提取和扩展函数来生成verify_data： verify_data = HKDF-Expand-Label(transcript_hash, \u0026#34;finished\u0026#34;, \u0026#34;\u0026#34;, length) 其中： transcript_hash 是所有握手消息的哈希摘要。 \u0026quot;finished\u0026quot; 是标签字符串。 length 是所需输出的长度。 发送和比较 \u0026ldquo;Finished\u0026rdquo; 消息\n客户端发送 \u0026ldquo;Finished\u0026rdquo; 消息：\n客户端根据上述方法计算出自己的verify_data，并将其作为“Finished”消息的一部分加密后发送给服务器。 服务器发送 \u0026ldquo;Finished\u0026rdquo; 消息：\n服务器同样按照相同的方法计算出自己的verify_data，并将其作为“Finished”消息的一部分加密后发送给客户端。 比较哈希值：\n客户端验证服务器的 “Finished” 消息：\n客户端收到服务器的“Finished”消息后，解密并从中提取出verify_data。 然后，客户端使用相同的PRF或HKDF算法，基于自己记录的所有握手消息重新计算预期的verify_data。 如果计算结果与接收到的verify_data匹配，则认为握手过程未被篡改，服务器的身份是可信的。 服务器验证客户端的 “Finished” 消息：\n同样地，服务器也会对接收到的客户端“Finished”消息进行验证，确保客户端参与了相同的握手流程，并且没有发生任何篡改。 示例\n假设在一个TLS 1.2握手过程中：\n握手消息包括：Client Hello、Server Hello、Certificate、Server Key Exchange、Client Key Exchange、Change Cipher Spec。 客户端和服务器各自计算出 Hash(handshake_messages)。 使用PRF和 master_secret 计算出各自的verify_data： Client Finished: PRF(master_secret, \u0026#34;client finished\u0026#34;, Hash(handshake_messages)) Server Finished: PRF(master_secret, \u0026#34;server finished\u0026#34;, Hash(handshake_messages)) 双方将这些verify_data作为“Finished”消息的一部分发送给对方，并在接收到对方的“Finished”消息时重新计算verify_data进行比较。 通过这种方式，\u0026ldquo;Finished\u0026quot;消息不仅确认了双方已经成功完成了密钥交换，还验证了整个握手过程的完整性和一致性，从而有效防止了中间人攻击和其他形式的数据篡改。\n使用Charles来解密https请求内容的原理是什么？ # 使用Charles等代理工具解密HTTPS请求内容的基本原理涉及到中间人（Man-in-the-Middle, MITM）技术的应用。以下是详细步骤和原理说明：\n基本原理\n安装Charles的根证书：\n为了能够解密HTTPS流量，用户首先需要在设备或浏览器中安装Charles提供的自签名根证书。 这个证书使得Charles可以作为受信任的CA（证书颁发机构），从而生成用于与目标网站通信的伪造证书。 拦截HTTPS连接：\n当客户端尝试建立一个HTTPS连接时，Charles作为代理服务器会拦截这个请求。 Charles代替原始服务器向客户端发送自己签发的伪造证书（基于之前安装的根证书），而不是服务器的真实证书。 客户端验证伪造证书：\n客户端收到伪造证书后，会根据已安装的信任证书列表进行验证。 因为用户已经安装了Charles的根证书，所以客户端认为这个伪造证书是有效的，并继续建立加密连接。 双向解密与重新加密：\nCharles能够解密从客户端发来的加密请求，因为它拥有对应的私钥（用于伪造证书的那一对公私钥）。 解密后的明文信息被显示给用户查看。 然后，Charles使用目标服务器的真实证书与服务器建立另一个独立的HTTPS连接，并将请求转发给服务器。 对于响应数据，Charles同样先从服务器接收加密响应，解密，展示给用户，再用伪造证书加密返回给客户端。 注意事项\n安全性风险：虽然这种方法对于调试和开发非常有用，但它也存在显著的安全隐患。如果恶意软件利用类似的技术，它可以窃听用户的敏感信息。因此，在公共网络或不受信任的环境中不应该随意安装未知来源的根证书。\n透明度和同意：实际操作中，使用这类工具通常要求明确告知用户并获得其同意，尤其是在涉及处理个人敏感信息时。\n通过这种方式，Charles能够在不破坏原有HTTPS加密机制的前提下，实现对HTTPS流量的监控和分析。这对于开发者来说是一个强大的工具，可以帮助他们调试应用程序、检查API调用以及确保网络安全配置正确无误。然而，使用此类工具时应谨慎考虑隐私和安全问题。\n在使用charles进行https抓包的时候，有些接口会连接失败，这是什么原因 # 在使用Charles进行HTTPS抓包时，如果某些接口连接失败，可能有以下几个原因：\n证书未正确安装\n客户端未信任Charles的根证书：确保已在客户端（如手机或浏览器）上正确安装并信任了Charles的根证书。对于移动设备，还需要特别注意是否针对该设备类型正确配置了证书。 应用不支持自定义证书：一些应用程序为了增强安全性，内置了对特定证书颁发机构（CA）的信任列表，并拒绝接受非官方或用户安装的证书。这种情况下，即使你安装了Charles的证书，这些应用也不会信任它，从而导致HTTPS请求失败。 SSL Pinning\nSSL Pinning技术的应用：部分应用程序实施了SSL Pinning（SSL锁定），这是一种安全措施，通过硬编码服务器的公钥或证书到应用程序中，强制要求与预设的服务器证书匹配。如果检测到中间人代理（如Charles）提供的伪造证书，即使这个证书是被系统信任的，应用程序也会拒绝建立连接。 网络配置问题\n代理设置错误：确保设备或浏览器已经正确设置了Charles作为HTTP/HTTPS代理。如果代理设置有误，可能导致请求无法正常路由到目标服务器。 防火墙或网络限制：某些网络环境可能设置了严格的防火墙规则或代理策略，阻止了通过第三方代理软件发送的请求。 服务器端限制\nIP地址黑名单：有些服务器可能会维护一个黑名单，列出不允许访问其资源的IP地址范围。如果你正在使用的代理服务器的IP地址被列入黑名单，那么通过该代理发出的所有请求都可能被服务器拒绝。 请求频率限制：频繁的抓包测试可能会触发服务器的速率限制机制，导致部分请求被拒绝。 解决方法\n检查并重新安装证书：确保Charles的根证书已正确安装并在设备上被信任。对于移动端，按照Charles的官方指南进行操作。 绕过SSL Pinning：对于支持修改的应用程序，可以尝试关闭SSL Pinning功能；不过，这通常需要反编译应用，修改代码后再重新打包，这对大多数普通用户来说较为复杂且可能违反服务条款。 确认代理设置：仔细检查设备上的代理设置，确保它们指向了运行Charles的主机和端口。 测试不同网络环境：尝试切换到不同的网络环境，排除因当前网络设置导致的问题。 联系服务提供商：如果是由于服务器端限制（如黑名单、速率限制等）导致的问题，可能需要联系服务提供商解决。 理解上述潜在原因后，你可以针对性地排查问题所在，并采取相应的解决措施。如果是在开发环境中遇到此类问题，开发者还可以利用调试工具或日志来进一步诊断具体的故障点。\n3.3.2 加密 # 3.4 实施HTTPS网站的必备条件 # 3.4.1 证书和密钥对 # 3.4.2 部署和配置HTTPS网站 # 3.4.3 全站HTTPS策略 # 3.5 从用户的角度看HTTPS # 3.5.1 绿色小锁图标 # 3.5.2 TLS/SSL握手失败 # 3.5.3 混合内容 # 第4章 选择HTTPS的必要性和疑惑 # 第5章 快速搭建一个HTTPS网站 # "},{"id":81,"href":"/zh/post/books/computer-science/%E6%94%B6%E5%89%B2-offer%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F/","title":"收割Offer：互联网大厂面经","section":"Computer Science","content":" 第1章 八股文 # 1.1 综合知识 # 1.1.1 单元化高可用架构演进历程 # 单体应用→单数据库→单机房→单地部署 微服务→分库分表→同城多机房→单元化 1 单体应用与单机房微服务 单体应用把所有的功能模块耦合在一起，它存在的问题是领域边界模糊，无法根据业务模块的需要进行伸缩扩容。除此之外，还存在需求开发分支冲突、线上问题定位困难、整体打包编译费时等问题，不适用于大型复杂项目。 由于系统内部处理耗时很小，并且后端服务与数据库部署在同一机房，因此该架构下整个请求链路上的耗时主要发生在用户到机房的物理距离上。 微服务化时代，巨大的单体应用被拆分为模块化的服务，每个服务都围绕特定的业务领域构建，微服务之间通过远程过程调用(Remote Procedure Call，RPC)实现通信，这就是单机房微服务。尽管服务拆分使得原本进程内部的调用变成了网络调用，但是应用都部署在同一个机房，因此RPC网络开销可以忽略。微服务解决了应用层的瓶颈，但随着业务的发展，数据库又成为制约系统扩容的瓶颈。 2 单数据库与分库分表 随着业务的发展数据量不断增多，出现了数据存储、读取方面的问题：一方面单机物理服务器的资源（如CPU、磁盘、内存、IO等）有限，磁盘读取和网络IO出现瓶颈；另一方面单表的数据量太大，查询时扫描的数据很多，造成SQL执行效率低下。为了解决上述问题，引入数据库中间件—实现对上层业务透明的分库分表。 分布式数据库的数据分区一般采用Hash函数+Map映射的方式来实现：首先根据数据的分表字段（一般为userid）计算出该数据的Hash桶位置，然后使用事先定义好的映射表将这个Hash桶中的数据映射到数据库物理节点。 3 单机房演进为同城多机房 为了解决单机房的容量限制，可在同城新建多个机房，机房之间通过专线连接，将应用服务部署在多个机房，数据库主库和备库部署到不同的机房，依靠不同的服务注册中心将应用层逻辑隔离，实现应用层请求不跨机房处理 数据库主库只在其中一个机房内，数据写入时只写主库，主备数据同步，异地机房备库可提供读服务。该方案存在的缺点是访问数据库存在跨机房调用、主备数据同步延迟的问题，但该方案的优点也很多 容量不受单机房限制，数据层与应用层均可自由扩容。 避免不可测因素导致单机房故障，使得全域产品服务不可用，比如地震、火灾、洪水等灾害使得机房断电或者网线被施工方意外挖断等。 用户请求就近接入，优先被物理距离较近的机房处理，减少网络耗时，保障用户体验。 4 同城多机房演进为单元化部署 因为应用层流量是随机的，任何一个应用节点都可能访问任意一个数据库节点，所以应用层每增加一台服务器实例都需要与数据库建立连接，数据库连接数量存在上限，这又制约了系统的水平扩容 提出了单元化的架构，该种架构的应用层也像数据层一样分片，但从应用层到数据层组成一个封闭的单元，一次请求处理收敛在一个单元内部，数据库只负责本单元的应用请求，从而大大节省了连接数；而每个单元可以作为一个独立整体进行部署或挪动，甚至还可以将单元部署到异地来实现容灾。 单元化设计的原则如下： 业务是可分片的，常以用户id或者地区作为分片维度 整个系统要面向逻辑分区进行设计，方便单元挪动 理想状态下单元内部是自封闭的，单元内可以完成业务的所有处理。 缺点是，有时跨单元调用是无法避免的，比如转账场景，用户A和B分别属于单元1和单元2，数据也存储在不同单元，扣减用户A的账户余额需要在单元1执行，增加用户B的账户余额需要在单元2执行，因此跨单元调用增加网络耗时这一问题无法避免。 1.1.2 Java中5种重要的队列 # 1 ArrayBlockingQueue队列 2 LinkedBlockingQueue队列 3 SynchronousQueue队 4 无锁队列 5 PriorityBlockingQueue队列 1.1.3 IO多路复用 # IO多路复用就是通过一种机制来监听多个文件描述符，某个文件描述符一旦就绪，它就能通知应用程序进行相应的处理。多路复用的3种实现方式有select、poll和epoll 1 阻塞IO 2 引入线程池 3 IO多路复用3种实现方式 1.1.4 ReentrantLock锁与Syschronized锁 # 1 公平锁与非公平锁 公平锁是指多个线程竞争锁时直接进入队列排队，根据申请锁的顺序获得锁，先到先得。而非公平锁则是多个线程竞争锁时，首先尝试直接抢锁，失败后再进入等待队列。 使用公平锁，先到先得，线程获取锁时不会出现饥饿现象。使用非公平锁，整体的吞吐效率比较高。 ReentrantLock默认是非公平锁，在构造方法中传入参数true则为公平锁；Synchronized是非公平锁。 2 可重入锁 可重入锁是指一个线程可以多次获取同一把锁，其实现原理是，为每个锁关联一个计数器，线程首次获取锁时，计数器置为1，再次获取该锁时，计数器加1；线程每退出同步块一次，计数器就减1。计数器为0则代表锁被当前线程释放。 Synchronized和ReentrantLock都是可重入锁。 3 ReentrantLock锁 4 Syschronized锁 1.1.5 Java SPI机制 # 1.1.6 限流算法 # 1 计数器\n2 漏桶算法\n3 令牌桶算法\n1.1.7 领域驱动设计 # 1 领域模型 数据模型 2 架构分层 3 领域驱动设计的基本概念 4 领域驱动实践 1.1.8 HashMap的底层原理 # 1 HashMap的get与put方法的执行过程 2 key的hash值的计算过程 3 HashMap是如何解决Hash冲突的 4 为什么链表转换为红黑树的阈值是8，而红黑树转换为链表的阈值却是6 5 JDK8为什么使用红黑树 6 HashMap扩容机制 7 为什么HashMap是两倍扩容，容量总为2的n次幂 1.1.9 JVM垃圾回收机制 # 1.1.10 零复制 # 1.1.11 TCC柔性事务 # 1.1.12 CAP与BASE # 1.1.13 Volatile关键字 # 1.1.14 双亲委派类加载器 # 1.1.15 从微服务到Service Mesh # 1.1.16 进程、线程与协程 # 进程 进程是系统进行资源调度和分配的基本单位 线程 线程是CPU调度和分配的基本单位 协程 协程比线程更加轻量级，它是一个特殊的函数，该函数可以在某个地方被挂起，也可以在挂起处继续执行。 从上下文切换方面来讲，进程和线程的切换者都是操作系统，切换时机也由操作系统决定，用户无感知；协程的切换者是用户（编程者），切换时机也由用户程序决定。 从并行运行方面来讲，多个进程或一个进程内的多个线程是可以并行运行的，一个线程的多个协程是串行执行的。 1.1.17 强引用、软引用、弱引用、虚引用 # 1 强引用(StrongReference)\n当内存空间不足时，即使JVM抛出OutOfMemoryError错误，垃圾回收器也不会回收具有强引用的对象。类似Object object = new Object()这种使用new操作符创建的对象，将它赋值给一个变量，这个变量就是指向该对象的一个强引用。\n2 软引用(SoftReference)\n3 弱引用(WeakReference)\n4 虚引用(PhantomReference)\n1.1.18 ThreadLocal # ThreadLocal为每个使用该变量的线程提供一个副本，每个线程都可以独立修改自己的副本，而不会与其他线程的副本产生冲突。 1.1.19 线程池 # 1 使用线程池的好处 已创建的线程，避免频繁创建和销毁线程带来的性能开销。 提高了线程的可管理性，避免了无节制创建线程而耗尽系统资源。 提高任务响应速度，任务到达时可立即执行，节省了线程创建的时间。 2 线程池ThreadPoolExecutor的设计与实现 3 线程池的状态与生命周期 4 如何设置线程池核心线程数量 对于CPU密集型任务，核心线程数设置为CPU核数+1。 对于I/O密集型任务，核心线程数设置为2×CPU核数。 1.1.20 控制访问某个资源或方法的并发数 # (1)使用线程池异步处理任务，通过设置线程池最大线程数来限制执行方法的最大并发数 (2)使用信号量semaphore控制同时访问共享资源的线程个数 1.1.21 Happens-Before # 1.1.22 对Java的理解 # 1.1.23 缓存穿透、雪崩、击穿 # 1 缓存穿透 穿透是指查询一个底层存储不存在的key，每次查询时缓存中都不存在该数据，进而穿透到底层存储进行二次查询。流量高峰时，缓存失去了意义，底层存储可能被打挂。 解决方案： 使用布隆过滤器拦截对底层存储不存在的key的读请求，减轻对底层存储的查询压力。 缓存空值，查询底层存储返回空时，将空值缓存起来，下次同样的查询就可避免穿透。 缓存预热，有些场景可以认为缓存不存在，底层数据也不会存在，比如广告特征数据从HBase预热到Redis中，Redis未命中，没必要穿透查询HBase。 2 缓存雪崩 雪崩是指大量的key过期时间设置得相同或者近似，导致某一时刻缓存同时失效，请求全部打到底层存储，引起系统崩溃。 解决方案 在缓存原有失效时间基础上加一个随机值，将失效时间随机打散。 3 缓存击穿 击穿是指缓存在某时刻过期，恰好此时对该key有大量的并发请求。击穿和雪崩的区别在于：缓存击穿是同一时刻对某一个key进行大量请求但没命中缓存，缓存雪崩是同一时刻对不同的过期的key进行大量请求。 解决方案： 抢锁成功的线程去底层存储获取数据并放入缓存，后续其他线程等待读取缓存中的数据。 一些场景允许这样的假设：缓存中没有数据，底层存储也没有。 1.1.24 虚拟机与容器对比 # 1.1.25 保障系统高可用的一般方法 # 1.1.26 伪共享 # 1.1.27 Caffeine缓存高性能分析 # 1.1.28 请自我介绍一下 # 1.2 数据库 # 1.2.1 一次SQL查询的执行过程 # 步骤01 连接器负责与客户端建立并管理连接、获取权限等。\n步骤02 查询缓存，执行过的语句及其结果可能会以键值对的形式缓存在内存中，key是查询语句，value是查询结果；若查询命中缓存则直接返回。如果表发生变化，那么和该表相关的所有缓存数据都将失效，因此只有数据更新不频繁的静态配置表才开启查询缓存。\n步骤03 分析器进行语法分析，判断SQL是否满足MySQL语法。\n步骤04 优化器选择索引，或者在多表关联时决定各个表的连接顺序，以此获取较好的查询性能。\n步骤05 执行器通过存储引擎的接口获取数据。\n1.2.2 binlog日志备份的3种模式 # 1.2.3 事务的两阶段提交 # 1 投票阶段 协调者发送事务执行请求给所有参与者，参与者根据事务在本地执行成功或者失败的结果回复同意或取消。 2 提交阶段 协调者可能收到3种事务执行结果： 所有参与者成功执行事务 如果所有参与者成功执行事务，那么协调者将向所有参与者发送事务提交的通知，参与者提交事务并返回执行结果 部分参与者执行事务失败 如果部分参与者执行事务失败或者协调者等待超时，那么协调者向所有参与者发送事务回滚通知，参与者执行回滚操作、释放资源，并将执行结果返回给协调者 协调者等待超时 1.2.4 二叉搜索树、平衡树、红黑树、B树、B+树的区别 # 1 二叉搜索树 2 AVL树 3 红黑树的特点 红黑树需要满足以下条件： 根节点是黑的 每个节点非红即黑 叶子节点是黑的 如果一个节点是红的，那么它的子节点一定是黑的 对于任意节点，它到叶子节点的所有路径上都包含相同数目的黑节点 4 B树 5 B+树 1.2.5 MySQL存储引擎InnoDB与MyISAM的区别 # MySQL有多种存储引擎，包括：MyISAM和InnoDB等。两者的主要区别如下 InnoDB支持事务，MyISAM不支持事务 InnoDB支持外键，MyISAM不支持 InnoDB是聚集索引，MyISAM是非聚集索引 InnoDB锁最小粒度是行锁，MyISAM锁最小粒度是表锁 1.2.6 聚集索引与非聚集索引的区别 # (1)每张表只能有一个聚集索引，可以有多个非聚集索引。 (2)聚集索引的叶节点就是数据节点，非聚集索引的叶节点仍然是索引，存在一个指针指向对应的数据块。 (3)聚集索引键值的逻辑顺序决定了相应行的物理存储顺序，非聚集索引的逻辑顺序与磁盘上行的物理存储顺序不同。 1.2.7 数据库事务的4大特性 # 1 原子性(Atomicity) 2 一致性(Consistency) 3 隔离性(Isolation) 4 持久性(Durability) 1.2.8 事务隔离级别与脏读、不可重复读、幻读 # 事务隔离级别 读未提交：该隔离级别下，一个事务在执行过程中可以看到其他未提交的事务操作。 读已提交：该隔离级别下，一个事务只能看见已提交事务所做的改变。 可重复读：MySQL默认的隔离级别，该隔离级别下，保证在同一个事务中多次读取同样记录的结果是一致的。 串行化：最高的隔离级别，强制事务串行执行。 1 脏读 2 不可重复读 3 幻读 不可重复读与幻读的区别在于前者是数据变了，后者是数据的行数变了 1.2.9 redo、undo、binlog数据库日志的作用 # 1 redo log 2 undo log 3 binlog 1.2.10 多版本并发控制 # 1 redo log 为了避免每次读写数据库都会产生随机IO，InnoDB为MySQL提供了Buffer Pool，读取数据时先从Buffer Pool读取，数据不存在则从磁盘读取后再写入Buffer Pool；数据写入时先写入Buffer Pool，Buffer Pool中的数据定期刷盘。Buffer Pool提升了数据库的读写性能，但数据库一旦宕机，Buffer Pool中缓存的数据若未刷盘就会丢失，因此，当数据变更时，还需要记录redo log，redo log是预写日志(Write-ahead logging，WAL)，所有对数据的修改先写入redo log，再更新到Buffer Pool，如果MySQL宕机，重启时可以读取redo log对数据进行恢复。这里需要说明的是，不同于数据库操作产生的随机读写，写redo日志是顺序写，效率极高。因此，记录redo日志虽然是磁盘操作但对数据库整体的读写性能几乎没有影响。 2 undo log 事务执行前，MySQL会将更新前的数据保存到undo日志中，如果事务回滚或者数据库崩溃，可以利用undo日志进行回退。undo log也可以用于实现多版本并发控制(MVCC)。 3 binlog 主从复制，从库利用主库上的binlog进行数据回放，实现主从同步。 1.2.11 数据库行锁、表锁、乐观锁与悲观锁 # 1 行锁 行锁锁住一行或者多行记录。行锁开销大，加锁慢，可能会出现死锁，但锁定粒度小、并发度高。InnoDB存储引擎默认的事务隔离级别为可重复读，并且在参数innodb_locks_unsafe_for_binlog = 0的模式下，行锁有3种类型：记录锁(record lock)、间隙锁(GAP lock)、临键锁(next-key lock)。 1）记录锁 2）间隙锁 3）临键锁 2 表锁 表锁锁定整张表，锁定期间其他事务不能对该表进行操作。查询非索引字段时一般触发表锁。表锁开销小，加锁快，不会出现死锁，但锁粒度大，并发度低。 3 数据库的乐观锁与悲观锁 悲观锁：数据修改前，假设一定会发生冲突，先尝试为它加锁。 乐观锁：假设数据修改不会造成冲突，在数据提交更新时才进行冲突检测。 在低并发场景下，使用乐观锁可以避免加锁开销；在高并发场景下，使用乐观锁会因为数据冲突频繁而导致执行效率变低，该场景下应使用悲观锁。 1.2.12 当前读与快照读 # 当前读 快照读 1.2.13 幻读是怎么解决的 # 幻读是指一个事务在前后两次查询同一个范围时，后一次查询观察到了前一次查询结果集中没有的记录。 快照读 在可重复读隔离级别下，普通的查询是快照读，ReadView只在事务开启的第一次查询时生成，之后的查询都复用之前的ReadView，这就使得前后两次查询结果相同。因此，快照读不会出现幻读问题。 当前读 当前读读取的是最新版本的数据，如果无法阻止其他事务在查询区间范围内插入新的数据，就会出现幻读现象。 为了解决幻读问题，引入间隙锁。间隙锁给某一个范围区间加锁，阻止其他事务将新的记录插入该范围区间内，因此也就不会出现幻读了。 1.2.14 SQL索引优化 # 1.2.15 Dao层缓存先更新缓存还是先更新数据库 # 1.2.16 MySQL高可用架构 # MySQL通过主从复制实现高可用 主库向从库同步自己的binlog日志 从库的IO线程将binlog日志写入relay log 从库的SQL线程读取relay log并进行数据回放。 1 异步复制 2 半同步复制 3 组复制 1.2.17 为什么遇到范围查询会停止索引的最左匹配 # 1.2.18 索引下推 # 1.2.19 索引覆盖 # 1.2.20 经典SQL语句考察：group by、join、having # 1.2.21 避免数据库热点更新 # 1.2.22 线上环境如何修改表结构 # MySQL在进行alter table等DDL操作时，有时会出现Waiting for table metadata lock的情况，后续对表的任何操作都无法进行。对千万数量级的表新增字段或者其他DDL操作，如何保证在不影响在线读写的同时完成表结构的修改？ 1.3 Redis # 1.3.1 Redis的5种基本数据类型及对应底层实现 # 1 Redis底层数据结构之SDS 2 Redis底层数据结构之压缩列表ziplist 3 Redis底层数据结构之双端链表linkedlist 4 Redis底层数据结构之快表quicklist 5 Redis底层数据结构之整数集合intset 6 Redis底层数据结构之哈希表hashtable 7 Redis底层数据结构之跳表skiplist 1.3.2 Redis为什么这么快 # -(1)Redis是一个键值对内存数据库。\n(2)使用IO多路复用技术。 (3)非CPU密集型任务。对大key进行非O(1)时间复杂度的操作（CPU密集）会阻塞后续请求，Redis快的前提是不会出现类似情况。 (4)单线程的优势。避免了多线程上下文切换以及共享资源加锁的性能损耗。 1.3.3 Redis持久化之RDB与AOF # 1.3.4 Redis实现分布式锁的关键点 # Redis锁主要利用Redis的setnx命令实现，setnx是SET if Not exists的简写。执行setnx key value，当键不存在时，将key的值设置为value，此时锁抢占成功。可以通过删除键值对或者过期时间来释放锁。 实现Redis锁需要注意的事项如下： 1 避免死锁 设置key的过期时间，以保证即使锁没有被显式释放，也可以在一定时间后自动释放，避免资源被永远锁住。 2 锁续期 当前线程获取锁后执行任务，当任务耗时大于Redis key过期时间时，锁会被释放，会存在其他线程获取到该锁的可能。此时可以为已经获取锁的线程增加守护线程，对将要过期但未释放的锁延长有效时间。 3 只允许获取锁的线程释放锁 将参与抢锁的客户端id设置在value中(setnx key value)，释放锁前校验value中存放的id是否为自己。 4 互斥性 Redis正常运行时执行setnx命令可以保证只允许一个客户端持有锁；当Redis发生主从切换时，key未及时同步到从节点，锁可能被其他客户端再一次获取，针对该场景可引入红锁机制。 5 可重入（可选） 若允许当前线程在持有锁的情况下再次请求加锁，那么这个锁就是可重入的。Redis可对锁进行重入计数，加锁时加1，解锁时减1，当计数归0时释放锁。 1.3.5 Redis与Memcache的区别 # 1.3.6 Redis主从复制原理之SYNC与PSYNC # 1.3.7 过期删除策略 # (1)定时删除策略。设置key过期时间的同时创建一个定时器，在键的过期时间来临时立即删除键。定时删除及时释放内存，但浪费CPU。 (2)惰性删除策略。在访问key时顺便检查它是否过期，若过期则删除，否则返回该键值对。惰性删除策略对CPU友好，但浪费内存空间。 (3)定期删除策略。该策略是定时删除和惰性删除方案的折中，每隔一段时间执行一次删除过期key的操作，删除哪些数据库的哪些过期键由算法决定。我们通过限制执行的时长和频率来减少对CPU的影响，同时定期主动删除过期键又有效地减少了内存浪费。 Redis使用的是惰性删除和定期删除策略。 1.3.8 Redis哈希槽 # 1.3.9 Redis Gossip协议 # 1.3.10 重定向moved与ask # 1.3.11 Pipeline有什么好处 # 1.4 RocketMQ # 1.4.1 RocketMQ的整体架构 # 1.4.2 消息队列典型的适用场景 # 1 系统解耦 2 削峰填谷 1.4.3 消费者、消费者组、队列之间的关系 # 1.4.4 RocketMQ消息发送与消费流程 # 1.4.5 消息刷盘策略 # 1.4.6 底层文件存储设计 # 1.4.7 事务消息 # 1.4.8 延迟消息 # 1.4.9 如何保证消息不丢失 # 1.4.10 消息过滤 128 # 1.4.11 顺序消息 128 # 1.4.12 消费者offset管理 # 1.4.13 Rebalance的危害 # 1.4.14 RocketMQ与Kafka的对比 # 1 存储形式 2 延时消息 3 消息重复 4 消息过滤 5 消费失败重试 6 服务发现 7 高可用 1.5 操作系统 # 1.5.1 进程与线程的区别 # 进程是系统进行资源调度和分配的基本单位，用于实现操作系统的并发。线程是CPU调度和分配的基本单位，用来实现进程内部的并发。 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；进程在执行过程中拥有独立的内存单元，而多个线程共享进程的资源。 1.5.2 为什么页内存大小是4KB # (1)过小的页面会导致较多的页表项，从而增加寻址时的查找时间和额外开销。 (2)过大的页面会浪费内存空间，产生内存碎片，降低内存的利用率。 1.5.3 进程间的通信方式 # 管道及命名管道 信号 消息队列 共享内存 信号量 套接字 1.5.4 页面置换算法 # 1 先进先出(FIFO)页面置换算法 2 最近最久未使用(LRU)置换算法 3 CLOCK置换算法 4 最佳置换算法(OPT) 1.5.5 虚拟内存 # 如果CPU直接操作内存的物理地址，那么在空间没有隔离的情况下，同时运行多个程序可能会出现非预期内的结果。比如，程序A在地址XXXX的位置进行写入操作，会擦除程序B存放在相同位置上的数据。因此，同时运行多个程序，地址空间不隔离会有程序崩溃的风险。为了解决这个问题，出现了虚拟内存的概念。所谓虚拟内存，是指为每个进程分配独立的虚拟地址，它们互不干涉，虚拟地址由操作系统负责映射到物理内存。常见的虚拟内存管理方式有分段和分页。 1 内存分段 2 内存分页 1.5.6 为什么多级页表可以节省内存 # 1.5.7 死锁及其产生的条件 # 1 死锁 所谓死锁是指两个或两个以上的进程在执行过程中，由于竞争资源造成的一种阻塞的现象，在未改变这种状态之前进程都不能向前推进，就说这一组进程产生了死锁。通俗地讲，就是两个或多个进程无限期地阻塞、相互等待的一种状态。 2 死锁产生的4个必要条件 互斥：在一段时间内某资源仅被一个进程占用。 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源被其他进程占有。 非抢占：进程已获得的资源在未使用完之前不能被强行剥夺。 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系。 1.5.8 线程状态转换 # 就绪状态(runnable) 运行状态(running) 阻塞状态(blocked) 等待状态(waiting) 终止状态(terminated) 1.5.9 进程调度策略 # 先来先服务 非抢占 最短作业优先 高响应比优先算法 优先级调度算法 时间片轮转调度算法 多级队列调度算法 1.5.10 线程同步有哪几种方式 # (1)锁Synchronized/Lock：只有拥有锁的线程才能访问临界资源。 (2)信号量Semaphore：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数。 1.5.11 内存颠簸 # 1.5.12 局部性原理 # 时间上的局部性是指最近被访问的页在不久的将来还会被访问。 空间上的局部性是指存储中的某个位置被访问，其周围的位置也很可能被访问。 1.6 计算机网络 # 1.6.1 TCP与UDP的区别 # TCP是面向连接的，UDP是无连接的，即发送数据前不需要建立连接。\nTCP提供可靠的服务，传送数据无差错、不丢失、不重复且按序到达；UDP尽最大努力交付。\nUDP实时性强，工作效率比TCP高，适用于对传输速度和延迟要求较高的场景，如语音和视频通信等。\n1.6.2 滑动窗口 # 1.6.3 拥塞控制 # 1 慢开始算法 2 拥塞避免算法 3 快重传算法 4 快恢复算法 1.6.4 重传机制 # 1 超时重传 2 快速重传 3 Selective Acknowledgment，SACK 4 D-SACK 1.6.5 流量控制 # 1.6.6 三次握手与四次挥手 # 1 三次握手建立连接 2 四次挥手 1.6.7 TCP四次挥手为什么要等待2MSL # 1.6.8 一次完整的HTTP请求 # 域名解析→3次握手建立TCP连接→发起HTTP请求→服务器返回数据，浏览器渲染页面 域名解析流程 1.6.9 HTTPS加密过程 # 1 对称与非对称加密 对称加密：所谓对称加密其实就是加密与解密使用同一把密钥。 非对称加密：一对密钥（公钥与私钥），使用其中一个密钥进行加密，另一个密钥进行解密。比如若使用公钥加密，则用私钥解密；若使用私钥加密，则用公钥解密。 2 使用两组非对称密钥可以保证通信安全吗 使用两组非对称密钥不可以保证通信安全。举个例子，客户端与服务器端通信，服务器端拥有公钥A与对应的私钥A\u0026rsquo;；客户端拥有公钥B与对应的私钥B\u0026rsquo;。客户端把公钥B明文传输给服务器端，服务器端把公钥A明文给传输给客户端，之后客户端向服务器端传输数据都用公钥A加密，服务器收到后用私钥A\u0026rsquo;解密。同理，服务器端向客户端传输数据都用公钥B加密，客户端收到后用私钥B\u0026rsquo;解密。私钥被通信发起方安全持有，使用两对密钥看起来可以保证信息安全，但其实存在非对称加密耗时与中间人攻击问题。 1）非对称加密耗时问题 相对于对称加密而言，非对称加密是耗时的，因此仅使用非对称加密的方式传递对称加密的密钥，后续数据通信使用对称密钥加解密。 2）中间人攻击问题 中间人分别与客户端和服务端进行密钥协商 3 数字签名保障证书不被篡改 1.6.10 TCP粘包与拆包 # 1.6.11 Nagle算法 # 1.7 Spring # 1.7.1 Spring Bean的作用域 # 1.7.2 Spring Bean的生命周期 # 1.7.3 Spring IoC # 1.7.4 Spring AOP # 1.7.5 Spring三级缓存解决Bean循环依赖 # Spring Bean循环依赖是指两个以上的Bean互相持有对方而形成循环。比如A依赖B，B依赖A singletonObjects：一级缓存，存储经历了完整生命周期的Bean对象 earlySingletonObjects：二级缓存，存储提前暴露出来的Bean对象，其生命周期未结束，属性未完全填充 singletonFactories：三级缓存，存储生成Bean的工厂 1.7.6 Spring事务实现 # 1.7.7 Spring事务失效的典型场景 # 1.7.8 Spring中BeanFactory和ApplicationContext的区别 # ApplicationContext配置的Bean是预先加载的，浪费内存。BeanFactory延迟加载，配置的Bean只有在使用时（调用getBean()）才对该Bean进行实例化，优点是节约内存，缺点是速度比较慢 1.8 ZooKeeper # 1.8.1 ZooKeeper典型使用场景 # 1 分布式锁 在开发业务功能时常需要使用定时任务来触发事件，假如我们的服务集群有n台服务器，而定时任务又要求时机来临仅被触发一次，则n台服务器抢锁成功者执行具体任务。 2 配置管理 有时需要配置实时生效，比如业务代码中的开关等。如果我们有n台服务器，那么硬编码修改起来就会特别麻烦，并且还需要重新发布应用。 3 服务注册与发现 1.8.2 ZooKeeper四种节点类型 # 1.8.3 ZooKeeper的顺序一致性 # 1.8.4 ZooKeeper集群节点为什么是奇数个 # 1.8.5 ZooKeeper集群中的三种角色 # 1.8.6 ZooKeeper的选主机制 # 1.8.7 ZooKeeper与Eureka的区别 # -(1)ZooKeeper保证数据一致性(consistency)和分区容错性Partition Tolerance。 ZooKeeper的过半策略保证了数据强一致性，当Leader节点因为网络故障与其他节点失去联系时，剩余节点会重新进行投票，选举出新的Leader，且选举期间整个集群不可用。\n(2)Eureka保证可用性(Availability)和分区容错性Partition Tolerance。 Eureka以对等复制的方式进行数据同步，集群节点都是平等的，即使部分节点挂掉（只要还有一台Eureka在），剩余的节点依然可以提供注册和查询服务。 1.8.8 ZooKeeper Atomic Broadcast协议 # 1.9 Dubbo # 1.9.1 Dubbo架构简述 # Dubbo整体架构由消费者(Consumer)、服务者(Provider)、注册中心(Registry)以及监控器(Monitor)组成。其中，服务者注册服务地址到注册中心，消费者从注册中心读取和订阅服务者地址列表，消费者在发起调用前进行路由选择、负载均衡策略，然后调用至服务者服务器，调用失败则进行集群容错。监控器对调用量、性能指标进行采集上报。 1.9.2 路由机制 # Dubbo路由机制实现了动态指定服务的提供者，如图1-149所示。admin管理后台动态添加路由的规则，并将它们存储在注册中心${service}/routers目录下，基于注册中心的事件机制最新路由会通知服务消费者（调用方）；服务消费者发起调用前，Dubbo依据配置的路由规则计算出哪些服务提供者可以处理本次请求，然后使用负载均衡策略选择其中一个服务实例来处理本次请求；当服务调用发生异常时，会有一些集群容错的策略。这就是服务调用的基本流程，从中也可以看出路由选择优先级高于集群容错和负载均衡策略。 1.9.3 负载均衡 # Dubbo负载均衡机制决定了一次请求调用哪个服务提供者 1 RandomLoadBalance：随机负载均衡算法 2 RoundRobinLoadBalance：轮询负载均衡算法 3 LeastActiveLoadBalance：最少活跃数负载均衡算法 4 ConsistentHashLoadBalance：一致性哈希 1.9.4 集群容错 # 集群容错是指消费者在调用服务提供者集群发生异常时的处理策略。 1 failover cluster 若服务调用失败则自动重试到其他的可用节点。 2 failfast cluster 快速失败，即一次调用失败就立即失败，常见于非幂等性的写操作。 3 failsafe cluster 快速失败，出现异常时直接忽略，通常用于写入审计日志等不重要的操作。 4 failback cluster 失败后定时重试。 5 forking cluster 并行调用多个服务提供者，只要有一个成功就立即返回。通常用于实时性要求比较高的读操作。 1.9.5 Dubbo的序列化 # -(1)Hessian2序列化：Hessian是一种跨语言的高效二进制序列化方式。Dubbo默认启用此序列化方式。 -(2)JSON序列化：易于解析阅读，但这种文本序列化性能一般不如二进制序列化。 -(3)Java序列化：JDK自带的序列化实现，无须引入任何依赖，但性能不理想。\n(4)Protobuf序列化：Protobuf是由Google设计的一种高效、轻量级的信息描述格式，优点是与语言无关，编码长度更短，传输效率更高，编解码速度更快；缺点是缺乏自描述，可读性差。 1.9.6 有了HTTP请求为什么还需要RPC调用 # -(1)HTTP信息效率低，包含了大量的HTTP头等冗余信息\n(2)业内成熟的RPC框架是面向服务的更高级的封装，其内涵包括了路由策略、负载均衡、集群容错、服务发现、数据统计以及数据看板等，更适用于一个分布式的大型系统内部之间的通信。 1.9.7 Dubbo的SPI机制 # 第2章 算法题目 # 2.1 递归 # 2.1.1 算法解释 # 2.1.2 经典题目—爬楼梯 # 2.2 双指针 # 2.2.1 算法解释 # 2.2.2 经典题目—寻找链表的中间节点（快慢指针） # 2.2.3 经典题目—有序数组两数之和（对撞指针） # 2.3 滑动窗口 # 2.3.1 算法解释 # 2.3.2 经典题目—长度为k的连续子数组的最大和 # 2.4 二分搜索 # 2.4.1 算法解释 # 2.4.2 经典题目——n的算术平方根 # 2.5 动态规划 # 2.5.1 算法解释 # 2.5.2 经典题目—最小路径和 # 2.6 回溯 # 2.6.1 算法解释 # 2.6.2 经典题目—n皇后问题 # 2.7 广度/深度优先搜索 # 2.7.1 算法解释 # 2.7.2 经典题目—深度优先搜索岛屿数量 # 2.7.3 经典题目—广度优先搜索层序遍历 # 第3章 设计题 # 3.1 秒杀系统 # 3.1.1 抢购商品允许超卖 # 3.1.2 抢购商品不允许超卖 # 3.1.3 异步消费控制用户并发数避免热点更新 # 3.1.4 用户交互设计角度的兜底考虑 # 3.2 分布式定时任务 # 3.2.1 设计思想 # 3.2.2 定时任务具体功能点的实现 # 3.3 其他高频出现的经典方案设计题目 # (1)抖音视频点赞、云音乐海量评论功能设计。 (2)微博千万粉丝博主、粉丝列表设计。 (3)设计RPC框架。 (4)排行榜。 (5)微信抢红包。 (6)微博feed流、微信朋友圈、Twitter timeline。 (7)限流的设计思路。 (8)如何设计count服务。 (9)设计一个短链系统。 (10)Open API接口设计。 (11)如何实现一个分布式锁，Redis、ZooKeeper两种方案的区别？ (12)如何设计无界实时数据流的Join 第4章 一个项目案例分析：合约广告库存预估 # 4.1 项目背景 # 4.2 系统领域划分与自己所在的位置 # 4.3 发现或者定义一个问题 # 4.4 可量化的正向结果 # 4.5 未来改进点 # 第5章 一个完整的后端系统 # 5.1 接入层（Nginx与网关） # 1 Nginx 2 网关(API Gateway) 3 BFF 5.2 业务层 # 定时任务触发 柔性事务、重试机制 配置中心动态配置 限流降级 微服务的治理依赖 消息队列 Redis DTS Trace全链路日志 5.3 数据层（DB→分布式缓存→本地内存） # 第6章 HR面试技巧——头部大厂HR访谈 # 6.1 面试的全流程—不要以为通过技术\u0026amp;HR面试就能拿Offer # 职业规划是什么？ 为什么要跳槽？ 你的优点和缺点有哪些？ 过往工作中遇到的困难你是怎么解决的？ 过往工作中取得了哪些成果？详细说说。 你的薪酬预期是多少？ 6.2 跳槽时找谁内推更容易通过面试 # 6.3 谈薪技巧 # 6.4 反问环节—怎么提问能加分 # 提问题的原则是：问题的提出必须符合自身的行为逻辑，符合自身定位。建议提问职业发展与个人成长规划、热点技术、目标岗位相关的业务问题等。 6.5 你的职业规划 # 6.6 为什么要跳槽 # 6.7 你的优点和缺点 # 6.8 过往工作中取得的成果 # 6.9 过往工作中遇到的困难是怎么解决的 # 我通过校园招聘加入网易云音乐，已经工作四年了，我的困难分两个阶段： 第一阶段是：刚入职阶段，入职时公司处于大发展阶段，人力不足，新人也要承担大型重要项目，我对新的环境、技术基础设施、工作流程等不熟悉，作为新人如何快速融入团队、完成产品运营交付的需求、按时高质量上线，对我来说是一种挑战。 第二阶段是：工作熟练以后，自己负责一块成熟的业务，增长上出现瓶颈，怎么在熟悉的业务里发现问题，甚至定义问题，以技术驱动业务的发展，落地执行取得正向可量化的业务指标，对我来说是一件极具挑战的事。 6.10 行业薪酬水平 # 6.11 没有做出算法题是否一定会被淘汰 # 6.12 能不能短时间内频繁面试同一家公司 # 6.13 “毕业季”应选择什么样的公司 # 6.14 国内互联网面试为什么要刷题 # 6.15 薪酬报高了会不会被HR直接淘汰 # 6.16 几年一跳算频繁 # 6.17 你是如何学习技术的 # 6.18 思维发散题目 # 参考文献 # "},{"id":82,"href":"/zh/zh/post/books/computer-science/%E6%94%B6%E5%89%B2-offer%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F/","title":"收割Offer：互联网大厂面经","section":"Computer Science","content":" 第1章 八股文 # 1.1 综合知识 # 1.1.1 单元化高可用架构演进历程 # 单体应用→单数据库→单机房→单地部署 微服务→分库分表→同城多机房→单元化 1 单体应用与单机房微服务 单体应用把所有的功能模块耦合在一起，它存在的问题是领域边界模糊，无法根据业务模块的需要进行伸缩扩容。除此之外，还存在需求开发分支冲突、线上问题定位困难、整体打包编译费时等问题，不适用于大型复杂项目。 由于系统内部处理耗时很小，并且后端服务与数据库部署在同一机房，因此该架构下整个请求链路上的耗时主要发生在用户到机房的物理距离上。 微服务化时代，巨大的单体应用被拆分为模块化的服务，每个服务都围绕特定的业务领域构建，微服务之间通过远程过程调用(Remote Procedure Call，RPC)实现通信，这就是单机房微服务。尽管服务拆分使得原本进程内部的调用变成了网络调用，但是应用都部署在同一个机房，因此RPC网络开销可以忽略。微服务解决了应用层的瓶颈，但随着业务的发展，数据库又成为制约系统扩容的瓶颈。 2 单数据库与分库分表 随着业务的发展数据量不断增多，出现了数据存储、读取方面的问题：一方面单机物理服务器的资源（如CPU、磁盘、内存、IO等）有限，磁盘读取和网络IO出现瓶颈；另一方面单表的数据量太大，查询时扫描的数据很多，造成SQL执行效率低下。为了解决上述问题，引入数据库中间件—实现对上层业务透明的分库分表。 分布式数据库的数据分区一般采用Hash函数+Map映射的方式来实现：首先根据数据的分表字段（一般为userid）计算出该数据的Hash桶位置，然后使用事先定义好的映射表将这个Hash桶中的数据映射到数据库物理节点。 3 单机房演进为同城多机房 为了解决单机房的容量限制，可在同城新建多个机房，机房之间通过专线连接，将应用服务部署在多个机房，数据库主库和备库部署到不同的机房，依靠不同的服务注册中心将应用层逻辑隔离，实现应用层请求不跨机房处理 数据库主库只在其中一个机房内，数据写入时只写主库，主备数据同步，异地机房备库可提供读服务。该方案存在的缺点是访问数据库存在跨机房调用、主备数据同步延迟的问题，但该方案的优点也很多 容量不受单机房限制，数据层与应用层均可自由扩容。 避免不可测因素导致单机房故障，使得全域产品服务不可用，比如地震、火灾、洪水等灾害使得机房断电或者网线被施工方意外挖断等。 用户请求就近接入，优先被物理距离较近的机房处理，减少网络耗时，保障用户体验。 4 同城多机房演进为单元化部署 因为应用层流量是随机的，任何一个应用节点都可能访问任意一个数据库节点，所以应用层每增加一台服务器实例都需要与数据库建立连接，数据库连接数量存在上限，这又制约了系统的水平扩容 提出了单元化的架构，该种架构的应用层也像数据层一样分片，但从应用层到数据层组成一个封闭的单元，一次请求处理收敛在一个单元内部，数据库只负责本单元的应用请求，从而大大节省了连接数；而每个单元可以作为一个独立整体进行部署或挪动，甚至还可以将单元部署到异地来实现容灾。 单元化设计的原则如下： 业务是可分片的，常以用户id或者地区作为分片维度 整个系统要面向逻辑分区进行设计，方便单元挪动 理想状态下单元内部是自封闭的，单元内可以完成业务的所有处理。 缺点是，有时跨单元调用是无法避免的，比如转账场景，用户A和B分别属于单元1和单元2，数据也存储在不同单元，扣减用户A的账户余额需要在单元1执行，增加用户B的账户余额需要在单元2执行，因此跨单元调用增加网络耗时这一问题无法避免。 1.1.2 Java中5种重要的队列 # 1 ArrayBlockingQueue队列 2 LinkedBlockingQueue队列 3 SynchronousQueue队 4 无锁队列 5 PriorityBlockingQueue队列 1.1.3 IO多路复用 # IO多路复用就是通过一种机制来监听多个文件描述符，某个文件描述符一旦就绪，它就能通知应用程序进行相应的处理。多路复用的3种实现方式有select、poll和epoll 1 阻塞IO 2 引入线程池 3 IO多路复用3种实现方式 1.1.4 ReentrantLock锁与Syschronized锁 # 1 公平锁与非公平锁 公平锁是指多个线程竞争锁时直接进入队列排队，根据申请锁的顺序获得锁，先到先得。而非公平锁则是多个线程竞争锁时，首先尝试直接抢锁，失败后再进入等待队列。 使用公平锁，先到先得，线程获取锁时不会出现饥饿现象。使用非公平锁，整体的吞吐效率比较高。 ReentrantLock默认是非公平锁，在构造方法中传入参数true则为公平锁；Synchronized是非公平锁。 2 可重入锁 可重入锁是指一个线程可以多次获取同一把锁，其实现原理是，为每个锁关联一个计数器，线程首次获取锁时，计数器置为1，再次获取该锁时，计数器加1；线程每退出同步块一次，计数器就减1。计数器为0则代表锁被当前线程释放。 Synchronized和ReentrantLock都是可重入锁。 3 ReentrantLock锁 4 Syschronized锁 1.1.5 Java SPI机制 # 1.1.6 限流算法 # 1 计数器\n2 漏桶算法\n3 令牌桶算法\n1.1.7 领域驱动设计 # 1 领域模型 数据模型 2 架构分层 3 领域驱动设计的基本概念 4 领域驱动实践 1.1.8 HashMap的底层原理 # 1 HashMap的get与put方法的执行过程 2 key的hash值的计算过程 3 HashMap是如何解决Hash冲突的 4 为什么链表转换为红黑树的阈值是8，而红黑树转换为链表的阈值却是6 5 JDK8为什么使用红黑树 6 HashMap扩容机制 7 为什么HashMap是两倍扩容，容量总为2的n次幂 1.1.9 JVM垃圾回收机制 # 1.1.10 零复制 # 1.1.11 TCC柔性事务 # 1.1.12 CAP与BASE # 1.1.13 Volatile关键字 # 1.1.14 双亲委派类加载器 # 1.1.15 从微服务到Service Mesh # 1.1.16 进程、线程与协程 # 进程 进程是系统进行资源调度和分配的基本单位 线程 线程是CPU调度和分配的基本单位 协程 协程比线程更加轻量级，它是一个特殊的函数，该函数可以在某个地方被挂起，也可以在挂起处继续执行。 从上下文切换方面来讲，进程和线程的切换者都是操作系统，切换时机也由操作系统决定，用户无感知；协程的切换者是用户（编程者），切换时机也由用户程序决定。 从并行运行方面来讲，多个进程或一个进程内的多个线程是可以并行运行的，一个线程的多个协程是串行执行的。 1.1.17 强引用、软引用、弱引用、虚引用 # 1 强引用(StrongReference)\n当内存空间不足时，即使JVM抛出OutOfMemoryError错误，垃圾回收器也不会回收具有强引用的对象。类似Object object = new Object()这种使用new操作符创建的对象，将它赋值给一个变量，这个变量就是指向该对象的一个强引用。\n2 软引用(SoftReference)\n3 弱引用(WeakReference)\n4 虚引用(PhantomReference)\n1.1.18 ThreadLocal # ThreadLocal为每个使用该变量的线程提供一个副本，每个线程都可以独立修改自己的副本，而不会与其他线程的副本产生冲突。 1.1.19 线程池 # 1 使用线程池的好处 已创建的线程，避免频繁创建和销毁线程带来的性能开销。 提高了线程的可管理性，避免了无节制创建线程而耗尽系统资源。 提高任务响应速度，任务到达时可立即执行，节省了线程创建的时间。 2 线程池ThreadPoolExecutor的设计与实现 3 线程池的状态与生命周期 4 如何设置线程池核心线程数量 对于CPU密集型任务，核心线程数设置为CPU核数+1。 对于I/O密集型任务，核心线程数设置为2×CPU核数。 1.1.20 控制访问某个资源或方法的并发数 # (1)使用线程池异步处理任务，通过设置线程池最大线程数来限制执行方法的最大并发数 (2)使用信号量semaphore控制同时访问共享资源的线程个数 1.1.21 Happens-Before # 1.1.22 对Java的理解 # 1.1.23 缓存穿透、雪崩、击穿 # 1 缓存穿透 穿透是指查询一个底层存储不存在的key，每次查询时缓存中都不存在该数据，进而穿透到底层存储进行二次查询。流量高峰时，缓存失去了意义，底层存储可能被打挂。 解决方案： 使用布隆过滤器拦截对底层存储不存在的key的读请求，减轻对底层存储的查询压力。 缓存空值，查询底层存储返回空时，将空值缓存起来，下次同样的查询就可避免穿透。 缓存预热，有些场景可以认为缓存不存在，底层数据也不会存在，比如广告特征数据从HBase预热到Redis中，Redis未命中，没必要穿透查询HBase。 2 缓存雪崩 雪崩是指大量的key过期时间设置得相同或者近似，导致某一时刻缓存同时失效，请求全部打到底层存储，引起系统崩溃。 解决方案 在缓存原有失效时间基础上加一个随机值，将失效时间随机打散。 3 缓存击穿 击穿是指缓存在某时刻过期，恰好此时对该key有大量的并发请求。击穿和雪崩的区别在于：缓存击穿是同一时刻对某一个key进行大量请求但没命中缓存，缓存雪崩是同一时刻对不同的过期的key进行大量请求。 解决方案： 抢锁成功的线程去底层存储获取数据并放入缓存，后续其他线程等待读取缓存中的数据。 一些场景允许这样的假设：缓存中没有数据，底层存储也没有。 1.1.24 虚拟机与容器对比 # 1.1.25 保障系统高可用的一般方法 # 1.1.26 伪共享 # 1.1.27 Caffeine缓存高性能分析 # 1.1.28 请自我介绍一下 # 1.2 数据库 # 1.2.1 一次SQL查询的执行过程 # 步骤01 连接器负责与客户端建立并管理连接、获取权限等。\n步骤02 查询缓存，执行过的语句及其结果可能会以键值对的形式缓存在内存中，key是查询语句，value是查询结果；若查询命中缓存则直接返回。如果表发生变化，那么和该表相关的所有缓存数据都将失效，因此只有数据更新不频繁的静态配置表才开启查询缓存。\n步骤03 分析器进行语法分析，判断SQL是否满足MySQL语法。\n步骤04 优化器选择索引，或者在多表关联时决定各个表的连接顺序，以此获取较好的查询性能。\n步骤05 执行器通过存储引擎的接口获取数据。\n1.2.2 binlog日志备份的3种模式 # 1.2.3 事务的两阶段提交 # 1 投票阶段 协调者发送事务执行请求给所有参与者，参与者根据事务在本地执行成功或者失败的结果回复同意或取消。 2 提交阶段 协调者可能收到3种事务执行结果： 所有参与者成功执行事务 如果所有参与者成功执行事务，那么协调者将向所有参与者发送事务提交的通知，参与者提交事务并返回执行结果 部分参与者执行事务失败 如果部分参与者执行事务失败或者协调者等待超时，那么协调者向所有参与者发送事务回滚通知，参与者执行回滚操作、释放资源，并将执行结果返回给协调者 协调者等待超时 1.2.4 二叉搜索树、平衡树、红黑树、B树、B+树的区别 # 1 二叉搜索树 2 AVL树 3 红黑树的特点 红黑树需要满足以下条件： 根节点是黑的 每个节点非红即黑 叶子节点是黑的 如果一个节点是红的，那么它的子节点一定是黑的 对于任意节点，它到叶子节点的所有路径上都包含相同数目的黑节点 4 B树 5 B+树 1.2.5 MySQL存储引擎InnoDB与MyISAM的区别 # MySQL有多种存储引擎，包括：MyISAM和InnoDB等。两者的主要区别如下 InnoDB支持事务，MyISAM不支持事务 InnoDB支持外键，MyISAM不支持 InnoDB是聚集索引，MyISAM是非聚集索引 InnoDB锁最小粒度是行锁，MyISAM锁最小粒度是表锁 1.2.6 聚集索引与非聚集索引的区别 # (1)每张表只能有一个聚集索引，可以有多个非聚集索引。 (2)聚集索引的叶节点就是数据节点，非聚集索引的叶节点仍然是索引，存在一个指针指向对应的数据块。 (3)聚集索引键值的逻辑顺序决定了相应行的物理存储顺序，非聚集索引的逻辑顺序与磁盘上行的物理存储顺序不同。 1.2.7 数据库事务的4大特性 # 1 原子性(Atomicity) 2 一致性(Consistency) 3 隔离性(Isolation) 4 持久性(Durability) 1.2.8 事务隔离级别与脏读、不可重复读、幻读 # 事务隔离级别 读未提交：该隔离级别下，一个事务在执行过程中可以看到其他未提交的事务操作。 读已提交：该隔离级别下，一个事务只能看见已提交事务所做的改变。 可重复读：MySQL默认的隔离级别，该隔离级别下，保证在同一个事务中多次读取同样记录的结果是一致的。 串行化：最高的隔离级别，强制事务串行执行。 1 脏读 2 不可重复读 3 幻读 不可重复读与幻读的区别在于前者是数据变了，后者是数据的行数变了 1.2.9 redo、undo、binlog数据库日志的作用 # 1 redo log 2 undo log 3 binlog 1.2.10 多版本并发控制 # 1 redo log 为了避免每次读写数据库都会产生随机IO，InnoDB为MySQL提供了Buffer Pool，读取数据时先从Buffer Pool读取，数据不存在则从磁盘读取后再写入Buffer Pool；数据写入时先写入Buffer Pool，Buffer Pool中的数据定期刷盘。Buffer Pool提升了数据库的读写性能，但数据库一旦宕机，Buffer Pool中缓存的数据若未刷盘就会丢失，因此，当数据变更时，还需要记录redo log，redo log是预写日志(Write-ahead logging，WAL)，所有对数据的修改先写入redo log，再更新到Buffer Pool，如果MySQL宕机，重启时可以读取redo log对数据进行恢复。这里需要说明的是，不同于数据库操作产生的随机读写，写redo日志是顺序写，效率极高。因此，记录redo日志虽然是磁盘操作但对数据库整体的读写性能几乎没有影响。 2 undo log 事务执行前，MySQL会将更新前的数据保存到undo日志中，如果事务回滚或者数据库崩溃，可以利用undo日志进行回退。undo log也可以用于实现多版本并发控制(MVCC)。 3 binlog 主从复制，从库利用主库上的binlog进行数据回放，实现主从同步。 1.2.11 数据库行锁、表锁、乐观锁与悲观锁 # 1 行锁 行锁锁住一行或者多行记录。行锁开销大，加锁慢，可能会出现死锁，但锁定粒度小、并发度高。InnoDB存储引擎默认的事务隔离级别为可重复读，并且在参数innodb_locks_unsafe_for_binlog = 0的模式下，行锁有3种类型：记录锁(record lock)、间隙锁(GAP lock)、临键锁(next-key lock)。 1）记录锁 2）间隙锁 3）临键锁 2 表锁 表锁锁定整张表，锁定期间其他事务不能对该表进行操作。查询非索引字段时一般触发表锁。表锁开销小，加锁快，不会出现死锁，但锁粒度大，并发度低。 3 数据库的乐观锁与悲观锁 悲观锁：数据修改前，假设一定会发生冲突，先尝试为它加锁。 乐观锁：假设数据修改不会造成冲突，在数据提交更新时才进行冲突检测。 在低并发场景下，使用乐观锁可以避免加锁开销；在高并发场景下，使用乐观锁会因为数据冲突频繁而导致执行效率变低，该场景下应使用悲观锁。 1.2.12 当前读与快照读 # 当前读 快照读 1.2.13 幻读是怎么解决的 # 幻读是指一个事务在前后两次查询同一个范围时，后一次查询观察到了前一次查询结果集中没有的记录。 快照读 在可重复读隔离级别下，普通的查询是快照读，ReadView只在事务开启的第一次查询时生成，之后的查询都复用之前的ReadView，这就使得前后两次查询结果相同。因此，快照读不会出现幻读问题。 当前读 当前读读取的是最新版本的数据，如果无法阻止其他事务在查询区间范围内插入新的数据，就会出现幻读现象。 为了解决幻读问题，引入间隙锁。间隙锁给某一个范围区间加锁，阻止其他事务将新的记录插入该范围区间内，因此也就不会出现幻读了。 1.2.14 SQL索引优化 # 1.2.15 Dao层缓存先更新缓存还是先更新数据库 # 1.2.16 MySQL高可用架构 # MySQL通过主从复制实现高可用 主库向从库同步自己的binlog日志 从库的IO线程将binlog日志写入relay log 从库的SQL线程读取relay log并进行数据回放。 1 异步复制 2 半同步复制 3 组复制 1.2.17 为什么遇到范围查询会停止索引的最左匹配 # 1.2.18 索引下推 # 1.2.19 索引覆盖 # 1.2.20 经典SQL语句考察：group by、join、having # 1.2.21 避免数据库热点更新 # 1.2.22 线上环境如何修改表结构 # MySQL在进行alter table等DDL操作时，有时会出现Waiting for table metadata lock的情况，后续对表的任何操作都无法进行。对千万数量级的表新增字段或者其他DDL操作，如何保证在不影响在线读写的同时完成表结构的修改？ 1.3 Redis # 1.3.1 Redis的5种基本数据类型及对应底层实现 # 1 Redis底层数据结构之SDS 2 Redis底层数据结构之压缩列表ziplist 3 Redis底层数据结构之双端链表linkedlist 4 Redis底层数据结构之快表quicklist 5 Redis底层数据结构之整数集合intset 6 Redis底层数据结构之哈希表hashtable 7 Redis底层数据结构之跳表skiplist 1.3.2 Redis为什么这么快 # -(1)Redis是一个键值对内存数据库。\n(2)使用IO多路复用技术。 (3)非CPU密集型任务。对大key进行非O(1)时间复杂度的操作（CPU密集）会阻塞后续请求，Redis快的前提是不会出现类似情况。 (4)单线程的优势。避免了多线程上下文切换以及共享资源加锁的性能损耗。 1.3.3 Redis持久化之RDB与AOF # 1.3.4 Redis实现分布式锁的关键点 # Redis锁主要利用Redis的setnx命令实现，setnx是SET if Not exists的简写。执行setnx key value，当键不存在时，将key的值设置为value，此时锁抢占成功。可以通过删除键值对或者过期时间来释放锁。 实现Redis锁需要注意的事项如下： 1 避免死锁 设置key的过期时间，以保证即使锁没有被显式释放，也可以在一定时间后自动释放，避免资源被永远锁住。 2 锁续期 当前线程获取锁后执行任务，当任务耗时大于Redis key过期时间时，锁会被释放，会存在其他线程获取到该锁的可能。此时可以为已经获取锁的线程增加守护线程，对将要过期但未释放的锁延长有效时间。 3 只允许获取锁的线程释放锁 将参与抢锁的客户端id设置在value中(setnx key value)，释放锁前校验value中存放的id是否为自己。 4 互斥性 Redis正常运行时执行setnx命令可以保证只允许一个客户端持有锁；当Redis发生主从切换时，key未及时同步到从节点，锁可能被其他客户端再一次获取，针对该场景可引入红锁机制。 5 可重入（可选） 若允许当前线程在持有锁的情况下再次请求加锁，那么这个锁就是可重入的。Redis可对锁进行重入计数，加锁时加1，解锁时减1，当计数归0时释放锁。 1.3.5 Redis与Memcache的区别 # 1.3.6 Redis主从复制原理之SYNC与PSYNC # 1.3.7 过期删除策略 # (1)定时删除策略。设置key过期时间的同时创建一个定时器，在键的过期时间来临时立即删除键。定时删除及时释放内存，但浪费CPU。 (2)惰性删除策略。在访问key时顺便检查它是否过期，若过期则删除，否则返回该键值对。惰性删除策略对CPU友好，但浪费内存空间。 (3)定期删除策略。该策略是定时删除和惰性删除方案的折中，每隔一段时间执行一次删除过期key的操作，删除哪些数据库的哪些过期键由算法决定。我们通过限制执行的时长和频率来减少对CPU的影响，同时定期主动删除过期键又有效地减少了内存浪费。 Redis使用的是惰性删除和定期删除策略。 1.3.8 Redis哈希槽 # 1.3.9 Redis Gossip协议 # 1.3.10 重定向moved与ask # 1.3.11 Pipeline有什么好处 # 1.4 RocketMQ # 1.4.1 RocketMQ的整体架构 # 1.4.2 消息队列典型的适用场景 # 1 系统解耦 2 削峰填谷 1.4.3 消费者、消费者组、队列之间的关系 # 1.4.4 RocketMQ消息发送与消费流程 # 1.4.5 消息刷盘策略 # 1.4.6 底层文件存储设计 # 1.4.7 事务消息 # 1.4.8 延迟消息 # 1.4.9 如何保证消息不丢失 # 1.4.10 消息过滤 128 # 1.4.11 顺序消息 128 # 1.4.12 消费者offset管理 # 1.4.13 Rebalance的危害 # 1.4.14 RocketMQ与Kafka的对比 # 1 存储形式 2 延时消息 3 消息重复 4 消息过滤 5 消费失败重试 6 服务发现 7 高可用 1.5 操作系统 # 1.5.1 进程与线程的区别 # 进程是系统进行资源调度和分配的基本单位，用于实现操作系统的并发。线程是CPU调度和分配的基本单位，用来实现进程内部的并发。 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；进程在执行过程中拥有独立的内存单元，而多个线程共享进程的资源。 1.5.2 为什么页内存大小是4KB # (1)过小的页面会导致较多的页表项，从而增加寻址时的查找时间和额外开销。 (2)过大的页面会浪费内存空间，产生内存碎片，降低内存的利用率。 1.5.3 进程间的通信方式 # 管道及命名管道 信号 消息队列 共享内存 信号量 套接字 1.5.4 页面置换算法 # 1 先进先出(FIFO)页面置换算法 2 最近最久未使用(LRU)置换算法 3 CLOCK置换算法 4 最佳置换算法(OPT) 1.5.5 虚拟内存 # 如果CPU直接操作内存的物理地址，那么在空间没有隔离的情况下，同时运行多个程序可能会出现非预期内的结果。比如，程序A在地址XXXX的位置进行写入操作，会擦除程序B存放在相同位置上的数据。因此，同时运行多个程序，地址空间不隔离会有程序崩溃的风险。为了解决这个问题，出现了虚拟内存的概念。所谓虚拟内存，是指为每个进程分配独立的虚拟地址，它们互不干涉，虚拟地址由操作系统负责映射到物理内存。常见的虚拟内存管理方式有分段和分页。 1 内存分段 2 内存分页 1.5.6 为什么多级页表可以节省内存 # 1.5.7 死锁及其产生的条件 # 1 死锁 所谓死锁是指两个或两个以上的进程在执行过程中，由于竞争资源造成的一种阻塞的现象，在未改变这种状态之前进程都不能向前推进，就说这一组进程产生了死锁。通俗地讲，就是两个或多个进程无限期地阻塞、相互等待的一种状态。 2 死锁产生的4个必要条件 互斥：在一段时间内某资源仅被一个进程占用。 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源被其他进程占有。 非抢占：进程已获得的资源在未使用完之前不能被强行剥夺。 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系。 1.5.8 线程状态转换 # 就绪状态(runnable) 运行状态(running) 阻塞状态(blocked) 等待状态(waiting) 终止状态(terminated) 1.5.9 进程调度策略 # 先来先服务 非抢占 最短作业优先 高响应比优先算法 优先级调度算法 时间片轮转调度算法 多级队列调度算法 1.5.10 线程同步有哪几种方式 # (1)锁Synchronized/Lock：只有拥有锁的线程才能访问临界资源。 (2)信号量Semaphore：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数。 1.5.11 内存颠簸 # 1.5.12 局部性原理 # 时间上的局部性是指最近被访问的页在不久的将来还会被访问。 空间上的局部性是指存储中的某个位置被访问，其周围的位置也很可能被访问。 1.6 计算机网络 # 1.6.1 TCP与UDP的区别 # TCP是面向连接的，UDP是无连接的，即发送数据前不需要建立连接。\nTCP提供可靠的服务，传送数据无差错、不丢失、不重复且按序到达；UDP尽最大努力交付。\nUDP实时性强，工作效率比TCP高，适用于对传输速度和延迟要求较高的场景，如语音和视频通信等。\n1.6.2 滑动窗口 # 1.6.3 拥塞控制 # 1 慢开始算法 2 拥塞避免算法 3 快重传算法 4 快恢复算法 1.6.4 重传机制 # 1 超时重传 2 快速重传 3 Selective Acknowledgment，SACK 4 D-SACK 1.6.5 流量控制 # 1.6.6 三次握手与四次挥手 # 1 三次握手建立连接 2 四次挥手 1.6.7 TCP四次挥手为什么要等待2MSL # 1.6.8 一次完整的HTTP请求 # 域名解析→3次握手建立TCP连接→发起HTTP请求→服务器返回数据，浏览器渲染页面 域名解析流程 1.6.9 HTTPS加密过程 # 1 对称与非对称加密 对称加密：所谓对称加密其实就是加密与解密使用同一把密钥。 非对称加密：一对密钥（公钥与私钥），使用其中一个密钥进行加密，另一个密钥进行解密。比如若使用公钥加密，则用私钥解密；若使用私钥加密，则用公钥解密。 2 使用两组非对称密钥可以保证通信安全吗 使用两组非对称密钥不可以保证通信安全。举个例子，客户端与服务器端通信，服务器端拥有公钥A与对应的私钥A\u0026rsquo;；客户端拥有公钥B与对应的私钥B\u0026rsquo;。客户端把公钥B明文传输给服务器端，服务器端把公钥A明文给传输给客户端，之后客户端向服务器端传输数据都用公钥A加密，服务器收到后用私钥A\u0026rsquo;解密。同理，服务器端向客户端传输数据都用公钥B加密，客户端收到后用私钥B\u0026rsquo;解密。私钥被通信发起方安全持有，使用两对密钥看起来可以保证信息安全，但其实存在非对称加密耗时与中间人攻击问题。 1）非对称加密耗时问题 相对于对称加密而言，非对称加密是耗时的，因此仅使用非对称加密的方式传递对称加密的密钥，后续数据通信使用对称密钥加解密。 2）中间人攻击问题 中间人分别与客户端和服务端进行密钥协商 3 数字签名保障证书不被篡改 1.6.10 TCP粘包与拆包 # 1.6.11 Nagle算法 # 1.7 Spring # 1.7.1 Spring Bean的作用域 # 1.7.2 Spring Bean的生命周期 # 1.7.3 Spring IoC # 1.7.4 Spring AOP # 1.7.5 Spring三级缓存解决Bean循环依赖 # Spring Bean循环依赖是指两个以上的Bean互相持有对方而形成循环。比如A依赖B，B依赖A singletonObjects：一级缓存，存储经历了完整生命周期的Bean对象 earlySingletonObjects：二级缓存，存储提前暴露出来的Bean对象，其生命周期未结束，属性未完全填充 singletonFactories：三级缓存，存储生成Bean的工厂 1.7.6 Spring事务实现 # 1.7.7 Spring事务失效的典型场景 # 1.7.8 Spring中BeanFactory和ApplicationContext的区别 # ApplicationContext配置的Bean是预先加载的，浪费内存。BeanFactory延迟加载，配置的Bean只有在使用时（调用getBean()）才对该Bean进行实例化，优点是节约内存，缺点是速度比较慢 1.8 ZooKeeper # 1.8.1 ZooKeeper典型使用场景 # 1 分布式锁 在开发业务功能时常需要使用定时任务来触发事件，假如我们的服务集群有n台服务器，而定时任务又要求时机来临仅被触发一次，则n台服务器抢锁成功者执行具体任务。 2 配置管理 有时需要配置实时生效，比如业务代码中的开关等。如果我们有n台服务器，那么硬编码修改起来就会特别麻烦，并且还需要重新发布应用。 3 服务注册与发现 1.8.2 ZooKeeper四种节点类型 # 1.8.3 ZooKeeper的顺序一致性 # 1.8.4 ZooKeeper集群节点为什么是奇数个 # 1.8.5 ZooKeeper集群中的三种角色 # 1.8.6 ZooKeeper的选主机制 # 1.8.7 ZooKeeper与Eureka的区别 # -(1)ZooKeeper保证数据一致性(consistency)和分区容错性Partition Tolerance。 ZooKeeper的过半策略保证了数据强一致性，当Leader节点因为网络故障与其他节点失去联系时，剩余节点会重新进行投票，选举出新的Leader，且选举期间整个集群不可用。\n(2)Eureka保证可用性(Availability)和分区容错性Partition Tolerance。 Eureka以对等复制的方式进行数据同步，集群节点都是平等的，即使部分节点挂掉（只要还有一台Eureka在），剩余的节点依然可以提供注册和查询服务。 1.8.8 ZooKeeper Atomic Broadcast协议 # 1.9 Dubbo # 1.9.1 Dubbo架构简述 # Dubbo整体架构由消费者(Consumer)、服务者(Provider)、注册中心(Registry)以及监控器(Monitor)组成。其中，服务者注册服务地址到注册中心，消费者从注册中心读取和订阅服务者地址列表，消费者在发起调用前进行路由选择、负载均衡策略，然后调用至服务者服务器，调用失败则进行集群容错。监控器对调用量、性能指标进行采集上报。 1.9.2 路由机制 # Dubbo路由机制实现了动态指定服务的提供者，如图1-149所示。admin管理后台动态添加路由的规则，并将它们存储在注册中心${service}/routers目录下，基于注册中心的事件机制最新路由会通知服务消费者（调用方）；服务消费者发起调用前，Dubbo依据配置的路由规则计算出哪些服务提供者可以处理本次请求，然后使用负载均衡策略选择其中一个服务实例来处理本次请求；当服务调用发生异常时，会有一些集群容错的策略。这就是服务调用的基本流程，从中也可以看出路由选择优先级高于集群容错和负载均衡策略。 1.9.3 负载均衡 # Dubbo负载均衡机制决定了一次请求调用哪个服务提供者 1 RandomLoadBalance：随机负载均衡算法 2 RoundRobinLoadBalance：轮询负载均衡算法 3 LeastActiveLoadBalance：最少活跃数负载均衡算法 4 ConsistentHashLoadBalance：一致性哈希 1.9.4 集群容错 # 集群容错是指消费者在调用服务提供者集群发生异常时的处理策略。 1 failover cluster 若服务调用失败则自动重试到其他的可用节点。 2 failfast cluster 快速失败，即一次调用失败就立即失败，常见于非幂等性的写操作。 3 failsafe cluster 快速失败，出现异常时直接忽略，通常用于写入审计日志等不重要的操作。 4 failback cluster 失败后定时重试。 5 forking cluster 并行调用多个服务提供者，只要有一个成功就立即返回。通常用于实时性要求比较高的读操作。 1.9.5 Dubbo的序列化 # -(1)Hessian2序列化：Hessian是一种跨语言的高效二进制序列化方式。Dubbo默认启用此序列化方式。 -(2)JSON序列化：易于解析阅读，但这种文本序列化性能一般不如二进制序列化。 -(3)Java序列化：JDK自带的序列化实现，无须引入任何依赖，但性能不理想。\n(4)Protobuf序列化：Protobuf是由Google设计的一种高效、轻量级的信息描述格式，优点是与语言无关，编码长度更短，传输效率更高，编解码速度更快；缺点是缺乏自描述，可读性差。 1.9.6 有了HTTP请求为什么还需要RPC调用 # -(1)HTTP信息效率低，包含了大量的HTTP头等冗余信息\n(2)业内成熟的RPC框架是面向服务的更高级的封装，其内涵包括了路由策略、负载均衡、集群容错、服务发现、数据统计以及数据看板等，更适用于一个分布式的大型系统内部之间的通信。 1.9.7 Dubbo的SPI机制 # 第2章 算法题目 # 2.1 递归 # 2.1.1 算法解释 # 2.1.2 经典题目—爬楼梯 # 2.2 双指针 # 2.2.1 算法解释 # 2.2.2 经典题目—寻找链表的中间节点（快慢指针） # 2.2.3 经典题目—有序数组两数之和（对撞指针） # 2.3 滑动窗口 # 2.3.1 算法解释 # 2.3.2 经典题目—长度为k的连续子数组的最大和 # 2.4 二分搜索 # 2.4.1 算法解释 # 2.4.2 经典题目——n的算术平方根 # 2.5 动态规划 # 2.5.1 算法解释 # 2.5.2 经典题目—最小路径和 # 2.6 回溯 # 2.6.1 算法解释 # 2.6.2 经典题目—n皇后问题 # 2.7 广度/深度优先搜索 # 2.7.1 算法解释 # 2.7.2 经典题目—深度优先搜索岛屿数量 # 2.7.3 经典题目—广度优先搜索层序遍历 # 第3章 设计题 # 3.1 秒杀系统 # 3.1.1 抢购商品允许超卖 # 3.1.2 抢购商品不允许超卖 # 3.1.3 异步消费控制用户并发数避免热点更新 # 3.1.4 用户交互设计角度的兜底考虑 # 3.2 分布式定时任务 # 3.2.1 设计思想 # 3.2.2 定时任务具体功能点的实现 # 3.3 其他高频出现的经典方案设计题目 # (1)抖音视频点赞、云音乐海量评论功能设计。 (2)微博千万粉丝博主、粉丝列表设计。 (3)设计RPC框架。 (4)排行榜。 (5)微信抢红包。 (6)微博feed流、微信朋友圈、Twitter timeline。 (7)限流的设计思路。 (8)如何设计count服务。 (9)设计一个短链系统。 (10)Open API接口设计。 (11)如何实现一个分布式锁，Redis、ZooKeeper两种方案的区别？ (12)如何设计无界实时数据流的Join 第4章 一个项目案例分析：合约广告库存预估 # 4.1 项目背景 # 4.2 系统领域划分与自己所在的位置 # 4.3 发现或者定义一个问题 # 4.4 可量化的正向结果 # 4.5 未来改进点 # 第5章 一个完整的后端系统 # 5.1 接入层（Nginx与网关） # 1 Nginx 2 网关(API Gateway) 3 BFF 5.2 业务层 # 定时任务触发 柔性事务、重试机制 配置中心动态配置 限流降级 微服务的治理依赖 消息队列 Redis DTS Trace全链路日志 5.3 数据层（DB→分布式缓存→本地内存） # 第6章 HR面试技巧——头部大厂HR访谈 # 6.1 面试的全流程—不要以为通过技术\u0026amp;HR面试就能拿Offer # 职业规划是什么？ 为什么要跳槽？ 你的优点和缺点有哪些？ 过往工作中遇到的困难你是怎么解决的？ 过往工作中取得了哪些成果？详细说说。 你的薪酬预期是多少？ 6.2 跳槽时找谁内推更容易通过面试 # 6.3 谈薪技巧 # 6.4 反问环节—怎么提问能加分 # 提问题的原则是：问题的提出必须符合自身的行为逻辑，符合自身定位。建议提问职业发展与个人成长规划、热点技术、目标岗位相关的业务问题等。 6.5 你的职业规划 # 6.6 为什么要跳槽 # 6.7 你的优点和缺点 # 6.8 过往工作中取得的成果 # 6.9 过往工作中遇到的困难是怎么解决的 # 我通过校园招聘加入网易云音乐，已经工作四年了，我的困难分两个阶段： 第一阶段是：刚入职阶段，入职时公司处于大发展阶段，人力不足，新人也要承担大型重要项目，我对新的环境、技术基础设施、工作流程等不熟悉，作为新人如何快速融入团队、完成产品运营交付的需求、按时高质量上线，对我来说是一种挑战。 第二阶段是：工作熟练以后，自己负责一块成熟的业务，增长上出现瓶颈，怎么在熟悉的业务里发现问题，甚至定义问题，以技术驱动业务的发展，落地执行取得正向可量化的业务指标，对我来说是一件极具挑战的事。 6.10 行业薪酬水平 # 6.11 没有做出算法题是否一定会被淘汰 # 6.12 能不能短时间内频繁面试同一家公司 # 6.13 “毕业季”应选择什么样的公司 # 6.14 国内互联网面试为什么要刷题 # 6.15 薪酬报高了会不会被HR直接淘汰 # 6.16 几年一跳算频繁 # 6.17 你是如何学习技术的 # 6.18 思维发散题目 # 参考文献 # "},{"id":83,"href":"/zh/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/","title":"一本书讲透 ElasticSearch：原理、进阶与工程实践","section":"Computer Science","content":" 第1章 Elastic Stack全景 # 首先，Elasticsearch支持各类应用、网站等的全文搜索，包括淘宝、京东等电商平台的搜索，360手机助手、豌豆荚等应用市场平台的搜索，以及腾讯文档、石墨文档等平台的全文检索服务。 许多知名企业，如58集团、唯品会、日志易、国投瑞银等，都使用Elasticsearch来快速分析和处理大量的日志数据，从而对业务运行状况进行实时的监控和故障排查。 许多知名企业的商业智能系统，如睿思BI、百度数据可视化Sugar BI、永洪BI等，都借助Elasticsearch的高效、实时的数据分析和可视化能力，帮助企业更好地理解市场趋势、优化决策过程。 ClickHouse ClickHouse是一款由俄罗斯搜索引擎Yandex开发并开源的列式存储数据库，专为**OLAP（在线分析处理）**场景设计。ClickHouse具有高速查询分析的能力，支持实时添加数据和修改结构，并且能够实现高度数据压缩比，从而有效节省存储空间。此外，ClickHouse支持SQL查询，易于使用和集成。 第2章 Elasticsearch基础知识 # 倒排索引 一本C语言图书末页的索引结构。这种结构揭示了核心关键词与页码之间的对应关系。这种关系模式可以视为倒排索引的实际例证。在此结构中，我们可以根据关键词快速找到包含这个关键词的内容的页码。这与倒排索引在接收关键词输入后能够迅速定位包含该关键词的文档的性质是一致的。借由这种类比，我们可以更为直观地理解倒排索引在数据查询中的关键作用。 数据索引化 数据索引化指的是数据在写入搜索引擎（本书中主要指Elasticsearch）的过程中，扫描文档中的每一个词项，结合分词器和词典对必要的词项建立倒排索引，同时指明该词项在文章中出现的次数和位置。 全文检索的前提是待检索的数据已经索引化，当用户查询时能根据建立的倒排索引进行查找。 全文检索的特点如下 只处理文本，不处理语义。 结果列表有相关度排序。 支持高亮显示结果数据。 原始的文本被切分为单个单词、短语或特殊标记后进行存储。 给定词与它的变体（如近义词）会被折叠为一个词，如electrification和ectric、mice和mouse、“土豆”和“马铃薯”、“西红柿”和“番茄”等，每组词均被视为同一个词。 2.2 Elasticsearch的核心概念 # 集群 Elasticsearch集群常用于处理大规模数据集，目的是实现容错和高可用。Elasticsearch集群需要一个唯一标识的集群名称来防止不必要的节点加入。集群大小从单个节点到数千个节点不等，具体大小取决于实际业务场景。 节点 节点是指一个Elasticsearch实例，更确切地说，它是一个Elasticsearch进程。节点可以部署到物理机或者虚拟机上。每当Elasticsearch启动时，节点就会开始运行。每个节点都有唯一标识的名称，在部署多节点集群环境的时候我们要注意不要写错节点名称。 索引 索引可以看作数据库中的一个表，它包含了一组具有相似结构的文档 在Elasticsearch中，数据以JSON格式的文档存储在索引内。 每个索引具有唯一的名称，以便在执行搜索、更新和删除操作时进行引用。 索引的名称可以由用户自定义，但必须全部小写。 分片 在了解分片是什么之前，让我们谈谈为什么需要分片。假设你有一个包含超大规模文档的索引，有总计1TB的数据。当前集群中有两个节点，每个节点有512GB的空间可用于存储数据。显然，整个索引无法存储在任何一个节点上，因此有必要以某种方式拆分索引的数据，否则会导致数据存储不完整。在这种情况下，索引的大小超过了单个节点的硬件限制，分片就派上用场了。分片通过将索引分成更小的部分来解决这个问题。 当处理涉及多个数据分片的查询时，Elasticsearch会将查询请求分发到各个相关的分片，并将它们的结果集进行聚合。 副本 分片可以被复制，被复制的分片称为“主分片”，如图2-3中的主分片1～4；主分片的复制版本称为“副本分片”或简称为“副本”，如图2-3中的副本1～4 创建索引时需要指定主分片，且主分片数一经指定就不支持动态更新了。而副本同样需要在创建索引时指定，每个分片可以有0或多个副本，副本数支持动态更新。 当某主分片所在的数据节点不可用时，会导致主分片丢失现象，若短时间内不对此采取补救措施，集群会将该分片对应的副本提升为新的主分片。 文档 关系型数据库将数据以行或元组为单位存储在数据库表中，而Elasticsearch将数据以文档为单位存储在索引中。 作为Elasticsearch的基本存储单元，文档是指存储在Elasticsearch索引中的JSON对象。文档中的数据由键值对构成。键是字段的名称，值是不同数据类型的字段。不同的数据类型包含但不限于字符串类型、数字类型、布尔类型、对象类型等。 字段 字段是Elasticsearch中最小的单个数据单元，类似于关系型数据库表中的字段。一般实战项目前期的设计环节都是根据业务需求拆分、定义字段，并且敲定字段类型。在上面航空类索引的示例中，“FlightNum”是字段，其含义为“航班号”，字段类型为keyword。 与关系型数据库不同的是，Elasticsearch的一个字段可以设定两种或两种以上的数据类型，通过定义multi-field来灵活地满足复杂的业务需求。 映射 不少初学者对映射(Mapping)这个概念会感觉不好理解。映射类似于关系型数据库中的Schema，可以近似地理解为**“表结构”**。 我们拿到一个业务需求后，往往会将业务细分会几个索引。每个索引都需要一个相对固定的表结构，包含但不限于字段名称、字段类型、是否需要分词、是否需要索引、是否需要存储、是否需要多字段类型等。这些都是设计映射时要考虑的问题。 分词 在英文文本中，空格就是切分语句或短语的“屏障”。但中文文本中则没有了这道“屏障”，于是分词就变得就不那么简单，需要由专门的分词算法构建的分词器来实现。 第3章 Elasticsearch集群部署 # 什么是堆内存\nJava中的堆是JVM所管理的最大的一块内存空间，主要用于存放各种类的实例对象。在Java中，堆被划分成两个不同的区域：新生代(Young)和老年代(Old)。新生代又被划分为3个区域：Eden、From Survivor、To Survivor。 这样划分的目的是使JVM更好地管理堆内存中的对象，包括内存的分配以及回收。 堆内存的作用是什么\n堆内存的唯一目的就是创建对象实例，所有的对象实例和数组都要在堆上分配。 堆内存如何配置\n默认情况下，Elasticsearch JVM使用的堆内存最小和最大值均为4 GB（8.X版本以上） 在转移到生产环境时，配置足够容量的堆大小以确保Elasticsearch功能和性能是必要的。 Elasticsearch将通过对Xms（最小堆大小）和Xmx（最大堆大小）的设置来分配jvm.options中指定的整个堆。 堆内存的值取决于服务器上可用的内存大小。Elasticsearch堆内存设置对其性能表现来说十分关键。建议将堆大小配置为服务器可用内存的50%，上限为32GB，且预留足够的内存给操作系统以提升缓存效率。合理调整堆内存大小可减轻垃圾回收工作的压力，优化查询速度和索引效率。请务必进行监控并根据实际需求来调整堆内存大小。 为什么堆内存不能超过物理机内存的一半\n堆对Elasticsearch来说绝对重要，它用于许多内存数据结构的快速操作。但还有另外一个非常重要的内存使用者——Lucene。 Lucene旨在利用底层操作系统来缓存内存中的数据结构。Lucene段存储在单个文件中。因为段一旦形成就不会改变，所以它们非常容易进行缓存，并且，底层操作系统会将热段保留在内存中以便更快地进行访问。这些段包括倒排索引（用于全文搜索）和正排索引（用于聚合）。 Lucene的性能依赖于与操作系统的这种交互。如果把所有可用的内存都给Elasticsearch堆，那么Lucene就不会有任何剩余的内存，这会严重影响其性能。针对内存的分配，通常的建议是将可用内存的一半分配给Elasticsearch堆，而保留剩下的一半。这种操作的核心在于平衡Elasticsearch堆和Lucene。剩余的内存看起来空闲，但其实并非如此，因为Lucene会利用这些“空闲”内存来提高搜索和索引的性能。这种内存分配策略确保了Elasticsearch与Lucene之间的高效协作，进而能够提升整体系统性能。 如果实际业务不需要在字符串字段上做聚合操作（开启text类型的fielddata），则可以考虑进一步降低堆大小。堆较小，就可以从Elasticsearch（更快的GC）和Lucene（更多内存缓存）中获得更好的性能。 Elasticsearch集群节点角色划分\n节点类型 主节点：负责集群管理和元数据维护，确保集群正常运行。 数据节点：负责存储、检索和处理数据，提供搜索和聚合功能。 协调节点：处理客户端请求，协调数据节点工作，优化分布式搜索。 ingest节点：即预处理节点，负责数据预处理，如过滤、转换等，准备好数据再将其索引到数据节点。 在Elasticsearch 8.X版本中，节点类型升级为节点角色。节点角色分得很细，包括数据节点角色、主节点角色、ingest节点角色、热节点角色等。 在Elasticsearch集群中，每个启动的Elasticsearch进程都可以叫作一个节点。以Elasticsearch 8.X版本集群为例，如果我们不手动设置节点角色，则默认节点角色为cdfhilmrstw 主节点 专用候选主节点(dedicated master-eligible node) 仅投票主节点(voting-only master-eligible node) 关于集群主节点配置，要强调一点：高可用性集群需要至少3个符合主节点资格的节点，其中至少两个不是仅投票节点。这样即使其中一个节点发生故障，该集群也能够选举出一个主节点。 数据节点 内容数据节点 热数据节点 热数据节点的用途主要是保存最近、最常访问的热数据，即经常被访问和更新的数据 温数据节点 冷数据节点 冷冻数据节点 ingest节点 这类节点通常执行由预处理管道组成的预处理任务 仅协调节点 这类节点的作用类似于智能负载均衡器，负责路由分发请求、聚拢（或叫作收集，可理解为分发的反过程）搜索或聚合结果 远程节点 这类节点用于跨集群检索或跨集群复制 机器学习节点 机器学习节点是一类特殊类型的节点，它专门用于运行机器学习功能。它们负责运行数据分析任务，如异常检测、预测和回归等。这类节点的功能是收费的，Elasticsearch开源版本并不提供。 转换节点 转换节点是一个特殊类型的节点，负责执行数据转换任务。数据转换是指将数据从一种格式或结构转换为另一种格式或结构的过程。在Elasticsearch中，这通常涉及对原始数据创建新的索引，并对新索引中的数据进行汇总、分组或其他转换操作，以便更有效地进行分析和查询。 Nginx+Elasticsearch Coordinate+Elasticsearch Master+Elasticsearch Node应该如何安装配置呢？可以只安装一个节点，然后拷贝并更改其他节点角色吗？\n先划分节点角色。节点不多的话可以一个个手动部署（部署好一个以后，可以在其他部署中进行拷贝，再修改角色、IP等）；节点非常多的话可以借助Ansible等脚本工具快速部署。 在Elasticsearch部署上，节点角色分为m、d、i等多种，它们在部署上各有什么优势？更推荐哪种？\nm代表主节点master，d代表数据节点data，i代表数据预处理节点ingest。不同节点角色有不同的应用场景，建议根据集群规模进行综合考虑。 请问在写入海量数据时，应该连接什么角色的节点，是专用协调节点还是数据节点？\n这要看节点规模和节点角色划分。如果已经有了独立协调节点，则连接独立协调节点。如果没有，则连接硬件配置较高的节点。 在进行节点角色的配置时，data_hot、data_warm、data_cold等角色和早期版本中自定义的attr属性有区别吗？\n新版本具有新特性，所以有区别。新的方式配置更为简洁，并且可读性强、用户体验优。 Elasticsearch的角色data、data_content、data_hot、data_warm、data_cold之间有什么区别？\n这涉及冷热集群架构的数据节点的分层处理机制。对于早期版本冷热集群架构中手动配置节点属性的部分，Elasticsearch 8.X版本做了精细切分，使得数据的冷热集群管理更为高效。尤其在默认迁移自动实现机制之后，早期版本的分片分配策略手动配置（如下方代码所示）变得不再必要。 Elasticsearch 8.X的data_content角色是什么？它和协调节点有什么区别？\n它们是两种完全不同的节点。data_content属于数据节点，是永久存储数据的地方。而协调节点是用来请求路由分发、结果汇聚处理的。 Elasticsearch集群核心配置解读\n开发模式和生产模式 默认情况下，Elasticsearch工作在开发模式(development mode)下。在该模式下，如果配置错误，则警告信息会写入日志文件，但节点依然是能启动的。而在生产模式(production mode)下，一旦出现配置错误，节点就无法正常启动了。这本质上是一种保护机制。 开发模式和生产模式的界限在于：当修改network.host的默认值之后，默认的开发模式会升级为生产模式。通俗地讲，如果开发者个人搭建集群，则推荐使用开发模式；如果企业级开发环境，务必使用生产模式。 Linux前置配置 修改文件描述符数目 首先，Elasticsearch在节点和HTTP客户端之间进行通信使用了大量的套接字，而套接字需要足够的文件描述符支持。 其次，在许多Linux发行版本中，每个进程默认有1024个文件描述符，这对Elasticsearch节点来说实在是太低了，何况该节点要处理数以百计的索引，所以要调大这个默认值。 修改最大映射数量 Elasticsearch对各种文件混合使用了niofs（非阻塞文件系统）和mmapfs（内存映射文件系统），以实现对各种文件的优化处理。为了保证系统的顺畅运行，需要合理配置最大映射数量(MMP)，以便有足够的虚拟内存可用于内存映射的文件。 path.data配置注意事项：\n不要修改data路径下的任何文件，手动修改会有数据损坏或丢失的风险。 不要尝试对数据目录进行备份，因为Elasticsearch不支持文件备份后的恢复操作。 使用快照snapshot命令对集群进行备份，使用restore命令进行恢复。 不要对数据路径进行病毒扫描，病毒扫描可能会阻止Elasticsearch工作，甚至修改数据目录内容。 在Elasticsearch系统中，为了保证数据安全，不同节点间的通信和数据传输通常采用HTTPS的加密协议。这样的设计能有效防止数据在传输过程中被窃取或篡改。同样，Elasticsearch与Kibana之间的互动也使用了HTTPS，以确保数据在交互过程中的安全性。\n第4章 Elasticsearch索引 # 4.1 索引的定义 # 索引是具有相同结构的文档的集合，由唯一索引名称标定。\n实战场景1：将采集的不同业务类型的数据存储到不同的索引。\n微博业务对应的索引weibo_index 新闻业务对应的索引news_index 博客业务对应的索引blog_index 以上3个索引包含的字段个数、字段名称、字段类型可能不完全一致。 实战场景2：按日期切分存储日志索引\n2025年1月的日志对应logs_202501 2025年3月的日志对应logs_202503 索引设置\n静态设置(static index settings)，只允许在创建索引时或者针对已关闭的索引进行设置。 设置主分片大小的参数是index.number_of_shards，只在创建索引时生效，不支持动态修改。默认主分片大小为1，且每个索引的分片数量上限默认为1024。此限制是一个安全限制，可防止索引分片数过多导致集群不稳定。 动态设置(dynamic index settings)，可以借助更新设置(update settings)的方式进行动态更新，更新后立即生效。 设置副本数参数为index.number_of_replicas，可以动态修改。 设置刷新频率参数为index.refresh_interval，可以动态修改。默认刷新频率参数值为1s，即每秒刷新一次。这1s决定了Elasticsearch是近实时的搜索引擎，而非准实时搜索引擎。如果业务层面对实时性的要求不高，可以考虑将该值调大。因为如果采用1s，则每秒都会生成一个新的分段，会影响写入性能。 max_result_window是Elasticsearch中的一个设置参数，用于控制搜索结果的最大窗口的大小。默认情况下，max_result_window的值为10000。这意味着在分页搜索时最多可以返回10000条数据。如果每页可显示10条数据，那么最多可以翻到1000页。 增大max_result_window的值可能会对Elasticsearch集群的性能产生影响，尤其是在处理大量数据时。因此，在根据实际需求调整此参数时，要权衡性能和查询范围之间的关系。如果需要遍历大量数据，则建议使用scroll API或search_after参数，以更高效地进行处理。 4.3 索引别名 # 场景1：面对PB级别的增量数据，对外提供服务的是基于日期切分的n个不同索引，每次检索都要指定数十个甚至数百个索引，非常麻烦。 场景2：线上提供服务的某个索引设计不合理，比如某字段分词定义不准确，那么如何保证对外提供服务不停止，也就是在不更改业务代码的前提下更换索引？ "},{"id":84,"href":"/zh/zh/post/books/computer-science/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AE%B2%E9%80%8F-elasticsearch%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/","title":"一本书讲透 ElasticSearch：原理、进阶与工程实践","section":"Computer Science","content":" 第1章 Elastic Stack全景 # 首先，Elasticsearch支持各类应用、网站等的全文搜索，包括淘宝、京东等电商平台的搜索，360手机助手、豌豆荚等应用市场平台的搜索，以及腾讯文档、石墨文档等平台的全文检索服务。 许多知名企业，如58集团、唯品会、日志易、国投瑞银等，都使用Elasticsearch来快速分析和处理大量的日志数据，从而对业务运行状况进行实时的监控和故障排查。 许多知名企业的商业智能系统，如睿思BI、百度数据可视化Sugar BI、永洪BI等，都借助Elasticsearch的高效、实时的数据分析和可视化能力，帮助企业更好地理解市场趋势、优化决策过程。 ClickHouse ClickHouse是一款由俄罗斯搜索引擎Yandex开发并开源的列式存储数据库，专为**OLAP（在线分析处理）**场景设计。ClickHouse具有高速查询分析的能力，支持实时添加数据和修改结构，并且能够实现高度数据压缩比，从而有效节省存储空间。此外，ClickHouse支持SQL查询，易于使用和集成。 第2章 Elasticsearch基础知识 # 倒排索引 一本C语言图书末页的索引结构。这种结构揭示了核心关键词与页码之间的对应关系。这种关系模式可以视为倒排索引的实际例证。在此结构中，我们可以根据关键词快速找到包含这个关键词的内容的页码。这与倒排索引在接收关键词输入后能够迅速定位包含该关键词的文档的性质是一致的。借由这种类比，我们可以更为直观地理解倒排索引在数据查询中的关键作用。 数据索引化 数据索引化指的是数据在写入搜索引擎（本书中主要指Elasticsearch）的过程中，扫描文档中的每一个词项，结合分词器和词典对必要的词项建立倒排索引，同时指明该词项在文章中出现的次数和位置。 全文检索的前提是待检索的数据已经索引化，当用户查询时能根据建立的倒排索引进行查找。 全文检索的特点如下 只处理文本，不处理语义。 结果列表有相关度排序。 支持高亮显示结果数据。 原始的文本被切分为单个单词、短语或特殊标记后进行存储。 给定词与它的变体（如近义词）会被折叠为一个词，如electrification和ectric、mice和mouse、“土豆”和“马铃薯”、“西红柿”和“番茄”等，每组词均被视为同一个词。 2.2 Elasticsearch的核心概念 # 集群 Elasticsearch集群常用于处理大规模数据集，目的是实现容错和高可用。Elasticsearch集群需要一个唯一标识的集群名称来防止不必要的节点加入。集群大小从单个节点到数千个节点不等，具体大小取决于实际业务场景。 节点 节点是指一个Elasticsearch实例，更确切地说，它是一个Elasticsearch进程。节点可以部署到物理机或者虚拟机上。每当Elasticsearch启动时，节点就会开始运行。每个节点都有唯一标识的名称，在部署多节点集群环境的时候我们要注意不要写错节点名称。 索引 索引可以看作数据库中的一个表，它包含了一组具有相似结构的文档 在Elasticsearch中，数据以JSON格式的文档存储在索引内。 每个索引具有唯一的名称，以便在执行搜索、更新和删除操作时进行引用。 索引的名称可以由用户自定义，但必须全部小写。 分片 在了解分片是什么之前，让我们谈谈为什么需要分片。假设你有一个包含超大规模文档的索引，有总计1TB的数据。当前集群中有两个节点，每个节点有512GB的空间可用于存储数据。显然，整个索引无法存储在任何一个节点上，因此有必要以某种方式拆分索引的数据，否则会导致数据存储不完整。在这种情况下，索引的大小超过了单个节点的硬件限制，分片就派上用场了。分片通过将索引分成更小的部分来解决这个问题。 当处理涉及多个数据分片的查询时，Elasticsearch会将查询请求分发到各个相关的分片，并将它们的结果集进行聚合。 副本 分片可以被复制，被复制的分片称为“主分片”，如图2-3中的主分片1～4；主分片的复制版本称为“副本分片”或简称为“副本”，如图2-3中的副本1～4 创建索引时需要指定主分片，且主分片数一经指定就不支持动态更新了。而副本同样需要在创建索引时指定，每个分片可以有0或多个副本，副本数支持动态更新。 当某主分片所在的数据节点不可用时，会导致主分片丢失现象，若短时间内不对此采取补救措施，集群会将该分片对应的副本提升为新的主分片。 文档 关系型数据库将数据以行或元组为单位存储在数据库表中，而Elasticsearch将数据以文档为单位存储在索引中。 作为Elasticsearch的基本存储单元，文档是指存储在Elasticsearch索引中的JSON对象。文档中的数据由键值对构成。键是字段的名称，值是不同数据类型的字段。不同的数据类型包含但不限于字符串类型、数字类型、布尔类型、对象类型等。 字段 字段是Elasticsearch中最小的单个数据单元，类似于关系型数据库表中的字段。一般实战项目前期的设计环节都是根据业务需求拆分、定义字段，并且敲定字段类型。在上面航空类索引的示例中，“FlightNum”是字段，其含义为“航班号”，字段类型为keyword。 与关系型数据库不同的是，Elasticsearch的一个字段可以设定两种或两种以上的数据类型，通过定义multi-field来灵活地满足复杂的业务需求。 映射 不少初学者对映射(Mapping)这个概念会感觉不好理解。映射类似于关系型数据库中的Schema，可以近似地理解为**“表结构”**。 我们拿到一个业务需求后，往往会将业务细分会几个索引。每个索引都需要一个相对固定的表结构，包含但不限于字段名称、字段类型、是否需要分词、是否需要索引、是否需要存储、是否需要多字段类型等。这些都是设计映射时要考虑的问题。 分词 在英文文本中，空格就是切分语句或短语的“屏障”。但中文文本中则没有了这道“屏障”，于是分词就变得就不那么简单，需要由专门的分词算法构建的分词器来实现。 第3章 Elasticsearch集群部署 # 什么是堆内存\nJava中的堆是JVM所管理的最大的一块内存空间，主要用于存放各种类的实例对象。在Java中，堆被划分成两个不同的区域：新生代(Young)和老年代(Old)。新生代又被划分为3个区域：Eden、From Survivor、To Survivor。 这样划分的目的是使JVM更好地管理堆内存中的对象，包括内存的分配以及回收。 堆内存的作用是什么\n堆内存的唯一目的就是创建对象实例，所有的对象实例和数组都要在堆上分配。 堆内存如何配置\n默认情况下，Elasticsearch JVM使用的堆内存最小和最大值均为4 GB（8.X版本以上） 在转移到生产环境时，配置足够容量的堆大小以确保Elasticsearch功能和性能是必要的。 Elasticsearch将通过对Xms（最小堆大小）和Xmx（最大堆大小）的设置来分配jvm.options中指定的整个堆。 堆内存的值取决于服务器上可用的内存大小。Elasticsearch堆内存设置对其性能表现来说十分关键。建议将堆大小配置为服务器可用内存的50%，上限为32GB，且预留足够的内存给操作系统以提升缓存效率。合理调整堆内存大小可减轻垃圾回收工作的压力，优化查询速度和索引效率。请务必进行监控并根据实际需求来调整堆内存大小。 为什么堆内存不能超过物理机内存的一半\n堆对Elasticsearch来说绝对重要，它用于许多内存数据结构的快速操作。但还有另外一个非常重要的内存使用者——Lucene。 Lucene旨在利用底层操作系统来缓存内存中的数据结构。Lucene段存储在单个文件中。因为段一旦形成就不会改变，所以它们非常容易进行缓存，并且，底层操作系统会将热段保留在内存中以便更快地进行访问。这些段包括倒排索引（用于全文搜索）和正排索引（用于聚合）。 Lucene的性能依赖于与操作系统的这种交互。如果把所有可用的内存都给Elasticsearch堆，那么Lucene就不会有任何剩余的内存，这会严重影响其性能。针对内存的分配，通常的建议是将可用内存的一半分配给Elasticsearch堆，而保留剩下的一半。这种操作的核心在于平衡Elasticsearch堆和Lucene。剩余的内存看起来空闲，但其实并非如此，因为Lucene会利用这些“空闲”内存来提高搜索和索引的性能。这种内存分配策略确保了Elasticsearch与Lucene之间的高效协作，进而能够提升整体系统性能。 如果实际业务不需要在字符串字段上做聚合操作（开启text类型的fielddata），则可以考虑进一步降低堆大小。堆较小，就可以从Elasticsearch（更快的GC）和Lucene（更多内存缓存）中获得更好的性能。 Elasticsearch集群节点角色划分\n节点类型 主节点：负责集群管理和元数据维护，确保集群正常运行。 数据节点：负责存储、检索和处理数据，提供搜索和聚合功能。 协调节点：处理客户端请求，协调数据节点工作，优化分布式搜索。 ingest节点：即预处理节点，负责数据预处理，如过滤、转换等，准备好数据再将其索引到数据节点。 在Elasticsearch 8.X版本中，节点类型升级为节点角色。节点角色分得很细，包括数据节点角色、主节点角色、ingest节点角色、热节点角色等。 在Elasticsearch集群中，每个启动的Elasticsearch进程都可以叫作一个节点。以Elasticsearch 8.X版本集群为例，如果我们不手动设置节点角色，则默认节点角色为cdfhilmrstw 主节点 专用候选主节点(dedicated master-eligible node) 仅投票主节点(voting-only master-eligible node) 关于集群主节点配置，要强调一点：高可用性集群需要至少3个符合主节点资格的节点，其中至少两个不是仅投票节点。这样即使其中一个节点发生故障，该集群也能够选举出一个主节点。 数据节点 内容数据节点 热数据节点 热数据节点的用途主要是保存最近、最常访问的热数据，即经常被访问和更新的数据 温数据节点 冷数据节点 冷冻数据节点 ingest节点 这类节点通常执行由预处理管道组成的预处理任务 仅协调节点 这类节点的作用类似于智能负载均衡器，负责路由分发请求、聚拢（或叫作收集，可理解为分发的反过程）搜索或聚合结果 远程节点 这类节点用于跨集群检索或跨集群复制 机器学习节点 机器学习节点是一类特殊类型的节点，它专门用于运行机器学习功能。它们负责运行数据分析任务，如异常检测、预测和回归等。这类节点的功能是收费的，Elasticsearch开源版本并不提供。 转换节点 转换节点是一个特殊类型的节点，负责执行数据转换任务。数据转换是指将数据从一种格式或结构转换为另一种格式或结构的过程。在Elasticsearch中，这通常涉及对原始数据创建新的索引，并对新索引中的数据进行汇总、分组或其他转换操作，以便更有效地进行分析和查询。 Nginx+Elasticsearch Coordinate+Elasticsearch Master+Elasticsearch Node应该如何安装配置呢？可以只安装一个节点，然后拷贝并更改其他节点角色吗？\n先划分节点角色。节点不多的话可以一个个手动部署（部署好一个以后，可以在其他部署中进行拷贝，再修改角色、IP等）；节点非常多的话可以借助Ansible等脚本工具快速部署。 在Elasticsearch部署上，节点角色分为m、d、i等多种，它们在部署上各有什么优势？更推荐哪种？\nm代表主节点master，d代表数据节点data，i代表数据预处理节点ingest。不同节点角色有不同的应用场景，建议根据集群规模进行综合考虑。 请问在写入海量数据时，应该连接什么角色的节点，是专用协调节点还是数据节点？\n这要看节点规模和节点角色划分。如果已经有了独立协调节点，则连接独立协调节点。如果没有，则连接硬件配置较高的节点。 在进行节点角色的配置时，data_hot、data_warm、data_cold等角色和早期版本中自定义的attr属性有区别吗？\n新版本具有新特性，所以有区别。新的方式配置更为简洁，并且可读性强、用户体验优。 Elasticsearch的角色data、data_content、data_hot、data_warm、data_cold之间有什么区别？\n这涉及冷热集群架构的数据节点的分层处理机制。对于早期版本冷热集群架构中手动配置节点属性的部分，Elasticsearch 8.X版本做了精细切分，使得数据的冷热集群管理更为高效。尤其在默认迁移自动实现机制之后，早期版本的分片分配策略手动配置（如下方代码所示）变得不再必要。 Elasticsearch 8.X的data_content角色是什么？它和协调节点有什么区别？\n它们是两种完全不同的节点。data_content属于数据节点，是永久存储数据的地方。而协调节点是用来请求路由分发、结果汇聚处理的。 Elasticsearch集群核心配置解读\n开发模式和生产模式 默认情况下，Elasticsearch工作在开发模式(development mode)下。在该模式下，如果配置错误，则警告信息会写入日志文件，但节点依然是能启动的。而在生产模式(production mode)下，一旦出现配置错误，节点就无法正常启动了。这本质上是一种保护机制。 开发模式和生产模式的界限在于：当修改network.host的默认值之后，默认的开发模式会升级为生产模式。通俗地讲，如果开发者个人搭建集群，则推荐使用开发模式；如果企业级开发环境，务必使用生产模式。 Linux前置配置 修改文件描述符数目 首先，Elasticsearch在节点和HTTP客户端之间进行通信使用了大量的套接字，而套接字需要足够的文件描述符支持。 其次，在许多Linux发行版本中，每个进程默认有1024个文件描述符，这对Elasticsearch节点来说实在是太低了，何况该节点要处理数以百计的索引，所以要调大这个默认值。 修改最大映射数量 Elasticsearch对各种文件混合使用了niofs（非阻塞文件系统）和mmapfs（内存映射文件系统），以实现对各种文件的优化处理。为了保证系统的顺畅运行，需要合理配置最大映射数量(MMP)，以便有足够的虚拟内存可用于内存映射的文件。 path.data配置注意事项：\n不要修改data路径下的任何文件，手动修改会有数据损坏或丢失的风险。 不要尝试对数据目录进行备份，因为Elasticsearch不支持文件备份后的恢复操作。 使用快照snapshot命令对集群进行备份，使用restore命令进行恢复。 不要对数据路径进行病毒扫描，病毒扫描可能会阻止Elasticsearch工作，甚至修改数据目录内容。 在Elasticsearch系统中，为了保证数据安全，不同节点间的通信和数据传输通常采用HTTPS的加密协议。这样的设计能有效防止数据在传输过程中被窃取或篡改。同样，Elasticsearch与Kibana之间的互动也使用了HTTPS，以确保数据在交互过程中的安全性。\n第4章 Elasticsearch索引 # 4.1 索引的定义 # 索引是具有相同结构的文档的集合，由唯一索引名称标定。\n实战场景1：将采集的不同业务类型的数据存储到不同的索引。\n微博业务对应的索引weibo_index 新闻业务对应的索引news_index 博客业务对应的索引blog_index 以上3个索引包含的字段个数、字段名称、字段类型可能不完全一致。 实战场景2：按日期切分存储日志索引\n2025年1月的日志对应logs_202501 2025年3月的日志对应logs_202503 索引设置\n静态设置(static index settings)，只允许在创建索引时或者针对已关闭的索引进行设置。 设置主分片大小的参数是index.number_of_shards，只在创建索引时生效，不支持动态修改。默认主分片大小为1，且每个索引的分片数量上限默认为1024。此限制是一个安全限制，可防止索引分片数过多导致集群不稳定。 动态设置(dynamic index settings)，可以借助更新设置(update settings)的方式进行动态更新，更新后立即生效。 设置副本数参数为index.number_of_replicas，可以动态修改。 设置刷新频率参数为index.refresh_interval，可以动态修改。默认刷新频率参数值为1s，即每秒刷新一次。这1s决定了Elasticsearch是近实时的搜索引擎，而非准实时搜索引擎。如果业务层面对实时性的要求不高，可以考虑将该值调大。因为如果采用1s，则每秒都会生成一个新的分段，会影响写入性能。 max_result_window是Elasticsearch中的一个设置参数，用于控制搜索结果的最大窗口的大小。默认情况下，max_result_window的值为10000。这意味着在分页搜索时最多可以返回10000条数据。如果每页可显示10条数据，那么最多可以翻到1000页。 增大max_result_window的值可能会对Elasticsearch集群的性能产生影响，尤其是在处理大量数据时。因此，在根据实际需求调整此参数时，要权衡性能和查询范围之间的关系。如果需要遍历大量数据，则建议使用scroll API或search_after参数，以更高效地进行处理。 4.3 索引别名 # 场景1：面对PB级别的增量数据，对外提供服务的是基于日期切分的n个不同索引，每次检索都要指定数十个甚至数百个索引，非常麻烦。 场景2：线上提供服务的某个索引设计不合理，比如某字段分词定义不准确，那么如何保证对外提供服务不停止，也就是在不更改业务代码的前提下更换索引？ "},{"id":85,"href":"/zh/post/books/%E8%8B%B1%E4%BC%9F%E8%BE%BE-%E9%BB%84%E4%BB%81%E5%8B%8B%E4%B9%8B%E8%8A%AF/","title":"英伟达-黄仁勋之芯","section":"Books","content":" 黄仁勋-英伟达之芯 # 第1章 求学生涯 # 第2章 职涯早期 # 第3章 从餐厅起步的Nvidia # 第4章 英伟达遭遇绝境 # 第5章 咸鱼翻身 # 第6章 新机器时代曙光初现 # 第7章 死亡竞赛 # 第8章 游戏玩家拯救英伟达 # 第9章 光速之道 # 第10章 同频共振 # 第11章 范式转变的时刻 # 第12章 千载难逢的机会 # 第13章 由机器引领的时代 # 克里泽夫斯基：辛顿在多伦多大学时的学生 因为无法解释神经网络的计算过程，学术界不认可这种方法 辛顿给苏茨克弗和克里泽夫斯基布置了一项艰巨的任务：利用英伟达的GPU训练计算机学会图像识别 卡坦扎罗 2011年加入英伟达 cuDNN cuda deep neural network 矩阵乘法 优秀的神经网络软件应该注重速度而不是精度 马克思与黄仁勋的分歧 马斯克认为，先进的人工智能可能带来灭绝级威胁。这一观点得到了包括辛顿和苏茨克弗在内的大批技术专家的认同，他们还是最初那篇关于AlexNet的论文的合著者。然而黄仁勋完全不这么认为。他竟觉得人工智能毫无风险，真是令我吃惊。 第14章 AI行业的佼佼者 # 2016年，英伟达的股价飙升了224%，这让黄仁勋重获荣光，再度跻身亿万富翁行列。不过，在当年的标准普尔500指数中，表现最抢眼的股票并非英伟达，而是其长期竞争对手AMD，其股价涨幅高达309%。黄仁勋并不甘心位居次席。 Omniverse 第15章 AI工厂 # 乌斯科雷特把这套学习机制命名为“自注意力” 第16章 全球最具价值的半导体企业 # 在2018年的GTC大会上，黄仁勋指出，在短短5年内，英伟达的GPU处理速度提升了25倍，这一成绩远超摩尔定律的预测。接着，他展示了一张图，这张图显示在2012年的显卡上需要一周的时间才能训练出AlexNet，而在他推出的新款计算机DGX-2上则仅需18分钟就能完成训练。 2020年7月，英伟达的市值终于超越了英特尔。没过多久，英伟达的市值又超越了AMD。 第17章 这个时代最重要的科技公司 # 第18章 人类需要更多智慧 # 第19章 更多电力更大算力 # 第20章 地球上最重要的股票 # 第21章 向理性本身发起挑战 # 第22章 深不见底的恐惧 # 第23章 思考机器 # "},{"id":86,"href":"/zh/zh/post/books/%E8%8B%B1%E4%BC%9F%E8%BE%BE-%E9%BB%84%E4%BB%81%E5%8B%8B%E4%B9%8B%E8%8A%AF/","title":"英伟达-黄仁勋之芯","section":"Books","content":" 黄仁勋-英伟达之芯 # 第1章 求学生涯 # 第2章 职涯早期 # 第3章 从餐厅起步的Nvidia # 第4章 英伟达遭遇绝境 # 第5章 咸鱼翻身 # 第6章 新机器时代曙光初现 # 第7章 死亡竞赛 # 第8章 游戏玩家拯救英伟达 # 第9章 光速之道 # 第10章 同频共振 # 第11章 范式转变的时刻 # 第12章 千载难逢的机会 # 第13章 由机器引领的时代 # 克里泽夫斯基：辛顿在多伦多大学时的学生 因为无法解释神经网络的计算过程，学术界不认可这种方法 辛顿给苏茨克弗和克里泽夫斯基布置了一项艰巨的任务：利用英伟达的GPU训练计算机学会图像识别 卡坦扎罗 2011年加入英伟达 cuDNN cuda deep neural network 矩阵乘法 优秀的神经网络软件应该注重速度而不是精度 马克思与黄仁勋的分歧 马斯克认为，先进的人工智能可能带来灭绝级威胁。这一观点得到了包括辛顿和苏茨克弗在内的大批技术专家的认同，他们还是最初那篇关于AlexNet的论文的合著者。然而黄仁勋完全不这么认为。他竟觉得人工智能毫无风险，真是令我吃惊。 第14章 AI行业的佼佼者 # 2016年，英伟达的股价飙升了224%，这让黄仁勋重获荣光，再度跻身亿万富翁行列。不过，在当年的标准普尔500指数中，表现最抢眼的股票并非英伟达，而是其长期竞争对手AMD，其股价涨幅高达309%。黄仁勋并不甘心位居次席。 Omniverse 第15章 AI工厂 # 乌斯科雷特把这套学习机制命名为“自注意力” 第16章 全球最具价值的半导体企业 # 在2018年的GTC大会上，黄仁勋指出，在短短5年内，英伟达的GPU处理速度提升了25倍，这一成绩远超摩尔定律的预测。接着，他展示了一张图，这张图显示在2012年的显卡上需要一周的时间才能训练出AlexNet，而在他推出的新款计算机DGX-2上则仅需18分钟就能完成训练。 2020年7月，英伟达的市值终于超越了英特尔。没过多久，英伟达的市值又超越了AMD。 第17章 这个时代最重要的科技公司 # 第18章 人类需要更多智慧 # 第19章 更多电力更大算力 # 第20章 地球上最重要的股票 # 第21章 向理性本身发起挑战 # 第22章 深不见底的恐惧 # 第23章 思考机器 # "},{"id":87,"href":"/zh/post/books/%E7%94%A8%E5%9C%B0%E5%9B%BE%E7%9C%8B%E6%87%82%E4%B8%96%E7%95%8C%E6%A0%BC%E5%B1%80/","title":"用地图看懂世界格局","section":"Books","content":" 用地图看懂世界格局 # 第一章：欧洲篇——从进退两难、英国脱欧说起 # 一、地缘造就宿命 # 二、摇摆中的外交 # 三、漫谈福利制度 # 四、英国脱欧 # 第二章：美国篇——从经略天下、美国大选说起 # 一、从地缘美国的“基本盘” # 二、创新之本 # 三、要法治还是要民主？ # 四、经略天下——美国的地缘战略变迁 # 五、美国的拐点与特朗普 # 附章：中产阶级与国家的战争潜力 # 第三章 俄罗斯篇——从俄土争端、叙利亚战争说起 # 一、地缘环境与“战斗种族” # 二、权力的游戏——漫谈俄土之间的渊源 # 三、叙利亚的博弈——地缘视角下的俄土关系 # 四、俄军介入叙利亚的看点 # 五、俄印军购——“男神”的另一面 # 第四章：中国周边——从萨德导弹、南海争端说起 # 一、朝鲜半岛与朝核问题 # 二、南海仲裁案 # 三、网络安全并非是让网络变得“人畜无害” # 四、以“大经济”的视角审视抗战 # "},{"id":88,"href":"/zh/zh/post/books/%E7%94%A8%E5%9C%B0%E5%9B%BE%E7%9C%8B%E6%87%82%E4%B8%96%E7%95%8C%E6%A0%BC%E5%B1%80/","title":"用地图看懂世界格局","section":"Books","content":" 用地图看懂世界格局 # 第一章：欧洲篇——从进退两难、英国脱欧说起 # 一、地缘造就宿命 # 二、摇摆中的外交 # 三、漫谈福利制度 # 四、英国脱欧 # 第二章：美国篇——从经略天下、美国大选说起 # 一、从地缘美国的“基本盘” # 二、创新之本 # 三、要法治还是要民主？ # 四、经略天下——美国的地缘战略变迁 # 五、美国的拐点与特朗普 # 附章：中产阶级与国家的战争潜力 # 第三章 俄罗斯篇——从俄土争端、叙利亚战争说起 # 一、地缘环境与“战斗种族” # 二、权力的游戏——漫谈俄土之间的渊源 # 三、叙利亚的博弈——地缘视角下的俄土关系 # 四、俄军介入叙利亚的看点 # 五、俄印军购——“男神”的另一面 # 第四章：中国周边——从萨德导弹、南海争端说起 # 一、朝鲜半岛与朝核问题 # 二、南海仲裁案 # 三、网络安全并非是让网络变得“人畜无害” # 四、以“大经济”的视角审视抗战 # "}]